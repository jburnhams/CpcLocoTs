/**
* cpclocots bundle
* Generated on 2026-02-01T21:06:29.303Z
*/
(function (global) {
'use strict';
const Polyfills = (typeof window !== "undefined" && window.Polyfills) ? window.Polyfills : globalThis.Polyfills;
class Utils {
static debug = 0;
static console = (typeof Polyfills !== "undefined" && Polyfills.console) ? Polyfills.console : (typeof window !== "undefined" ? window.console : globalThis.console);
static fnLoadScriptOrStyle(script, fnSuccess, fnError) {
let ieTimeoutCount = 3; // IE timeout count
const onScriptLoad = function (event) {
const type = event.type, // "load" or "error"
node = (event.currentTarget || event.srcElement), fullUrl = node.src || node.href, // src for script, href for link
key = node.getAttribute("data-key");
if (Utils.debug > 1) {
Utils.console.debug("onScriptLoad:", type, fullUrl, key);
}
node.removeEventListener("load", onScriptLoad, false);
node.removeEventListener("error", onScriptLoad, false);
if (type === "load") {
fnSuccess(fullUrl, key);
}
else {
fnError(fullUrl, key);
}
}, onScriptReadyStateChange = function (event) {
const node = (event ? (event.currentTarget || event.srcElement) : script), fullUrl = node.src || node.href, // src for script, href for link
key = node.getAttribute("data-key"), node2 = node;
if (node2.detachEvent) {
node2.detachEvent("onreadystatechange", onScriptReadyStateChange);
}
if (Utils.debug > 1) {
Utils.console.debug("onScriptReadyStateChange: " + fullUrl);
}
if (node2.readyState !== "loaded" && node2.readyState !== "complete") {
if (node2.readyState === "loading" && ieTimeoutCount) {
ieTimeoutCount -= 1;
const timeout = 200; // some delay
Utils.console.error("onScriptReadyStateChange: Still loading: " + fullUrl + " Waiting " + timeout + "ms (count=" + ieTimeoutCount + ")");
setTimeout(function () {
onScriptReadyStateChange(); // check again
}, timeout);
}
else {
Utils.console.error("onScriptReadyStateChange: Cannot load file " + fullUrl + " readystate=" + node2.readyState);
fnError(fullUrl, key);
}
}
else {
fnSuccess(fullUrl, key);
}
};
if (script.readyState) { // old IE8
ieTimeoutCount = 3;
script.attachEvent("onreadystatechange", onScriptReadyStateChange);
}
else { // Others
script.addEventListener("load", onScriptLoad, false);
script.addEventListener("error", onScriptLoad, false);
}
document.getElementsByTagName("head")[0].appendChild(script);
}
static loadScript(url, fnSuccess, fnError, key) {
const script = document.createElement("script");
script.type = "text/javascript";
script.charset = "utf-8";
script.async = true;
script.src = url;
script.setAttribute("data-key", key);
this.fnLoadScriptOrStyle(script, fnSuccess, fnError);
}
static hexEscape(str) {
return str.replace(/[\x00-\x1f]/g, function (char) {
return "\\x" + ("00" + char.charCodeAt(0).toString(16)).slice(-2);
});
}
/*
static hexUnescape(str: string): string {
return str.replace(/\\x([0-9A-Fa-f]{2})/g, function () {
return String.fromCharCode(parseInt(arguments[1], 16));
});
}
*/
static dateFormat(d) {
return d.getFullYear() + "/" + ("0" + (d.getMonth() + 1)).slice(-2) + "/" + ("0" + d.getDate()).slice(-2) + " "
+ ("0" + d.getHours()).slice(-2) + ":" + ("0" + d.getMinutes()).slice(-2) + ":" + ("0" + d.getSeconds()).slice(-2) + "." + ("0" + d.getMilliseconds()).slice(-3);
}
static stringCapitalize(str) {
return str.charAt(0).toUpperCase() + str.substring(1);
}
static numberWithCommas(x) {
const parts = String(x).split(".");
parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
return parts.join(".");
}
static toRadians(deg) {
return deg * Math.PI / 180;
}
static toDegrees(rad) {
return rad * 180 / Math.PI;
}
static toPrecision9(num) {
const numStr = num.toPrecision(9), // some rounding, formatting
[decimal, exponent] = numStr.split("e"), // eslint-disable-line array-element-newline
result = String(Number(decimal)) + (exponent !== undefined ? ("E" + exponent.replace(/(\D)(\d)$/, "$10$2")) : "");
return result;
}
static testIsSupported(testExpression) {
try {
Function(testExpression); // eslint-disable-line no-new-func
}
catch (e) {
return false;
}
return true;
}
static supportsBinaryLiterals = Utils.testIsSupported("0b01"); // does the browser support binary literals?
static supportReservedNames = Utils.testIsSupported("({}).return()"); // does the browser support reserved names (delete, new, return) in dot notation? (not old IE8; "goto" is ok)
static stringTrimEnd(str) {
return str.replace(/[\s\uFEFF\xA0]+$/, "");
}
static localStorage = (typeof Polyfills !== "undefined" && Polyfills.localStorage) ? Polyfills.localStorage : (typeof window !== "undefined" ? window.localStorage : undefined);
static atob = function (data) {
return window.atob(data);
};
static btoa = function (data) {
return window.btoa(data);
};
static isCustomError(e) {
return e.pos !== undefined;
}
static split2(str, char) {
const index = str.indexOf(char);
return index >= 0 ? [str.slice(0, index), str.slice(index + 1)] : [str]; // eslint-disable-line array-element-newline
}
static string2Uint8Array(data) {
const buf = new ArrayBuffer(data.length), view = new Uint8Array(buf);
for (let i = 0; i < data.length; i += 1) {
view[i] = data.charCodeAt(i);
}
return view;
}
static uint8Array2string(data) {
const callSize = 25000; // use call window to avoid "maximum call stack error" for e.g. size 336461
let len = data.length, offset = 0, out = "";
while (len) {
const chunkLen = Math.min(len, callSize), chunk = data.slice ? data.slice(offset, offset + chunkLen) : data.subarray(offset, offset + chunkLen); // array.slice on Uint8Array not for IE11
out += String.fromCharCode.apply(null, chunk); // on Chrome this is faster than single character processing
offset += chunkLen;
len -= chunkLen;
}
return out;
}
static composeError(name, errorObject, message, value, pos, len, line, hidden) {
const customError = errorObject;
customError.name = name;
customError.message = message;
customError.value = value;
if (pos !== undefined) {
customError.pos = pos;
}
if (len !== undefined) {
customError.len = len;
}
if (line !== customError.line) {
customError.line = line;
}
if (hidden !== undefined) {
customError.hidden = hidden;
}
let errorLen = customError.len;
if (errorLen === undefined && customError.value !== undefined) {
errorLen = String(customError.value).length;
}
const endPos = (customError.pos || 0) + (errorLen || 0), lineMsg = (customError.line !== undefined ? " in " + customError.line : ""), posMsg = pos !== undefined ? (" at pos " + (pos !== endPos ? customError.pos + "-" + endPos : customError.pos)) : "";
customError.shortMessage = customError.message + (lineMsg || posMsg) + ": " + customError.value;
customError.message += lineMsg + posMsg + ": " + customError.value;
return customError;
}
static composeVmError(name, errorObject, errCode, value) {
const customError = Utils.composeError(name, errorObject, String(errCode), value);
customError.errCode = errCode;
return customError;
}
}
class BasicFormatter {
options;
label = ""; // current label (line) for error messages
constructor(options) {
this.options = {
implicitLines: false
};
this.setOptions(options);
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
composeError(error, message, value, pos, len) {
return Utils.composeError("BasicFormatter", error, message, value, pos, len, this.label);
}
static fnHasLabel(label) {
return label !== "";
}
fnCreateLabelEntry(node, lastLine, implicitLines) {
const origLen = (node.orig || node.value).length;
if (!BasicFormatter.fnHasLabel(node.value) && implicitLines) {
node.value = String(lastLine + 1); // generate label
}
const label = node.value;
this.label = label; // for error messages
if (BasicFormatter.fnHasLabel(label)) {
const line = Number(label);
if (line < 1 || line > 65535) {
throw this.composeError(Error(), "Line number overflow", label, node.pos, node.len);
}
if (line <= lastLine) {
throw this.composeError(Error(), "Expected increasing line number", label, node.pos, node.len);
}
}
const labelEntry = {
value: label,
pos: node.pos,
len: origLen, // original length
refCount: 0
};
return labelEntry;
}
fnCreateLabelMap(nodes, implicitLines) {
const lines = {}; // line numbers
let lastLine = 0;
for (let i = 0; i < nodes.length; i += 1) {
const node = nodes[i];
if (node.type === "label") {
const labelEntry = this.fnCreateLabelEntry(node, lastLine, implicitLines);
lines[labelEntry.value] = labelEntry;
lastLine = Number(labelEntry.value);
}
}
return lines;
}
fnAddSingleReference(node, lines, refs) {
if (node.type === "linenumber") {
if (node.value in lines) {
refs.push({
value: node.value,
pos: node.pos,
len: (node.orig || node.value).length
});
const linesEntry = lines[node.value];
if (linesEntry.refCount === undefined) { // not needed for renum but for removing line numbers
linesEntry.refCount = 1;
}
else {
linesEntry.refCount += 1;
}
}
else {
throw this.composeError(Error(), "Line does not exist", node.value, node.pos);
}
}
}
fnAddReferencesForNode(node, lines, refs) {
if (node.type === "label") {
this.label = node.value;
}
else {
this.fnAddSingleReference(node, lines, refs);
}
if (node.left) {
this.fnAddSingleReference(node.left, lines, refs);
}
if (node.right) {
this.fnAddSingleReference(node.right, lines, refs);
}
if (node.args) {
if (node.type === "onErrorGoto" && node.args.length === 1 && node.args[0].value === "0") {
}
else {
this.fnAddReferences(node.args, lines, refs); // recursive
}
}
}
fnAddReferences(nodes, lines, refs) {
for (let i = 0; i < nodes.length; i += 1) {
this.fnAddReferencesForNode(nodes[i], lines, refs);
}
}
fnRenumberLines(lines, refs, newLine, oldLine, step, keep) {
const changes = {}, keys = Object.keys(lines);
function fnSortbyPosition(a, b) {
return lines[a].pos - lines[b].pos;
}
keys.sort(fnSortbyPosition);
for (let i = 0; i < keys.length; i += 1) {
const lineEntry = lines[keys[i]], hasLabel = BasicFormatter.fnHasLabel(lineEntry.value), line = Number(lineEntry.value);
if (!hasLabel || (line >= oldLine && line < keep)) {
if (newLine > 65535) {
throw this.composeError(Error(), "Line number overflow", lineEntry.value, lineEntry.pos);
}
lineEntry.newValue = String(newLine);
changes[lineEntry.pos] = lineEntry;
newLine += step;
}
}
for (let i = 0; i < refs.length; i += 1) {
const ref = refs[i], lineString = ref.value, line = Number(lineString);
if (line >= oldLine && line < keep) {
if (lineString !== lines[lineString].newValue) {
ref.newValue = lines[lineString].newValue;
changes[ref.pos] = ref;
}
}
}
return changes;
}
static fnSortNumbers(a, b) {
return a - b;
}
static fnApplyChanges(input, changes) {
const keys = Object.keys(changes).map(Number);
keys.sort(BasicFormatter.fnSortNumbers);
for (let i = keys.length - 1; i >= 0; i -= 1) {
const line = changes[keys[i]];
input = input.substring(0, line.pos) + line.newValue + input.substring(line.pos + line.len);
}
return input;
}
fnRenumber(input, parseTree, newLine, oldLine, step, keep) {
const refs = [], // references
lines = this.fnCreateLabelMap(parseTree, Boolean(this.options.implicitLines));
this.fnAddReferences(parseTree, lines, refs); // create reference list
const changes = this.fnRenumberLines(lines, refs, newLine, oldLine, step, keep), output = BasicFormatter.fnApplyChanges(input, changes);
return output;
}
renumber(input, newLine, oldLine, step, keep) {
const out = {
text: ""
};
this.label = ""; // current line (label)
try {
const tokens = this.options.lexer.lex(input), parseTree = this.options.parser.parse(tokens), output = this.fnRenumber(input, parseTree, newLine, oldLine, step, keep || 65535);
out.text = output;
}
catch (e) {
if (Utils.isCustomError(e)) {
out.error = e;
}
else { // other errors
out.error = e; // force set other error
Utils.console.error(e);
}
}
return out;
}
fnRemoveUnusedLines(input, parseTree) {
const refs = [], // references
implicitLines = true, lines = this.fnCreateLabelMap(parseTree, implicitLines);
this.fnAddReferences(parseTree, lines, refs); // create reference list
const changes = {}, keys = Object.keys(lines);
for (let i = 0; i < keys.length; i += 1) {
const lineEntry = lines[keys[i]];
if (lineEntry.len && !lineEntry.refCount) { // non-empty label without references?
lineEntry.newValue = ""; // set empty line number
if (input[lineEntry.pos + lineEntry.len] === " ") { // space following line number?
lineEntry.len += 1; // remove it as well
}
changes[lineEntry.pos] = lineEntry;
}
}
const output = BasicFormatter.fnApplyChanges(input, changes);
return output;
}
removeUnusedLines(input) {
const out = {
text: ""
};
this.label = ""; // current line (label)
try {
const tokens = this.options.lexer.lex(input), parseTree = this.options.parser.parse(tokens), output = this.fnRemoveUnusedLines(input, parseTree);
out.text = output;
}
catch (e) {
if (Utils.isCustomError(e)) {
out.error = e;
}
else { // other errors
out.error = e; // force set other error
Utils.console.error(e);
}
}
return out;
}
}
class BasicLexer {
options;
label = ""; // for error messages
takeNumberAsLabel = true; // first number in a line is assumed to be a label (line number)
input = ""; // input to analyze
index = 0; // position in input
tokens = [];
whiteSpace = ""; // collected whitespace
constructor(options) {
this.options = {
keepWhiteSpace: false,
quiet: false
};
this.setOptions(options);
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
composeError(error, message, value, pos, len) {
return Utils.composeError("BasicLexer", error, message, value, pos, len, this.label || undefined);
}
static isOperatorOrStreamOrAddress(c) {
return (/[+\-*/^=()[\],;:?\\@#]/).test(c);
}
static isComparison(c) {
return (/[<>]/).test(c);
}
static isComparison2(c) {
return (/[<>=]/).test(c);
}
static isDigit(c) {
return (/\d/).test(c);
}
static isSign(c) {
return (/[+-]/).test(c);
}
static isBin(c) {
return (/[01]/).test(c);
}
static isHex(c) {
return (/[0-9A-Fa-f]/).test(c);
}
static isWhiteSpace(c) {
return (/[ \r]/).test(c);
}
static isNotQuotes(c) {
return c !== "" && c !== '"' && c !== "\n"; // quoted string must be in one line!
}
static isIdentifierStart(c) {
return c !== "" && (/[A-Za-z]/).test(c); // cannot use complete [A-Za-z]+[\w]*[$%!]?
}
static isIdentifierMiddle(c) {
return c !== "" && (/[A-Za-z0-9.]/).test(c);
}
static isIdentifierEnd(c) {
return c !== "" && (/[$%!]/).test(c);
}
static isNotNewLine(c) {
return c !== "" && c !== "\n";
}
static isUnquotedData(c) {
return c !== "" && (/[^:,\r\n]/).test(c);
}
testChar(add) {
return this.input.charAt(this.index + add);
}
getChar() {
return this.input.charAt(this.index);
}
advance() {
this.index += 1;
return this.getChar();
}
advanceWhile(char, fn) {
let token = "";
do {
token += char;
char = this.advance();
} while (fn(char));
return token;
}
debugCheckValue(type, value, pos, orig) {
const origValue = orig || value, part = this.input.substring(pos, pos + origValue.length);
if (part !== origValue) {
Utils.console.debug("BasicLexer:debugCheckValue:", type, part, "<>", origValue, "at pos", pos);
}
}
addToken(type, value, pos, orig) {
const node = {
type: type,
value: value,
pos: pos
};
if (orig !== undefined) {
if (orig !== value) {
node.orig = orig;
}
}
if (this.whiteSpace !== "") {
node.ws = this.whiteSpace;
this.whiteSpace = "";
}
if (Utils.debug > 1) {
this.debugCheckValue(type, value, pos, node.orig); // check position of added value
}
this.tokens.push(node);
}
fnParseExponentialNumber(char) {
let token = "", index = 1;
while (BasicLexer.isWhiteSpace(this.testChar(index))) { // whitespace between e and rest?
index += 1;
}
const char1 = this.testChar(index), char2 = this.testChar(index + 1);
if (BasicLexer.isDigit(char1) || (BasicLexer.isSign(char1) && BasicLexer.isDigit(char2))) { // so it is a number
token += char; // take "E"
char = this.advance();
while (BasicLexer.isWhiteSpace(char)) {
token += char;
char = this.advance();
}
if (BasicLexer.isSign(char)) {
token += char; // take sign "+" or "-"
char = this.advance();
}
if (BasicLexer.isDigit(char)) {
token += this.advanceWhile(char, BasicLexer.isDigit);
}
}
return token;
}
fnParseNumber(char, startPos, startsWithDot) {
let token = "";
if (startsWithDot) {
token = char;
char = this.advance();
}
token += this.advanceWhile(char, BasicLexer.isDigit); // TODO: isDigitOrSpace: numbers may contain spaces!
char = this.getChar();
if (char === "." && !startsWithDot) {
token += char;
char = this.advance();
if (BasicLexer.isDigit(char)) { // digits after dot?
token += this.advanceWhile(char, BasicLexer.isDigit);
char = this.getChar();
}
}
let expNumberPart = "";
if (char === "e" || char === "E") { // we also try to check: [eE][+-]?\d+; because "E" could be ERR, ELSE,...
expNumberPart = this.fnParseExponentialNumber(char);
token += expNumberPart;
if (expNumberPart[1] === " " && !this.options.quiet) {
Utils.console.warn(this.composeError({}, "Whitespace in exponential number", token, startPos).message);
}
}
const orig = token;
token = token.replace(/ /g, ""); // remove spaces
if (!isFinite(Number(token))) { // Infnity?
throw this.composeError(Error(), "Number is too large or too small", token, startPos); // for a 64-bit double
}
const number = expNumberPart ? token : parseFloat(token);
this.addToken(expNumberPart ? "expnumber" : "number", String(number), startPos, orig); // store number as string
if (this.takeNumberAsLabel) {
this.takeNumberAsLabel = false;
this.label = String(number); // save just for error message
}
}
fnParseCompleteLineForRemOrApostrophe(char, startPos) {
if (BasicLexer.isNotNewLine(char)) {
let token = this.advanceWhile(char, BasicLexer.isNotNewLine), whiteSpace = "";
char = this.getChar();
if (token.endsWith("\r")) {
token = token.substring(0, token.length - 1);
whiteSpace = "\r";
}
this.addToken("unquoted", token, startPos);
if (whiteSpace && this.options.keepWhiteSpace) {
this.whiteSpace = whiteSpace;
}
}
return char;
}
fnParseWhiteSpace(char) {
const token = this.advanceWhile(char, BasicLexer.isWhiteSpace);
if (this.options.keepWhiteSpace) {
this.whiteSpace = token;
}
}
fnParseUnquoted(char, pos) {
const reSpacesAtEnd = new RegExp(/\s+$/);
let token = this.advanceWhile(char, BasicLexer.isUnquotedData);
const match = reSpacesAtEnd.exec(token), endingSpaces = (match && match[0]) || "";
token = token.trim(); // remove whitespace before and after; do we need this?
this.addToken("unquoted", token, pos); // could be interpreted as string or number during runtime
if (this.options.keepWhiteSpace) {
this.whiteSpace = endingSpaces;
}
}
fnParseCompleteLineForData(char) {
let pos;
while (BasicLexer.isNotNewLine(char)) {
if (BasicLexer.isWhiteSpace(char)) {
this.fnParseWhiteSpace(char);
char = this.getChar();
}
if (char === "\n") { // now newline?
break;
}
pos = this.index;
if (char === '"') {
this.fnParseString(pos);
char = this.getChar();
}
else if (char === ",") { // empty argument?
}
else {
this.fnParseUnquoted(char, pos);
char = this.getChar();
}
if (BasicLexer.isWhiteSpace(char)) {
this.fnParseWhiteSpace(char);
char = this.getChar();
}
if (char !== ",") {
break;
}
pos = this.index;
this.addToken(char, char, pos); // ","
char = this.advance();
if (char === "\r") { // IE8 has "/r/n" newlines
char = this.advance();
}
}
}
fnParseIdentifier(char, startPos) {
let token = char;
char = this.advance();
let lcToken = (token + char).toLowerCase(); // combine first 2 letters
if (lcToken === "fn" && this.options.keywords[lcToken]) {
this.addToken(lcToken, token + char, startPos); // create "fn" token
this.advance();
return;
}
if (BasicLexer.isIdentifierMiddle(char)) {
token += this.advanceWhile(char, BasicLexer.isIdentifierMiddle);
char = this.getChar();
}
if (BasicLexer.isIdentifierEnd(char)) {
token += char;
char = this.advance();
}
lcToken = token.toLowerCase();
if (this.options.keywords[lcToken]) {
this.addToken(lcToken, token, startPos);
if (lcToken === "rem") { // special handling for line comment
startPos += lcToken.length;
this.fnParseCompleteLineForRemOrApostrophe(char, startPos);
}
else if (lcToken === "data") { // special handling because strings in data lines need not to be quoted
this.fnParseCompleteLineForData(char);
}
}
else {
this.addToken("identifier", token, startPos);
}
}
fnParseHexOrBin(char, startPos) {
let token = char;
char = this.advance();
if (char.toLowerCase() === "x") { // binary?
token += char;
char = this.advance();
if (BasicLexer.isBin(char)) {
token += this.advanceWhile(char, BasicLexer.isBin);
this.addToken("binnumber", token, startPos);
}
else {
throw this.composeError(Error(), "Expected binary number", token, startPos);
}
}
else { // hex
if (char.toLowerCase() === "h") { // optional h
token += char;
char = this.advance();
}
if (BasicLexer.isHex(char)) {
token += this.advanceWhile(char, BasicLexer.isHex);
this.addToken("hexnumber", token, startPos);
}
else {
throw this.composeError(Error(), "Expected hex number", token, startPos);
}
}
}
fnTryContinueString(char) {
let out = "";
while (char === "\n") {
const char1 = this.testChar(1);
if (char1 !== "" && (char1 < "0" || char1 > "9")) { // heuristic: next char not a digit => continue with the (multiline) string
out += this.advanceWhile(char, BasicLexer.isNotQuotes);
char = this.getChar();
}
else {
break;
}
}
return out;
}
fnParseString(startPos) {
let char = "", token = this.advanceWhile(char, BasicLexer.isNotQuotes), type = "string", whiteSpace = "";
char = this.getChar();
if (char !== '"') {
const contString = this.fnTryContinueString(char); // heuristic to detect an LF in the string
if (contString) {
if (Utils.debug) {
Utils.console.debug(this.composeError({}, "Continued string", token, startPos + 1).message);
}
token += contString;
char = this.getChar();
}
}
if (char === '"') { // not for newline
this.advance();
}
else {
if (Utils.debug) {
Utils.console.debug(this.composeError({}, "Unterminated string", token, startPos + 1).message);
}
type = "ustring"; // unterminated string
if (token.endsWith("\r")) {
token = token.substring(0, token.length - 1);
whiteSpace = "\r";
}
}
this.addToken(type, token, startPos + 1);
if (whiteSpace && this.options.keepWhiteSpace) {
this.whiteSpace = whiteSpace;
}
}
fnParseRsx(char, startPos) {
let token = char;
char = this.advance();
if (BasicLexer.isIdentifierMiddle(char)) {
token += this.advanceWhile(char, BasicLexer.isIdentifierMiddle);
}
this.addToken("|", token, startPos);
}
processNextCharacter(startPos) {
let char = this.getChar(), token;
if (BasicLexer.isWhiteSpace(char)) {
this.fnParseWhiteSpace(char);
}
else if (char === "\n") {
this.addToken("(eol)", char, startPos);
this.advance();
this.takeNumberAsLabel = true;
}
else if (char === "'") { // apostrophe (comment)
this.addToken(char, char, startPos);
char = this.advance();
this.fnParseCompleteLineForRemOrApostrophe(char, startPos + 1);
}
else if (BasicLexer.isOperatorOrStreamOrAddress(char)) {
this.addToken(char, char, startPos);
this.advance();
}
else if (BasicLexer.isDigit(char)) { // number starting with a digit?
this.fnParseNumber(char, startPos, false);
}
else if (char === ".") { // number starting with a dot?
this.fnParseNumber(char, startPos, true);
}
else if (char === "&") { // isHexOrBin: bin: &X, hex: & or &H
this.fnParseHexOrBin(char, startPos);
}
else if (char === '"') {
this.fnParseString(startPos);
}
else if (BasicLexer.isIdentifierStart(char)) {
this.fnParseIdentifier(char, startPos);
}
else if (char === "|") { // isRsx
this.fnParseRsx(char, startPos);
}
else if (BasicLexer.isComparison(char)) {
token = this.advanceWhile(char, BasicLexer.isComparison2);
this.addToken(token, token, startPos); // like operator
}
else {
throw this.composeError(Error(), "Unrecognized token", char, startPos);
}
}
lex(input) {
let startPos;
this.input = input;
this.index = 0;
this.label = ""; // for error messages
this.takeNumberAsLabel = true;
this.whiteSpace = "";
this.tokens.length = 0;
while (this.index < input.length) {
startPos = this.index;
this.processNextCharacter(startPos);
}
this.addToken("(end)", "", this.index);
return this.tokens;
}
}
class BasicParser {
options;
keywordsBasic10; // keyward list for BASIC 1.0
keywords = BasicParser.keywordsBasic11;
label = "0"; // for error messages
symbols = {};
tokens = [];
index = 0;
previousToken;
token; // current token
parseTree = [];
statementList = []; // just to check last statement when generating error message
constructor(options) {
this.options = {
basicVersion: "1.1", // default
quiet: false,
keepBrackets: false,
keepColons: false,
keepDataComma: false,
keepTokens: false
};
this.setOptions(options, true);
this.previousToken = {}; // to avoid warnings
this.token = this.previousToken;
}
getOptions() {
return this.options;
}
setOptions(options, force) {
const currentBasicVersion = this.options.basicVersion;
Object.assign(this.options, options);
if (force || (this.options.basicVersion !== currentBasicVersion)) { // changed?
this.applyBasicVersion();
}
}
getKeywords() {
return this.keywords;
}
applyBasicVersion() {
const basicVersion = this.options.basicVersion;
this.keywords = basicVersion === "1.0" ? this.getKeywords10() : BasicParser.keywordsBasic11;
this.fnClearSymbols();
this.fnGenerateSymbols();
}
static parameterTypes = {
c: "command",
f: "function",
o: "operator",
n: "number",
s: "string",
l: "line number", // checked
q: "line number range",
v: "variable", // checked,
r: "letter or range",
a: "any parameter",
"n0?": "optional parameter with default null",
"#": "stream"
};
static keywordsBasic11 = {
abs: "f n", // ABS(<numeric expression>)
after: "c", // => afterGosub
afterGosub: "c n n?", // AFTER <timer delay>[,<timer number>] GOSUB <line number> / (special, cannot check optional first n, and line number)
and: "o", // <argument> AND <argument>
asc: "f s", // ASC(<string expression>)
atn: "f n", // ATN(<numeric expression>)
auto: "c n0? n0?", // AUTO [<line number>][,<increment>]
bin$: "f n n?", // BIN$(<unsigned integer expression>[,<integer expression>])
border: "c n n?", // BORDER <color>[,<color>]
"break": "p", // see: ON BREAK...
call: "c n *", // CALL <address expression>[,<list of: parameter>]
cat: "c", // CAT
chain: "c s n? *", // CHAIN <filename>[,<line number expression>][,DELETE <line number range>]  (accepts also delete syntax) or: => chainMerge
chainMerge: "c s n? *", // CHAIN MERGE <filename>[,<line number expression>][,DELETE <line number range>] / (special)
chr$: "f n", // CHR$(<integer expression>)
cint: "f n", // CINT(<numeric expression>)
clear: "c", // CLEAR  or: => clearInput
clearInput: "c", // CLEAR INPUT  (BASIC 1.1)
clg: "c n?", // CLG [<ink>]
closein: "c", // CLOSEIN
closeout: "c", // CLOSEOUT
cls: "c #0?", // CLS[#<stream expression>]
cont: "c", // CONT
copychr$: "f #", // COPYCHR$(#<stream expression>)  (BASIC 1.1)
cos: "f n", // COS(<numeric expression>)
creal: "f n", // CREAL(<numeric expression>)
cursor: "c #0? n0? n?", // CURSOR [<system switch>][,<user switch>] (either parameter can be omitted but not both)  (BASIC 1.1)
data: "c n0*", // DATA <list of: constant> (rather 0*, insert dummy null, if necessary)
dec$: "f n s", // DEC$(<numeric expression>,<format template>)  (corrected with BASIC 1.1)
def: "c s *", // DEF FN[<space>]<function name>[(<formal parameters>)]=<expression> / (not checked from this)
defint: "c r r*", // DEFINT <list of: letter range>
defreal: "c r r*", // DEFREAL <list of: letter range>
defstr: "c r r*", // DEFSTR <list of: letter range>
deg: "c", // DEG
"delete": "c q0?", // DELETE [<line number range>]
derr: "f", // DERR [BASIC 1.1]
di: "c", // DI
dim: "c v *", // DIM <list of: subscripted variable>
draw: "c n n n0? n?", // DRAW <x coordinate>,<y coordinate>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink mode>)
drawr: "c n n n0? n?", // DRAWR <x offset>,<y offset>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink mode>)
edit: "c l", // EDIT <line number>
ei: "c", // EI
"else": "c", // see: IF (else belongs to "if", but can also be used as command)
end: "c", // END
ent: "c n *", // ENT <envelope number>[,<envelope section][,<envelope section>]... (up to 5) / section: <number of steps>,<step size>,<pause time>  or: =<tone period>,<pause time>
env: "c n *", // ENV <envelope number>[,<envelope section][,<envelope section>]... (up to 5) / section: <number of steps>,<step size>,<pause time>  or: =<hardware envelope>,<envelope period>
eof: "f", // EOF
erase: "c v *", // ERASE <list of: variable name>  (array names without indices or dimensions)
erl: "f", // ERL
err: "f", // ERR
error: "c n", // ERROR <integer expression>
every: "c", // => everyGosub
everyGosub: "c n n?", // EVERY <timer delay>[,<timer number>] GOSUB <line number>  / (special, cannot check optional first n, and line number)
exp: "f n", // EXP(<numeric expression>)
fill: "c n", // FILL <ink>  (BASIC 1.1)
fix: "f n", // FIX(<numeric expression>)
fn: "x", // see DEF FN / (FN can also be separate from <function name>)
"for": "c", // FOR <simple variable>=<start> TO <end> [STEP <size>]
frame: "c", // FRAME
fre: "f a", // FRE(<numeric expression>)  or: FRE(<string expression>)
gosub: "c l", // GOSUB <line number>
"goto": "c l", // GOTO <line number>
graphics: "c", // => graphicsPaper or graphicsPen  (BASIC 1.1)
graphicsPaper: "x n", // GRAPHICS PAPER <ink>  / (special)  (BASIC 1.1)
graphicsPen: "x n0? n?", // GRAPHICS PEN [<ink>][,<background mode>]  / (either of the parameters may be omitted, but not both)  (BASIC 1.1)
hex$: "f n n?", // HEX$(<unsigned integer expression>[,<field width>])
himem: "f", // HIMEM
"if": "c", // IF <logical expression> THEN <option part> [ELSE <option part>]
ink: "c n n n?", // INK <ink>,<color>[,<color>]
inkey: "f n", // INKEY(<integer expression>)
inkey$: "f", // INKEY$
inp: "f n", // INP(<port number>)
input: "c #0? *", // INPUT[#<stream expression>,][;][<quoted string><separator>]<list of: variable>  / (special: not checked from this)
instr: "f a a a?", // INSTR([<start position>,]<searched string>,<searched for string>)  / (cannot check "f n? s s")
"int": "f n", // INT(<numeric expression>)
joy: "f n", // JOY(<integer expression>)
key: "c n s", // KEY <expansion token number>,<string expression>  / or: => keyDef
keyDef: "c n n n? n? n?", // KEY DEF <key number>,<repeat>[,<normal>[,<shifted>[,<control>]]]
left$: "f s n", // LEFT$(<string expression>,<required length>)
len: "f s", // LEN(<string expression>)
let: "c", // LET <variable>=<expression>
line: "c", // => lineInput / (not checked from this)
lineInput: "c #0? *", // INPUT INPUT[#<stream expression>,][;][<quoted string><separator>]<string variable> (not checked from this)
list: "c q0? #0?", // LIST [<line number range>][,#<stream expression>] (not checked from this, we cannot check multiple optional args; here we have stream as last parameter)
load: "c s n?", // LOAD <filename>[,<address expression>]
locate: "c #0? n n", // LOCATE [#<stream expression>,]<x coordinate>,<y coordinate>
log: "f n", // LOG(<numeric expression>)
log10: "f n", // LOG10(<numeric expression>)
lower$: "f s", // LOWER$(<string expression>)
mask: "c n0? n?", // MASK [<integer expression>][,<first point setting>]  / (either of the parameters may be omitted, but not both)  (BASIC 1.1)
max: "f a *", // MAX(<list of: numeric expression> | <one number of string>)
memory: "c n", // MEMORY <address expression>
merge: "c s", // MERGE <filename>
mid$: "f s n n?", // MID$(<string expression>,<start position>[,<sub-string length>])  / (start position=1..255, sub-string length=0..255)
mid$Assign: "f s n n?", // MID$(<string variable>,<insertion point>[,<new string length>])=<new string expression>  / (mid$ as assign)
min: "f a *", // MIN(<list of: numeric expression> | <one number of string>)
mod: "o", // <argument> MOD <argument>
mode: "c n", // MODE <integer expression>
move: "c n n n0? n?", // MOVE <x coordinate>,<y coordinate>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink>,<ink mode>)
mover: "c n n n0? n?", // MOVER <x offset>,<y offset>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink>,<ink mode>)
"new": "c", // NEW
next: "c v*", // NEXT [<list of: variable>]
not: "o", // NOT <argument>
on: "c", // => onBreakCont, on break gosub, on break stop, on error goto, on <ex> gosub, on <ex> goto, on sq(n) gosub
onBreakCont: "c", // ON BREAK CONT  / (special)
onBreakGosub: "c l", // ON BREAK GOSUB <line number>  / (special)
onBreakStop: "c", // ON BREAK STOP  / (special)
onErrorGoto: "c l", // ON ERROR GOTO <line number>  / (special)
onGosub: "c l l*", // ON <selector> GOSUB <list of: line number>  / (special; n not checked from this)
onGoto: "c l l*", // ON <selector> GOTO <list of: line number>  / (special; n not checked from this)
onSqGosub: "c l", // ON SQ(<channel>) GOSUB <line number>  / (special)
openin: "c s", // OPENIN <filename>
openout: "c s", // OPENOUT <filename>
or: "o", // <argument> OR <argument>
origin: "c n n n? n? n? n?", // ORIGIN <x>,<y>[,<left>,<right>,<top>,<bottom>]
out: "c n n", // OUT <port number>,<integer expression>
paper: "c #0? n", // PAPER[#<stream expression>,]<ink>
peek: "f n", // PEEK(<address expression>)
pen: "c #0? n0 n?", // PEN[#<stream expression>,][<ink>][,<background mode>]  / ink=0..15; background mode=0..1 (BASIC 1.1 with <background mode)
pi: "f", // PI
plot: "c n n n0? n?", // PLOT <x coordinate>,<y coordinate>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink mode>)
plotr: "c n n n0? n?", // PLOTR <x offset>,<y offset>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink mode>)
poke: "c n n", // POKE <address expression>,<integer expression>
pos: "f #", // POS(#<stream expression>)
print: "c #0? *", // PRINT[#<stream expression>,][<list of: print items>] ... [;][SPC(<integer expression>)] ... [;][TAB(<integer expression>)] ... [;][USING <format template>][<separator expression>]
rad: "c", // RAD
randomize: "c n?", // RANDOMIZE [<numeric expression>]
read: "c v v*", // READ <list of: variable>
release: "c n", // RELEASE <sound channels>  / (sound channels=1..7)
rem: "c s?", // REM <rest of line>
"'": "c s?", // '<rest of line> (apostrophe comment)
remain: "f n", // REMAIN(<timer number>)  / (timer number=0..3)
renum: "c n0? n0? n?", // RENUM [<new line number>][,<old line number>][,<increment>]
restore: "c l?", // RESTORE [<line number>]
resume: "c l?", // RESUME [<line number>]  or: => resumeNext
resumeNext: "c", // RESUME NEXT
"return": "c", // RETURN
right$: "f s n", // RIGHT$(<string expression>,<required length>)
rnd: "f n?", // RND[(<numeric expression>)]
round: "f n n?", // ROUND(<numeric expression>[,<decimals>])
run: "c a?", // RUN <string expression>  or: RUN [<line number>]  / (cannot check "c s | l?")
save: "c s a? n? n? n?", // SAVE <filename>[,<file type>][,<binary parameters>]  // <binary parameters>=<start address>,<file tength>[,<entry point>]
sgn: "f n", // SGN(<numeric expression>)
sin: "f n", // SIN(<numeric expression>)
sound: "c n n n? n0? n0? n0? n?", // SOUND <channel status>,<tone period>[,<duration>[,<volume>[,<valume envelope>[,<tone envelope>[,<noise period>]]]]]
space$: "f n", // SPACE$(<integer expression>)
spc: "f n", // SPC(<integer expression)  / see: PRINT SPC
speed: "c", // => speedInk, speedKey, speedWrite
speedInk: "c n n", // SPEED INK <period1>,<period2>  / (special)
speedKey: "c n n", // SPEED KEY <start delay>,<repeat period>  / (special)
speedWrite: "c n", // SPEED WRITE <integer expression>  / (integer expression=0..1)
sq: "f n", // SQ(<channel>)  / (channel=1,2 or 4)
sqr: "f n", // SQR(<numeric expression>)
step: "p", // STEP <size> / see: FOR
stop: "c", // STOP
str$: "f n", // STR$(<numeric expression>)
string$: "f n a", // STRING$(<length>,<character specificier>) / character specificier=string character or number 0..255
swap: "p n n?", // => windowSwap
symbol: "c n n *", // SYMBOL <character number>,<list of: rows>   or => symbolAfter  / character number=0..255, list of 1..8 rows=0..255
symbolAfter: "c n", // SYMBOL AFTER <integer expression>  / integer expression=0..256 (special)
tab: "f n", // TAB(<integer expression)  / see: PRINT TAB
tag: "c #0?", // TAG[#<stream expression>]
tagoff: "c #0?", // TAGOFF[#<stream expression>]
tan: "f n", // TAN(<numeric expression>)
test: "f n n", // TEST(<x coordinate>,<y coordinate>)
testr: "f n n", // TESTR(<x offset>,<y offset>)
then: "p", // THEN <option part>  / see: IF
time: "f", // TIME
to: "p", // TO <end>  / see: FOR
troff: "c", // TROFF
tron: "c", // TRON
unt: "f n", // UNT(<address expression>)
upper$: "f s", // UPPER$(<string expression>)
using: "p", // USING <format template>[<separator expression>]  / see: PRINT
val: "f s", // VAL (<string expression>)
vpos: "f #", // VPOS(#<stream expression>)
wait: "c n n n?", // WAIT <port number>,<mask>[,<inversion>]
wend: "c", // WEND
"while": "c n", // WHILE <logical expression>
width: "c n", // WIDTH <integer expression>
window: "c #0? n n n n", // WINDOW[#<stream expression>,]<left>,<right>,<top>,<bottom>  / or: => windowSwap
windowSwap: "c n n?", // WINDOW SWAP <stream expression>[,<stream expression>]  / (special: with numbers, not streams)
write: "c #0? *", // WRITE [#<stream expression>,][<write list>]
xor: "o", // <argument> XOR <argument>
xpos: "f", // XPOS
ypos: "f", // YPOS
zone: "c n", // ZONE <integer expression>  / integer expression=1..255
_rsx1: "c a a*", // |<rsxName>[, <argument list>] dummy with at least one parameter
_any1: "x *", // dummy: any number of args
_vars1: "x v*" // dummy: any number of variables
};
/* eslint-disable no-invalid-this */
specialStatements = {
"|": this.rsx, // rsx
after: this.afterEveryGosub,
chain: this.chain,
clear: this.clear,
data: this.data,
def: this.def,
"else": this.fnElse, // simular to a comment, normally not used
ent: this.entOrEnv,
env: this.entOrEnv,
every: this.afterEveryGosub,
"for": this.fnFor,
graphics: this.graphics,
"if": this.fnIf,
input: this.input,
key: this.key,
let: this.let,
line: this.line,
mid$: this.mid$Assign, // mid$Assign
on: this.on,
print: this.print,
"?": this.question, // ? is same as print
resume: this.resume,
run: this.run,
speed: this.speed,
symbol: this.symbol,
window: this.window,
write: this.write
};
/* eslint-enable no-invalid-this */
static closeTokensForLine = {
"(eol)": 1,
"(end)": 1
};
static closeTokensForLineAndElse = {
"(eol)": 1,
"(end)": 1,
"else": 1
};
static closeTokensForArgs = {
":": 1,
"(eol)": 1,
"(end)": 1,
"else": 1,
rem: 1,
"'": 1
};
static fnIsInString(string, find) {
return find && string.indexOf(find) >= 0;
}
getKeywords10() {
if (this.keywordsBasic10) {
return this.keywordsBasic10;
}
const keywords10 = {
...BasicParser.keywordsBasic11
}; // clone
for (const key in keywords10) {
if (keywords10.hasOwnProperty(key)) {
const keyWithSpaces = " " + key + " ";
if (BasicParser.fnIsInString(" clearInput copychr$ cursor derr fill frame graphics graphicsPaper graphicsPen mask onBreakCont ", keyWithSpaces)) {
delete keywords10[key]; // remove keywords which do not exist in BASIC 1.0
}
else if (BasicParser.fnIsInString(" draw drawr move mover pen plot plotr ", keyWithSpaces)) {
keywords10[key] = keywords10[key].substring(0, keywords10[key].lastIndexOf(" ")); // remove the last parameter <ink mode>; or <background mode> for pen
if (BasicParser.fnIsInString(" move mover ", keyWithSpaces)) {
keywords10[key] = keywords10[key].substring(0, keywords10[key].lastIndexOf(" ")); // also remove parameter <ink>
}
}
}
}
this.keywordsBasic10 = keywords10;
return keywords10;
}
composeError(error, message, value, pos, len) {
len = value === "(end)" ? 0 : len;
return Utils.composeError("BasicParser", error, message, value, pos, len, this.label || undefined);
}
fnLastStatementIsOnErrorGotoX() {
const statements = this.statementList;
let isOnErrorGoto = false;
for (let i = statements.length - 1; i >= 0; i -= 1) {
const lastStatement = statements[i];
if (lastStatement.type !== ":") { // ignore colons (separator when keepTokens=true)
if (lastStatement.type === "onErrorGoto" && lastStatement.args && Number(lastStatement.args[0].value) > 0) {
isOnErrorGoto = true;
}
break;
}
}
return isOnErrorGoto;
}
fnMaskedError(node, message) {
if (!this.fnLastStatementIsOnErrorGotoX()) {
throw this.composeError(Error(), message, node.value, node.pos);
}
else if (!this.options.quiet) {
Utils.console.warn(this.composeError({}, message, node.value, node.pos).message);
}
}
advance(id) {
let token = this.token;
this.previousToken = this.token;
if (id && id !== token.type) {
if (!this.fnLastStatementIsOnErrorGotoX()) {
throw this.composeError(Error(), "Expected " + id, token.value === "" ? token.type : token.value, token.pos); // we cannot mask this error because advance is very generic
}
else if (!this.options.quiet) {
Utils.console.warn(this.composeError({}, "Expected " + id, token.value === "" ? token.type : token.value, token.pos).message);
}
}
token = this.tokens[this.index]; // we get a lex token and reuse it as parseTree token
if (!token) { // should not occur
Utils.console.error(this.composeError({}, "advance: End of file", "", this.token && this.token.pos).message);
return this.token; // old token
}
this.index += 1;
const sym = this.symbols[token.type];
if (!sym) {
throw this.composeError(Error(), "Unknown token", token.type, token.pos);
}
this.token = token;
return token;
}
expression(rbp) {
let t = this.token, s = this.symbols[t.type];
if (Utils.debug > 3) {
Utils.console.debug("parse: expression rbp=" + rbp + " type=" + t.type + " t=%o", t);
}
if (t.type === "(end)") {
throw this.composeError(Error(), "Unexpected end of file", "", t.pos);
}
this.advance();
if (!s.nud) {
throw this.composeError(Error(), "Unexpected token", t.value, t.pos);
}
let left = s.nud(t); // process literals, variables, and prefix operators
t = this.token;
s = this.symbols[t.type];
while (rbp < (s.lbp || 0)) { // as long as the right binding power is less than the left binding power of the next token...
this.advance();
if (!s.led) {
throw this.composeError(Error(), "Unexpected token", t.type, t.pos);
}
left = s.led(left); // ...the led method is invoked on the following token (infix and suffix operators), can be recursive
t = this.token;
s = this.symbols[t.type];
}
return left;
}
fnCheckExpressionType(expression, expectedType, typeFirstChar) {
if (expression.type !== expectedType) {
this.fnMaskedError(expression, "Expected " + BasicParser.parameterTypes[typeFirstChar]);
}
}
assignment() {
this.fnCheckExpressionType(this.token, "identifier", "v");
const left = this.expression(90), // take it (can also be an array) and stop
value = this.token;
this.advance("="); // equal as assignment
value.left = left;
value.right = this.expression(0);
value.type = "assign"; // replace "="
return value;
}
statement() {
const t = this.token, s = this.symbols[t.type];
if (s.std) { // statement?
this.advance();
return s.std(this.previousToken);
}
let value;
if (t.type === "identifier") {
value = this.assignment();
}
else {
value = this.expression(0);
}
if (value.type !== "assign" && value.type !== "fcall" && value.type !== "def" && value.type !== "(" && value.type !== "[") {
this.fnMaskedError(t, "Bad expression statement");
}
return value;
}
statements(statementList, closeTokens) {
this.statementList = statementList; // fast hack to access last statement for error messages
let colonExpected = false;
while (!closeTokens[this.token.type]) {
if (colonExpected || this.token.type === ":") {
if (this.token.type !== "'" && this.token.type !== "else") { // no colon required for line comment or ELSE
this.advance(":");
if (this.options.keepColons) {
statementList.push(this.previousToken);
}
else if (this.previousToken.ws) { // colon token has ws?
this.token.ws = this.previousToken.ws + (this.token.ws || ""); // add ws to next token
}
}
colonExpected = false;
}
else {
statementList.push(this.statement());
colonExpected = true;
}
}
return statementList;
}
static fnCreateDummyArg(type, value) {
return {
type: type, // e.g. "null"
value: value || "",
pos: 0,
len: 0
};
}
basicLine() {
let node;
if (this.token.type !== "number") {
node = BasicParser.fnCreateDummyArg("label", "");
node.pos = this.token.pos;
}
else {
this.advance();
node = this.previousToken; // number token
node.type = "label"; // number => label
}
this.label = node.value; // set line number for error messages
node.args = this.statements([], BasicParser.closeTokensForLine);
if (this.token.type === "(eol)") {
if (this.options.keepTokens) { // not really a token
node.args.push(this.token); // eol token with whitespace
}
this.advance();
}
else if (this.token.type === "(end)" && this.token.ws && this.options.keepTokens) {
node.args.push(this.token); // end token with whitespace
}
return node;
}
fnCombineTwoTokensNoArgs(node, token2) {
const name = node.type + Utils.stringCapitalize(this.token.type); // e.g ."speedInk"
node.value += (this.token.ws || " ") + this.token.value; // combine values of both
this.token = this.advance(token2); // for "speed" e.g. "ink", "key", "write" (this.token.type)
if (this.options.keepTokens) {
if (!node.right) {
node.right = this.previousToken; // set second token in first token
}
else { // e.g. on break...
node.right.right = this.previousToken;
}
}
this.previousToken = node; // fast hack to get e.g. "speed" token
return name;
}
fnCombineTwoTokens(node, token2) {
return this.fnCreateCmdCallForType(node, this.fnCombineTwoTokensNoArgs(node, token2));
}
fnGetOptionalStream() {
let node;
if (this.token.type === "#") { // stream?
node = this.expression(0);
}
else { // create dummy
node = BasicParser.fnCreateDummyArg("#"); // dummy stream
node.right = BasicParser.fnCreateDummyArg("null", "0"); // ...with dummy parameter
}
return node;
}
fnChangeNumber2LineNumber(node) {
this.fnCheckExpressionType(node, "number", "l");
node.type = "linenumber"; // change type: number => linenumber
}
fnGetLineRange() {
let left;
if (this.token.type === "number") {
left = this.token;
this.advance();
this.fnChangeNumber2LineNumber(left);
}
let range;
if (this.token.type === "-") {
range = this.token;
this.advance();
}
if (range) {
let right;
if (this.token.type === "number") {
right = this.token;
this.advance();
this.fnChangeNumber2LineNumber(right);
}
range.type = "linerange"; // change "-" => "linerange"
range.left = left || BasicParser.fnCreateDummyArg("null"); // insert dummy for left
range.right = right || BasicParser.fnCreateDummyArg("null"); // insert dummy for right (do not skip it)
}
else if (left) {
range = left; // single line number
}
else {
throw this.composeError(Error(), "Programming error: Undefined range", this.token.value, this.token.pos);
}
return range;
}
static fnIsSingleLetterIdentifier(node) {
return node.type === "identifier" && !node.args && node.value.length === 1;
}
fnGetLetterRange(typeFirstChar) {
this.fnCheckExpressionType(this.token, "identifier", typeFirstChar);
const expression = this.expression(0); // n or n-n
if (BasicParser.fnIsSingleLetterIdentifier(expression)) { // ok
expression.type = "letter"; // change type: identifier -> letter
}
else if (expression.type === "-" && expression.left && expression.right && BasicParser.fnIsSingleLetterIdentifier(expression.left) && BasicParser.fnIsSingleLetterIdentifier(expression.right)) { // also ok
expression.type = "range"; // change type: "-" => range
expression.left.type = "letter"; // change type: identifier -> letter
expression.right.type = "letter"; // change type: identifier -> letter
}
else {
this.fnMaskedError(expression, "Expected " + BasicParser.parameterTypes[typeFirstChar]);
}
return expression;
}
fnCheckRemainingTypes(types) {
for (let i = 0; i < types.length; i += 1) { // some more parameters expected?
const type = types[i];
if (!type.endsWith("?") && !type.endsWith("*")) { // mandatory?
const text = BasicParser.parameterTypes[type] || ("parameter " + type);
this.fnMaskedError(this.token, "Expected " + text + " for " + this.previousToken.type);
}
}
}
fnCheckStaticTypeNotNumber(expression, typeFirstChar) {
const type = expression.type, isStringFunction = (this.keywords[type] || "").startsWith("f") && type.endsWith("$"), isStringIdentifier = type === "identifier" && expression.value.endsWith("$");
if (type === "string" || type === "ustring" || type === "#" || isStringFunction || isStringIdentifier) { // got a string or a stream? (statical check)
this.fnMaskedError(expression, "Expected " + BasicParser.parameterTypes[typeFirstChar]);
}
}
fnCheckStaticTypeNotString(expression, typeFirstChar) {
const type = expression.type, isNumericFunction = (this.keywords[type] || "").startsWith("f") && !type.endsWith("$"), isNumericIdentifier = type === "identifier" && (expression.value.endsWith("%") || expression.value.endsWith("!")), isComparison = type === "=" || type.startsWith("<") || type.startsWith(">"); // =, <, >, <=, >=
if (type === "number" || type === "binnumber" || type === "hexnumber" || type === "expnumber" || type === "#" || isNumericFunction || isNumericIdentifier || isComparison) { // got e.g. number or a stream? (statical check)
this.fnMaskedError(expression, "Expected " + BasicParser.parameterTypes[typeFirstChar]);
}
}
fnGetExpressionForType(args, type, types) {
const typeFirstChar = type.charAt(0), separator = ",";
let expression, suppressAdvance = false;
switch (typeFirstChar) {
case "#": // stream expected? (for functions)
if (type === "#0?") { // optional stream?
if (this.token.type !== "#") { // no stream?
suppressAdvance = true;
type = ",";
}
expression = this.fnGetOptionalStream();
}
else {
expression = this.expression(0);
this.fnCheckExpressionType(expression, "#", typeFirstChar); // check that it is a stream and not a number
}
break;
case "l":
expression = this.expression(0);
this.fnCheckExpressionType(expression, "number", typeFirstChar);
this.fnChangeNumber2LineNumber(expression);
break;
case "v": // variable (identifier)
expression = this.expression(0);
this.fnCheckExpressionType(expression, "identifier", typeFirstChar);
break;
case "r": // letter or range of letters (defint, defreal, defstr)
expression = this.fnGetLetterRange(typeFirstChar);
break;
case "q": // line number range
if (type !== "q0?") { // optional line number range
throw this.composeError(Error(), "Programming error: Unexpected line range type", this.token.type, this.token.pos); // should not occur
}
if (this.token.type === "number" || this.token.type === "-") {
expression = this.fnGetLineRange();
}
else {
expression = BasicParser.fnCreateDummyArg("null");
if (types.length) {
type = ","; // needMore=true, maybe take it as next parameter
}
}
break;
case "n": // number"
if (type.substring(0, 2) === "n0" && this.token.type === separator) { // n0 or n0?: if parameter not specified, insert default value null?
expression = BasicParser.fnCreateDummyArg("null");
}
else {
expression = this.expression(0);
this.fnCheckStaticTypeNotNumber(expression, typeFirstChar);
}
break;
case "s": // string
expression = this.expression(0);
this.fnCheckStaticTypeNotString(expression, typeFirstChar);
break;
default:
expression = this.expression(0);
if (expression.type === "#") { // got stream?
this.fnMaskedError(expression, "Unexpected stream");
}
break;
}
args.push(expression);
if (this.token.type === separator) {
if (!suppressAdvance) {
this.advance(separator);
if (this.options.keepTokens) {
args.push(this.previousToken);
}
}
if (type.slice(-1) !== "*") {
type = "xxx"; // initial needMore
}
}
else if (type !== ",") { // !needMore
type = ""; // stop
}
return type;
}
fnGetArgs(args, keyword) {
const keyOpts = this.keywords[keyword], types = keyOpts.split(" "), closeTokens = BasicParser.closeTokensForArgs;
let type = "xxx"; // initial needMore
types.shift(); // remove keyword type
while (type && !closeTokens[this.token.type]) {
if (types && type.slice(-1) !== "*") { // "*"= any number of parameters
type = types.shift() || "";
if (!type) {
this.fnMaskedError(this.previousToken, "Expected end of arguments"); // If masked, it will accept more args than expected
}
}
type = this.fnGetExpressionForType(args, type, types);
}
if (types.length) { // some more parameters expected?
this.fnCheckRemainingTypes(types); // error if remaining mandatory args
type = types[0];
if (type === "#0?") { // null stream to add?
const expression = BasicParser.fnCreateDummyArg("#"); // dummy stream with dummy arg
expression.right = BasicParser.fnCreateDummyArg("null", "0");
args.push(expression);
}
}
if (this.previousToken.type === "," && keyword !== "delete" && keyword !== "list") { // for line number range in delete, list it is ok
this.fnMaskedError(this.previousToken, "Operand missing");
}
return args;
}
fnGetArgsSepByCommaSemi(args) {
const closeTokens = BasicParser.closeTokensForArgs;
while (!closeTokens[this.token.type]) {
args.push(this.expression(0));
if (this.token.type === "," || this.token.type === ";") {
args.push(this.token); // keep comma or semicolon
this.advance();
}
else {
break;
}
}
return args;
}
fnGetArgsInParenthesis(args, keyword) {
this.advance("(");
if (this.options.keepTokens) {
args.push(this.previousToken);
}
this.fnGetArgs(args, keyword || "_any1"); // until ")"
this.advance(")");
if (this.options.keepTokens) {
args.push(this.previousToken);
}
return args;
}
static brackets = {
"(": ")",
"[": "]"
};
fnGetArgsInParenthesesOrBrackets(args) {
const brackets = BasicParser.brackets;
this.advance(this.token.type === "[" ? "[" : "(");
const bracketOpen = this.previousToken;
args.push(bracketOpen);
this.fnGetArgs(args, "_any1"); // until "]" or ")"
this.advance(this.token.type === "]" ? "]" : ")");
const bracketClose = this.previousToken;
args.push(bracketClose);
if (!this.options.quiet && (brackets[bracketOpen.type] !== bracketClose.type)) {
Utils.console.warn(this.composeError({}, "Inconsistent bracket style", this.previousToken.value, this.previousToken.pos).message);
}
return args;
}
fnCreateCmdCall(node) {
node.args = this.fnGetArgs([], node.type);
return node;
}
fnCreateCmdCallForType(node, type) {
if (type) {
node.type = type; // override
}
return this.fnCreateCmdCall(node);
}
fnCreateFuncCall(node) {
node.args = [];
if (this.token.type === "(") { // args in parenthesis?
if (node.type === "dec$" && this.options.basicVersion === "1.0") {
this.advance("("); // BASIC 1.0: simulate DEC$(( bug with 2 open brackets
}
this.fnGetArgsInParenthesis(node.args, node.type);
}
else { // no parenthesis?
const keyOpts = this.keywords[node.type];
if (keyOpts) {
const types = keyOpts.split(" ");
types.shift(); // remove key
this.fnCheckRemainingTypes(types);
}
}
return node;
}
fnIdentifier(node) {
if (this.token.type === "(" || this.token.type === "[") {
node.args = [];
this.fnGetArgsInParenthesesOrBrackets(node.args);
}
return node;
}
fnParenthesis(node) {
if (this.options.keepBrackets) {
node.args = [this.expression(0)];
}
else {
if (node.ws) { // bracket open has ws?
this.token.ws = node.ws + (this.token.ws || ""); // add ws to next token
}
node = this.expression(0);
}
this.advance(")");
if (this.options.keepBrackets) {
node.args.push(this.previousToken);
}
else if (this.previousToken.ws) { // bracket close token has ws?
this.token.ws = this.previousToken.ws + (this.token.ws || ""); // add ws to next token
}
return node;
}
fnFn(node) {
node.args = [];
this.token = this.advance("identifier");
node.right = this.previousToken;
if (this.token.type === "(") { // optional args?
this.fnGetArgsInParenthesis(node.args);
}
return node;
}
rsx(node) {
node.args = [];
let type = "_any1"; // expect any number of arguments
if (this.token.type === ",") { // arguments starting with comma
this.advance();
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
type = "_rsx1"; // dummy token: expect at least 1 argument
}
this.fnGetArgs(node.args, type); // get arguments
if (this.options.basicVersion === "1.0") { // BASIC 1.0: make sure there are no string parameters
for (let i = 0; i < node.args.length; i += 1) {
this.fnCheckStaticTypeNotNumber(node.args[i], "n");
}
}
return node;
}
afterEveryGosub(node) {
const combinedNode = this.fnCreateCmdCallForType(node, node.type + "Gosub"); // "afterGosub" or "everyGosub", interval and optional timer
if (!combinedNode.args) {
throw this.composeError(Error(), "Programming error: Undefined args", this.token.type, this.token.pos); // should not occur
}
if (combinedNode.args.length < 2) { // add default timer 0
combinedNode.args.push(BasicParser.fnCreateDummyArg("null"));
}
this.advance("gosub");
if (this.options.keepTokens) {
combinedNode.args.push(this.previousToken);
}
this.fnGetArgs(combinedNode.args, "gosub"); // line number
return combinedNode;
}
chain(node) {
if (this.token.type === "merge") { // chain merge?
const name = this.fnCombineTwoTokensNoArgs(node, this.token.type); // chainMerge
node.type = name;
}
node.args = [];
let node2 = this.expression(0); // filename
node.args.push(node2);
if (this.token.type === ",") {
this.token = this.advance();
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
let numberExpression = false; // line number (expression) found
if (this.token.type !== "," && this.token.type !== "(eol)" && this.token.type !== "(end)") {
node2 = this.expression(0); // line number or expression
node.args.push(node2);
numberExpression = true;
}
if (this.token.type === ",") {
this.advance();
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
if (!numberExpression) {
node2 = BasicParser.fnCreateDummyArg("null"); // insert dummy arg for line
node.args.push(node2);
}
this.advance("delete");
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
this.fnGetArgs(node.args, this.previousToken.type); // args for "delete"
}
}
return node;
}
clear(node) {
const tokenType = this.token.type;
return tokenType === "input" && this.keywords.clearInput ? this.fnCombineTwoTokens(node, tokenType) : this.fnCreateCmdCall(node); // "clear input" (BASIC 1.1) or "clear"
}
data(node) {
let parameterFound = false;
node.args = [];
if (this.token.type !== "," && this.token.type !== "(eol)" && this.token.type !== "(end)") {
node.args.push(this.expression(0)); // take first argument
parameterFound = true;
}
while (this.token.type === ",") {
if (!parameterFound) {
node.args.push(BasicParser.fnCreateDummyArg("null")); // insert null parameter
}
this.token = this.advance();
if (this.options.keepDataComma) {
node.args.push(this.previousToken); // ","
}
parameterFound = false;
if (this.token.type === "(eol)" || this.token.type === "(end)") {
break;
}
else if (this.token.type !== ",") {
node.args.push(this.expression(0));
parameterFound = true;
}
}
if (!parameterFound) {
node.args.push(BasicParser.fnCreateDummyArg("null")); // insert null parameter
}
return node;
}
def(node) {
node.args = [];
this.advance("fn");
if (this.options.keepTokens) {
node.right = this.previousToken;
}
this.token = this.advance("identifier");
if (node.right) { // keepTokens
node.right.right = this.previousToken;
}
else {
node.right = this.previousToken;
}
if (this.token.type === "(") {
this.fnGetArgsInParenthesis(node.args, "_vars1"); // accept only variable names
}
this.advance("=");
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
const expression = this.expression(0);
node.args.push(expression);
return node;
}
fnElse(node) {
node.args = [];
node.type += "Comment"; // else => elseComment
if (!this.options.quiet) {
Utils.console.warn(this.composeError({}, "ELSE: Weird use of ELSE", this.previousToken.type, this.previousToken.pos).message);
}
if (this.token.type === "number") { // first token number?
this.fnChangeNumber2LineNumber(this.token);
}
while (this.token.type !== "(eol)" && this.token.type !== "(end)") {
node.args.push(this.token); // collect tokens unchecked, may contain syntax error
this.advance();
}
return node;
}
entOrEnv(node) {
node.args = [this.expression(0)]; // should be number or variable
let count = 0;
while (this.token.type === ",") {
this.token = this.advance();
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
if (this.token.type === "=" && count % 3 === 0) { // special handling for parameter "number of steps"
this.advance();
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
node.args.push(BasicParser.fnCreateDummyArg("null")); // insert null parameter
count += 1;
}
const expression = this.expression(0);
node.args.push(expression);
count += 1;
}
return node;
}
fnFor(node) {
this.fnCheckExpressionType(this.token, "identifier", "v");
const name = this.expression(90); // take simple identifier, nothing more
this.fnCheckExpressionType(name, "identifier", "v"); // expected simple
node.args = [name];
this.advance("=");
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
node.args.push(this.expression(0));
this.token = this.advance("to");
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
node.args.push(this.expression(0));
if (this.token.type === "step") {
this.advance();
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
node.args.push(this.expression(0));
}
return node;
}
graphics(node) {
const tokenType = this.token.type;
if (tokenType !== "pen" && tokenType !== "paper") {
throw this.composeError(Error(), "Expected PEN or PAPER", tokenType, this.token.pos);
}
return this.fnCombineTwoTokens(node, tokenType);
}
fnCheckForUnreachableCode(args) {
for (let i = 0; i < args.length; i += 1) {
const node = args[i], tokenType = node.type;
if ((i === 0 && tokenType === "linenumber") || tokenType === "goto" || tokenType === "stop") {
const index = i + 1;
if (index < args.length && (args[index].type !== "rem") && (args[index].type !== "'")) {
if (args[index].type === ":" && this.options.keepColons) {
}
else if (!this.options.quiet) {
Utils.console.warn(this.composeError({}, "IF: Unreachable code after THEN or ELSE", tokenType, node.pos).message);
}
break;
}
}
}
}
fnIf(node) {
node.right = this.expression(0); // condition
node.args = [];
if (this.token.type !== "goto") { // no "goto", expect "then" token...
this.advance("then");
if (this.options.keepTokens) {
node.args.unshift(this.previousToken);
}
if (this.token.type === "number") {
this.fnGetArgs(node.args, "goto"); // take number parameter as line number
}
}
this.statements(node.args, BasicParser.closeTokensForLineAndElse); // get "then" statements until "else" or eol
this.fnCheckForUnreachableCode(node.args);
if (this.token.type === "else") {
this.token = this.advance("else");
const elseNode = this.previousToken;
node.args.push(elseNode);
elseNode.args = [];
if (this.token.type === "number") {
this.fnGetArgs(elseNode.args, "goto"); // take number parameter as line number
}
if (this.token.type === "if") {
elseNode.args.push(this.statement());
}
else {
this.statements(elseNode.args, BasicParser.closeTokensForLineAndElse);
}
this.fnCheckForUnreachableCode(elseNode.args);
}
return node;
}
input(node) {
const stream = this.fnGetOptionalStream();
node.args = [stream];
if (stream.len !== 0) { // not an inserted stream?
this.advance(",");
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
}
if (this.token.type === ";") { // no newline after input?
node.args.push(this.token);
this.advance();
}
else {
node.args.push(BasicParser.fnCreateDummyArg("null"));
}
if (this.token.type === "string" || this.token.type === "ustring") { // message
node.args.push(this.token);
this.token = this.advance();
if (this.token.type === ";" || this.token.type === ",") { // ";" => need to append prompt "? " , "," = no prompt
node.args.push(this.token);
this.advance();
}
else {
throw this.composeError(Error(), "Expected ; or ,", this.token.type, this.token.pos);
}
}
else {
node.args.push(BasicParser.fnCreateDummyArg("null")); // dummy message
node.args.push(BasicParser.fnCreateDummyArg("null")); // dummy prompt
}
do { // we need loop for input
const value2 = this.expression(90); // we expect "identifier", no fnxx
this.fnCheckExpressionType(value2, "identifier", "v");
node.args.push(value2);
if (node.type === "lineInput" || this.token.type !== ",") {
break; // no loop for lineInput (only one arg) or no more args
}
this.advance(",");
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
} while (true); // eslint-disable-line no-constant-condition
return node;
}
key(node) {
const tokenType = this.token.type;
return tokenType === "def" ? this.fnCombineTwoTokens(node, tokenType) : this.fnCreateCmdCall(node); // "key def" or "key"
}
let(node) {
node.right = this.assignment();
return node;
}
line(node) {
node.type = this.fnCombineTwoTokensNoArgs(node, "input"); // combine "line" => "lineInput"
return this.input(node); // continue with input
}
mid$Assign(node) {
node.type = "mid$Assign"; // change type mid$ => mid$Assign
this.fnCreateFuncCall(node);
if (!node.args) {
throw this.composeError(Error(), "Programming error: Undefined args", this.token.type, this.token.pos); // should not occur
}
let i = 0;
if (this.options.keepTokens) {
while (node.args[i].type === "(" && i < (node.args.length - 1)) {
i += 1;
}
}
this.fnCheckExpressionType(node.args[i], "identifier", "v");
this.advance("="); // equal as assignment
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
const expression = this.expression(0);
node.args.push(expression);
return node;
}
on(node) {
node.args = [];
let tokenType;
switch (this.token.type) {
case "break":
node.type = this.fnCombineTwoTokensNoArgs(node, "break"); // onBreak
tokenType = this.token.type;
if ((tokenType === "cont" && this.keywords.onBreakCont) || tokenType === "gosub" || tokenType === "stop") {
this.fnCombineTwoTokens(node, this.token.type); // onBreakGosub, onBreakCont, onBreakStop
}
else {
const msgContPart = this.keywords.onBreakCont ? "CONT, " : "";
throw this.composeError(Error(), "Expected " + msgContPart + "GOSUB or STOP", this.token.type, this.token.pos);
}
break;
case "error": // on error goto
node.type = this.fnCombineTwoTokensNoArgs(node, "error"); // onError..
this.fnCombineTwoTokens(node, "goto"); // onErrorGoto
break;
case "sq": // on sq(n) gosub
node.right = this.expression(0);
if (!node.right.args) {
throw this.composeError(Error(), "Programming error: Undefined args", this.token.type, this.token.pos); // should not occur
}
this.advance("gosub");
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
node.type = "onSqGosub";
this.fnGetArgs(node.args, node.type);
break;
default: // on <expr> goto|gosub
node.args.push(this.expression(0));
if (this.token.type === "gosub" || this.token.type === "goto") {
this.advance();
if (this.options.keepTokens) {
node.args.push(this.previousToken); // modify
}
node.type = "on" + Utils.stringCapitalize(this.previousToken.type); // onGoto, onGosub
this.fnGetArgs(node.args, node.type);
}
else {
throw this.composeError(Error(), "Expected GOTO or GOSUB", this.token.type, this.token.pos);
}
break;
}
return node;
}
print(node) {
const closeTokens = BasicParser.closeTokensForArgs, stream = this.fnGetOptionalStream();
node.args = [stream];
if (stream.len !== 0) { // not an inserted stream?
if (!closeTokens[this.token.type]) {
this.advance(",");
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
}
}
while (!closeTokens[this.token.type]) {
let node2;
if (this.token.type === "spc" || this.token.type === "tab") {
this.advance();
node2 = this.fnCreateFuncCall(this.previousToken);
}
else if (this.token.type === "using") {
node2 = this.token;
node2.args = [];
this.advance();
node2.args.push(this.expression(0)); // format
this.advance(";"); // after the format there must be a ";"
node2.args.push(this.previousToken); // semicolon
node2.args = this.fnGetArgsSepByCommaSemi(node2.args);
if (this.previousToken.type === ";") { // using closed by ";"?
node2.args.pop(); // remove it from using
node.args.push(node2);
node2 = this.previousToken; // keep it for print
}
}
else if (this.token.type === ";" || this.token.type === ",") { // separator ";" or comma tab separator ","
node2 = this.token;
this.advance();
}
else {
node2 = this.expression(0);
}
node.args.push(node2);
}
return node;
}
question(node) {
const node2 = this.print(node); // not really a new node
node2.type = "print";
return node2;
}
resume(node) {
const tokenType = this.token.type;
return tokenType === "next" ? this.fnCombineTwoTokens(node, tokenType) : this.fnCreateCmdCall(node); // "resume next" or "resume"
}
run(node) {
if (this.token.type === "number") {
node.args = this.fnGetArgs([], "goto"); // we get linenumber arg as for goto
}
else {
node = this.fnCreateCmdCall(node);
}
return node;
}
speed(node) {
const tokenType = this.token.type;
if (tokenType !== "ink" && tokenType !== "key" && tokenType !== "write") {
throw this.composeError(Error(), "Expected INK, KEY or WRITE", tokenType, this.token.pos);
}
return this.fnCombineTwoTokens(node, tokenType);
}
symbol(node) {
const tokenType = this.token.type;
return tokenType === "after" ? this.fnCombineTwoTokens(node, tokenType) : this.fnCreateCmdCall(node); // "symbol after" or "symbol"
}
window(node) {
const tokenType = this.token.type;
return tokenType === "swap" ? this.fnCombineTwoTokens(node, tokenType) : this.fnCreateCmdCall(node); // "window swap" or "window"
}
write(node) {
const closeTokens = BasicParser.closeTokensForArgs, stream = this.fnGetOptionalStream();
node.args = [stream];
if (stream.len !== 0) { // not an inserted stream?
if (!closeTokens[this.token.type]) {
this.advance(",");
if (this.options.keepTokens) {
node.args.push(this.previousToken);
}
}
}
const lengthBefore = node.args.length;
this.fnGetArgsSepByCommaSemi(node.args);
if ((this.previousToken.type === "," && node.args.length > lengthBefore) || this.previousToken.type === ";") {
this.fnMaskedError(this.previousToken, "Operand missing");
}
return node;
}
fnClearSymbols() {
this.symbols = {};
}
static fnNode(node) {
return node;
}
createSymbol(id) {
if (!this.symbols[id]) { // some symbols are extended, e.g. symbols for both infix and prefix
this.symbols[id] = {}; // create symbol
}
return this.symbols[id];
}
createNudSymbol(id, nud) {
const symbol = this.createSymbol(id);
symbol.nud = nud;
return symbol;
}
fnInfixLed(left, rbp) {
const node = this.previousToken;
node.left = left;
node.right = this.expression(rbp);
return node;
}
createInfix(id, lbp, rbp) {
const symbol = this.createSymbol(id);
symbol.lbp = lbp;
symbol.led = (left) => this.fnInfixLed(left, rbp || lbp);
}
createInfixr(id, lbp) {
const symbol = this.createSymbol(id);
symbol.lbp = lbp;
symbol.led = (left) => this.fnInfixLed(left, lbp - 1);
}
fnPrefixNud(rbp) {
const node = this.previousToken;
node.right = this.expression(rbp);
return node;
}
createPrefix(id, rbp) {
this.createNudSymbol(id, () => this.fnPrefixNud(rbp));
}
createStatement(id, fn) {
const symbol = this.createSymbol(id);
symbol.std = () => fn.call(this, this.previousToken);
return symbol;
}
fnGenerateKeywordSymbols() {
for (const key in this.keywords) {
if (this.keywords.hasOwnProperty(key)) {
const keywordType = this.keywords[key].charAt(0);
if (keywordType === "f") {
this.createNudSymbol(key, () => this.fnCreateFuncCall(this.previousToken));
}
else if (keywordType === "c") {
this.createStatement(key, this.specialStatements[key] || this.fnCreateCmdCall);
}
else if (keywordType === "p") { // additional parts of command
this.createSymbol(key);
}
}
}
}
fnGenerateSymbols() {
this.fnGenerateKeywordSymbols();
this.createStatement("|", this.specialStatements["|"]); // rsx
this.createStatement("mid$", this.specialStatements.mid$); // mid$Assign (statement), combine with function
this.createStatement("?", this.specialStatements["?"]); // "?" is same as print
this.createSymbol(":");
this.createSymbol(";");
this.createSymbol(",");
this.createSymbol(")");
this.createSymbol("[");
this.createSymbol("]");
this.createSymbol("(eol)");
this.createSymbol("(end)");
this.createNudSymbol("number", BasicParser.fnNode);
this.createNudSymbol("binnumber", BasicParser.fnNode);
this.createNudSymbol("expnumber", BasicParser.fnNode);
this.createNudSymbol("hexnumber", BasicParser.fnNode);
this.createNudSymbol("linenumber", BasicParser.fnNode);
this.createNudSymbol("string", BasicParser.fnNode);
this.createNudSymbol("ustring", BasicParser.fnNode);
this.createNudSymbol("unquoted", BasicParser.fnNode);
this.createNudSymbol("ws", BasicParser.fnNode); // optional whitespace
this.createNudSymbol("identifier", () => this.fnIdentifier(this.previousToken));
this.createNudSymbol("(", () => this.fnParenthesis(this.previousToken));
this.createNudSymbol("fn", () => this.fnFn(this.previousToken)); // separate fn
this.createPrefix("@", 95); // address of
this.createInfix("^", 90, 80);
this.createPrefix("+", 80); // + can be uses as prefix or infix
this.createPrefix("-", 80); // - can be uses as prefix or infix
this.createInfix("*", 70);
this.createInfix("/", 70);
this.createInfix("\\", 60); // integer division
this.createInfix("mod", 50);
this.createInfix("+", 40); // + can be uses as prefix or infix, so combine with prefix function
this.createInfix("-", 40); // - can be uses as prefix or infix, so combine with prefix function
this.createInfix("=", 30); // equal for comparison, left associative
this.createInfix("<>", 30);
this.createInfix("<", 30);
this.createInfix("<=", 30);
this.createInfix(">", 30);
this.createInfix(">=", 30);
this.createPrefix("not", 23);
this.createInfixr("and", 22);
this.createInfixr("or", 21);
this.createInfixr("xor", 20);
this.createPrefix("#", 10); // priority ok?
}
parse(tokens) {
this.tokens = tokens;
this.label = "0"; // for error messages
this.index = 0;
this.token = {};
this.previousToken = this.token; // just to avoid warning
const parseTree = this.parseTree;
parseTree.length = 0;
this.advance();
while (this.token.type !== "(end)") {
parseTree.push(this.basicLine());
}
return parseTree;
}
}
class BasicTokenizer {
pos = 0;
line = 0;
lineEnd = 0;
input = "";
needSpace = false; // hmm
debug = {
startPos: 0,
line: 0,
info: ""
};
fnNum8Dec() {
const num = this.input.charCodeAt(this.pos);
this.pos += 1;
return num;
}
fnNum16Dec() {
return this.fnNum8Dec() + this.fnNum8Dec() * 256;
}
fnNum32Dec() {
return this.fnNum16Dec() + this.fnNum16Dec() * 65536;
}
fnNum8DecAsStr() {
return String(this.fnNum8Dec());
}
fnNum16DecAsStr() {
return String(this.fnNum16Dec());
}
fnNum16LineAddrAsStr() {
const prgStart = 0x170, // assuming this as program start
lineAddr = this.fnNum16Dec() - prgStart, // address of (byte 0 before line)
addr = lineAddr + 3, // address of line number
line = this.input.charCodeAt(addr) + this.input.charCodeAt(addr + 1) * 256;
return String(line);
}
fnNum16Bin() {
return "&X" + this.fnNum16Dec().toString(2);
}
fnNum16Hex() {
return "&" + this.fnNum16Dec().toString(16).toUpperCase();
}
fnNumFp() {
const value = this.fnNum32Dec(); // signed integer
let exponent = this.fnNum8Dec(), out;
if (!exponent) { // exponent zero? => 0
out = "0";
}
else { // beware: JavaScript has no unsigned int except for ">>> 0"
const mantissa = value >= 0 ? value + 0x80000000 : value;
exponent -= 0x81; // 2-complement: 2^-127 .. 2^128
const num = mantissa * Math.pow(2, exponent - 31);
out = Utils.toPrecision9(num);
}
return out;
}
fnGetBit7TerminatedString() {
const data = this.input;
let pos = this.pos;
while (data.charCodeAt(pos) <= 0x7f && pos < this.lineEnd) { // last character b7=1 (>= 0x80)
pos += 1;
}
const out = data.substring(this.pos, pos) + String.fromCharCode(data.charCodeAt(pos) & 0x7f); // eslint-disable-line no-bitwise
if (pos < this.lineEnd) { // maybe corrupted if used in DATA line
this.pos = pos + 1;
}
return out;
}
fnVar() {
this.fnNum16Dec(); // ignore offset (offset to memory location of variable)
return this.fnGetBit7TerminatedString();
}
fnIntVar() {
return this.fnVar() + "%";
}
fnStringVar() {
return this.fnVar() + "$";
}
fnFpVar() {
return this.fnVar() + "!";
}
fnRsx() {
let name = this.fnGetBit7TerminatedString();
name = name.substring(1); // ignore length (offset to tokens following RSX name)
return "|" + name;
}
static fnControlsToUnicode(s) {
return s.replace(/[\x00-\x1F\x80-\x9F]/g, function (ch) {
return String.fromCharCode(ch.charCodeAt(0) + 0x100);
});
}
fnStringUntilEol() {
const out = BasicTokenizer.fnControlsToUnicode(this.input.substring(this.pos, this.lineEnd - 1)); // take remaining line
this.pos = this.lineEnd;
return out;
}
fnApostrophe() {
return "'" + this.fnStringUntilEol();
}
fnRem() {
return "REM" + this.fnStringUntilEol();
}
fnQuotedString() {
const closingQuotes = this.input.indexOf('"', this.pos);
let out = "";
if (closingQuotes < 0 || closingQuotes >= this.lineEnd) { // unclosed quoted string (quotes not found or not in this line)
out = BasicTokenizer.fnControlsToUnicode(this.fnStringUntilEol()); // take remaining line
}
else {
out = BasicTokenizer.fnControlsToUnicode(this.input.substring(this.pos, closingQuotes + 1));
this.pos = closingQuotes + 1; // after quotes
}
out = '"' + out;
if (out.indexOf("\r") >= 0) {
Utils.console.log("BasicTokenizer line", this.line, ": string contains CR, replaced by CHR$(13)");
out = out.replace(/\r/g, '"+chr$(13)+"');
}
if ((/\n\d/).test(out)) {
Utils.console.log("BasicTokenizer line", this.line, ": string contains LF<digit>, replaced by CHR$(10)<digit>");
out = out.replace(/\n(\d)/g, '"+chr$(10)+"$1');
}
return out;
}
/* eslint-disable no-invalid-this */
tokens = {
0x00: "", // marker for "end of tokenised line"
0x01: ":", // ":" statement seperator
0x02: this.fnIntVar, // integer variable definition (defined with "%" suffix)
0x03: this.fnStringVar, // string variable definition (defined with "$" suffix)
0x04: this.fnFpVar, // floating point variable definition (defined with "!" suffix)
0x05: "var?",
0x06: "var?",
0x07: "var?", // ??
0x08: "var?", // ??
0x09: "var?", // ??
0x0a: "var?", // ??
0x0b: this.fnVar, // integer variable definition (no suffix)
0x0c: this.fnVar, // string variable definition (no suffix)
0x0d: this.fnVar, // floating point or no type (no suffix)
0x0e: "0", // number constant "0"
0x0f: "1", // number constant "1"
0x10: "2", // number constant "2"
0x11: "3", // number constant "3"
0x12: "4", // number constant "4"
0x13: "5", // number constant "5"
0x14: "6", // number constant "6"
0x15: "7", // number constant "7"
0x16: "8", // number constant "8"
0x17: "9", // number constant "9"
0x18: "10", // number constant "10"
0x19: this.fnNum8DecAsStr, // 8-bit integer decimal value
0x1a: this.fnNum16DecAsStr, // 16-bit integer decimal value
0x1b: this.fnNum16Bin, // 16-bit integer binary value (with "&X" prefix)
0x1c: this.fnNum16Hex, // num16Hex: 16-bit integer hexadecimal value (with "&H" or "&" prefix)
0x1d: this.fnNum16LineAddrAsStr, // 16-bit BASIC program line memory address pointer
0x1e: this.fnNum16DecAsStr, // 16-bit integer BASIC line number
0x1f: this.fnNumFp, // floating point value
0x22: this.fnQuotedString, // '"' quoted string value
0x7c: this.fnRsx, // "|" symbol; prefix for RSX commands
0x80: "AFTER",
0x81: "AUTO",
0x82: "BORDER",
0x83: "CALL",
0x84: "CAT",
0x85: "CHAIN",
0x86: "CLEAR",
0x87: "CLG",
0x88: "CLOSEIN",
0x89: "CLOSEOUT",
0x8a: "CLS",
0x8b: "CONT",
0x8c: "DATA",
0x8d: "DEF",
0x8e: "DEFINT",
0x8f: "DEFREAL",
0x90: "DEFSTR",
0x91: "DEG",
0x92: "DELETE",
0x93: "DIM",
0x94: "DRAW",
0x95: "DRAWR",
0x96: "EDIT",
0x97: "ELSE", // always with 0x01 0x97
0x98: "END",
0x99: "ENT",
0x9a: "ENV",
0x9b: "ERASE",
0x9c: "ERROR",
0x9d: "EVERY",
0x9e: "FOR",
0x9f: "GOSUB",
0xa0: "GOTO",
0xa1: "IF",
0xa2: "INK",
0xa3: "INPUT",
0xa4: "KEY",
0xa5: "LET",
0xa6: "LINE",
0xa7: "LIST",
0xa8: "LOAD",
0xa9: "LOCATE",
0xaa: "MEMORY",
0xab: "MERGE",
0xac: "MID$",
0xad: "MODE",
0xae: "MOVE",
0xaf: "MOVER",
0xb0: "NEXT",
0xb1: "NEW",
0xb2: "ON",
0xb3: "ON BREAK",
0xb4: "ON ERROR GOTO 0", // (on error goto n > 0 is decoded with separate tokens)
0xb5: "ON SQ",
0xb6: "OPENIN",
0xb7: "OPENOUT",
0xb8: "ORIGIN",
0xb9: "OUT",
0xba: "PAPER",
0xbb: "PEN",
0xbc: "PLOT",
0xbd: "PLOTR",
0xbe: "POKE",
0xbf: "PRINT",
0xc0: this.fnApostrophe, // "'" symbol (same function as REM keyword); always with 0x01 0xC0
0xc1: "RAD",
0xc2: "RANDOMIZE",
0xc3: "READ",
0xc4: "RELEASE",
0xc5: this.fnRem, // REM
0xc6: "RENUM",
0xc7: "RESTORE",
0xc8: "RESUME",
0xc9: "RETURN",
0xca: "RUN",
0xcb: "SAVE",
0xcc: "SOUND",
0xcd: "SPEED",
0xce: "STOP",
0xcf: "SYMBOL",
0xd0: "TAG",
0xd1: "TAGOFF",
0xd2: "TROFF",
0xd3: "TRON",
0xd4: "WAIT",
0xd5: "WEND",
0xd6: "WHILE",
0xd7: "WIDTH",
0xd8: "WINDOW",
0xd9: "WRITE",
0xda: "ZONE",
0xdb: "DI",
0xdc: "EI",
0xdd: "FILL", // (v1.1)
0xde: "GRAPHICS", // (v1.1)
0xdf: "MASK", // (v1.1)
0xe0: "FRAME", // (v1.1)
0xe1: "CURSOR", // (v1.1)
0xe2: "<unused>",
0xe3: "ERL",
0xe4: "FN",
0xe5: "SPC",
0xe6: "STEP",
0xe7: "SWAP",
0xe8: "<unused>",
0xe9: "<unused>",
0xea: "TAB",
0xeb: "THEN",
0xec: "TO",
0xed: "USING",
0xee: ">", // (greater than)
0xef: "=", // (equal)
0xf0: ">=", // (greater or equal)
0xf1: "<", // (less than)
0xf2: "<>", // (not equal)
0xf3: "<=", // =<, <=, < = (less than or equal)
0xf4: "+", // (addition)
0xf5: "-", // (subtraction or unary minus)
0xf6: "*", // (multiplication)
0xf7: "/", // (division)
0xf8: "^", // (x to the power of y)
0xf9: "\\", // (integer division)
0xfa: "AND",
0xfb: "MOD",
0xfc: "OR",
0xfd: "XOR",
0xfe: "NOT"
};
/* eslint-enable no-invalid-this */
tokensFF = {
0x00: "ABS",
0x01: "ASC",
0x02: "ATN",
0x03: "CHR$",
0x04: "CINT",
0x05: "COS",
0x06: "CREAL",
0x07: "EXP",
0x08: "FIX",
0x09: "FRE",
0x0a: "INKEY",
0x0b: "INP",
0x0c: "INT",
0x0d: "JOY",
0x0e: "LEN",
0x0f: "LOG",
0x10: "LOG10",
0x11: "LOWER$",
0x12: "PEEK",
0x13: "REMAIN",
0x14: "SGN",
0x15: "SIN",
0x16: "SPACE$",
0x17: "SQ",
0x18: "SQR",
0x19: "STR$",
0x1a: "TAN",
0x1b: "UNT",
0x1c: "UPPER$",
0x1d: "VAL",
0x40: "EOF",
0x41: "ERR",
0x42: "HIMEM",
0x43: "INKEY$",
0x44: "PI",
0x45: "RND",
0x46: "TIME",
0x47: "XPOS",
0x48: "YPOS",
0x49: "DERR", // (v1.1)
0x71: "BIN$",
0x72: "DEC$", // (v1.1)
0x73: "HEX$",
0x74: "INSTR",
0x75: "LEFT$",
0x76: "MAX",
0x77: "MIN",
0x78: "POS",
0x79: "RIGHT$",
0x7a: "ROUND",
0x7b: "STRING$",
0x7c: "TEST",
0x7d: "TESTR",
0x7e: "COPYCHR$", // (v1.1)
0x7f: "VPOS"
};
debugPrintInfo() {
const debug = this.debug;
Utils.console.debug("BasicTokenizer Details:\n", debug.info);
debug.line = 0;
debug.info = "";
}
debugCollectInfo(tokenLine) {
const debug = this.debug, hex = this.input.substring(debug.startPos, this.pos).split("").map(function (s) {
return s.charCodeAt(0).toString(16).toUpperCase().padStart(2, "0");
}).join(",");
if (this.line !== debug.line) {
if (debug.info) {
debug.info += "\n";
}
debug.line = this.line;
debug.info += debug.line + ": ";
}
debug.info += " [" + hex + "] " + tokenLine;
}
fnParseNextToken(input) {
const oldNeedSpace = this.needSpace;
let token = this.fnNum8Dec();
if (token === 0x01) { // statement seperator ":"?
if (this.pos < input.length) {
const nextToken = input.charCodeAt(this.pos); // test next token
if (nextToken === 0x97 || nextToken === 0xc0) { // ELSE or rem '?
token = nextToken; // ignore ':'
this.pos += 1;
}
}
}
this.needSpace = ((token >= 0x05 && token <= 0x0d) || (token === 0x7c)); // variable without suffix, or RSX?
let tokenValue;
if (token === 0xff) { // extended token?
token = this.fnNum8Dec(); // get it
tokenValue = this.tokensFF[token];
}
else {
tokenValue = this.tokens[token];
}
let tstr;
if (tokenValue !== undefined) {
tstr = typeof tokenValue === "function" ? tokenValue.call(this) : tokenValue;
if ((/[a-zA-Z.]$/).test(tstr) && token !== 0xe4) { // last character char, dot? (not for token "FN")
this.needSpace = true; // maybe need space next time...
}
}
else { // normal ASCII
tstr = String.fromCharCode(token);
}
if (oldNeedSpace) {
if ((/^[a-zA-Z$%!]/).test(tstr) || (token >= 0x02 && token <= 0x1f)) {
tstr = " " + tstr;
}
}
if (Utils.debug > 2) {
this.debugCollectInfo(tstr);
}
return tstr;
}
fnParseLineFragment() {
const input = this.input;
let out = "";
this.needSpace = false; // only needed in fnParseNextToken
while (this.pos < this.lineEnd) {
this.debug.startPos = this.pos;
const tstr = this.fnParseNextToken(input);
out += tstr;
}
return out;
}
fnParseNextLine() {
const lineLength = this.fnNum16Dec();
if (!lineLength) {
return undefined; // nothing more
}
this.line = this.fnNum16Dec();
this.lineEnd = this.pos - 4 + lineLength;
if (this.lineEnd > this.input.length) {
this.lineEnd = this.input.length;
Utils.console.warn("fnParseNextLine: pos=" + this.pos + ": EOF met!");
}
return this.line + " " + this.fnParseLineFragment();
}
fnParseProgram() {
let out = "", line;
while ((line = this.fnParseNextLine()) !== undefined) {
out += line + "\n";
}
return out;
}
decodeLineFragment(program, offset, length) {
this.input = program;
this.pos = offset;
this.line = 0;
this.lineEnd = this.pos + length;
const out = this.fnParseLineFragment();
if (Utils.debug > 2) {
this.debugPrintInfo();
}
return out;
}
decode(program) {
this.input = program;
this.pos = 0;
this.line = 0;
const out = this.fnParseProgram();
if (Utils.debug > 2) {
this.debugPrintInfo();
}
return out;
}
}
class View {
static getElementById1(id) {
const element = window.document.getElementById(id);
if (!element) {
throw new Error("Unknown " + id);
}
return element;
}
static getElementByIdAs(id) {
return View.getElementById1(id);
}
getHidden(id) {
const element = View.getElementById1(id);
return element.className.indexOf("displayNone") >= 0;
}
setHidden(id, hidden, display) {
const element = View.getElementById1(id), displayVisible = "display" + Utils.stringCapitalize(display || "block");
if (hidden) {
if (element.className.indexOf("displayNone") < 0) {
this.toggleClass(id, "displayNone");
}
if (element.className.indexOf(displayVisible) >= 0) {
this.toggleClass(id, displayVisible);
}
}
else {
if (element.className.indexOf("displayNone") >= 0) {
this.toggleClass(id, "displayNone");
}
if (element.className.indexOf(displayVisible) < 0) {
this.toggleClass(id, displayVisible);
}
}
return this;
}
setDisabled(id, disabled) {
const element = View.getElementByIdAs(id);
element.disabled = disabled;
return this;
}
toggleClass(id, className) {
const element = View.getElementById1(id);
let classes = element.className;
const nameIndex = classes.indexOf(className);
if (nameIndex === -1) {
classes = classes.trim() + " " + className;
}
else {
classes = classes.substring(0, nameIndex) + classes.substring(nameIndex + className.length + 1).trim();
}
element.className = classes;
}
getAreaValue(id) {
const element = View.getElementByIdAs(id);
return element.value;
}
setAreaValue(id, value) {
const element = View.getElementByIdAs(id);
element.value = value;
return this;
}
getInputValue(id) {
const element = View.getElementByIdAs(id);
return element.value;
}
setInputValue(id, value) {
const element = View.getElementByIdAs(id);
element.value = value;
return this;
}
getInputChecked(id) {
const element = View.getElementByIdAs(id);
return element.checked;
}
setInputChecked(id, checked) {
const element = View.getElementByIdAs(id);
element.checked = checked;
return this;
}
setAreaInputList(id, inputs) {
const element = View.getElementByIdAs(id), childNodes = element.childNodes;
while (childNodes.length && childNodes[0].nodeType !== Node.ELEMENT_NODE) { // remove all non-element nodes
element.removeChild(element.firstChild);
}
for (let i = 0; i < inputs.length; i += 1) {
const item = inputs[i];
let input, label;
if (i * 2 >= childNodes.length) {
input = window.document.createElement("input");
input.type = "radio";
input.id = "galleryItem" + i;
input.name = "gallery";
input.value = item.value;
input.checked = item.checked;
label = window.document.createElement("label");
label.setAttribute("for", "galleryItem" + i);
label.setAttribute("style", 'background: url("' + item.imgUrl + '"); background-size: cover');
label.setAttribute("title", item.title);
element.appendChild(input);
element.appendChild(label);
}
else {
input = childNodes[i * 2];
if (input.value !== item.value) {
if (Utils.debug > 3) {
Utils.console.debug("setInputList: " + id + ": value changed for index " + i + ": " + item.value);
}
input.value = item.value;
label = childNodes[i * 2 + 1];
label.setAttribute("style", 'background: url("' + item.imgUrl + '");');
label.setAttribute("title", item.title);
}
if (input.checked !== item.checked) {
input.checked = item.checked;
}
}
}
while (element.childElementCount > inputs.length * 2) {
element.removeChild(element.lastChild);
}
return this;
}
setSelectOptions(id, options) {
const element = View.getElementByIdAs(id), optionList = [], existingElements = element.length;
for (let i = existingElements; i < options.length; i += 1) {
const item = options[i], option = window.document.createElement("option");
option.value = item.value;
option.text = item.text;
option.title = item.title;
option.selected = item.selected; // multi-select
optionList.push(option);
}
for (let i = 0; i < options.length; i += 1) {
if (i >= existingElements) {
element.add(optionList[i - existingElements], null); // null needed for old FF 3.x
}
else {
const item = options[i], option = element.options[i];
if (option.value !== item.value) {
option.value = item.value;
}
if (option.text !== item.text) {
if (Utils.debug > 3) {
Utils.console.debug("setSelectOptions: " + id + ": text changed for index " + i + ": " + item.text);
}
option.text = item.text;
option.title = item.title;
}
option.selected = item.selected; // multi-select
}
}
element.options.length = options.length;
return this;
}
getSelectOptions(id) {
const element = View.getElementByIdAs(id), elementOptions = element.options, options = [];
for (let i = 0; i < elementOptions.length; i += 1) {
const elementOption = elementOptions[i];
options.push({
value: elementOption.value,
text: elementOption.text,
title: elementOption.title,
selected: elementOption.selected
});
}
return options;
}
getSelectValue(id) {
const element = View.getElementByIdAs(id);
return element.value;
}
setSelectValue(id, value) {
const element = View.getElementByIdAs(id);
if (value) {
element.value = value;
}
return this;
}
setSelectTitleFromSelectedOption(id) {
const element = View.getElementByIdAs(id), selectedIndex = element.selectedIndex, title = (selectedIndex >= 0) ? element.options[selectedIndex].title : "";
element.title = title;
return this;
}
setAreaScrollTop(id, scrollTop) {
const element = View.getElementByIdAs(id);
if (scrollTop === undefined) {
scrollTop = element.scrollHeight;
}
element.scrollTop = scrollTop;
return this;
}
setSelectionRange(textarea, selectionStart, selectionEnd) {
const fullText = textarea.value;
textarea.value = fullText.substring(0, selectionEnd);
const scrollHeight = textarea.scrollHeight;
textarea.value = fullText;
const textareaHeight = textarea.clientHeight;
let scrollTop = scrollHeight;
if (scrollTop > textareaHeight) {
scrollTop -= textareaHeight / 2;
}
else {
scrollTop = 0;
}
textarea.scrollTop = scrollTop;
textarea.setSelectionRange(selectionStart, selectionEnd);
return this;
}
setAreaSelection(id, pos, endPos) {
const element = View.getElementByIdAs(id);
if (element.selectionStart !== undefined) {
if (element.setSelectionRange !== undefined) {
element.focus(); // not needed for scrolling but we want to see the selected text
this.setSelectionRange(element, pos, endPos);
}
else {
element.focus();
element.selectionStart = pos;
element.selectionEnd = endPos;
}
}
return this;
}
addEventListener(type, eventListener, element) {
if (element) {
element.addEventListener(type, eventListener, false);
}
else {
window.document.addEventListener(type, eventListener, false);
}
return this;
}
addEventListenerById(type, eventListener, id) {
if (Utils.debug) {
Utils.console.debug("addEventListenerById: type=" + type + ", id=" + id);
}
const element = id === "window" /* ViewID.window */ ? undefined : View.getElementById1(id);
this.addEventListener(type, eventListener, element);
return this;
}
removeEventListener(type, eventListener, element) {
if (element) {
element.removeEventListener(type, eventListener, false);
}
else {
window.document.removeEventListener(type, eventListener, false);
}
return this;
}
removeEventListenerById(type, eventListener, id) {
if (Utils.debug) {
Utils.console.debug("removeEventListener: type=" + type + ", id=" + id);
}
const element = id === "window" /* ViewID.window */ ? undefined : View.getElementById1(id);
this.removeEventListener(type, eventListener, element);
return this;
}
static pointerEventNames = {
down: "pointerdown",
move: "pointermove",
up: "pointerup",
cancel: "pointercancel",
out: "pointerout",
type: "pointer"
};
static touchEventNames = {
down: "touchstart",
move: "touchmove",
up: "touchend",
cancel: "touchcancel",
out: "", // n.a.
type: "touch"
};
static mouseEventNames = {
down: "mousedown",
move: "mousemove",
up: "mouseup",
cancel: "", // n.a.
out: "mouseout",
type: "mouse"
};
static getPointerEventNames() {
let eventNames;
if (window.PointerEvent) {
eventNames = View.pointerEventNames;
}
else if ("ontouchstart" in window || navigator.maxTouchPoints) {
eventNames = View.touchEventNames;
}
else {
eventNames = View.mouseEventNames;
}
return eventNames;
}
fnAttachPointerEvents(id, fnDown, fnMove, fnUp) {
const element = id === "window" /* ViewID.window */ ? undefined : View.getElementById1(id), eventNames = View.getPointerEventNames();
if (fnDown) {
this.addEventListener(eventNames.down, fnDown, element);
}
if (fnMove) {
this.addEventListener(eventNames.move, fnMove, element);
}
if (fnUp) {
this.addEventListener(eventNames.up, fnUp, element);
if (eventNames.cancel) {
this.addEventListener(eventNames.cancel, fnUp, element); // also fnUp handler
}
}
return eventNames;
}
fnDetachPointerEvents(id, fnDown, fnMove, fnUp) {
const element = id === "window" /* ViewID.window */ ? undefined : View.getElementById1(id), eventNames = View.getPointerEventNames();
if (fnDown) {
this.removeEventListener(eventNames.down, fnDown, element);
}
if (fnMove) {
this.removeEventListener(eventNames.move, fnMove, element);
}
if (fnUp) {
this.removeEventListener(eventNames.up, fnUp, element);
if (eventNames.cancel) {
this.removeEventListener(eventNames.cancel, fnUp, element); // also fnUp handler
}
}
return eventNames;
}
static getEventTarget(event) {
const target = event.target || event.srcElement; // target, not currentTarget; srcElement for IE8
if (!target) {
Utils.console.error("getEventTarget: Undefined event target: " + target);
}
return target;
}
requestFullscreenForId(id) {
const element = View.getElementById1(id), anyEl = element, that = this, requestMethod = element.requestFullscreen || anyEl.webkitRequestFullscreen || anyEl.mozRequestFullscreen || anyEl.msRequestFullscreen, fullscreenchangedHandler = function (event) {
const target = View.getEventTarget(event);
if (document.fullscreenElement) {
if (Utils.debug > 0) {
Utils.console.debug("Entered fullscreen mode: " + document.fullscreenElement.id);
}
}
else {
if (Utils.debug > 0) {
Utils.console.debug("Leaving fullscreen mode.");
}
that.removeEventListener("fullscreenchange", fullscreenchangedHandler, target);
that.setHidden(id, true);
window.setTimeout(function () {
that.setHidden(id, false);
}, 0);
}
};
if (requestMethod) {
const promise = requestMethod.call(element); // can we ALLOW_KEYBOARD_INPUT?
if (promise) {
promise.then(function () {
if (Utils.debug > 0) {
Utils.console.debug("requestFullscreenForId: " + id + ": success");
}
that.addEventListenerById("fullscreenchange", fullscreenchangedHandler, id);
}).catch(function (err) {
Utils.console.error("requestFullscreenForId: " + id + ": Error attempting to enable fullscreen mode: ", err);
});
}
}
else if (typeof window.ActiveXObject !== "undefined") { // older IE
const wscript = new window.ActiveXObject("WScript.Shell");
if (wscript !== null) {
wscript.SendKeys("{F11}"); // eslint-disable-line new-cap
}
}
else {
return false;
}
return true;
}
fnDownloadBlob(data, filename) {
if (typeof Blob === "undefined") {
Utils.console.warn("fnDownloadBlob: Blob undefined");
return;
}
const data8 = Utils.string2Uint8Array(data), type = "octet/stream", blob = new Blob([data8.buffer], {
type: type
});
if (window.navigator && window.navigator.msSaveOrOpenBlob) { // IE11 support
window.navigator.msSaveOrOpenBlob(blob, filename);
return;
}
const url = URL.createObjectURL(blob), a = document.createElement("a"), clickHandler = function () {
setTimeout(function () {
URL.revokeObjectURL(url);
a.removeEventListener("click", clickHandler);
}, 150);
};
a.href = url;
a.download = filename || "download";
this.addEventListener("click", clickHandler, a);
a.click();
}
}
/* globals ArrayBuffer, Uint8Array, Uint32Array */
class Canvas {
options;
fnUpdateCanvasHandler;
fnUpdateCanvas2Handler;
fps = 15; // FPS for canvas update
isRunning = false;
animationTimeoutId;
animationFrame;
cpcAreaBox;
customCharset = {};
gColMode = 0; // 0=normal, 1=xor, 2=and, 3=or
mask = 255;
maskBit = 128;
maskFirst = 1;
offset = 0; // screen offset
canvas;
width;
height;
borderWidth = 4;
dataset8;
needUpdate = false;
colorValues = [];
currentInks = [];
speedInk = [];
inkSet = 0;
pen2ColorMap = [];
ctx;
imageData;
fnCopy2Canvas;
littleEndian = true;
pen2Color32;
data32;
use32BitCopy = true; // determined later
gPen = 0;
gPaper = 0;
speedInkCount = 0; // usually 10
hasFocus = false; // canvas has focus
mode = 0;
modeData = Canvas.modeData[0];
xPos = 0;
yPos = 0;
xOrig = 0;
yOrig = 0;
xLeft = 0;
xRight = 639;
yTop = 399;
yBottom = 0;
gTransparent = false;
constructor(options) {
this.fnUpdateCanvasHandler = this.updateCanvas.bind(this);
this.fnUpdateCanvas2Handler = this.updateCanvas2.bind(this);
this.options = {};
this.setOptions(options, true);
const canvas = View.getElementByIdAs(this.options.canvasID);
this.canvas = canvas;
this.cpcAreaBox = View.getElementById1("cpcArea" /* ViewID.cpcArea */);
if (canvas.offsetParent === null) {
Utils.console.error("Error: canvas is not visible!");
}
const width = canvas.width, height = canvas.height;
this.width = width;
this.height = height;
this.dataset8 = new Uint8Array(new ArrayBuffer(width * height)); // array with pen values
this.animationTimeoutId = undefined;
this.animationFrame = undefined;
if (this.canvas.getContext) { // not available on e.g. IE8
this.ctx = this.canvas.getContext("2d");
this.imageData = this.ctx.getImageData(0, 0, width, height);
if (typeof Uint32Array !== "undefined" && this.imageData.data.buffer) { // imageData.data.buffer not available on IE10
this.littleEndian = Canvas.isLittleEndian();
this.pen2Color32 = new Uint32Array(new ArrayBuffer(Canvas.modeData[3].pens * 4));
this.data32 = new Uint32Array(this.imageData.data.buffer);
this.use32BitCopy = true;
Utils.console.log("Canvas: using optimized copy2Canvas32bit, littleEndian:", this.littleEndian);
}
else {
this.setAlpha(255);
this.use32BitCopy = false;
Utils.console.log("Canvas: using copy2Canvas8bit");
}
this.fnCopy2Canvas = this.getCopy2CanvasFunction(this.offset);
}
else {
Utils.console.warn("Error: canvas.getContext is not supported.");
this.fnCopy2Canvas = () => {
};
this.ctx = {}; // not available
this.imageData = {}; // not available
}
this.reset();
}
getOptions() {
return this.options;
}
setOptions(options, force) {
const currentPalette = this.options.palette;
Object.assign(this.options, options);
if (force || (this.options.palette !== currentPalette)) { // changed?
this.applyPalette();
}
}
static palettes = {
color: [
"#000000", //  0 Black
"#000080", //  1 Blue
"#0000FF", //  2 Bright Blue
"#800000", //  3 Red
"#800080", //  4 Magenta
"#8000FF", //  5 Mauve
"#FF0000", //  6 Bright Red
"#FF0080", //  7 Purple
"#FF00FF", //  8 Bright Magenta
"#008000", //  9 Green
"#008080", // 10 Cyan
"#0080FF", // 11 Sky Blue
"#808000", // 12 Yellow
"#808080", // 13 White
"#8080FF", // 14 Pastel Blue
"#FF8000", // 15 Orange
"#FF8080", // 16 Pink
"#FF80FF", // 17 Pastel Magenta
"#00FF00", // 18 Bright Green
"#00FF80", // 19 Sea Green
"#00FFFF", // 20 Bright Cyan
"#80FF00", // 21 Lime
"#80FF80", // 22 Pastel Green
"#80FFFF", // 23 Pastel Cyan
"#FFFF00", // 24 Bright Yellow
"#FFFF80", // 25 Pastel Yellow
"#FFFFFF", // 26 Bright White
"#808080", // 27 White (same as 13)
"#FF00FF", // 28 Bright Magenta (same as 8)
"#FFFF80", // 29 Pastel Yellow (same as 25)
"#000080", // 30 Blue (same as 1)
"#00FF80" //  31 Sea Green (same as 19)
]
};
static defaultInks = [
[1, 24, 20, 6, 26, 0, 2, 8, 10, 12, 14, 16, 18, 22, 1, 16, 1], // eslint-disable-line array-element-newline
[1, 24, 20, 6, 26, 0, 2, 8, 10, 12, 14, 16, 18, 22, 24, 11, 1] // eslint-disable-line array-element-newline
];
static modeData = [
{
pens: 16, // number of pens
pixelWidth: 4, // pixel width
pixelHeight: 2 // pixel height
},
{
pens: 4,
pixelWidth: 2,
pixelHeight: 2
},
{
pens: 2,
pixelWidth: 1,
pixelHeight: 2
},
{
pens: 16, // mode 3 not available on a real CPC
pixelWidth: 1,
pixelHeight: 1
}
];
applyBorderColor() {
this.canvas.style.borderColor = Canvas.palettes[this.options.palette][this.currentInks[this.inkSet][16]];
}
reset() {
this.changeMode(1);
this.inkSet = 0;
this.setDefaultInks();
this.speedInk[0] = 10;
this.speedInk[1] = 10;
this.speedInkCount = this.speedInk[this.inkSet];
this.applyBorderColor();
this.setGPen(1);
this.setGPaper(0);
this.resetCustomChars();
this.setMode(1);
this.clearGraphicsWindow();
}
resetCustomChars() {
this.customCharset = {}; // symbol
}
static computePalette(palette) {
if (palette === "green" || palette === "grey") {
const colorPalette = Canvas.palettes.color, colorValues = [], monoPalette = [];
Canvas.extractAllColorValues(colorPalette, colorValues);
for (let i = 0; i < colorPalette.length; i += 1) {
const monoValue = (0.299 * colorValues[i][0] + 0.587 * colorValues[i][1] + 0.114 * colorValues[i][2]) | 0, // eslint-disable-line no-bitwise
monoHex = monoValue.toString(16).toUpperCase().padStart(2, "0");
monoPalette[i] = palette === "green" ? "#00" + monoHex + "00" : "#" + monoHex + monoHex + monoHex;
}
Canvas.palettes[palette] = monoPalette;
}
}
applyPalette() {
const palette = this.options.palette;
if (!Canvas.palettes[palette]) {
Canvas.computePalette(palette);
}
this.setColorValues(Canvas.palettes[palette]);
if (this.currentInks.length) { // only if initialized (not if called from constructor)
this.updateColorMap();
this.setNeedUpdate();
this.applyBorderColor();
}
}
static isLittleEndian() {
const b = new ArrayBuffer(4), a = new Uint32Array(b), c = new Uint8Array(b);
a[0] = 0xdeadbeef;
return (c[0] === 0xef);
}
static extractColorValues(color) {
return [
parseInt(color.substring(1, 3), 16),
parseInt(color.substring(3, 5), 16),
parseInt(color.substring(5, 7), 16)
];
}
static extractAllColorValues(colors, colorValues) {
for (let i = 0; i < colors.length; i += 1) {
colorValues[i] = Canvas.extractColorValues(colors[i]);
}
}
setColorValues(palette) {
Canvas.extractAllColorValues(palette, this.colorValues);
}
setAlpha(alpha) {
const buf8 = this.imageData.data, length = this.dataset8.length; // or: this.width * this.height
for (let i = 0; i < length; i += 1) {
buf8[i * 4 + 3] = alpha; // alpha
}
}
setNeedUpdate() {
this.needUpdate = true;
}
updateCanvas2() {
if (!this.isRunning) {
return; // ignore remaining timeouts, if stopped
}
this.animationFrame = requestAnimationFrame(this.fnUpdateCanvasHandler);
if (this.needUpdate) { // could be improved: update only updateRect
this.needUpdate = false;
this.fnCopy2Canvas();
}
}
updateCanvas() {
this.animationTimeoutId = window.setTimeout(this.fnUpdateCanvas2Handler, 1000 / this.fps); // ts (node)
}
startUpdateCanvas() {
if (!this.isRunning && this.canvas.offsetParent !== null) { // animation off and canvas visible in DOM?
this.isRunning = true;
this.updateCanvas();
}
}
stopUpdateCanvas() {
if (this.isRunning) {
this.isRunning = false;
if (this.animationFrame) {
cancelAnimationFrame(this.animationFrame);
this.animationFrame = undefined;
}
clearTimeout(this.animationTimeoutId);
this.animationTimeoutId = undefined;
}
}
copy2Canvas8bit() {
const buf8 = this.imageData.data, // use Uint8ClampedArray from canvas
dataset8 = this.dataset8, length = dataset8.length, // or: this.width * this.height
pen2ColorMap = this.pen2ColorMap;
for (let i = 0; i < length; i += 1) {
const color = pen2ColorMap[dataset8[i]], j = i * 4;
buf8[j] = color[0]; // r
buf8[j + 1] = color[1]; // g
buf8[j + 2] = color[2]; // b
}
this.ctx.putImageData(this.imageData, 0, 0);
}
copy2Canvas32bit() {
const dataset8 = this.dataset8, data32 = this.data32, pen2Color32 = this.pen2Color32;
for (let i = 0; i < data32.length; i += 1) {
data32[i] = pen2Color32[dataset8[i]];
}
this.ctx.putImageData(this.imageData, 0, 0);
}
copy2Canvas32bitWithOffset() {
const dataset8 = this.dataset8, data32 = this.data32, pen2Color32 = this.pen2Color32, offset = this.offset;
for (let i = 0; i < data32.length - offset; i += 1) {
data32[i + offset] = pen2Color32[dataset8[i]];
}
for (let i = data32.length - offset; i < data32.length; i += 1) {
data32[i + offset - data32.length] = pen2Color32[dataset8[i]];
}
this.ctx.putImageData(this.imageData, 0, 0);
}
getCopy2CanvasFunction(offset) {
if (this.use32BitCopy) {
return offset ? this.copy2Canvas32bitWithOffset : this.copy2Canvas32bit;
}
return offset ? this.copy2Canvas8bit : this.copy2Canvas8bit; // TODO: for older browsers
}
setScreenOffset(offset) {
if (offset) {
offset = (offset % 80) * 8 + ((offset / 80) | 0) * 80 * 16 * 8; // eslint-disable-line no-bitwise
offset = 640 * 400 - offset;
}
if (offset !== this.offset) {
this.offset = offset;
this.fnCopy2Canvas = this.getCopy2CanvasFunction(offset);
this.setNeedUpdate();
}
}
updateColorMap() {
const colorValues = this.colorValues, currentInksInSet = this.currentInks[this.inkSet], pen2ColorMap = this.pen2ColorMap, pen2Color32 = this.pen2Color32, maxPens = 16, alpha = 255;
for (let i = 0; i < maxPens; i += 1) {
pen2ColorMap[i] = colorValues[currentInksInSet[i]];
}
if (pen2Color32) {
for (let i = 0; i < maxPens; i += 1) {
const color = pen2ColorMap[i];
if (this.littleEndian) {
pen2Color32[i] = color[0] + color[1] * 256 + color[2] * 65536 + alpha * 65536 * 256;
}
else {
pen2Color32[i] = color[2] + color[1] * 256 + color[0] * 65536 + alpha * 65536 * 256; // for big endian (untested)
}
}
}
}
updateColorsAndCanvasImmediately(inkList) {
const currentInksInSet = this.currentInks[this.inkSet], memorizedInks = currentInksInSet.slice();
this.currentInks[this.inkSet] = inkList; // temporary inks
this.updateColorMap();
this.fnCopy2Canvas(); // do it immediately
this.currentInks[this.inkSet] = memorizedInks.slice();
this.updateColorMap();
this.needUpdate = true; // we want to restore it with the next update...
}
updateSpeedInk() {
const pens = this.modeData.pens;
this.speedInkCount -= 1;
if (this.speedInkCount <= 0) {
const currentInkSet = this.inkSet, newInkSet = currentInkSet ^ 1; // eslint-disable-line no-bitwise
this.inkSet = newInkSet;
this.speedInkCount = this.speedInk[newInkSet];
for (let i = 0; i < pens; i += 1) {
if (this.currentInks[newInkSet][i] !== this.currentInks[currentInkSet][i]) {
this.updateColorMap(); // need ink update
this.needUpdate = true; // we also need update
break;
}
}
if (this.currentInks[newInkSet][16] !== this.currentInks[currentInkSet][16]) {
this.applyBorderColor();
}
}
}
setCustomChar(char, charData) {
this.customCharset[char] = charData;
}
getCharData(char) {
return this.customCharset[char] || this.options.charset[char];
}
setDefaultInks() {
this.currentInks[0] = Canvas.defaultInks[0].slice(); // copy ink set 0 array
this.currentInks[1] = Canvas.defaultInks[1].slice(); // copy ink set 1 array
this.updateColorMap();
this.setGPen(this.gPen);
}
setFocusOnCanvas() {
this.cpcAreaBox.style.background = "#463c3c";
if (this.canvas) {
this.canvas.focus();
}
this.hasFocus = true;
}
getMousePos(event) {
const anyDoc = document, isFullScreen = Boolean(document.fullscreenElement || anyDoc.mozFullScreenElement || anyDoc.webkitFullscreenElement || anyDoc.msFullscreenElement), rect = this.canvas.getBoundingClientRect();
if (isFullScreen) {
const areaX = 0, areaY = 0, rectwidth = rect.right - rect.left - (this.borderWidth + areaX) * 2, rectHeight = rect.bottom - rect.top - (this.borderWidth + areaY) * 2, ratioX = rectwidth / this.canvas.width, ratioY = rectHeight / this.canvas.height, minRatio = ratioX <= ratioY ? ratioX : ratioY, diffX = rectwidth - (this.canvas.width * minRatio), diffY = rectHeight - (this.canvas.height * minRatio);
return {
x: (event.clientX - this.borderWidth - rect.left - diffX / 2) / ratioX * ratioX / minRatio,
y: (event.clientY - this.borderWidth - rect.top - diffY / 2) / ratioY * ratioY / minRatio
};
}
return {
x: (event.clientX - this.borderWidth - rect.left) / (rect.right - rect.left - this.borderWidth * 2) * this.canvas.width,
y: (event.clientY - this.borderWidth - rect.top) / (rect.bottom - rect.top - this.borderWidth * 2) * this.canvas.height
};
}
canvasClickAction(event) {
const pos = this.getMousePos(event),
/* eslint-disable no-bitwise */
x = pos.x | 0, // force integer
y = pos.y | 0;
/* eslint-enable no-bitwise */
if (this.options.onCanvasClick) {
if (x >= 0 && x <= this.width - 1 && y >= 0 && y <= this.height - 1) {
const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8,
/* eslint-disable no-bitwise */
xTxt = (x / charWidth) | 0, yTxt = (y / charHeight) | 0;
/* eslint-enable no-bitwise */
this.options.onCanvasClick(event, x, y, xTxt, yTxt);
}
}
}
onCanvasClick(event) {
if (!this.hasFocus) {
this.setFocusOnCanvas();
}
else {
this.canvasClickAction(event);
}
event.stopPropagation();
}
onWindowClick(_event) {
if (this.hasFocus) {
this.hasFocus = false;
this.cpcAreaBox.style.background = "";
}
}
getXpos() {
return this.xPos;
}
getYpos() {
return this.yPos;
}
fillMyRect(x, y, width, height, paper) {
const canvasWidth = this.width, dataset8 = this.dataset8;
for (let row = 0; row < height; row += 1) {
const idx = x + (y + row) * canvasWidth;
dataset8.fill(paper, idx, idx + width);
}
}
fillTextBox(left, top, width, height, paper) {
const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8;
paper %= this.modeData.pens; // limit papers
this.fillMyRect(left * charWidth, top * charHeight, width * charWidth, height * charHeight, paper);
this.setNeedUpdate();
}
moveMyRectUp(x, y, width, height, x2, y2) {
const canvasWidth = this.width, dataset8 = this.dataset8;
for (let row = 0; row < height; row += 1) {
const idx1 = x + (y + row) * canvasWidth, idx2 = x2 + (y2 + row) * canvasWidth;
dataset8.copyWithin(idx2, idx1, idx1 + width);
}
}
moveMyRectDown(x, y, width, height, x2, y2) {
const canvasWidth = this.width, dataset8 = this.dataset8;
for (let row = height - 1; row >= 0; row -= 1) {
const idx1 = x + (y + row) * canvasWidth, idx2 = x2 + (y2 + row) * canvasWidth;
dataset8.copyWithin(idx2, idx1, idx1 + width);
}
}
invertChar(x, y, pen, paper) {
const pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, penXorPaper = pen ^ paper; // eslint-disable-line no-bitwise
for (let row = 0; row < 8; row += 1) {
for (let col = 0; col < 8; col += 1) {
let testPen = this.testSubPixel(x + col * pixelWidth, y + row * pixelHeight);
testPen ^= penXorPaper; // eslint-disable-line no-bitwise
this.setSubPixelsNormal(x + col * pixelWidth, y + row * pixelHeight, testPen);
}
}
}
setChar(char, x, y, pen, paper, transparent, gColMode, textAtGraphics) {
const charData = this.customCharset[char] || this.options.charset[char], pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight;
for (let row = 0; row < 8; row += 1) {
for (let col = 0; col < 8; col += 1) {
const charValue = charData[row], bit = charValue & (0x80 >> col); // eslint-disable-line no-bitwise
if (!(transparent && !bit)) { // do not set background pixel in transparent mode
const penOrPaper = (bit) ? pen : paper;
if (textAtGraphics) {
this.setPixel(x + col * pixelWidth, y - row * pixelHeight, penOrPaper, gColMode);
}
else { // text mode
this.setSubPixels(x + col * pixelWidth, y + row * pixelHeight, penOrPaper, gColMode); // colMode always 0 in text mode
}
}
}
}
}
readCharData(x, y, expectedPen) {
const charData = [], pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight;
for (let row = 0; row < 8; row += 1) {
let charValue = 0;
for (let col = 0; col < 8; col += 1) {
const pen = this.testSubPixel(x + col * pixelWidth, y + row * pixelHeight);
if (pen === expectedPen) {
charValue |= (0x80 >> col); // eslint-disable-line no-bitwise
}
}
charData[row] = charValue;
}
return charData;
}
setSubPixelsNormal(x, y, gPen) {
const pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, width = this.width;
/* eslint-disable no-bitwise */
x &= ~(pixelWidth - 1); // match CPC pixel
y &= ~(pixelHeight - 1);
for (let row = 0; row < pixelHeight; row += 1) {
const i = x + width * (y + row);
for (let col = 0; col < pixelWidth; col += 1) {
this.dataset8[i + col] = gPen;
}
}
/* eslint-enable no-bitwise */
}
setSubPixels(x, y, gPen, gColMode) {
const pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, width = this.width;
/* eslint-disable no-bitwise */
x &= ~(pixelWidth - 1); // match CPC pixel
y &= ~(pixelHeight - 1);
for (let row = 0; row < pixelHeight; row += 1) {
let i = x + width * (y + row);
for (let col = 0; col < pixelWidth; col += 1) {
switch (gColMode) {
case 0: // normal
this.dataset8[i] = gPen;
break;
case 1: // xor
this.dataset8[i] ^= gPen;
break;
case 2: // and
this.dataset8[i] &= gPen;
break;
case 3: // or
this.dataset8[i] |= gPen;
break;
default:
Utils.console.warn("setSubPixels: Unknown colMode:", gColMode);
break;
}
i += 1;
}
}
/* eslint-enable no-bitwise */
}
static roundCoordinate(cor, widthOrHeight) {
/* eslint-disable no-bitwise */
return cor >= 0 ? cor & ~(widthOrHeight - 1) : -(-cor & ~(widthOrHeight - 1));
/* eslint-enable no-bitwise */
}
setPixel(x, y, gPen, gColMode) {
x = Canvas.roundCoordinate(x, this.modeData.pixelWidth);
y = Canvas.roundCoordinate(y, this.modeData.pixelHeight);
x += this.xOrig;
y = this.height - 1 - (y + this.yOrig);
if (x < this.xLeft || x > this.xRight || y < (this.height - 1 - this.yTop) || y > (this.height - 1 - this.yBottom)) {
return; // not in graphics window
}
this.setSubPixels(x, y, gPen, gColMode);
}
setPixelOriginIncluded(x, y, gPen, gColMode) {
if (x < this.xLeft || x > this.xRight || y < (this.height - 1 - this.yTop) || y > (this.height - 1 - this.yBottom)) {
return; // not in graphics window
}
this.setSubPixels(x, y, gPen, gColMode);
}
testSubPixel(x, y) {
const i = x + this.width * y, pen = this.dataset8[i];
return pen;
}
testPixel(x, y) {
x = Canvas.roundCoordinate(x, this.modeData.pixelWidth);
y = Canvas.roundCoordinate(y, this.modeData.pixelHeight);
x += this.xOrig;
y = this.height - 1 - (y + this.yOrig);
if (x < this.xLeft || x > this.xRight || y < (this.height - 1 - this.yTop) || y > (this.height - 1 - this.yBottom)) {
return this.gPaper; // not in graphics window => return graphics paper
}
const i = x + this.width * y, pen = this.dataset8[i];
return pen;
}
getByte(addr) {
/* eslint-disable no-bitwise */
const mode = this.mode, pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, x = ((addr & 0x7ff) % 80) * 8, y = (((addr & 0x3800) / 0x800) + (((addr & 0x7ff) / 80) | 0) * 8) * pixelHeight;
let byte = null, // null=cannot read
gPen;
if (y < this.height) { // only if in visible range
if (mode === 0) {
gPen = this.dataset8[x + this.width * y];
byte = ((gPen >> 2) & 0x02) | ((gPen << 3) & 0x20) | ((gPen << 2) & 0x08) | ((gPen << 7) & 0x80); // b1,b5,b3,b7 (left pixel)
gPen = this.dataset8[x + pixelWidth + this.width * y];
byte |= ((gPen >> 3) & 0x01) | ((gPen << 2) & 0x10) | ((gPen << 1) & 0x04) | ((gPen << 6) & 0x40); // b0,b4,b2,b6 (right pixel)
}
else if (mode === 1) {
byte = 0;
gPen = this.dataset8[x + this.width * y];
byte |= ((gPen & 0x02) << 2) | ((gPen & 0x01) << 7); // b3,b7 (left pixel 1)
gPen = this.dataset8[x + pixelWidth + this.width * y];
byte |= ((gPen & 0x02) << 1) | ((gPen & 0x01) << 6); // b2,b6 (pixel 2)
gPen = this.dataset8[x + pixelWidth * 2 + this.width * y];
byte |= ((gPen & 0x02) << 0) | ((gPen & 0x01) << 5); // b1,b5 (pixel 3)
gPen = this.dataset8[x + pixelWidth * 3 + this.width * y];
byte |= ((gPen & 0x02) >> 1) | ((gPen & 0x01) << 4); // b0,b4 (right pixel 4)
}
else if (mode === 2) {
byte = 0;
for (let i = 0; i <= 7; i += 1) {
gPen = this.dataset8[x + i + this.width * y];
byte |= (gPen & 0x01) << (7 - i);
}
}
else { // mode === 3
}
}
/* eslint-enable no-bitwise */
return byte;
}
setByte(addr, byte) {
/* eslint-disable no-bitwise */
const mode = this.mode, pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, x = ((addr & 0x7ff) % 80) * 8, y = (((addr & 0x3800) / 0x800) + (((addr & 0x7ff) / 80) | 0) * 8) * pixelHeight;
let gPen;
if (y < this.height) { // only if in visible range
if (mode === 0) {
gPen = ((byte << 2) & 0x08) | ((byte >> 3) & 0x04) | ((byte >> 2) & 0x02) | ((byte >> 7) & 0x01); // b1,b5,b3,b7 (left pixel)
this.setSubPixelsNormal(x, y, gPen);
gPen = ((byte << 3) & 0x08) | ((byte >> 2) & 0x04) | ((byte >> 1) & 0x02) | ((byte >> 6) & 0x01); // b0,b4,b2,b6 (right pixel)
this.setSubPixelsNormal(x + pixelWidth, y, gPen);
this.setNeedUpdate();
}
else if (mode === 1) {
gPen = ((byte >> 2) & 0x02) | ((byte >> 7) & 0x01); // b3,b7 (left pixel 1)
this.setSubPixelsNormal(x, y, gPen);
gPen = ((byte >> 1) & 0x02) | ((byte >> 6) & 0x01); // b2,b6 (pixel 2)
this.setSubPixelsNormal(x + pixelWidth, y, gPen);
gPen = ((byte >> 0) & 0x02) | ((byte >> 5) & 0x01); // b1,b5 (pixel 3)
this.setSubPixelsNormal(x + pixelWidth * 2, y, gPen);
gPen = ((byte << 1) & 0x02) | ((byte >> 4) & 0x01); // b0,b4 (right pixel 4)
this.setSubPixelsNormal(x + pixelWidth * 3, y, gPen);
this.setNeedUpdate();
}
else if (mode === 2) {
for (let i = 0; i <= 7; i += 1) {
gPen = (byte >> (7 - i)) & 0x01;
this.setSubPixelsNormal(x + i * pixelWidth, y, gPen);
}
this.setNeedUpdate();
}
else { // mode === 3 (not supported)
}
}
/* eslint-enable no-bitwise */
}
drawBresenhamLine(xstart, ystart, xend, yend) {
const pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, gPen = this.gPen, gPaper = this.gPaper, mask = this.mask, maskFirst = this.maskFirst, gColMode = this.gColMode, transparent = this.gTransparent;
let maskBit = this.maskBit;
xstart = Canvas.roundCoordinate(xstart, pixelWidth);
ystart = Canvas.roundCoordinate(ystart, pixelHeight);
xend = Canvas.roundCoordinate(xend, pixelWidth);
yend = Canvas.roundCoordinate(yend, pixelHeight);
xstart += this.xOrig;
ystart = this.height - 1 - (ystart + this.yOrig);
xend += this.xOrig;
yend = this.height - 1 - (yend + this.yOrig);
/* eslint-disable no-bitwise */
let dx = ((xend - xstart) / pixelWidth) | 0, dy = ((yend - ystart) / pixelHeight) | 0;
/* eslint-enable no-bitwise */
const incx = Math.sign(dx) * pixelWidth, incy = Math.sign(dy) * pixelHeight;
if (dx < 0) {
dx = -dx;
}
if (dy < 0) {
dy = -dy;
}
let pdx, pdy, ddx, ddy, deltaslowdirection, deltafastdirection;
if (dx > dy) {
pdx = incx;
pdy = 0;
ddx = incx;
ddy = incy;
deltaslowdirection = dy;
deltafastdirection = dx;
}
else {
pdx = 0;
pdy = incy;
ddx = incx;
ddy = incy;
deltaslowdirection = dx;
deltafastdirection = dy;
}
let x = xstart, y = ystart, err = deltafastdirection >> 1; // eslint-disable-line no-bitwise
if (maskFirst) { // draw first pixel?
const bit = mask & maskBit; // eslint-disable-line no-bitwise
if (!(transparent && !bit)) { // do not set background pixel in transparent mode
this.setPixelOriginIncluded(x, y, bit ? gPen : gPaper, gColMode); // we expect integers
}
maskBit = (maskBit >> 1) | ((maskBit << 7) & 0xff); // eslint-disable-line no-bitwise
}
for (let t = 0; t < deltafastdirection; t += 1) {
err -= deltaslowdirection;
if (err < 0) {
err += deltafastdirection;
x += ddx;
y += ddy;
}
else {
x += pdx;
y += pdy;
}
const bit = mask & maskBit; // eslint-disable-line no-bitwise
if (!(transparent && !bit)) { // do not set background pixel in transparent mode
this.setPixelOriginIncluded(x, y, bit ? gPen : gPaper, gColMode); // we expect integers
}
maskBit = (maskBit >> 1) | ((maskBit << 7) & 0xff); // eslint-disable-line no-bitwise
}
this.maskBit = maskBit;
}
draw(x, y) {
const xStart = this.xPos, yStart = this.yPos;
this.move(x, y); // destination
this.drawBresenhamLine(xStart, yStart, x, y);
this.setNeedUpdate();
}
move(x, y) {
this.xPos = x; // must be integer
this.yPos = y;
}
plot(x, y) {
this.move(x, y);
this.setPixel(x, y, this.gPen, this.gColMode); // must be integer
this.setNeedUpdate();
}
test(x, y) {
this.move(x, y);
return this.testPixel(this.xPos, this.yPos); // use rounded values
}
setInk(pen, ink1, ink2) {
let needInkUpdate = false;
if (this.currentInks[0][pen] !== ink1) {
this.currentInks[0][pen] = ink1;
needInkUpdate = true;
}
if (this.currentInks[1][pen] !== ink2) {
this.currentInks[1][pen] = ink2;
needInkUpdate = true;
}
if (needInkUpdate) {
this.updateColorMap();
this.setNeedUpdate(); // we need to notify that an update is needed
}
return needInkUpdate;
}
setBorder(ink1, ink2) {
const needInkUpdate = this.setInk(16, ink1, ink2);
if (needInkUpdate) {
this.applyBorderColor();
}
}
setGPen(gPen) {
this.gPen = gPen % this.modeData.pens; // limit pens
}
setGPaper(gPaper) {
this.gPaper = gPaper % this.modeData.pens; // limit to pens
}
setGTransparentMode(transparent) {
this.gTransparent = transparent;
}
printGChar(char) {
const charWidth = this.modeData.pixelWidth * 8;
if (char >= this.options.charset.length) {
Utils.console.warn("printGChar: Ignoring char with code", char);
return;
}
this.setChar(char, this.xPos, this.yPos, this.gPen, this.gPaper, this.gTransparent, this.gColMode, true);
this.xPos += charWidth;
this.setNeedUpdate();
}
printChar(char, x, y, pen, paper, transparent) {
const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8, pens = this.modeData.pens;
if (char >= this.options.charset.length) {
Utils.console.warn("printChar: Ignoring char with code", char);
return;
}
pen %= pens;
paper %= pens; // also pens
this.setChar(char, x * charWidth, y * charHeight, pen, paper, transparent, 0, false);
this.setNeedUpdate();
}
drawCursor(x, y, pen, paper) {
const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8, pens = this.modeData.pens;
pen %= pens;
paper %= pens; // also pens
this.invertChar(x * charWidth, y * charHeight, pen, paper);
this.setNeedUpdate();
}
findMatchingChar(charData) {
const charset = this.options.charset;
let char = -1; // not detected
for (let i = 0; i < charset.length; i += 1) {
const charData2 = this.customCharset[i] || charset[i];
let match = true;
for (let j = 0; j < 8; j += 1) {
if (charData[j] !== charData2[j]) {
match = false;
break;
}
}
if (match) {
char = i;
break;
}
}
return char;
}
readChar(x, y, pen, paper) {
const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8, pens = this.modeData.pens;
pen %= pens;
paper %= pens; // also pens
x *= charWidth;
y *= charHeight;
let charData = this.readCharData(x, y, pen), char = this.findMatchingChar(charData);
if (char < 0 || char === 32) { // no match? => check inverse with paper, char=32?
charData = this.readCharData(x, y, paper);
for (let i = 0; i < charData.length; i += 1) {
charData[i] ^= 0xff; // eslint-disable-line no-bitwise
}
let char2 = this.findMatchingChar(charData);
if (char2 >= 0) {
if (char2 === 143) { // invers of space?
char2 = 32; // use space
}
char = char2;
}
}
return char;
}
fnIsNotInWindow(x, y) {
return (x < this.xLeft || x > this.xRight || y < (this.height - 1 - this.yTop) || y > (this.height - 1 - this.yBottom));
}
fill(fillPen) {
const gPen = this.gPen, pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, pixels = [], fnIsStopPen = function (p) {
return p === fillPen || p === gPen;
};
let xPos = this.xPos, yPos = this.yPos;
fillPen %= this.modeData.pens; // limit pens
xPos += this.xOrig;
yPos = this.height - 1 - (yPos + this.yOrig);
if (this.fnIsNotInWindow(xPos, yPos)) {
return;
}
pixels.push({
x: xPos,
y: yPos
});
while (pixels.length) {
const pixel = pixels.pop();
let y1 = pixel.y, p1 = this.testSubPixel(pixel.x, y1);
while (y1 >= (this.height - 1 - this.yTop) && !fnIsStopPen(p1)) {
y1 -= pixelHeight;
p1 = this.testSubPixel(pixel.x, y1);
}
y1 += pixelHeight;
let spanLeft = false, spanRight = false;
p1 = this.testSubPixel(pixel.x, y1);
while (y1 <= (this.height - 1 - this.yBottom) && !fnIsStopPen(p1)) {
this.setSubPixelsNormal(pixel.x, y1, fillPen);
let x1 = pixel.x - pixelWidth;
const p2 = this.testSubPixel(x1, y1);
if (!spanLeft && x1 >= this.xLeft && !fnIsStopPen(p2)) {
pixels.push({
x: x1,
y: y1
});
spanLeft = true;
}
else if (spanLeft && ((x1 < this.xLeft) || fnIsStopPen(p2))) {
spanLeft = false;
}
x1 = pixel.x + pixelWidth;
const p3 = this.testSubPixel(x1, y1);
if (!spanRight && x1 <= this.xRight && !fnIsStopPen(p3)) {
pixels.push({
x: x1,
y: y1
});
spanRight = true;
}
else if (spanRight && ((x1 > this.xRight) || fnIsStopPen(p3))) {
spanRight = false;
}
y1 += pixelHeight;
p1 = this.testSubPixel(pixel.x, y1);
}
}
this.setNeedUpdate();
}
static fnPutInRange(n, min, max) {
if (n < min) {
n = min;
}
else if (n > max) {
n = max;
}
return n;
}
setOrigin(xOrig, yOrig) {
const pixelWidth = this.modeData.pixelWidth;
xOrig &= ~(pixelWidth - 1); // eslint-disable-line no-bitwise
this.xOrig = xOrig; // must be integer
this.yOrig = yOrig;
this.move(0, 0);
}
getXOrigin() {
return this.xOrig;
}
getYOrigin() {
return this.yOrig;
}
setGWindow(xLeft, xRight, yTop, yBottom) {
const pixelWidth = 8, // force byte boundaries: always 8 x/byte
pixelHeight = this.modeData.pixelHeight; // usually 2, anly for mode 3 we have 1
xLeft = Canvas.fnPutInRange(xLeft, 0, this.width - 1);
xRight = Canvas.fnPutInRange(xRight, 0, this.width - 1);
yTop = Canvas.fnPutInRange(yTop, 0, this.height - 1);
yBottom = Canvas.fnPutInRange(yBottom, 0, this.height - 1);
if (xRight < xLeft) {
const tmp = xRight;
xRight = xLeft;
xLeft = tmp;
}
if (yTop < yBottom) {
const tmp = yTop;
yTop = yBottom;
yBottom = tmp;
}
/* eslint-disable no-bitwise */
xLeft &= ~(pixelWidth - 1);
xRight |= (pixelWidth - 1);
yTop |= (pixelHeight - 1); // we know: top is larger than bottom
yBottom &= ~(pixelHeight - 1);
/* eslint-enable no-bitwise */
this.xLeft = xLeft;
this.xRight = xRight;
this.yTop = yTop;
this.yBottom = yBottom;
}
setGColMode(gColMode) {
if (gColMode !== this.gColMode) {
this.gColMode = gColMode;
}
}
clearTextWindow(left, right, top, bottom, paper) {
const width = right + 1 - left, height = bottom + 1 - top;
this.fillTextBox(left, top, width, height, paper);
}
clearGraphicsWindow() {
this.fillMyRect(this.xLeft, this.height - 1 - this.yTop, this.xRight + 1 - this.xLeft, this.yTop + 1 - this.yBottom, this.gPaper); // +1 or not?
this.move(0, 0);
this.setNeedUpdate();
}
clearFullWindow() {
const paper = 0;
this.fillMyRect(0, 0, this.width, this.height, paper);
this.setNeedUpdate();
}
windowScrollUp(left, right, top, bottom, paper) {
const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8, width = right + 1 - left, height = bottom + 1 - top;
if (height > 1) { // scroll part
this.moveMyRectUp(left * charWidth, (top + 1) * charHeight, width * charWidth, (height - 1) * charHeight, left * charWidth, top * charHeight);
}
this.fillTextBox(left, bottom, width, 1, paper);
this.setNeedUpdate();
}
windowScrollDown(left, right, top, bottom, paper) {
const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8, width = right + 1 - left, height = bottom + 1 - top;
if (height > 1) { // scroll part
this.moveMyRectDown(left * charWidth, top * charHeight, width * charWidth, (height - 1) * charHeight, left * charWidth, (top + 1) * charHeight);
}
this.fillTextBox(left, top, width, 1, paper);
this.setNeedUpdate();
}
setSpeedInk(time1, time2) {
this.speedInk[0] = time1;
this.speedInk[1] = time2;
}
setMask(mask) {
this.mask = mask;
this.maskBit = 128;
}
setMaskFirst(maskFirst) {
this.maskFirst = maskFirst;
}
getMode() {
return this.mode;
}
changeMode(mode) {
const modeData = Canvas.modeData[mode];
this.mode = mode;
this.modeData = modeData;
}
setMode(mode) {
this.setScreenOffset(0);
this.changeMode(mode);
this.setOrigin(0, 0);
this.setGWindow(0, this.width - 1, this.height - 1, 0);
this.setGColMode(0);
this.setMask(255);
this.setMaskFirst(1);
this.setGPen(this.gPen); // keep, but maybe different for other mode
this.setGPaper(this.gPaper); // keep, maybe different for other mode
this.setGTransparentMode(false);
}
takeScreenShot() {
if (this.canvas.toDataURL) {
return this.canvas.toDataURL("image/png").replace("image/png", "image/octet-stream"); // here is the most important part because if you do not replace you will get a DOM 18 exception.
}
Utils.console.warn("Screenshot not available");
return "";
}
}
class CodeGeneratorBasic {
options;
keywords;
hasColons = false;
keepWhiteSpace = false;
line = 0; // current line (label)
constructor(options) {
this.options = {
quiet: false
};
this.setOptions(options);
this.keywords = options.parser.getKeywords();
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
static combinedKeywords = {
chainMerge: "CHAIN", // "CHAIN MERGE"
clearInput: "CLEAR", // "CLEAR INPUT"
graphicsPaper: "GRAPHICS", // "GRAPHICS PAPER"
graphicsPen: "GRAPHICS", // "GRAPHICS PEN"
keyDef: "KEY", // "KEY DEF"
lineInput: "LINE", // "LINE INPUT"
mid$Assign: "MID$",
onBreakCont: "ON", // ""ON BREAK CONT"
onBreakGosub: "ON", // ""ON BREAK GOSUB"
onBreakStop: "ON", // ""ON BREAK STOP"
onErrorGoto: "ON", // "ON ERROR GOTO"
resumeNext: "RESUME", // "RESUME NEXT"
speedInk: "SPEED", // "SPEED INK"
speedKey: "SPEED", // "SPEED KEY"
speedWrite: "SPEED", // "SPEED WRITE"
symbolAfter: "SYMBOL", // "SYMBOL AFTER"
windowSwap: "WINDOW" // "WINDOW SWAP"
};
static operators = {
"+": "+",
"-": "-",
"*": "*",
"/": "/",
"\\": "\\",
"^": "^",
and: "AND",
or: "OR",
xor: "XOR",
not: "NOT",
mod: "MOD",
">": ">",
"<": "<",
">=": ">=",
"<=": "<=",
"=": "=",
"<>": "<>",
"@": "@",
"#": "#"
};
static operatorPrecedence = {
"@": 95, // prefix
"^": 90,
"p-": 80, // prefix - (fast hack)
"p+": 80, // prefix + (fast hack)
"*": 70,
"/": 70,
"\\": 60,
mod: 50,
"+": 40,
"-": 40,
"=": 30,
"<>": 30,
"<": 30,
"<=": 30,
">": 30,
">=": 30,
not: 23, // prefix
and: 22,
or: 21,
xor: 20,
"#": 10 // priority?
};
static operatorAssociativity = {
"^": "right", // right-associative
"*": "left", // left-associative (commutative, so parens not needed for equal precedence)
"+": "left", // left-associative (commutative, so parens not needed for equal precedence)
"/": "left", // left-associative (non-commutative, so parens ARE needed for equal precedence)
"\\": "left", // left-associative (non-commutative, so parens ARE needed)
mod: "left", // left-associative (non-commutative)
"-": "left", // left-associative (non-commutative, so parens ARE needed for equal precedence)
"=": "none", // comparison operators are non-associative
"<>": "none",
"<": "none",
"<=": "none",
">": "none",
">=": "none",
and: "left",
or: "left",
xor: "left"
};
composeError(error, message, value, pos) {
return Utils.composeError("CodeGeneratorBasic", error, message, value, pos, undefined, this.line);
}
static fnWs(node) {
return node.ws || "";
}
static fnSpace1(value) {
return (!value.length || value.startsWith(" ") ? "" : " ") + value;
}
static getUcKeyword(node) {
const type = node.type;
return CodeGeneratorBasic.combinedKeywords[type] || type.toUpperCase();
}
fnParseArgs(args) {
const nodeArgs = []; // do not modify node.args here (could be a parameter of defined function)
if (!args) {
throw this.composeError(Error(), "Programming error: Undefined args", "", -1); // should not occur
}
for (let i = 0; i < args.length; i += 1) {
let value = this.parseNode(args[i]);
if (args[i].type === "'" || args[i].type === "else" || args[i].type === "elseComment") { // fast hack to put a space before "'", "else" or "elseComment", if there is no space previously
if (i > 0 && !nodeArgs[i - 1].endsWith(" ") && !nodeArgs[i - 1].endsWith(":")) {
value = CodeGeneratorBasic.fnSpace1(value);
}
}
nodeArgs.push(value);
}
return nodeArgs;
}
combineArgsWithColon(args) {
if (!this.hasColons) {
for (let i = 1; i < args.length; i += 1) { // start with 1
const arg = args[i].trim();
if (!arg.startsWith("ELSE") && !arg.startsWith("'") && arg !== "") {
args[i] = ":" + args[i];
}
}
}
return args.join("");
}
fnParenthesisOpen(node) {
return CodeGeneratorBasic.fnWs(node) + node.value + (node.args ? this.fnParseArgs(node.args).join("") : "");
}
static string(node) {
return CodeGeneratorBasic.fnWs(node) + '"' + node.value + '"';
}
static ustring(node) {
return CodeGeneratorBasic.fnWs(node) + '"' + node.value;
}
assign(node) {
if (node.left.type !== "identifier") {
throw this.composeError(Error(), "Unexpected assign type", node.type, node.pos); // should not occur
}
return this.parseNode(node.left) + CodeGeneratorBasic.fnWs(node) + node.value + this.parseNode(node.right);
}
static expnumber(node) {
return CodeGeneratorBasic.fnWs(node) + Number(node.value).toExponential().toUpperCase().replace(/(\d+)$/, function (x) {
return x.length >= 2 ? x : x.padStart(2, "0"); // format with 2 exponential digits
});
}
static binHexNumber(node) {
return CodeGeneratorBasic.fnWs(node) + node.value.toUpperCase(); // binnumber: maybe "&x", hexnumber: mayby "&h"
}
label(node) {
this.line = Number(node.value); // set line before parsing args
const value = this.combineArgsWithColon(this.fnParseArgs(node.args));
return CodeGeneratorBasic.fnWs(node) + node.value + (node.value !== "" ? CodeGeneratorBasic.fnSpace1(value) : value);
}
vertical(node) {
return CodeGeneratorBasic.fnWs(node) + node.value.toUpperCase() + this.fnParseArgs(node.args).join("");
}
afterEveryGosub(node) {
const nodeArgs = this.fnParseArgs(node.args);
nodeArgs[0] = CodeGeneratorBasic.fnSpace1(nodeArgs[0]); // first argument
nodeArgs[nodeArgs.length - 2] = CodeGeneratorBasic.fnSpace1(nodeArgs[nodeArgs.length - 2]); // "gosub"
nodeArgs[nodeArgs.length - 1] = CodeGeneratorBasic.fnSpace1(nodeArgs[nodeArgs.length - 1]); // line number
return CodeGeneratorBasic.fnWs(node) + node.value.toUpperCase() + nodeArgs.join("");
}
chainOrChainMerge(node) {
const nodeArgs = this.fnParseArgs(node.args);
if (nodeArgs.length > 2) { // with delete?
if (nodeArgs[nodeArgs.length - 2] === "DELETE") {
nodeArgs[nodeArgs.length - 1] = CodeGeneratorBasic.fnSpace1(nodeArgs[nodeArgs.length - 1]);
}
}
return CodeGeneratorBasic.fnWs(node) + CodeGeneratorBasic.getUcKeyword(node) + (node.right ? CodeGeneratorBasic.fnSpace1(this.parseNode(node.right)) : "") + CodeGeneratorBasic.fnSpace1(nodeArgs.join(""));
}
data(node) {
const nodeArgs = this.fnParseArgs(node.args);
for (let i = 0; i < nodeArgs.length; i += 1) {
const value2 = nodeArgs[i];
nodeArgs[i] = value2;
}
let args = nodeArgs.join("");
if (!this.keepWhiteSpace) {
args = Utils.stringTrimEnd(args); // remove trailing spaces
}
return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + CodeGeneratorBasic.fnSpace1(args);
}
def(node) {
return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + (node.right ? CodeGeneratorBasic.fnSpace1(this.parseNode(node.right)) + this.fnParseArgs(node.args).join("") : "");
}
elseComment(node) {
if (!node.args) {
throw this.composeError(Error(), "Programming error: Undefined args", "", -1); // should not occur
}
const args = node.args;
let value = "";
for (let i = 0; i < args.length; i += 1) {
const token = args[i];
if (token.value) {
if (this.keepWhiteSpace) {
value += CodeGeneratorBasic.fnWs(token) + token.value;
}
else {
value += CodeGeneratorBasic.fnSpace1(CodeGeneratorBasic.fnWs(token) + token.value);
}
}
}
return CodeGeneratorBasic.fnWs(node) + "else".toUpperCase() + value;
}
fn(node) {
if (!node.right) {
return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase(); // only fn
}
const nodeArgs = node.args ? this.fnParseArgs(node.args) : [];
let right = this.parseNode(node.right);
if ((node.right.pos - node.pos) > 2) { // space between fn and identifier?
right = CodeGeneratorBasic.fnSpace1(right); // keep it
}
return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + right + nodeArgs.join("");
}
fnFor(node) {
const nodeArgs = this.fnParseArgs(node.args);
for (let i = 0; i < nodeArgs.length; i += 1) {
if (i !== 1 && i !== 2) { // not for "=" and startValue
nodeArgs[i] = CodeGeneratorBasic.fnSpace1(nodeArgs[i]); // set minimal spaces in case we do not keep whitespace
}
}
return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + nodeArgs.join("");
}
fnElse(node) {
return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + CodeGeneratorBasic.fnSpace1(this.combineArgsWithColon(this.fnParseArgs(node.args)));
}
fnIf(node) {
const nodeArgs = this.fnParseArgs(node.args), partName = nodeArgs.shift(); // "then"/"goto"
return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + CodeGeneratorBasic.fnSpace1(this.parseNode(node.right))
+ CodeGeneratorBasic.fnSpace1(partName) + CodeGeneratorBasic.fnSpace1(this.combineArgsWithColon(nodeArgs));
}
inputLineInput(node) {
const nodeArgs = node.args ? this.fnParseArgs(node.args) : [], // also for clear input, which has no args
name = node.right ? this.parseNode(node.right) : ""; // line input?
return CodeGeneratorBasic.fnWs(node) + CodeGeneratorBasic.getUcKeyword(node) + CodeGeneratorBasic.fnSpace1(name) + CodeGeneratorBasic.fnSpace1(nodeArgs.join(""));
}
list(node) {
const nodeArgs = this.fnParseArgs(node.args);
if (nodeArgs.length && nodeArgs[0] === "") { // empty range?
nodeArgs.shift(); // remove
}
if (nodeArgs.length && nodeArgs[nodeArgs.length - 1] === "#") { // dummy stream?
nodeArgs.pop(); // remove
}
return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + CodeGeneratorBasic.fnSpace1(nodeArgs.join(""));
}
mid$Assign(node) {
return CodeGeneratorBasic.fnWs(node) + CodeGeneratorBasic.getUcKeyword(node) + this.fnParseArgs(node.args).join("");
}
onBreakOrError(node) {
return CodeGeneratorBasic.fnWs(node) + "ON" + CodeGeneratorBasic.fnSpace1(this.parseNode(node.right)) + CodeGeneratorBasic.fnSpace1(this.fnParseArgs(node.args).join(""));
}
onGotoGosub(node) {
const nodeArgs = this.fnParseArgs(node.args), expression = nodeArgs.shift(), instruction = nodeArgs.shift(); // "goto" or "gosub"
return CodeGeneratorBasic.fnWs(node) + "ON" + CodeGeneratorBasic.fnSpace1(expression) + CodeGeneratorBasic.fnSpace1(instruction) + CodeGeneratorBasic.fnSpace1(nodeArgs.join(""));
}
onSqGosub(node) {
const nodeArgs = this.fnParseArgs(node.args);
nodeArgs[nodeArgs.length - 2] = CodeGeneratorBasic.fnSpace1(nodeArgs[nodeArgs.length - 2]); // "gosub" with space (optional)
nodeArgs[nodeArgs.length - 1] = CodeGeneratorBasic.fnSpace1(nodeArgs[nodeArgs.length - 1]); // line number with space
return CodeGeneratorBasic.fnWs(node) + "ON" + CodeGeneratorBasic.fnSpace1(this.parseNode(node.right)) + nodeArgs.join("");
}
print(node) {
const nodeArgs = this.fnParseArgs(node.args);
let value = "";
for (let i = 0; i < nodeArgs.length; i += 1) {
value += nodeArgs[i];
}
if (node.value !== "?") { // for "print"
value = CodeGeneratorBasic.fnSpace1(value);
}
return CodeGeneratorBasic.fnWs(node) + node.value.toUpperCase() + value; // we use value to get PRINT or ?
}
rem(node) {
return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + this.fnParseArgs(node.args).join("");
}
using(node) {
const nodeArgs = this.fnParseArgs(node.args), template = nodeArgs.length ? nodeArgs.shift() || "" : "";
return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + CodeGeneratorBasic.fnSpace1(template) + nodeArgs.join("");
}
write(node) {
return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + (node.args ? CodeGeneratorBasic.fnSpace1(this.fnParseArgs(node.args).join("")) : ""); // separators already there
}
/* eslint-disable no-invalid-this */
parseFunctions = {
"(": this.fnParenthesisOpen,
string: CodeGeneratorBasic.string,
ustring: CodeGeneratorBasic.ustring,
assign: this.assign,
expnumber: CodeGeneratorBasic.expnumber,
binnumber: CodeGeneratorBasic.binHexNumber,
hexnumber: CodeGeneratorBasic.binHexNumber,
label: this.label,
"|": this.vertical,
afterGosub: this.afterEveryGosub,
chain: this.chainOrChainMerge,
chainMerge: this.chainOrChainMerge,
data: this.data,
def: this.def,
"else": this.fnElse,
elseComment: this.elseComment,
everyGosub: this.afterEveryGosub,
fn: this.fn,
"for": this.fnFor,
"if": this.fnIf,
input: this.inputLineInput,
lineInput: this.inputLineInput,
list: this.list,
mid$Assign: this.mid$Assign,
onBreakCont: this.onBreakOrError, // 3 parts
onBreakGosub: this.onBreakOrError,
onBreakStop: this.onBreakOrError,
onErrorGoto: this.onBreakOrError,
onGosub: this.onGotoGosub,
onGoto: this.onGotoGosub,
onSqGosub: this.onSqGosub,
print: this.print,
rem: this.rem,
using: this.using,
write: this.write
};
/* eslint-enable no-invalid-this */
fnParseOther(node) {
const type = node.type;
let value = ""; // CodeGeneratorBasic.fnGetWs(node);
if (node.left) {
value += this.parseNode(node.left);
}
value += CodeGeneratorBasic.fnWs(node);
const keyType = this.keywords[type];
if (keyType) {
value += CodeGeneratorBasic.getUcKeyword(node);
}
else if (node.value) { // e.g. string,...
value += node.value;
}
let right = "";
if (node.right) {
right = this.parseNode(node.right);
const needSpace1 = this.keywords[right.toLowerCase()] || keyType;
value += needSpace1 ? CodeGeneratorBasic.fnSpace1(right) : right;
}
if (node.args) {
const nodeArgs = this.fnParseArgs(node.args).join(""), needSpace2 = keyType && keyType.charAt(0) !== "f" && node.type !== "'";
value += needSpace2 ? CodeGeneratorBasic.fnSpace1(nodeArgs) : nodeArgs;
}
return value;
}
static getLeftOrRightOperatorPrecedence(node) {
const precedence = CodeGeneratorBasic.operatorPrecedence, operators = CodeGeneratorBasic.operators;
let pr;
if (operators[node.type] && (node.left || node.right)) { // binary operator (or unary operator, e.g. not)
if (node.left) { // right is binary
pr = precedence[node.type] || 0;
}
else {
pr = precedence["p" + node.type] || precedence[node.type] || 0;
}
}
return pr;
}
parseOperator(node) {
const precedence = CodeGeneratorBasic.operatorPrecedence, operators = CodeGeneratorBasic.operators;
let value;
if (node.left) {
value = this.parseNode(node.left);
const p = precedence[node.type], pl = CodeGeneratorBasic.getLeftOrRightOperatorPrecedence(node.left);
if (pl !== undefined && pl < p) {
value = "(" + value + ")";
}
const right = node.right;
let value2 = this.parseNode(right);
const pr = CodeGeneratorBasic.getLeftOrRightOperatorPrecedence(right);
if (pr !== undefined) {
if (pr < p) {
value2 = "(" + value2 + ")";
}
else if (pr === p) {
const assoc = CodeGeneratorBasic.operatorAssociativity[node.type];
if (assoc === "right") {
}
else if (assoc === "left") {
if ((/(^|-|\/|\\|mod|=|<>|<|<=|>|>=)$/).test(node.type)) {
value2 = "(" + value2 + ")";
}
}
else {
value2 = "(" + value2 + ")";
}
}
}
const operator = CodeGeneratorBasic.fnWs(node) + operators[node.type].toUpperCase();
if ((/^(and|or|xor|mod)$/).test(node.type)) {
value += CodeGeneratorBasic.fnSpace1(operator) + CodeGeneratorBasic.fnSpace1(value2);
}
else {
value += operator + value2;
}
}
else if (node.right) { // unary operator, e.g. not, '#'
if (node.len === 0) {
value = ""; // ignore dummy token, e.g. '#'
}
else {
const right = node.right;
value = this.parseNode(right);
let pr;
if (right.left) { // was binary op?
pr = precedence[right.type] || 0; // no special prio
}
else {
pr = precedence["p" + right.type] || precedence[right.type] || 0; // check unary operator first
}
const p = precedence["p" + node.type] || precedence[node.type] || 0; // check unary operator first
if (p && pr && (pr < p)) {
value = "(" + value + ")";
}
value = CodeGeneratorBasic.fnWs(node) + operators[node.type].toUpperCase() + (node.type === "not" ? CodeGeneratorBasic.fnSpace1(value) : value);
}
}
else { // no operator, e.g. "=" in "for"
value = this.fnParseOther(node);
}
return value;
}
parseNode(node) {
const type = node.type;
if (Utils.debug > 3) {
Utils.console.debug("evaluate: parseNode node=%o type=" + type + " value=" + node.value + " left=%o right=%o args=%o", node, node.left, node.right, node.args);
}
let value;
if (CodeGeneratorBasic.operators[type]) {
value = this.parseOperator(node);
}
else if (this.parseFunctions[type]) { // function with special handling?
value = this.parseFunctions[type].call(this, node);
}
else { // for other functions, generate code directly
if ((type === "identifier" || type === "letter") && this.options.lowercaseVars) {
node.value = node.value.toLowerCase();
}
value = this.fnParseOther(node);
}
return value;
}
evaluate(parseTree) {
let output = "";
for (let i = 0; i < parseTree.length; i += 1) {
if (Utils.debug > 2) {
Utils.console.debug("evaluate: parseTree i=%d, node=%o", i, parseTree[i]);
}
const line = this.parseNode(parseTree[i]);
if ((line !== undefined) && (line !== "")) {
if (line !== null) {
if (output.length === 0) {
output = line;
}
else {
output += line;
}
}
else {
output = ""; // cls (clear output when node is set to null)
}
}
}
return output;
}
generate(input) {
const out = {
text: ""
};
this.hasColons = Boolean(this.options.parser.getOptions().keepColons);
this.keepWhiteSpace = Boolean(this.options.lexer.getOptions().keepWhiteSpace);
this.keywords = this.options.parser.getKeywords();
this.line = 0;
try {
const tokens = this.options.lexer.lex(input), parseTree = this.options.parser.parse(tokens), output = this.evaluate(parseTree);
out.text = output;
}
catch (e) {
if (Utils.isCustomError(e)) {
out.error = e;
if (!this.options.quiet) {
Utils.console.warn(e); // show our customError as warning
}
}
else { // other errors
out.error = e; // force set other error
Utils.console.error(e);
}
}
return out;
}
}
class CodeGeneratorJs {
options;
line = "0"; // current line (label)
reJsKeywords;
stack = {
forLabel: [],
forVarName: [],
whileLabel: []
};
gosubCount = 0;
ifCount = 0;
stopCount = 0;
forCount = 0; // stack needed
whileCount = 0; // stack needed
referencedLabelsCount = {};
dataList = []; // collected data from data lines
labelList = []; // all labels
sourceMap = {};
countMap = {};
variables = {}; // will be set later
defScopeArgs;
defintDefstrTypes = {};
constructor(options) {
this.options = {
quiet: false
};
this.setOptions(options); // optional options
this.reJsKeywords = CodeGeneratorJs.createJsKeywordRegex();
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
static jsKeywords = [
"do",
"if",
"in",
"for",
"int",
"new",
"try",
"var",
"byte",
"case",
"char",
"else",
"enum",
"goto",
"long",
"null",
"this",
"true",
"void",
"with",
"break",
"catch",
"class",
"const",
"false",
"final",
"float",
"short",
"super",
"throw",
"while",
"delete",
"double",
"export",
"import",
"native",
"public",
"return",
"static",
"switch",
"throws",
"typeof",
"boolean",
"default",
"extends",
"finally",
"package",
"private",
"abstract",
"continue",
"debugger",
"function",
"volatile",
"interface",
"protected",
"transient",
"implements",
"instanceof",
"synchronized"
];
reset() {
const stack = this.stack;
stack.forLabel.length = 0;
stack.forVarName.length = 0;
stack.whileLabel.length = 0;
this.line = "0"; // current line (label)
this.resetCountsPerLine();
this.labelList.length = 0;
this.dataList.length = 0;
this.sourceMap = {};
this.referencedLabelsCount = {}; // labels or line numbers
this.countMap = {};
}
resetCountsPerLine() {
this.gosubCount = 0;
this.ifCount = 0;
this.stopCount = 0;
this.forCount = 0; // stack needed
this.whileCount = 0; // stack needed
}
composeError(error, message, value, pos) {
return Utils.composeError("CodeGeneratorJs", error, message, value, pos, undefined, this.line);
}
static createJsKeywordRegex() {
return new RegExp("^(" + CodeGeneratorJs.jsKeywords.join("|") + ")$");
}
fnDeclareVariable(name) {
if (!this.variables.variableExist(name)) { // variable not yet defined?
this.variables.initVariable(name);
}
}
static varTypeMap = {
"!": "R",
"%": "I",
$: "$" // or "S"?
};
fnAdaptVariableName(node, name, arrayIndices) {
const defScopeArgs = this.defScopeArgs;
name = name.toLowerCase().replace(/\./g, "_");
const firstChar = name.charAt(0);
if ((defScopeArgs && !defScopeArgs.suppressEscape) || !Utils.supportReservedNames) { // avoid keywords as def fn parameters (keep for ERASE); and for IE8 avoid keywords in dot notation
if (this.reJsKeywords.test(name)) { // IE8: avoid keywords in dot notation
name = "_" + name; // prepend underscore
}
}
const mappedTypeChar = CodeGeneratorJs.varTypeMap[name.charAt(name.length - 1)] || ""; // map last char
if (mappedTypeChar) {
name = name.slice(0, -1); // remove type char
node.pt = name.charAt(name.length - 1); // set also type; TODO currently not used
}
if (arrayIndices) {
name += "A".repeat(arrayIndices);
}
name += mappedTypeChar; // put type at the end
let needDeclare = false;
if (defScopeArgs) {
if (!defScopeArgs.suppressEscape) { // do not escape variable names for ERASE
if (name === "o" || name === "t" || name === "v") { // we must not use formal parameter "o", "t", "v", since we use them already
name = "N" + name; // change variable name to something we cannot set in BASIC
}
}
if (!defScopeArgs.collectDone) { // in collection mode?
defScopeArgs[name] = true; // declare DEF scope variable
}
else if (!(name in defScopeArgs)) {
needDeclare = true;
}
}
else {
needDeclare = true;
}
if (needDeclare) {
if (mappedTypeChar) { // we have an explicit type
this.fnDeclareVariable(name);
name = "v." + name; // access with "v."
}
else if (!this.defintDefstrTypes[firstChar]) {
name += "R"; // then we know that the type is real
this.fnDeclareVariable(name);
name = "v." + name; // access with "v."
}
else {
this.fnDeclareVariable(name + "I");
this.fnDeclareVariable(name + "R");
this.fnDeclareVariable(name + "$");
name = 'v["' + name + '" + t.' + name.charAt(0) + "]";
}
}
return name;
}
fnParseOneArg(arg) {
this.parseNode(arg); // eslint-disable-line no-use-before-define
return arg.pv;
}
fnParseArgRange(args, start, stop) {
const nodeArgs = []; // do not modify node.args here (could be a parameter of defined function)
for (let i = start; i <= stop; i += 1) {
nodeArgs.push(this.fnParseOneArg(args[i]));
}
return nodeArgs;
}
fnParseArgs(args) {
if (!args) {
throw this.composeError(Error(), "Programming error: Undefined args", "", -1); // should not occur
}
return this.fnParseArgRange(args, 0, args.length - 1);
}
fnParseArgsIgnoringCommaSemi(args) {
const nodeArgs = [];
for (let i = 0; i < args.length; i += 1) {
if (args[i].type !== "," && args[i].type !== ";") { // ignore separators
nodeArgs.push(this.fnParseOneArg(args[i]));
}
}
return nodeArgs;
}
fnDetermineStaticVarType(name) {
return this.variables.determineStaticVarType(name);
}
static fnExtractVarName(name) {
if (name.indexOf("v.") === 0) { // variable object?
name = name.substring(2); // remove preceding "v."
const bracketIndex = name.indexOf("[");
if (bracketIndex >= 0) {
name = name.substring(0, bracketIndex);
}
}
if (name.indexOf('v["') === 0) { // variable object in brackets?
name = name.substring(3); // remove preceding 'v["'
const quotesIndex = name.indexOf('"');
name = name.substring(0, quotesIndex);
}
return name;
}
static fnGetNameTypeExpression(name) {
if (name.indexOf("v.") === 0) { // variable object with dot?
name = name.substring(2); // remove preceding "v."
const bracketIndex = name.indexOf("[");
if (bracketIndex >= 0) {
name = name.substring(0, bracketIndex);
}
name = '"' + name + '"';
}
if (name.indexOf("v[") === 0) { // variable object with brackets?
name = name.substring(2); // remove preceding "v["
const closeBracketIndex = name.indexOf("]");
name = name.substring(0, closeBracketIndex);
}
return name;
}
static fnIsIntConst(a) {
const reIntConst = /^[+-]?(\d+|0x[0-9a-f]+|0b[0-1]+)$/; // regex for integer, hex, binary constant
return reIntConst.test(a);
}
fnGetRoundString(node, err) {
if (node.pt !== "I") { // no rounding needed for integer, hex, binary constants, integer variables, functions returning integer (optimization)
node.pv = "o.vmRound(" + node.pv + ")";
}
return this.options.integerOverflow ? "o.vmInRange16(" + node.pv + ', "' + err + '")' : node.pv;
}
static fnIsInString(string, find) {
return find && string.indexOf(find) >= 0;
}
fnPropagateStaticTypes(node, left, right, types) {
if (left.pt && right.pt) {
if (CodeGeneratorJs.fnIsInString(types, left.pt + right.pt)) {
node.pt = left.pt === right.pt ? left.pt : "R";
}
else {
throw this.composeError(Error(), "Type error", node.value, node.pos);
}
}
else if (left.pt && !CodeGeneratorJs.fnIsInString(types, left.pt) || right.pt && !CodeGeneratorJs.fnIsInString(types, right.pt)) {
throw this.composeError(Error(), "Type error", node.value, node.pos);
}
}
plus(node, left, right) {
if (left === undefined) { // unary plus? => skip it
node.pv = right.pv;
const type = right.pt;
if (CodeGeneratorJs.fnIsInString("IR$", type)) { // I, R or $?
node.pt = type;
}
else if (type) {
throw this.composeError(Error(), "Type error", node.value, node.pos);
}
}
else {
node.pv = left.pv + " + " + right.pv;
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI $$");
}
}
minus(node, left, right) {
if (left === undefined) { // unary minus?
const value = right.pv, type = right.pt;
if (CodeGeneratorJs.fnIsIntConst(value) || right.type === "number") { // int const or number const (also fp)
if (value.charAt(0) === "-") { // starting already with "-"?
node.pv = value.substring(1); // remove "-"
}
else {
node.pv = "-" + value;
}
}
else {
node.pv = "-(" + value + ")"; // can be an expression
}
if (CodeGeneratorJs.fnIsInString("IR", type)) { // I or R?
node.pt = type;
}
else if (type) {
throw this.composeError(Error(), "Type error", node.value, node.pos);
}
}
else {
node.pv = left.pv + " - " + right.pv;
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI");
}
}
mult(node, left, right) {
node.pv = left.pv + " * " + right.pv;
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI");
}
div(node, left, right) {
node.pv = left.pv + " / " + right.pv;
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI");
node.pt = "R"; // event II can get a fraction
}
intDiv(node, left, right) {
node.pv = "(" + this.fnGetRoundString(left, "IDIV") + " / " + this.fnGetRoundString(right, "IDIV") + ") | 0"; // integer division
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI");
node.pt = "I";
}
exponent(node, left, right) {
node.pv = "Math.pow(" + left.pv + ", " + right.pv + ")";
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI");
}
and(node, left, right) {
node.pv = this.fnGetRoundString(left, "AND") + " & " + this.fnGetRoundString(right, "AND");
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI");
node.pt = "I";
}
or(node, left, right) {
node.pv = this.fnGetRoundString(left, "OR") + " | " + this.fnGetRoundString(right, "OR");
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI");
node.pt = "I";
}
xor(node, left, right) {
node.pv = this.fnGetRoundString(left, "XOR") + " ^ " + this.fnGetRoundString(right, "XOR");
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI");
node.pt = "I";
}
not(node, _oLeft, right) {
node.pv = "~(" + this.fnGetRoundString(right, "NOT") + ")"; // a can be an expression
node.pt = "I";
}
mod(node, left, right) {
node.pv = this.fnGetRoundString(left, "MOD") + " % " + this.fnGetRoundString(right, "MOD");
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI");
node.pt = "I";
}
greater(node, left, right) {
node.pv = left.pv + " > " + right.pv + " ? -1 : 0";
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI $$");
node.pt = "I";
}
less(node, left, right) {
node.pv = left.pv + " < " + right.pv + " ? -1 : 0";
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI $$");
node.pt = "I";
}
greaterEqual(node, left, right) {
node.pv = left.pv + " >= " + right.pv + " ? -1 : 0";
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI $$");
node.pt = "I";
}
lessEqual(node, left, right) {
node.pv = left.pv + " <= " + right.pv + " ? -1 : 0";
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI $$");
node.pt = "I";
}
equal(node, left, right) {
node.pv = left.pv + " === " + right.pv + " ? -1 : 0";
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI $$");
node.pt = "I";
}
notEqual(node, left, right) {
node.pv = left.pv + " !== " + right.pv + " ? -1 : 0";
this.fnPropagateStaticTypes(node, left, right, "II RR IR RI $$");
node.pt = "I";
}
addressOf(node, _oLeft, right) {
if (right.type !== "identifier") {
throw this.composeError(Error(), "Expected variable", node.value, node.pos);
}
const name = CodeGeneratorJs.fnGetNameTypeExpression(right.pv);
node.pv = "o.addressOf(" + name + ")"; // address of
node.pt = "I";
}
static stream(node, _oLeft, right) {
node.pv = right.pv;
node.pt = "I";
}
/* eslint-disable no-invalid-this */
allOperators = {
"+": this.plus,
"-": this.minus,
"*": this.mult,
"/": this.div,
"\\": this.intDiv,
"^": this.exponent,
and: this.and,
or: this.or,
xor: this.xor,
not: this.not,
mod: this.mod,
">": this.greater,
"<": this.less,
">=": this.greaterEqual,
"<=": this.lessEqual,
"=": this.equal,
"<>": this.notEqual,
"@": this.addressOf,
"#": CodeGeneratorJs.stream
};
unaryOperators = {
"+": this.plus,
"-": this.minus,
not: this.not,
"@": this.addressOf,
"#": CodeGeneratorJs.stream
};
/* eslint-enable no-invalid-this */
fnParseDefIntRealStr(node) {
const nodeArgs = this.fnParseArgs(node.args);
for (let i = 0; i < nodeArgs.length; i += 1) {
const arg = nodeArgs[i];
nodeArgs[i] = "o." + node.type + '("' + arg + '")';
}
node.pv = nodeArgs.join("; ");
}
fnAddReferenceLabel(label, node) {
if (label in this.referencedLabelsCount) {
this.referencedLabelsCount[label] += 1;
}
else {
if (Utils.debug > 1) {
Utils.console.debug("fnAddReferenceLabel: line does not (yet) exist:", label);
}
if (!this.countMap.merge && !this.countMap.chainMerge) {
throw this.composeError(Error(), "Line does not exist", label, node.pos);
}
}
}
fnGetForLabel() {
const label = this.line + "f" + this.forCount;
this.forCount += 1;
return label;
}
fnGetGosubLabel() {
const label = this.line + "g" + this.gosubCount;
this.gosubCount += 1;
return label;
}
fnGetIfLabel() {
const label = this.line + "i" + this.ifCount;
this.ifCount += 1;
return label;
}
fnGetStopLabel() {
const label = this.line + "s" + this.stopCount;
this.stopCount += 1;
return label;
}
fnGetWhileLabel() {
const label = this.line + "w" + this.whileCount;
this.whileCount += 1;
return label;
}
fnCommandWithGoto(node, nodeArgs) {
nodeArgs = nodeArgs || this.fnParseArgs(node.args);
const label = this.fnGetStopLabel();
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + "); o.vmGoto(\"" + label + "\"); break;\ncase \"" + label + "\":";
return node.pv;
}
static commaOrSemicolon(node) {
node.pv = node.type;
}
vertical(node) {
const rsxName = node.value.substring(1).toLowerCase(), nodeArgs = this.fnParseArgs(node.args), label = this.fnGetStopLabel();
nodeArgs.unshift('"' + rsxName + '"'); // put as first arg
node.pv = "o.callRsx(" + nodeArgs.join(", ") + "); o.vmGoto(\"" + label + "\"); break;\ncase \"" + label + "\":"; // most RSX commands need goto (era, ren,...)
}
static number(node) {
node.pt = (/^\d+$/).test(node.value) ? "I" : "R";
node.pv = node.value;
}
static expnumber(node) {
node.pt = "R";
node.pv = node.value;
}
static binnumber(node) {
let value = node.value.slice(2); // remove &x
if (Utils.supportsBinaryLiterals) {
value = "0b" + ((value.length) ? value : "0"); // &x->0b; 0b is ES6
}
else {
value = "0x" + ((value.length) ? parseInt(value, 2).toString(16) : "0"); // we convert it to hex
}
node.pt = "I";
node.pv = value;
}
static hexnumber(node) {
let value = node.value.slice(1); // remove &
if (value.charAt(0).toLowerCase() === "h") { // optional h
value = value.slice(1); // remove
}
value ||= "0";
let n = parseInt(value, 16);
if (n > 32767) { //	two's complement
n = 65536 - n;
value = "-0x" + n.toString(16);
}
else {
value = "0x" + value;
}
node.pt = "I";
node.pv = value;
}
identifier(node) {
const nodeArgs = node.args ? this.fnParseArgRange(node.args, 1, node.args.length - 2) : [], // array: we skip open and close bracket
name = this.fnAdaptVariableName(node, node.value, nodeArgs.length); // here we use node.value;
let indices = "";
for (let i = 0; i < nodeArgs.length; i += 1) { // array indices
const arg = node.args[i + 1], // +1 because of opening braket
index = arg.pt !== "I" ? ("o.vmRound(" + nodeArgs[i] + ")") : nodeArgs[i];
indices += "[" + index + "]";
}
const varType = this.fnDetermineStaticVarType(name);
if (varType.length > 1) {
node.pt = varType.charAt(1);
}
node.pv = name + indices;
}
static letter(node) {
node.pv = node.value.toLowerCase();
}
static linenumber(node) {
node.pv = node.value;
}
range(node) {
if (!node.left || !node.right) {
throw this.composeError(Error(), "Programming error: Undefined left or right", node.type, node.pos); // should not occur
}
const left = this.fnParseOneArg(node.left).toLowerCase(), right = this.fnParseOneArg(node.right).toLowerCase();
if (left > right) {
throw this.composeError(Error(), "Decreasing range", node.value, node.pos);
}
node.pv = left + '", "' + right;
}
linerange(node) {
if (!node.left || !node.right) {
throw this.composeError(Error(), "Programming error: Undefined left or right", node.type, node.pos); // should not occur
}
const left = this.fnParseOneArg(node.left), right = this.fnParseOneArg(node.right), leftNumber = Number(left), // "undefined" gets NaN (should we check node.left.type for null?)
rightNumber = Number(right);
if (leftNumber > rightNumber) { // comparison with NaN and number is always false
throw this.composeError(Error(), "Decreasing line range", node.value, node.pos);
}
const rightSpecified = (right === "undefined") ? "65535" : right; // make sure we set a missing right range parameter
node.pv = !right ? left : left + ", " + rightSpecified;
}
static string(node) {
let value = node.value;
value = value.replace(/\\/g, "\\\\"); // escape backslashes
value = Utils.hexEscape(value);
node.pt = "$";
node.pv = '"' + value + '"';
}
static unquoted(node) {
node.pt = "$";
node.pv = node.value;
}
static fnNull(node) {
node.pv = node.value || "undefined"; // use explicit value or "undefined"
}
assign(node) {
if (!node.left || !node.right) {
throw this.composeError(Error(), "Programming error: Undefined left or right", node.type, node.pos); // should not occur
}
if (node.left.type !== "identifier") {
throw this.composeError(Error(), "Unexpected assign type", node.type, node.pos); // should not occur
}
const name = this.fnParseOneArg(node.left), assignValue = this.fnParseOneArg(node.right);
this.fnPropagateStaticTypes(node, node.left, node.right, "II RR IR RI $$");
const varType = this.fnDetermineStaticVarType(name);
let value;
if (node.pt) {
if (node.left.pt === "I" && node.right.pt === "R") { // special handing for IR: rounding needed
value = "o.vmRound(" + assignValue + ")";
node.pt = "I"; // "R" => "I"
}
else {
value = assignValue;
}
}
else {
value = "o.vmAssign(\"" + varType + "\", " + assignValue + ")";
}
node.pv = name + " = " + value;
}
generateTraceLabel(node, tracePrefix, i) {
const traceLabel = tracePrefix + ((i > 0) ? "t" + i : ""), pos = node.pos, len = node.len || node.value.length || 0;
this.sourceMap[traceLabel] = [
pos,
len
];
return traceLabel;
}
label(node) {
const isTraceActive = this.options.trace || Boolean(this.countMap.tron), isResumeNext = Boolean(this.countMap.resumeNext), isResumeNoArgs = Boolean(this.countMap.resumeNoArgsCount);
let label = node.value;
this.line = label; // set line before parsing args
if (this.countMap.resumeNext) {
this.labelList.push(label); // only needed to support resume next
}
this.resetCountsPerLine(); // we want to have "stable" counts, even if other lines change, e.g. direct
const isDirect = label === "direct";
let value = "";
if (isDirect) { // special handling for direct
value = "o.vmGoto(\"directEnd\"); break;\n";
label = '"direct"';
}
if (!this.options.noCodeFrame) {
value += "case " + label + ":";
value += " o.line = " + label + ";";
if (isTraceActive) {
value += " o.vmTrace();";
}
}
else {
value = "";
}
const nodeArgs = this.fnParseArgs(node.args);
for (let i = 0; i < nodeArgs.length; i += 1) {
let value2 = nodeArgs[i];
if (value2 !== "") {
if (isTraceActive || isResumeNext || isResumeNoArgs) {
const traceLabel = this.generateTraceLabel(node.args[i], this.line, i); // side effect: put position in source map
if (i > 0) { // only if not first statement in the line
if (isResumeNext || isResumeNoArgs) { // eslint-disable-line max-depth
value += '\ncase "' + traceLabel + '":';
}
value += ' o.line = "' + traceLabel + '";';
if (isResumeNext) { // eslint-disable-line max-depth
this.labelList.push('"' + traceLabel + '"'); // only needed to support resume next
}
}
}
if (!(/[}:;\n]$/).test(value2)) { // does not end with } : ; \n
value2 += ";";
}
else if (value2.substring(value2.length - 1) === "\n") {
value2 = value2.substring(0, value2.length - 1);
}
value += " " + value2;
}
}
if (isDirect && !this.options.noCodeFrame) {
value += "\n o.vmGoto(\"end\"); break;\ncase \"directEnd\":"; // put in next line because of possible "rem"
}
node.pv = value;
}
afterEveryGosub(node) {
const nodeArgs = this.fnParseArgs(node.args);
if (!node.args) {
throw this.composeError(Error(), "Programming error: Undefined args", node.type, node.pos); // should not occur
}
this.fnAddReferenceLabel(nodeArgs[2], node.args[2]); // argument 2 = line number
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + ")";
}
static cont(node) {
node.pv = "o." + node.type + "(); break;"; // append break
}
data(node) {
const nodeArgs = this.fnParseArgs(node.args);
for (let i = 0; i < node.args.length; i += 1) {
if (node.args[i].type === "unquoted") {
nodeArgs[i] = '"' + nodeArgs[i].replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + '"'; // escape backslashes and quotes, put in quotes
}
}
let lineString = String(this.line); // TODO: already string?
if (lineString === "direct") {
lineString = '"' + lineString + '"';
}
nodeArgs.unshift(lineString); // prepend line number
this.dataList.push("o.data(" + nodeArgs.join(", ") + ")"); // will be set at the beginning of the script
node.pv = "/* data */";
}
def(node) {
if (!node.right) {
throw this.composeError(Error(), "Programming error: Undefined right", node.type, node.pos); // should not occur
}
const savedValue = node.right.value;
node.right.value = "fn" + savedValue; // prefix with "fn"
const name = this.fnParseOneArg(node.right);
node.right.value = savedValue; // restore
const expressionArg = node.args.pop();
this.defScopeArgs = {}; // collect DEF scope args
const nodeArgs = this.fnParseArgs(node.args);
this.defScopeArgs.collectDone = true; // collection done => now use them
const expression = this.fnParseOneArg(expressionArg);
this.defScopeArgs = undefined;
this.fnPropagateStaticTypes(node, node.right, expressionArg, "II RR IR RI $$");
let value;
if (node.pt) {
if (node.right.pt === "I" && expressionArg.pt === "R") { // special handing for IR: rounding needed
value = "o.vmRound(" + expression + ")";
node.pt = "I"; // "R" => "I"
}
else {
value = expression;
}
}
else {
const varType = this.fnDetermineStaticVarType(name);
value = "o.vmAssign(\"" + varType + "\", " + expression + ")";
}
value = name + " = function (" + nodeArgs.join(", ") + ") { return " + value + "; };";
node.pv = value;
}
dim(node) {
const args = [];
if (!node.args) {
throw this.composeError(Error(), "Programming error: Undefined args", node.type, node.pos); // should not occur
}
for (let i = 0; i < node.args.length; i += 1) {
const nodeArg = node.args[i];
if (nodeArg.type !== "identifier") {
throw this.composeError(Error(), "Expected variable in DIM", node.type, node.pos);
}
if (!nodeArg.args) {
throw this.composeError(Error(), "Programming error: Undefined args", nodeArg.type, nodeArg.pos); // should not occur
}
const nodeArgs = this.fnParseArgRange(nodeArg.args, 1, nodeArg.args.length - 2), // we skip open and close bracket
fullExpression = this.fnParseOneArg(nodeArg), name = CodeGeneratorJs.fnGetNameTypeExpression(fullExpression);
nodeArgs.unshift(name); // put as first arg
args.push("/* " + fullExpression + " = */ o.dim(" + nodeArgs.join(", ") + ")");
}
node.pv = args.join("; ");
}
fnDelete(node) {
const nodeArgs = this.fnParseArgs(node.args), name = Utils.supportReservedNames ? ("o." + node.type) : 'o["' + node.type + '"]';
if (!nodeArgs.length) { // no arguments? => complete range
nodeArgs.push("1");
nodeArgs.push("65535");
}
node.pv = name + "(" + nodeArgs.join(", ") + "); break;";
}
edit(node) {
const nodeArgs = this.fnParseArgs(node.args);
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + "); break;";
}
elseComment(node) {
if (!node.args) {
throw this.composeError(Error(), "Programming error: Undefined args", "", -1); // should not occur
}
let value = "else"; // not: node.type;
for (let i = 0; i < node.args.length; i += 1) {
const token = node.args[i];
if (token.value) {
value += " " + token.value;
}
}
node.pv = "// " + value + "\n";
}
erase(node) {
this.defScopeArgs = {}; // collect DEF scope args
this.defScopeArgs.suppressEscape = true; // suppress escape with prefix "N"
const nodeArgs = this.fnParseArgs(node.args);
this.defScopeArgs = undefined;
for (let i = 0; i < nodeArgs.length; i += 1) {
nodeArgs[i] = '"' + nodeArgs[i] + '"'; // put in quotes
}
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + ")";
}
error(node) {
const nodeArgs = this.fnParseArgs(node.args);
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + "); break";
}
fn(node) {
if (!node.right) {
throw this.composeError(Error(), "Programming error: Undefined right", node.type, node.pos); // should not occur
}
const nodeArgs = this.fnParseArgs(node.args), savedValue = node.right.value;
node.right.value = "fn" + savedValue; // prefix with "fn"
const name = this.fnParseOneArg(node.right);
node.right.value = savedValue; // restore
if (node.right.pt) {
node.pt = node.right.pt;
}
node.pv = name + "(" + nodeArgs.join(", ") + ")";
}
static parseIntNumber(numString) {
const hasSign = numString[0] === "-", value = hasSign ? -Number(numString.substring(1)) : Number(numString);
return value;
}
fnFor(node) {
const nodeArgs = this.fnParseArgs(node.args), varName = nodeArgs[0], label = this.fnGetForLabel();
this.stack.forLabel.push(label);
this.stack.forVarName.push(varName);
if (!node.args) {
throw this.composeError(Error(), "Programming error: Undefined args", node.type, node.pos); // should not occur
}
const startNode = node.args[1], endNode = node.args[2], stepNode = node.args[3]; // optional
let startValue = nodeArgs[1], endValue = nodeArgs[2], stepValue = stepNode ? nodeArgs[3] : "1"; // default step
const startIsIntConst = CodeGeneratorJs.fnIsIntConst(startValue), endIsIntConst = CodeGeneratorJs.fnIsIntConst(endValue), stepIsIntConst = CodeGeneratorJs.fnIsIntConst(stepValue), varType = this.fnDetermineStaticVarType(varName), type = (varType.length > 1) ? varType.charAt(1) : "";
if (type === "$") {
throw this.composeError(Error(), "Type error", node.args[0].value, node.args[0].pos);
}
if (!startIsIntConst) {
if (startNode.pt !== "I") {
startValue = "o.vmAssign(\"" + varType + "\", " + startValue + ")"; // assign checks and rounds, if needed
}
}
let endName;
if (!endIsIntConst) {
if (endNode.pt !== "I") {
endValue = "o.vmAssign(\"" + varType + "\", " + endValue + ")";
}
endName = CodeGeneratorJs.fnExtractVarName(varName) + "End";
this.fnDeclareVariable(endName); // declare also end variable
endName = "v." + endName;
}
if (varName.indexOf("v[") === 0) { // untyped?
}
let stepName;
if (!stepIsIntConst) {
if (stepNode && stepNode.pt !== "I") {
stepValue = "o.vmAssign(\"" + varType + "\", " + stepValue + ")";
}
stepName = CodeGeneratorJs.fnExtractVarName(varName) + "Step";
this.fnDeclareVariable(stepName); // declare also step variable
stepName = "v." + stepName;
}
let value = "/* for() */";
if (type !== "I" && type !== "R") {
value += " o.vmAssertNumberType(\"" + varType + "\");"; // do a type check: assert number type
}
value += " " + varName + " = " + startValue + ";";
if (!endIsIntConst) {
value += " " + endName + " = " + endValue + ";";
}
if (!stepIsIntConst) {
value += " " + stepName + " = " + stepValue + ";";
}
value += " o.vmGoto(\"" + label + "b\"); break;";
value += "\ncase \"" + label + "\": ";
value += varName + " += " + (stepIsIntConst ? stepValue : stepName) + ";";
value += "\ncase \"" + label + "b\": ";
const endNameOrValue = endIsIntConst ? endValue : endName;
if (stepIsIntConst) {
const stepValueAsNum = CodeGeneratorJs.parseIntNumber(stepValue); // can also be a negative binary or hexadecimal string
if (stepValueAsNum > 0) {
value += "if (" + varName + " > " + endNameOrValue + ") { o.vmGoto(\"" + label + "e\"); break; }";
}
else if (stepValueAsNum < 0) {
value += "if (" + varName + " < " + endNameOrValue + ") { o.vmGoto(\"" + label + "e\"); break; }";
}
else { // stepValue === 0 => endless loop, if starting with variable !== end
value += "if (" + varName + " === " + endNameOrValue + ") { o.vmGoto(\"" + label + "e\"); break; }";
}
}
else {
value += "if (" + stepName + " > 0 && " + varName + " > " + endNameOrValue + " || " + stepName + " < 0 && " + varName + " < " + endNameOrValue + " || !" + stepName + " && " + varName + " === " + endNameOrValue + ") { o.vmGoto(\"" + label + "e\"); break; }";
}
node.pv = value;
}
gosub(node) {
const nodeArgs = this.fnParseArgs(node.args), label = this.fnGetGosubLabel();
for (let i = 0; i < nodeArgs.length; i += 1) {
this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);
}
node.pv = "o." + node.type + '("' + label + '", ' + nodeArgs.join(", ") + '); break;\ncase "' + label + '":';
}
gotoOrResume(node) {
const nodeArgs = this.fnParseArgs(node.args);
for (let i = 0; i < nodeArgs.length; i += 1) {
this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);
}
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + "); break"; // with break
}
fnThenOrElsePart(args, tracePrefix) {
const isTraceActive = this.options.trace, isResumeNext = Boolean(this.countMap.resumeNext), isResumeNoArgs = Boolean(this.countMap.resumeNoArgsCount), nodeArgs = this.fnParseArgs(args);
if (args.length && args[0].type === "linenumber") {
const line = nodeArgs[0];
this.fnAddReferenceLabel(line, args[0]);
nodeArgs[0] = "o.goto(" + line + "); break"; // convert to "goto"
}
if (isTraceActive || isResumeNext || isResumeNoArgs) {
for (let i = 0; i < nodeArgs.length; i += 1) {
const traceLabel = this.generateTraceLabel(args[i], tracePrefix, i);
let value = "";
if (isResumeNext || isResumeNoArgs) {
value += '\ncase "' + traceLabel + '":';
}
if (isResumeNext) {
this.labelList.push('"' + traceLabel + '"'); // only needed to support resume next
}
value += ' o.line = "' + traceLabel + '";';
nodeArgs[i] = value + " " + nodeArgs[i];
}
}
return nodeArgs.join("; ");
}
static fnIsSimplePart(part) {
const partNoTrailingBreak = part.replace(/; break$/, ""), simplePart = !(/case|break/).test(partNoTrailingBreak);
return simplePart;
}
fnIf(node) {
if (!node.right) {
throw this.composeError(Error(), "Programming error: Undefined left", node.type, node.pos); // should not occur
}
let expression = this.fnParseOneArg(node.right);
if (expression.endsWith(" ? -1 : 0")) { // optimize simple expression
expression = expression.replace(/ \? -1 : 0$/, "");
}
const label = this.fnGetIfLabel(), // need it also for tracing nested if
elseArgs = node.args.length && node.args[node.args.length - 1].type === "else" ? node.args.pop().args : undefined, elsePart = elseArgs ? this.fnThenOrElsePart(elseArgs, label + "E") : "", thenPart = this.fnThenOrElsePart(node.args, label + "T"), // "then"/"goto" statements
simpleThen = CodeGeneratorJs.fnIsSimplePart(thenPart), simpleElse = elsePart ? CodeGeneratorJs.fnIsSimplePart(elsePart) : true;
let value = "if (" + expression + ") { ";
if (simpleThen && simpleElse) {
value += thenPart + "; }";
if (elsePart) {
value += " else { " + elsePart + "; }";
}
}
else {
value += 'o.vmGoto("' + label + '"); break; } ';
if (elsePart !== "") { // "else" statements?
value += "/* else */ " + elsePart + "; ";
}
value += 'o.vmGoto("' + label + 'e"); break;\ncase "' + label + '": ' + thenPart + ';\ncase "' + label + 'e": ';
}
node.pv = value;
}
inputOrlineInput(node) {
const nodeArgs = this.fnParseArgs(node.args), varTypes = [], label = this.fnGetStopLabel();
if (nodeArgs.length < 4) {
throw this.composeError(Error(), "Programming error: Not enough parameters", node.type, node.pos); // should not occur
}
const stream = nodeArgs[0];
let noCRLF = nodeArgs[1];
if (noCRLF === ";") { // ; or null
noCRLF = '"' + noCRLF + '"';
}
let msg = nodeArgs[2];
if (!node.args) {
throw this.composeError(Error(), "Programming error: Undefined args", node.type, node.pos); // should not occur
}
if (node.args[2].type === "null") { // message type
msg = '""';
}
const prompt = nodeArgs[3];
if (prompt === ";" || node.args[3].type === "null") { // ";" => insert prompt "? " in quoted string
msg = msg.substring(0, msg.length - 1) + "? " + msg.substr(-1, 1);
}
for (let i = 4; i < nodeArgs.length; i += 1) {
varTypes[i - 4] = this.fnDetermineStaticVarType(nodeArgs[i]);
}
let value = "o.vmGoto(\"" + label + "\"); break;\ncase \"" + label + "\":"; // also before input
const label2 = this.fnGetStopLabel();
value += "o." + node.type + "(" + stream + ", " + noCRLF + ", " + msg + ", \"" + varTypes.join('", "') + "\"); o.vmGoto(\"" + label2 + "\"); break;\ncase \"" + label2 + "\":";
for (let i = 4; i < nodeArgs.length; i += 1) {
value += "; " + nodeArgs[i] + " = o.vmGetNextInput()";
}
node.pv = value;
}
let(node) {
if (!node.right) {
throw this.composeError(Error(), "Programming error: Undefined right", node.type, node.pos); // should not occur
}
this.assign(node.right);
node.pv = node.right.pv;
node.pt = node.right.pt; // TODO: Do we need this?
}
list(node) {
const nodeArgs = this.fnParseArgs(node.args); // or: fnCommandWithGoto
if (!node.args) {
throw this.composeError(Error(), "Programming error: Undefined args", node.type, node.pos); // should not occur
}
if (!node.args.length || node.args[node.args.length - 1].type === "#") { // last parameter stream? or no parameters?
const stream = nodeArgs.pop() || "0";
nodeArgs.unshift(stream); // put it first
}
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + "); break;";
}
mid$Assign(node) {
const nodeArgs = this.fnParseArgs(node.args);
if (nodeArgs.length < 4) {
nodeArgs.splice(2, 0, "undefined"); // set empty length
}
const name = nodeArgs[0], varType = this.fnDetermineStaticVarType(name);
node.pv = name + " = o.vmAssign(\"" + varType + "\", o.mid$Assign(" + nodeArgs.join(", ") + "))";
}
static fnNew(node) {
const name = Utils.supportReservedNames ? ("o." + node.type) : 'o["' + node.type + '"]';
node.pv = name + "();";
}
next(node) {
const nodeArgs = this.fnParseArgs(node.args);
if (!nodeArgs.length) {
nodeArgs.push(""); // we have no variable, so use empty argument
}
for (let i = 0; i < nodeArgs.length; i += 1) {
const label = this.stack.forLabel.pop(), varName = this.stack.forVarName.pop();
let errorNode;
if (label === undefined) {
if (nodeArgs[i] === "") { // inserted node?
errorNode = node;
}
else { // identifier arg
errorNode = node.args[i];
}
throw this.composeError(Error(), "Unexpected NEXT", errorNode.type, errorNode.pos);
}
if (nodeArgs[i] !== "" && nodeArgs[i] !== varName) {
errorNode = node.args[i];
throw this.composeError(Error(), "Unexpected NEXT variable", errorNode.value, errorNode.pos);
}
nodeArgs[i] = "/* " + node.type + "(\"" + nodeArgs[i] + "\") */ o.vmGoto(\"" + label + "\"); break;\ncase \"" + label + "e\":";
}
node.pv = nodeArgs.join("; ");
}
onBreakGosubOrRestore(node) {
const nodeArgs = this.fnParseArgs(node.args);
for (let i = 0; i < nodeArgs.length; i += 1) {
this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);
}
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + ")";
}
onErrorGoto(node) {
const nodeArgs = this.fnParseArgs(node.args);
for (let i = 0; i < nodeArgs.length; i += 1) {
if (Number(nodeArgs[i])) { // only for lines > 0
this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);
}
}
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + ")";
}
onGosubOnGoto(node) {
const nodeArgs = this.fnParseArgs(node.args), label = node.type === "onGosub" ? this.fnGetGosubLabel() : this.fnGetStopLabel();
for (let i = 1; i < nodeArgs.length; i += 1) { // starting with 1
this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);
}
nodeArgs.unshift('"' + label + '"');
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + '); break;\ncase "' + label + '":';
}
onSqGosub(node) {
const nodeArgs = this.fnParseArgs(node.args);
for (let i = 0; i < nodeArgs.length; i += 1) {
this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);
}
if (!node.right) {
throw this.composeError(Error(), "Programming error: Undefined right", "", -1); // should not occur
}
const sqArgs = this.fnParseArgs(node.right.args);
nodeArgs.unshift(sqArgs[0]);
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + ")";
}
print(node) {
const args = node.args, nodeArgs = [];
let newLine = true;
for (let i = 0; i < args.length; i += 1) {
const arg = args[i];
let argString = this.fnParseOneArg(arg);
if (i === args.length - 1) {
if (arg.type === ";" || arg.type === "," || arg.type === "spc" || arg.type === "tab") {
newLine = false;
}
}
if (arg.type === ",") { // comma tab
argString = "{type: \"commaTab\", args: []}"; // we must delay the commaTab() call until print() is called
nodeArgs.push(argString);
}
else if (arg.type !== ";") { // ignore ";" separators
nodeArgs.push(argString);
}
}
if (newLine) {
const arg2 = '"\\r\\n"';
nodeArgs.push(arg2);
}
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + ")";
}
randomize(node) {
let value;
if (node.args.length) {
const nodeArgs = this.fnParseArgs(node.args);
value = "o." + node.type + "(" + nodeArgs.join(", ") + ")";
}
else {
const label = this.fnGetStopLabel();
value = "o.vmGoto(\"" + label + "\"); break;\ncase \"" + label + "\":"; // also before input
value += this.fnCommandWithGoto(node) + " o.randomize(o.vmGetNextInput())";
}
node.pv = value;
}
read(node) {
const nodeArgs = this.fnParseArgs(node.args);
for (let i = 0; i < nodeArgs.length; i += 1) {
const name = nodeArgs[i], varType = this.fnDetermineStaticVarType(name);
nodeArgs[i] = name + " = o." + node.type + "(\"" + varType + "\")";
}
node.pv = nodeArgs.join("; ");
}
rem(node) {
const nodeArgs = this.fnParseArgs(node.args);
node.pv = "//" + nodeArgs.join("") + "\n";
}
apostrophe(node) {
const nodeArgs = this.fnParseArgs(node.args);
if (nodeArgs.length && !nodeArgs[0].startsWith(" ")) {
nodeArgs[0] = " " + nodeArgs[0]; // add extra space
}
node.pv = "//" + nodeArgs.join("") + "\n";
}
static fnReturn(node) {
const name = Utils.supportReservedNames ? ("o." + node.type) : 'o["' + node.type + '"]';
node.pv = name + "(); break;";
}
run(node) {
if (node.args.length) {
if (node.args[0].type === "linenumber" || node.args[0].type === "number") { // optional line number, should be linenumber only
this.fnAddReferenceLabel(this.fnParseOneArg(node.args[0]), node.args[0]); // parse only one arg, args are parsed later
}
}
node.pv = this.fnCommandWithGoto(node);
}
save(node) {
let nodeArgs = [];
if (node.args.length) {
const fileName = this.fnParseOneArg(node.args[0]);
nodeArgs.push(fileName);
if (node.args.length > 1) {
this.defScopeArgs = {}; // collect DEF scope args
const type = '"' + this.fnParseOneArg(node.args[1]) + '"';
this.defScopeArgs = undefined;
nodeArgs.push(type);
const nodeArgs2 = node.args.slice(2), // get remaining args
nodeArgs3 = this.fnParseArgs(nodeArgs2);
nodeArgs = nodeArgs.concat(nodeArgs3);
}
}
node.pv = this.fnCommandWithGoto(node, nodeArgs);
}
spc(node) {
const nodeArgs = this.fnParseArgs(node.args);
node.pv = "{type: \"spc\", args: [" + nodeArgs.join(", ") + "]}"; // we must delay the spc() call until print() is called because we need stream
}
stopOrEnd(node) {
const label = this.fnGetStopLabel();
node.pv = "o." + node.type + "(\"" + label + "\"); break;\ncase \"" + label + "\":";
}
tab(node) {
const nodeArgs = this.fnParseArgs(node.args);
node.pv = "{type: \"tab\", args: [" + nodeArgs.join(", ") + "]}"; // we must delay the tab() call until print() is called
}
usingOrWrite(node) {
const nodeArgs = this.fnParseArgsIgnoringCommaSemi(node.args);
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + ")";
}
wend(node) {
const label = this.stack.whileLabel.pop();
if (label === undefined) {
throw this.composeError(Error(), "Unexpected WEND", node.type, node.pos);
}
node.pv = "/* o." + node.type + "() */ o.vmGoto(\"" + label + "\"); break;\ncase \"" + label + "e\":";
}
fnWhile(node) {
const nodeArgs = this.fnParseArgs(node.args), label = this.fnGetWhileLabel();
this.stack.whileLabel.push(label);
node.pv = "\ncase \"" + label + "\": if (!(" + nodeArgs + ")) { o.vmGoto(\"" + label + "e\"); break; }";
}
/* eslint-disable no-invalid-this */
parseFunctions = {
";": CodeGeneratorJs.commaOrSemicolon, // ";" for input, line input
",": CodeGeneratorJs.commaOrSemicolon, // "," for input, line input
"|": this.vertical,
number: CodeGeneratorJs.number,
expnumber: CodeGeneratorJs.expnumber,
binnumber: CodeGeneratorJs.binnumber,
hexnumber: CodeGeneratorJs.hexnumber,
linenumber: CodeGeneratorJs.linenumber,
identifier: this.identifier,
letter: CodeGeneratorJs.letter, // for defint, defreal, defstr
range: this.range,
linerange: this.linerange,
string: CodeGeneratorJs.string,
ustring: CodeGeneratorJs.string, // unterminated string the same as string
unquoted: CodeGeneratorJs.unquoted,
"null": CodeGeneratorJs.fnNull,
assign: this.assign,
label: this.label,
afterGosub: this.afterEveryGosub,
call: this.fnCommandWithGoto,
chain: this.fnCommandWithGoto,
chainMerge: this.fnCommandWithGoto,
clear: this.fnCommandWithGoto, // will also do e.g. closeout
closeout: this.fnCommandWithGoto,
cont: CodeGeneratorJs.cont,
data: this.data,
def: this.def,
defint: this.fnParseDefIntRealStr,
defreal: this.fnParseDefIntRealStr,
defstr: this.fnParseDefIntRealStr,
dim: this.dim,
"delete": this.fnDelete,
edit: this.edit,
elseComment: this.elseComment,
end: this.stopOrEnd,
erase: this.erase,
error: this.error,
everyGosub: this.afterEveryGosub,
fn: this.fn,
"for": this.fnFor,
frame: this.fnCommandWithGoto,
gosub: this.gosub,
"goto": this.gotoOrResume,
"if": this.fnIf,
input: this.inputOrlineInput,
let: this.let,
lineInput: this.inputOrlineInput,
list: this.list,
load: this.fnCommandWithGoto,
merge: this.fnCommandWithGoto,
mid$Assign: this.mid$Assign,
"new": CodeGeneratorJs.fnNew,
next: this.next,
onBreakGosub: this.onBreakGosubOrRestore,
onErrorGoto: this.onErrorGoto,
onGosub: this.onGosubOnGoto,
onGoto: this.onGosubOnGoto,
onSqGosub: this.onSqGosub,
openin: this.fnCommandWithGoto,
print: this.print,
randomize: this.randomize,
read: this.read,
rem: this.rem,
"'": this.apostrophe, // apostrophe comment
renum: this.fnCommandWithGoto,
restore: this.onBreakGosubOrRestore,
resume: this.gotoOrResume,
resumeNext: this.gotoOrResume,
"return": CodeGeneratorJs.fnReturn,
run: this.run,
save: this.save,
sound: this.fnCommandWithGoto, // maybe queue is full, so insert break
spc: this.spc,
stop: this.stopOrEnd,
tab: this.tab,
tron: this.fnCommandWithGoto, // not really needed with goto, but...
using: this.usingOrWrite,
wend: this.wend,
"while": this.fnWhile,
write: this.usingOrWrite
};
/* eslint-enable no-invalid-this */
fnParseOther(node) {
const nodeArgs = this.fnParseArgs(node.args), typeWithSpaces = " " + node.type + " ";
node.pv = "o." + node.type + "(" + nodeArgs.join(", ") + ")";
if (CodeGeneratorJs.fnIsInString(" asc cint derr eof erl err fix fre inkey inp instr int joy len memory peek pos remain sgn sq test testr unt vpos xpos ypos ", typeWithSpaces)) {
node.pt = "I";
}
else if (CodeGeneratorJs.fnIsInString(" abs atn cos creal exp log log10 pi rnd round sin sqr tan time val ", typeWithSpaces)) {
node.pt = "R";
}
else if (CodeGeneratorJs.fnIsInString(" bin$ chr$ copychr$ dec$ hex$ inkey$ left$ lower$ mid$ right$ space$ str$ string$ upper$ ", typeWithSpaces)) {
node.pt = "$";
}
if (node.type === "min" || node.type === "max") {
if (node.args.length === 1) {
if (node.args[0].type === "$") {
node.pt = "$";
}
}
else if (node.args.length > 1) {
node.pt = "R";
}
}
}
parseOperator(node) {
const operators = this.allOperators;
if (node.left) {
this.parseNode(node.left);
if (operators[node.left.type] && node.left.left) { // binary operator?
node.left.pv = "(" + node.left.pv + ")";
}
if (!node.right) {
throw this.composeError(Error(), "Programming error: Undefined right", "", -1); // should not occur
}
this.parseNode(node.right);
if (operators[node.right.type] && node.right.left) { // binary operator?
node.right.pv = "(" + node.right.pv + ")";
}
operators[node.type].call(this, node, node.left, node.right);
}
else {
if (!node.right) {
throw this.composeError(Error(), "Programming error: Undefined right", "", -1); // should not occur
}
this.parseNode(node.right);
this.unaryOperators[node.type].call(this, node, undefined, node.right); // unary operator: we just use node.right
}
}
parseNode(node) {
if (Utils.debug > 3) {
Utils.console.debug("evaluate: parseNode node=%o type=" + node.type + " value=" + node.value + " left=%o right=%o args=%o", node, node.left, node.right, node.args);
}
if (this.allOperators[node.type]) {
this.parseOperator(node);
}
else if (this.parseFunctions[node.type]) { // function with special handling?
this.parseFunctions[node.type].call(this, node);
}
else { // for other functions, generate code directly
this.fnParseOther(node);
}
}
static fnCommentUnusedCases(output, labels) {
return output.replace(/^case (\d+):/gm, function (all, line) {
return (labels[line]) ? all : "/* " + all + " */";
});
}
fnCheckLabel(node, lastLine) {
let label = node.value;
if (label === "") {
if (this.options.implicitLines) {
label = String(lastLine + 1); // no line => we just increase the last line by 1
node.value = label; // we also modify the parse tree
}
else {
throw this.composeError(Error(), "Direct command found", label, node.pos);
}
}
const lineNumber = Number(label);
if ((lineNumber | 0) !== lineNumber) { // eslint-disable-line no-bitwise
throw this.composeError(Error(), "Expected integer line number", label, node.pos);
}
if (lineNumber < 1 || lineNumber > 65535) {
throw this.composeError(Error(), "Line number overflow", label, node.pos);
}
if (lineNumber <= lastLine) {
throw this.composeError(Error(), "Expected increasing line number", label, node.pos);
}
return label;
}
fnCreateLabelMap(nodes, labels) {
let lastLine = 0;
for (let i = 0; i < nodes.length; i += 1) {
const node = nodes[i];
if (node.type === "label" && node.value !== "direct") {
const label = this.fnCheckLabel(node, lastLine);
if (label) {
labels[label] = 0; // init call count
lastLine = Number(label);
}
}
}
}
removeAllDefVarTypes() {
const varTypes = this.defintDefstrTypes;
for (const name in varTypes) { // eslint-disable-line guard-for-in
delete varTypes[name];
}
}
fnSetDefVarTypeRange(type, first, last) {
const firstNum = first.charCodeAt(0), lastNum = last.charCodeAt(0);
for (let i = firstNum; i <= lastNum; i += 1) {
const varChar = String.fromCharCode(i);
this.defintDefstrTypes[varChar] = type;
}
}
fnPrecheckDefintDefstr(node) {
if (node.args) {
const type = node.type === "defint" ? "I" : "$";
for (let i = 0; i < node.args.length; i += 1) {
const arg = node.args[i];
if (arg.type === "letter") {
this.defintDefstrTypes[arg.value.toLowerCase()] = type;
}
else if (arg.type === "range") {
if (!arg.left || !arg.right) {
throw this.composeError(Error(), "Programming error: Undefined left or right", node.type, node.pos); // should not occur
}
this.fnSetDefVarTypeRange(type, arg.left.value.toLowerCase(), arg.right.value.toLowerCase());
}
}
}
}
fnPrecheckTree(nodes, countMap) {
for (let i = 0; i < nodes.length; i += 1) {
const node = nodes[i];
countMap[node.type] = (countMap[node.type] || 0) + 1;
if (node.type === "defint" || node.type === "defstr") {
if (node.args) {
this.fnPrecheckDefintDefstr(node);
}
}
if (node.type === "resume" && !(node.args && node.args.length)) {
const resumeNoArgs = "resumeNoArgsCount";
countMap[resumeNoArgs] = (countMap[resumeNoArgs] || 0) + 1;
}
if (node.args) {
this.fnPrecheckTree(node.args, countMap); // recursive
}
}
}
evaluate(parseTree, variables) {
this.variables = variables;
this.defScopeArgs = undefined;
this.fnCreateLabelMap(parseTree, this.referencedLabelsCount);
this.removeAllDefVarTypes();
this.fnPrecheckTree(parseTree, this.countMap); // also sets "resumeNoArgsCount" for resume without args
let output = "";
for (let i = 0; i < parseTree.length; i += 1) {
if (Utils.debug > 2) {
Utils.console.debug("evaluate: parseTree i=%d, node=%o", i, parseTree[i]);
}
const line = this.fnParseOneArg(parseTree[i]);
if ((line !== undefined) && (line !== "")) {
if (line !== null) {
if (output.length === 0) {
output = line;
}
else {
output += "\n" + line;
}
}
else {
output = ""; // cls (clear output when node is set to null)
}
}
}
if (!this.countMap.merge && !this.countMap.chainMerge && !this.countMap.resumeNext && !this.countMap.resumeNoArgsCount) {
output = CodeGeneratorJs.fnCommentUnusedCases(output, this.referencedLabelsCount);
}
return output;
}
static combineData(data) {
return data.length ? data.join(";\n") + ";\n" : "";
}
static combineLabels(data) {
return data.length ? "o.vmSetLabels([" + data.join(",") + "]);\n" : "";
}
getSourceMap() {
return this.sourceMap;
}
debugGetLabelsCount() {
return Object.keys(this.referencedLabelsCount).length;
}
generate(input, variables, allowDirect) {
const out = {
text: ""
};
this.reset();
try {
const tokens = this.options.lexer.lex(input), parseTree = this.options.parser.parse(tokens);
if (allowDirect && parseTree.length) {
const lastLine = parseTree[parseTree.length - 1];
if (lastLine.type === "label" && lastLine.value === "") {
lastLine.value = "direct";
}
}
let output = this.evaluate(parseTree, variables);
const combinedData = CodeGeneratorJs.combineData(this.dataList), combinedLabels = CodeGeneratorJs.combineLabels(this.labelList);
if (!this.options.noCodeFrame) {
output = '"use strict"\n'
+ "var v=o.vmGetAllVariables();\n"
+ "var t=o.vmGetAllVarTypes();\n"
+ "while (o.vmLoopCondition()) {\nswitch (o.line) {\ncase 0:\n"
+ combinedData
+ combinedLabels
+ " o.vmGoto(o.startLine ? o.startLine : \"start\"); break;\ncase \"start\":\n"
+ output
+ "\ncase \"end\": o.line=\"end\"; o.vmStop(\"end\", 90); break;\ndefault: o.error(8); o.vmGoto(\"end\"); break;\n}}\n";
}
else {
output = combinedData + output;
}
out.text = output;
}
catch (e) {
if (Utils.isCustomError(e)) {
out.error = e;
if (!this.options.quiet) {
Utils.console.warn(e); // show our customError as warning
}
}
else { // other errors
out.error = e; // force set other error
Utils.console.error(e);
}
}
return out;
}
}
class CodeGeneratorToken {
options;
label = "0"; // current line (label)
constructor(options) {
this.options = {
allowLineFragments: false, // only for testing
implicitLines: false,
quiet: false
};
this.setOptions(options);
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
static tokens = {
_eol: 0x00, // marker for "end of tokenised line"
":": 0x01, // ":" statement seperator
_intVar: 0x02, // integer variable definition (defined with "%" suffix)  "(A-Z)+%"
_stringVar: 0x03, // string variable definition (defined with "$" suffix)  "(A-Z)+\$"
_floatVar: 0x04, // floating point variable definition (defined with "!" suffix) "(A-Z)+!"
_anyVar: 0x0d, // floating point or no type (no suffix)
0: 0x0e, // number constant "0"
1: 0x0f, // number constant "1"
2: 0x10, // number constant "2"
3: 0x11, // number constant "3"
4: 0x12, // number constant "4"
5: 0x13, // number constant "5"
6: 0x14, // number constant "6"
7: 0x15, // number constant "7"
8: 0x16, // number constant "8"
9: 0x17, // number constant "9"
10: 0x18, // number constant "10" (not sure when this is used)
_dec8: 0x19, // 8-bit integer decimal value
_dec16: 0x1a, // 16-bit integer decimal value
_bin16: 0x1b, // 16-bit integer binary value (with "&X" prefix)
_hex16: 0x1c, // num16Hex: 16-bit integer hexadecimal value (with "&H" or "&" prefix)
_line16: 0x1e, // 16-bit integer BASIC line number
_float: 0x1f, // floating point value
"#": 0x23, // "#" character (stream)
"(": 0x28, // "(" character
")": 0x29, // ")" character
",": 0x2c, // "," character
"?": 0x3f, // "?" character (print)
"@": 0x40, // "@" character (address of)
"[": 0x5b, // "[" character
"]": 0x5d, // "]" character
"|": 0x7c, // "|" symbol; prefix for RSX commands
after: 0x80,
afterGosub: 0x80,
auto: 0x81,
border: 0x82,
call: 0x83,
cat: 0x84,
chain: 0x85,
chainMerge: 0x85, // 0xab85
clear: 0x86,
clearInput: 0x86, // 0xa386
clg: 0x87,
closein: 0x88,
closeout: 0x89,
cls: 0x8a,
cont: 0x8b,
data: 0x8c,
def: 0x8d,
defint: 0x8e,
defreal: 0x8f,
defstr: 0x90,
deg: 0x91,
"delete": 0x92,
dim: 0x93,
draw: 0x94,
drawr: 0x95,
edit: 0x96,
"else": 0x97,
end: 0x98,
ent: 0x99,
env: 0x9a,
erase: 0x9b,
error: 0x9c,
every: 0x9d,
everyGosub: 0x9d,
"for": 0x9e,
gosub: 0x9f,
"goto": 0xa0,
"if": 0xa1,
ink: 0xa2,
input: 0xa3,
key: 0xa4,
keyDef: 0xa4, // 0x8da4
let: 0xa5,
line: 0xa6,
lineInput: 0xa6, // 0xa3a6
list: 0xa7,
load: 0xa8,
locate: 0xa9,
memory: 0xaa,
merge: 0xab,
mid$: 0xac,
mid$Assign: 0xac,
mode: 0xad,
move: 0xae,
mover: 0xaf,
next: 0xb0,
"new": 0xb1,
on: 0xb2,
_onBreak: 0xb3, // onBreakCont, onBreakGosub, onBreakStop
_onErrorGoto0: 0xb4, // "on error goto 0" (on error goto n > 0 is decoded with separate tokens)
onGosub: 0xb2,
onGoto: 0xb2,
_onSq: 0xb5, // "on sq" (onSqGosub)
openin: 0xb6,
openout: 0xb7,
origin: 0xb8,
out: 0xb9,
paper: 0xba,
pen: 0xbb,
plot: 0xbc,
plotr: 0xbd,
poke: 0xbe,
print: 0xbf,
"'": 0xc0, // apostrophe "'" symbol (same function as REM keyword)
rad: 0xc1,
randomize: 0xc2,
read: 0xc3,
release: 0xc4,
rem: 0xc5, // rem
renum: 0xc6,
restore: 0xc7,
resume: 0xc8,
resumeNext: 0xc8, // 0xb0c8
"return": 0xc9,
run: 0xca,
save: 0xcb,
sound: 0xcc,
speedInk: 0xcd, // 0xa2cd
speedKey: 0xcd, // 0xa4cd,
speedWrite: 0xcd, // 0xd9cd
stop: 0xce,
swap: 0xe7,
symbol: 0xcf,
symbolAfter: 0xcf, // 0x80cf
tag: 0xd0,
tagoff: 0xd1,
troff: 0xd2,
tron: 0xd3,
wait: 0xd4,
wend: 0xd5,
"while": 0xd6,
width: 0xd7,
window: 0xd8,
windowSwap: 0xd8, // 0xe7d8
write: 0xd9,
zone: 0xda,
di: 0xdb,
ei: 0xdc,
fill: 0xdd, // (v1.1)
graphics: 0xde, // (v1.1)
graphicsPaper: 0xde, // 0xbade
graphicsPen: 0xde, // 0xbbde
mask: 0xdf, // (v1.1)
frame: 0xe0, // (v1.1)
cursor: 0xe1, // (v1.1)
erl: 0xe3,
fn: 0xe4,
spc: 0xe5,
step: 0xe6,
tab: 0xea,
then: 0xeb,
to: 0xec,
using: 0xed,
">": 0xee, // (greater than)
"=": 0xef, // (equal)
assign: 0xef, // equal as assign
">=": 0xf0, // (greater or equal)
"<": 0xf1, // (less than)
"<>": 0xf2, // (not equal)
"<=": 0xf3, // =<, <=, < = (less than or equal)
"+": 0xf4, // (addition)
"-": 0xf5, // (subtraction or unary minus)
"*": 0xf6, // (multiplication)
"/": 0xf7, // (division)
"^": 0xf8, // (x to the power of y)
"\\": 0xf9, // (integer division)
and: 0xfa,
mod: 0xfb,
or: 0xfc,
xor: 0xfd,
not: 0xfe
};
static tokensFF = {
abs: 0x00,
asc: 0x01,
atn: 0x02,
chr$: 0x03,
cint: 0x04,
cos: 0x05,
creal: 0x06,
exp: 0x07,
fix: 0x08,
fre: 0x09,
inkey: 0x0a,
inp: 0x0b,
"int": 0x0c,
joy: 0x0d,
len: 0x0e,
log: 0x0f,
log10: 0x10,
lower$: 0x11,
peek: 0x12,
remain: 0x13,
sgn: 0x14,
sin: 0x15,
space$: 0x16,
sq: 0x17,
sqr: 0x18,
str$: 0x19,
tan: 0x1a,
unt: 0x1b,
upper$: 0x1c,
val: 0x1d,
eof: 0x40,
err: 0x41,
himem: 0x42,
inkey$: 0x43,
pi: 0x44,
rnd: 0x45,
time: 0x46,
xpos: 0x47,
ypos: 0x48,
derr: 0x49, // (v1.1)
bin$: 0x71,
dec$: 0x72, // (v1.1)
hex$: 0x73,
instr: 0x74,
left$: 0x75,
max: 0x76,
min: 0x77,
pos: 0x78,
right$: 0x79,
round: 0x7a,
string$: 0x7b,
test: 0x7c,
testr: 0x7d,
copychr$: 0x7e, // (v1.1)
vpos: 0x7f
};
composeError(error, message, value, pos) {
return Utils.composeError("CodeGeneratorToken", error, message, value, pos, undefined, this.label);
}
static convUInt8ToString(n) {
return String.fromCharCode(n);
}
static convUInt16ToString(n) {
return String.fromCharCode(n & 0xff) + String.fromCharCode(n >> 8); // eslint-disable-line no-bitwise
}
static convInt32ToString(n) {
return CodeGeneratorToken.convUInt16ToString(n & 0xffff) + CodeGeneratorToken.convUInt16ToString((n >> 16) & 0xffff); // eslint-disable-line no-bitwise
}
static token2String(name) {
let token = CodeGeneratorToken.tokens[name], result = "";
if (token === undefined) {
token = CodeGeneratorToken.tokensFF[name];
if (token === undefined) {
Utils.console.error("token2String: Not a token: " + name);
return name; // return something
}
result = CodeGeneratorToken.convUInt8ToString(0xff); // prefix for special tokens
}
return result + CodeGeneratorToken.convUInt8ToString(token);
}
static getBit7TerminatedString(s) {
return s.substring(0, s.length - 1) + String.fromCharCode(s.charCodeAt(s.length - 1) | 0x80); // eslint-disable-line no-bitwise
}
static fnGetWs(node) {
return node.ws || "";
}
fnParseArgs(args) {
const nodeArgs = []; // do not modify node.args here (could be a parameter of defined function)
if (!args) {
throw this.composeError(Error(), "Programming error: Undefined args", "", -1); // should not occur
}
for (let i = 0; i < args.length; i += 1) {
nodeArgs.push(this.parseNode(args[i]));
}
return nodeArgs;
}
fnArgs(node) {
return this.fnParseArgs(node.args).join(node.value);
}
range(node) {
return this.parseNode(node.left) + CodeGeneratorToken.fnGetWs(node) + node.value + this.parseNode(node.right);
}
linerange(node) {
return this.parseNode(node.left) + CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(node.value) + this.parseNode(node.right);
}
static string(node) {
return CodeGeneratorToken.fnGetWs(node) + '"' + node.value + '"';
}
static ustring(node) {
return CodeGeneratorToken.fnGetWs(node) + '"' + node.value; // unterminated string
}
static fnEol() {
return "";
}
static floatToByteString(number) {
let mantissa = 0, exponent = 0, sign = 0;
if (number !== 0) {
if (number < 0) {
sign = 0x80000000;
number = -number;
}
exponent = Math.ceil(Math.log(number) / Math.log(2));
mantissa = Math.round(number / Math.pow(2, exponent - 32)) & ~0x80000000; // eslint-disable-line no-bitwise
if (mantissa === 0) {
exponent += 1;
}
exponent += 0x80;
}
return CodeGeneratorToken.convInt32ToString(sign + mantissa) + CodeGeneratorToken.convUInt8ToString(exponent);
}
static number(node) {
const numberString = node.value.toUpperCase(), // maybe "e" inside
number = Number(numberString);
let result = "";
if (number === Math.floor(number)) { // integer?
if (number >= 0 && number <= 9) { // integer number constant 0-9? (not sure when 10 is used)
result = CodeGeneratorToken.token2String(numberString);
}
else if (number >= 10 && number <= 0xff) {
result = CodeGeneratorToken.token2String("_dec8") + CodeGeneratorToken.convUInt8ToString(number);
}
else if (number >= -0x7fff && number <= 0x7fff) {
result = (number < 0 ? CodeGeneratorToken.token2String("-") : "") + CodeGeneratorToken.token2String("_dec16") + CodeGeneratorToken.convUInt16ToString(number);
}
}
if (result === "") { // no integer number yet, use float...
result = CodeGeneratorToken.token2String("_float") + CodeGeneratorToken.floatToByteString(number);
}
return CodeGeneratorToken.fnGetWs(node) + result;
}
static binnumber(node) {
const valueString = node.value.slice(2), // remove &x
value = (valueString.length) ? parseInt(valueString, 2) : 0; // we convert it to dec
return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String("_bin16") + CodeGeneratorToken.convUInt16ToString(value);
}
static hexnumber(node) {
let valueString = node.value.slice(1); // remove &
if (valueString.charAt(0).toLowerCase() === "h") { // optional h
valueString = valueString.slice(1); // remove
}
const value = (valueString.length) ? parseInt(valueString, 16) : 0; // we convert it to dec
return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String("_hex16") + CodeGeneratorToken.convUInt16ToString(value);
}
static varTypeMap = {
"!": "_floatVar",
"%": "_intVar",
$: "_stringVar"
};
identifier(node) {
let name = node.value, // keep case, maybe mixed
mappedTypeName = CodeGeneratorToken.varTypeMap[name.charAt(name.length - 1)] || ""; // map last char
if (mappedTypeName) {
name = name.slice(0, -1); // remove type char
}
else {
mappedTypeName = "_anyVar";
}
const offset = 0; // (offset to memory location of variable; not used here)
return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(mappedTypeName) + CodeGeneratorToken.convUInt16ToString(offset) + CodeGeneratorToken.getBit7TerminatedString(name) + (node.args ? this.fnParseArgs(node.args).join("") : "");
}
static linenumber(node) {
return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String("_line16") + CodeGeneratorToken.convUInt16ToString(Number(node.value));
}
fnLabel(node) {
if (node.value === "") { // direct
if (this.options.implicitLines) {
node.value = String(Number(this.label) + 1); // no line => we just increase the last line by 1
}
else if (!this.options.allowLineFragments) {
throw this.composeError(Error(), "Direct command found", node.value, node.pos);
}
}
this.label = node.value; // set line before parsing args
const line = Number(this.label), nodeArgs = this.fnParseArgs(node.args);
let value = nodeArgs.join("");
if (node.value !== "") { // not direct
if (value.charAt(0) === " ") { // remove one space (implicit space after label)
value = value.substring(1);
}
value = CodeGeneratorToken.convUInt16ToString(line) + value + CodeGeneratorToken.token2String("_eol"); // no ws
value = CodeGeneratorToken.convUInt16ToString(value.length + 2) + value;
}
return value;
}
vertical(node) {
const rsxName = node.value.substring(1).toUpperCase(), nodeArgs = this.fnParseArgs(node.args), offset = 0; // offset to tokens following RSX name
return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(node.type) + (rsxName.length ? CodeGeneratorToken.convUInt8ToString(offset) : "") + CodeGeneratorToken.getBit7TerminatedString(rsxName) + nodeArgs.join("");
}
fnElseOrApostrophe(node) {
return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(":") + CodeGeneratorToken.token2String(node.type) + this.fnParseArgs(node.args).join("");
}
elseComment(node) {
if (!node.args) {
throw this.composeError(Error(), "Programming error: Undefined args", "", -1); // should not occur
}
const type = "else"; // not "elseComment"
let value = CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(":") + CodeGeneratorToken.token2String(type); // always prefix with ":"
const args = node.args;
for (let i = 0; i < args.length; i += 1) {
const token = args[i];
let value2 = token.value;
if (value2) {
if (token.type === "linenumber") {
value2 = CodeGeneratorToken.linenumber(token);
}
value += value2;
}
}
return value;
}
onBreakContOrGosubOrStop(node) {
return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String("_onBreak") + (node.right && node.right.right ? this.parseNode(node.right.right) : "") + this.fnParseArgs(node.args).join("");
}
onErrorGoto(node) {
if (node.args && node.args.length && node.args[0].value === "0") { // on error goto 0?
return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String("_onErrorGoto0");
}
return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String("on") + this.parseNode(node.right) + this.fnParseArgs(node.args).join("");
}
onSqGosub(node) {
return CodeGeneratorToken.token2String("_onSq") + this.fnParseArgs(node.right.args).join("") + this.fnParseArgs(node.args).join("");
}
/* eslint-disable no-invalid-this */
parseFunctions = {
args: this.fnArgs,
range: this.range,
linerange: this.linerange,
string: CodeGeneratorToken.string,
ustring: CodeGeneratorToken.ustring,
"(eol)": CodeGeneratorToken.fnEol, // ignore newline "\n"
number: CodeGeneratorToken.number,
expnumber: CodeGeneratorToken.number, // same handling as for number
binnumber: CodeGeneratorToken.binnumber,
hexnumber: CodeGeneratorToken.hexnumber,
identifier: this.identifier,
linenumber: CodeGeneratorToken.linenumber,
label: this.fnLabel,
"|": this.vertical,
"else": this.fnElseOrApostrophe,
elseComment: this.elseComment,
onBreakCont: this.onBreakContOrGosubOrStop,
onBreakGosub: this.onBreakContOrGosubOrStop,
onBreakStop: this.onBreakContOrGosubOrStop,
onErrorGoto: this.onErrorGoto,
onSqGosub: this.onSqGosub,
"'": this.fnElseOrApostrophe
};
/* eslint-enable no-invalid-this */
fnParseOther(node) {
const type = node.type, isToken = CodeGeneratorToken.tokens[type] !== undefined || CodeGeneratorToken.tokensFF[type] !== undefined;
let value = ""; // CodeGeneratorToken.fnGetWs(node);
if (node.left) {
value += this.parseNode(node.left);
}
value += CodeGeneratorToken.fnGetWs(node);
if (isToken) {
value += CodeGeneratorToken.token2String(type);
}
else if (node.value) { // e.g. string,...
value += node.value;
}
if (node.right) {
value += this.parseNode(node.right);
}
if (node.args) {
value += this.fnParseArgs(node.args).join("");
}
return value;
}
parseNode(node) {
if (Utils.debug > 3) {
Utils.console.debug("evaluate: parseNode node=%o type=" + node.type + " value=" + node.value + " left=%o right=%o args=%o", node, node.left, node.right, node.args);
}
const type = node.type;
let value;
if (node.len === 0 && type !== "label") { // ignore dummy token, e.g. '#' (but not label)
value = "";
}
else {
value = this.parseFunctions[type] ? this.parseFunctions[type].call(this, node) : this.fnParseOther(node);
}
if (Utils.debug > 2) {
Utils.console.debug("parseNode: type='" + type + "', value='" + node.value + "', ws='" + node.ws + "', resultValue='" + value + "'");
}
return value;
}
evaluate(parseTree) {
let output = "";
for (let i = 0; i < parseTree.length; i += 1) {
if (Utils.debug > 2) {
Utils.console.debug("evaluate: parseTree i=%d, node=%o", i, parseTree[i]);
}
const node = this.parseNode(parseTree[i]);
if ((node !== undefined) && (node !== "")) {
if (node !== null) {
output += node;
}
else {
output = ""; // cls (clear output when node is set to null)
}
}
}
if (this.label) {
output += CodeGeneratorToken.token2String("_eol") + CodeGeneratorToken.token2String("_eol"); // 2 times eol is eof
}
return output;
}
generate(input) {
const out = {
text: ""
};
this.label = "0";
try {
const tokens = this.options.lexer.lex(input), parseTree = this.options.parser.parse(tokens), output = this.evaluate(parseTree);
out.text = output;
}
catch (e) {
if (Utils.isCustomError(e)) {
out.error = e;
if (!this.options.quiet) {
Utils.console.warn(e); // show our customError as warning
}
}
else { // other errors
out.error = e; // force set other error
Utils.console.error(e);
}
}
return out;
}
}
class CommonEventHandler {
options;
model;
view;
controller;
eventDefInternalMap = {};
fnUserAction = undefined;
constructor(options) {
this.options = {};
this.setOptions(options);
this.model = this.options.model;
this.view = this.options.view;
this.controller = this.options.controller;
this.createEventDefMap();
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
fnSetUserAction(fnAction) {
this.fnUserAction = fnAction;
}
initOneToggle(_type, id, eventDef) {
if (eventDef.property) {
if (eventDef.toggleId) {
const isEnabled = this.model.getProperty(eventDef.property);
this.view.setHidden(eventDef.toggleId, !isEnabled, eventDef.display);
if (Utils.debug > 3) {
Utils.console.debug("initToggles: setHidden: togglId:", eventDef.toggleId, ", property:", eventDef.property, ", hidden:", !isEnabled, ", display:", eventDef.display);
}
}
if (eventDef.viewType === "checked") {
const isEnabled2 = this.model.getProperty(eventDef.property);
this.view.setInputChecked(id, isEnabled2);
if (Utils.debug > 3) {
Utils.console.debug("initToggles: checked: id:", id, ", property:", eventDef.property, ", checked:", isEnabled2);
}
}
else if (eventDef.viewType === "select") {
const value = this.model.getProperty(eventDef.property);
this.view.setSelectValue(id, value);
if (Utils.debug > 3) {
Utils.console.debug("initToggles: select: id:", id, ", property:", eventDef.property, ", value:", value);
}
}
else if (eventDef.viewType === "numberInput") {
const value = this.model.getProperty(eventDef.property);
this.view.setInputValue(id, String(value));
if (Utils.debug > 3) {
Utils.console.debug("initToggles: numberInput: id:", id, ", property:", eventDef.property, ", value:", value);
}
}
}
}
initToggles() {
const eventDefInternalMap = this.eventDefInternalMap;
for (const type in eventDefInternalMap) {
if (eventDefInternalMap.hasOwnProperty(type)) {
const eventDefMap4Type = eventDefInternalMap[type];
for (const id in eventDefMap4Type) {
if (eventDefMap4Type.hasOwnProperty(id)) {
const eventDef = eventDefMap4Type[id];
this.initOneToggle(type, id, eventDef);
}
}
}
}
}
static getToggleId(eventDef) {
if (!eventDef.toggleId) {
Utils.console.error("getToggleId: id=" + eventDef.id + ": toggleId missing!");
return ""; //TTT
}
return eventDef.toggleId;
}
static getproperty(eventDef) {
if (!eventDef.property) {
Utils.console.error("setPopoversHiddenExcept: id=" + eventDef.id + ": property missing!");
return ""; //TTT
}
return eventDef.property;
}
setPopoversHiddenExcept(exceptId) {
const eventDefInternalMap = this.eventDefInternalMap, eventDefMapClick = eventDefInternalMap.click;
for (const id in eventDefMapClick) {
if (eventDefMapClick.hasOwnProperty(id)) {
const eventDef = eventDefMapClick[id];
if (eventDef.isPopover && (eventDef.toggleId !== exceptId)) {
const toggleId = CommonEventHandler.getToggleId(eventDef), property = CommonEventHandler.getproperty(eventDef);
if (!this.view.getHidden(toggleId)) {
this.model.setProperty(property, false);
this.view.setHidden(toggleId, true, eventDef.display);
}
}
}
}
}
toggleAreaHidden(eventDef) {
const toggleId = CommonEventHandler.getToggleId(eventDef), property = CommonEventHandler.getproperty(eventDef), visible = !this.model.getProperty(property);
this.model.setProperty(property, visible);
this.view.setHidden(toggleId, !visible, eventDef.display);
if (visible && eventDef.display === "flex" && this.view.getHidden(toggleId)) {
this.view.setHidden(toggleId, !visible);
}
if (visible && eventDef.isPopover) {
this.setPopoversHiddenExcept(toggleId);
}
return visible;
}
getEventDefById(type, id) {
const eventDefForType = this.eventDefInternalMap[type], eventDef = eventDefForType[id];
if (!eventDef) {
Utils.console.error("getEventDefById: type=" + type + ", id=" + id + ": No eventDef!");
}
return eventDef;
}
toggleAreaHiddenById(type, id) {
const eventDef = this.getEventDefById(type, id);
return this.toggleAreaHidden(eventDef);
}
onCheckedChange(eventDef) {
const id = eventDef.id, property = CommonEventHandler.getproperty(eventDef), checked = this.view.getInputChecked(id);
this.model.setProperty(property, checked);
return checked;
}
onNumberInputChange(eventDef) {
const id = eventDef.id, property = CommonEventHandler.getproperty(eventDef), valueAsString = this.view.getInputValue(id), value = Number(valueAsString);
this.model.setProperty(property, value);
return value;
}
onSelectChange(eventDef) {
const id = eventDef.id, property = CommonEventHandler.getproperty(eventDef), value = this.view.getSelectValue(id);
this.model.setProperty(property, value);
this.view.setSelectTitleFromSelectedOption(id);
return value;
}
onExportButtonClick(eventDef) {
if (this.toggleAreaHidden(eventDef)) {
this.controller.setExportSelectOptions("exportFileSelect" /* ViewID.exportFileSelect */);
}
}
onGalleryButtonClick(eventDef) {
if (this.toggleAreaHidden(eventDef)) {
this.controller.setGalleryAreaInputs();
}
}
fnUpdateAreaText(input) {
this.controller.setInputText(input, true);
this.view.setAreaValue("outputText" /* ViewID.outputText */, "");
}
onUndoButtonClick() {
const input = this.controller.undoStackElement();
this.fnUpdateAreaText(input);
}
onRedoButtonClick() {
const input = this.controller.redoStackElement();
this.fnUpdateAreaText(input);
}
onContinueButtonClick(eventDef, event) {
this.controller.startContinue();
this.onCpcCanvasClick(eventDef, event);
}
onParseRunButtonClick(eventDef, event) {
this.controller.startParseRun();
this.onCpcCanvasClick(eventDef, event);
}
static onHelpButtonClick() {
window.open("https://github.com/benchmarko/cpclocots/#readme");
}
onGalleryItemClick(_eventDef, event) {
const target = View.getEventTarget(event), value = target.value;
this.view.setSelectValue("exampleSelect" /* ViewID.exampleSelect */, value);
this.setPopoversHiddenExcept(); // close
this.controller.onExampleSelectChange();
}
onCopyTextButtonClick() {
const textText = View.getElementByIdAs("textText" /* ViewID.textText */);
textText.select();
this.view.setAreaSelection("textText" /* ViewID.textText */, 0, 99999); // for mobile devices
if (window.navigator && window.navigator.clipboard) {
window.navigator.clipboard.writeText(textText.value);
}
else {
Utils.console.warn("Copy to clipboard not available");
}
}
static encodeUriParam(params) {
const parts = [];
for (const key in params) {
if (params.hasOwnProperty(key)) {
const value = params[key];
parts[parts.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value === null ? "" : value);
}
}
return parts.join("&");
}
onReloadButtonClick() {
this.setPopoversHiddenExcept(); // hide all popovers,
const changed = this.model.getChangedProperties();
let paras = CommonEventHandler.encodeUriParam(changed);
paras = paras.replace(/%2[Ff]/g, "/"); // unescape %2F -> /
window.location.search = "?" + paras;
}
onVarSelectChange() {
const par = this.view.getSelectValue("varSelect" /* ViewID.varSelect */), value = this.controller.getVariable(par), valueString = (value !== undefined) ? String(value) : "";
this.view.setAreaValue("varText" /* ViewID.varText */, valueString);
}
onKbdLayoutSelectChange(eventDef) {
const value = this.onSelectChange(eventDef);
this.view.setHidden("kbdAlpha" /* ViewID.kbdAlpha */, value === "num");
this.view.setHidden("kbdNum" /* ViewID.kbdNum */, value === "alpha");
}
onBasicVersionSelectChange(eventDef) {
const value = this.onSelectChange(eventDef);
this.controller.setBasicVersion(value);
}
onPaletteSelectChange(eventDef) {
const value = this.onSelectChange(eventDef);
this.controller.setPalette(value);
}
onCanvasTypeSelectChange(eventDef) {
const value = this.onSelectChange(eventDef);
this.controller.setCanvasType(value);
}
onDebugInputChange(eventDef) {
const value = this.onNumberInputChange(eventDef);
Utils.debug = value;
}
onDragElementsInputChange(eventDef) {
const checked = this.onCheckedChange(eventDef);
this.controller.fnDragElementsActive(checked);
}
onShowCpcInputChange(eventDef) {
if (this.toggleAreaHidden(eventDef)) {
this.controller.startUpdateCanvas();
}
else {
this.controller.stopUpdateCanvas();
}
}
onShowKbdInputChange(eventDef) {
if (this.toggleAreaHidden(eventDef)) {
this.controller.getVirtualKeyboard(); // maybe draw it
}
}
onDisassInputChange() {
const addressStr = this.view.getInputValue("disassInput" /* ViewID.disassInput */), addrList = addressStr.split("-"), // maybe range
addr = parseInt(addrList[0], 16), // parse as hex
endAddr = addrList[1] ? parseInt(addrList[1], 16) : undefined; // parse as hex
this.controller.setDisassAddr(addr, endAddr);
}
onSoundInputChange(eventDef) {
this.onCheckedChange(eventDef);
this.controller.setSoundActive();
}
onScreenshotButtonClick() {
var example = this.view.getSelectValue("exampleSelect" /* ViewID.exampleSelect */), image = this.controller.startScreenshot(), link = View.getElementById1("screenshotLink" /* ViewID.screenshotLink */), name = example + ".png";
if (image) {
link.setAttribute("download", name);
link.setAttribute("href", image);
link.click();
}
}
onClearInputButtonClick() {
this.view.setAreaValue("inp2Text" /* ViewID.inp2Text */, ""); // delete input
}
onFullscreenButtonClick() {
let id;
if (!this.view.getHidden("cpcCanvas" /* ViewID.cpcCanvas */)) {
id = "cpcCanvas" /* ViewID.cpcCanvas */;
}
else if (!this.view.getHidden("textText" /* ViewID.textText */)) {
id = "textCanvasDiv" /* ViewID.textCanvasDiv */;
}
else {
Utils.console.warn("Fullscreen only possible for graphics or text canvas");
return;
}
const switched = this.view.requestFullscreenForId(id); // make sure to use an element with tabindex set to get keyboard events
if (!switched) {
Utils.console.warn("Switch to fullscreen not available");
}
}
onCpcCanvasClick(_eventDef, event) {
this.setPopoversHiddenExcept(); // hide all popovers
this.controller.onCpcCanvasClick(event);
}
createEventDefMap() {
const eventDefInternalMap = this.eventDefInternalMap, eventDefs = {
click: [
{
id: "clearInputButton" /* ViewID.clearInputButton */,
func: this.onClearInputButtonClick
},
{
id: "continueButton" /* ViewID.continueButton */,
func: this.onContinueButtonClick
},
{
id: "cpcCanvas" /* ViewID.cpcCanvas */,
func: this.onCpcCanvasClick
},
{
id: "copyTextButton" /* ViewID.copyTextButton */,
func: this.onCopyTextButtonClick
},
{
id: "downloadButton" /* ViewID.downloadButton */,
controllerFunc: this.controller.fnDownload
},
{
id: "enterButton" /* ViewID.enterButton */,
controllerFunc: this.controller.startEnter
},
{
id: "exportButton" /* ViewID.exportButton */,
toggleId: "exportArea" /* ViewID.exportArea */,
property: "showExport" /* ModelPropID.showExport */,
display: "flex",
isPopover: true,
func: this.onExportButtonClick
},
{
id: "fullscreenButton" /* ViewID.fullscreenButton */,
func: this.onFullscreenButtonClick
},
{
id: "galleryButton" /* ViewID.galleryButton */,
toggleId: "galleryArea" /* ViewID.galleryArea */,
property: "showGallery" /* ModelPropID.showGallery */,
display: "flex",
isPopover: true,
func: this.onGalleryButtonClick
},
{
id: "galleryItem" /* ViewID.galleryItem */,
func: this.onGalleryItemClick
},
{
id: "helpButton" /* ViewID.helpButton */,
func: CommonEventHandler.onHelpButtonClick
},
{
id: "lineNumberAddButton" /* ViewID.lineNumberAddButton */,
controllerFunc: this.controller.fnAddLines
},
{
id: "lineNumberRemoveButton" /* ViewID.lineNumberRemoveButton */,
controllerFunc: this.controller.fnRemoveLines
},
{
id: "moreButton" /* ViewID.moreButton */,
toggleId: "moreArea" /* ViewID.moreArea */,
property: "showMore" /* ModelPropID.showMore */,
display: "flex",
isPopover: true,
func: this.toggleAreaHidden
},
{
id: "parseButton" /* ViewID.parseButton */,
controllerFunc: this.controller.startParse
},
{
id: "parseRunButton" /* ViewID.parseRunButton */,
func: this.onParseRunButtonClick
},
{
id: "prettyButton" /* ViewID.prettyButton */,
controllerFunc: this.controller.fnPretty
},
{
id: "prettyPopoverButton" /* ViewID.prettyPopoverButton */,
toggleId: "prettyArea" /* ViewID.prettyArea */,
property: "showPretty" /* ModelPropID.showPretty */,
display: "flex",
isPopover: true,
func: this.toggleAreaHidden
},
{
id: "redoButton" /* ViewID.redoButton */,
func: this.onRedoButtonClick
},
{
id: "redoButton2" /* ViewID.redoButton2 */,
func: this.onRedoButtonClick // same redo
},
{
id: "reloadButton" /* ViewID.reloadButton */,
func: this.onReloadButtonClick
},
{
id: "reload2Button" /* ViewID.reload2Button */,
func: this.onReloadButtonClick // same as relaodButton
},
{
id: "renumButton" /* ViewID.renumButton */,
controllerFunc: this.controller.startRenum
},
{
id: "renumPopoverButton" /* ViewID.renumPopoverButton */,
toggleId: "renumArea" /* ViewID.renumArea */,
property: "showRenum" /* ModelPropID.showRenum */,
display: "flex",
isPopover: true,
func: this.toggleAreaHidden
},
{
id: "resetButton" /* ViewID.resetButton */,
controllerFunc: this.controller.startReset
},
{
id: "runButton" /* ViewID.runButton */,
controllerFunc: this.controller.startRun
},
{
id: "screenshotButton" /* ViewID.screenshotButton */,
func: this.onScreenshotButtonClick
},
{
id: "screenshotLink" /* ViewID.screenshotLink */ // nothing
},
{
id: "settingsButton" /* ViewID.settingsButton */,
toggleId: "settingsArea" /* ViewID.settingsArea */,
property: "showSettings" /* ModelPropID.showSettings */,
display: "flex",
isPopover: true,
func: this.toggleAreaHidden
},
{
id: "stopButton" /* ViewID.stopButton */,
controllerFunc: this.controller.startBreak
},
{
id: "textText" /* ViewID.textText */,
func: this.onCpcCanvasClick // same as for cpcCanvas
},
{
id: "undoButton" /* ViewID.undoButton */,
func: this.onUndoButtonClick
},
{
id: "undoButton2" /* ViewID.undoButton2 */,
func: this.onUndoButtonClick // same undo
},
{
id: "viewButton" /* ViewID.viewButton */,
toggleId: "viewArea" /* ViewID.viewArea */,
property: "showView" /* ModelPropID.showView */,
display: "flex",
isPopover: true,
func: this.toggleAreaHidden
},
{
id: "window" /* ViewID.window */, //TTT do we need this?
controllerFunc: this.controller.onWindowClick
}
],
change: [
{
id: "arrayBoundsInput" /* ViewID.arrayBoundsInput */,
viewType: "checked",
property: "arrayBounds" /* ModelPropID.arrayBounds */,
func: this.onCheckedChange,
controllerFunc: this.controller.fnArrayBounds
},
{
id: "autorunInput" /* ViewID.autorunInput */,
viewType: "checked",
property: "autorun" /* ModelPropID.autorun */,
func: this.onCheckedChange
},
{
id: "basicVersionSelect" /* ViewID.basicVersionSelect */,
viewType: "select",
property: "basicVersion" /* ModelPropID.basicVersion */,
func: this.onBasicVersionSelectChange
},
{
id: "canvasTypeSelect" /* ViewID.canvasTypeSelect */,
viewType: "select",
property: "canvasType" /* ModelPropID.canvasType */,
func: this.onCanvasTypeSelectChange
},
{
id: "databaseSelect" /* ViewID.databaseSelect */,
controllerFunc: this.controller.onDatabaseSelectChange
},
{
id: "debugInput" /* ViewID.debugInput */,
viewType: "numberInput",
property: "debug" /* ModelPropID.debug */,
func: this.onDebugInputChange
},
{
id: "directorySelect" /* ViewID.directorySelect */,
controllerFunc: this.controller.onDirectorySelectChange
},
{
id: "disassInput" /* ViewID.disassInput */,
func: this.onDisassInputChange
},
{
id: "exampleSelect" /* ViewID.exampleSelect */,
controllerFunc: this.controller.onExampleSelectChange
},
{
id: "implicitLinesInput" /* ViewID.implicitLinesInput */,
viewType: "checked",
property: "implicitLines" /* ModelPropID.implicitLines */,
func: this.onCheckedChange,
controllerFunc: this.controller.fnImplicitLines
},
{
id: "integerOverflowInput" /* ViewID.integerOverflowInput */,
viewType: "checked",
property: "integerOverflow" /* ModelPropID.integerOverflow */,
func: this.onCheckedChange,
controllerFunc: this.controller.fnIntegerOverflow
},
{
id: "kbdLayoutSelect" /* ViewID.kbdLayoutSelect */,
viewType: "select",
property: "kbdLayout" /* ModelPropID.kbdLayout */,
func: this.onKbdLayoutSelectChange
},
{
id: "linesOnLoadInput" /* ViewID.linesOnLoadInput */,
viewType: "checked",
property: "linesOnLoad" /* ModelPropID.linesOnLoad */,
func: this.onCheckedChange
},
{
id: "dragElementsInput" /* ViewID.dragElementsInput */,
viewType: "checked",
property: "dragElements" /* ModelPropID.dragElements */,
func: this.onDragElementsInputChange
},
{
id: "outputText" /* ViewID.outputText */,
controllerFunc: this.controller.invalidateScript
},
{
id: "paletteSelect" /* ViewID.paletteSelect */,
viewType: "select",
property: "palette" /* ModelPropID.palette */,
func: this.onPaletteSelectChange
},
{
id: "prettyBracketsInput" /* ViewID.prettyBracketsInput */,
viewType: "checked",
property: "prettyBrackets" /* ModelPropID.prettyBrackets */,
func: this.onCheckedChange
},
{
id: "prettyColonsInput" /* ViewID.prettyColonsInput */,
viewType: "checked",
property: "prettyColons" /* ModelPropID.prettyColons */,
func: this.onCheckedChange
},
{
id: "prettyLowercaseVarsInput" /* ViewID.prettyLowercaseVarsInput */,
viewType: "checked",
property: "prettyLowercaseVars" /* ModelPropID.prettyLowercaseVars */,
func: this.onCheckedChange,
controllerFunc: this.controller.fnPrettyLowercaseVars
},
{
id: "prettySpaceInput" /* ViewID.prettySpaceInput */,
viewType: "checked",
property: "prettySpace" /* ModelPropID.prettySpace */,
func: this.onCheckedChange
},
{
id: "selectDataFilesInput" /* ViewID.selectDataFilesInput */,
viewType: "checked",
property: "selectDataFiles" /* ModelPropID.selectDataFiles */,
func: this.onCheckedChange
},
{
id: "showConsoleLogInput" /* ViewID.showConsoleLogInput */,
viewType: "checked",
toggleId: "consoleLogArea" /* ViewID.consoleLogArea */,
property: "showConsoleLog" /* ModelPropID.showConsoleLog */,
func: this.toggleAreaHidden
},
{
id: "showCpcInput" /* ViewID.showCpcInput */,
viewType: "checked",
toggleId: "cpcArea" /* ViewID.cpcArea */,
property: "showCpc" /* ModelPropID.showCpc */,
func: this.onShowCpcInputChange
},
{
id: "showDisassInput" /* ViewID.showDisassInput */,
viewType: "checked",
toggleId: "disassArea" /* ViewID.disassArea */,
property: "showDisass" /* ModelPropID.showDisass */,
func: this.toggleAreaHidden
},
{
id: "showInp2Input" /* ViewID.showInp2Input */,
viewType: "checked",
toggleId: "inp2Area" /* ViewID.inp2Area */,
property: "showInp2" /* ModelPropID.showInp2 */,
func: this.toggleAreaHidden
},
{
id: "showInputInput" /* ViewID.showInputInput */,
viewType: "checked",
toggleId: "inputArea" /* ViewID.inputArea */,
property: "showInput" /* ModelPropID.showInput */,
func: this.toggleAreaHidden
},
{
id: "showKbdInput" /* ViewID.showKbdInput */,
viewType: "checked",
toggleId: "kbdArea" /* ViewID.kbdArea */,
property: "showKbd" /* ModelPropID.showKbd */,
func: this.onShowKbdInputChange
},
{
id: "showOutputInput" /* ViewID.showOutputInput */,
viewType: "checked",
toggleId: "outputArea" /* ViewID.outputArea */,
property: "showOutput" /* ModelPropID.showOutput */,
func: this.toggleAreaHidden
},
{
id: "showResultInput" /* ViewID.showResultInput */,
viewType: "checked",
toggleId: "resultArea" /* ViewID.resultArea */,
property: "showResult" /* ModelPropID.showResult */,
func: this.toggleAreaHidden
},
{
id: "showVariableInput" /* ViewID.showVariableInput */,
viewType: "checked",
toggleId: "variableArea" /* ViewID.variableArea */,
property: "showVariable" /* ModelPropID.showVariable */,
func: this.toggleAreaHidden
},
{
id: "soundInput" /* ViewID.soundInput */,
viewType: "checked",
property: "sound" /* ModelPropID.sound */,
func: this.onSoundInputChange
},
{
id: "speedInput" /* ViewID.speedInput */,
viewType: "numberInput",
property: "speed" /* ModelPropID.speed */,
func: this.onNumberInputChange,
controllerFunc: this.controller.fnSpeed
},
{
id: "traceInput" /* ViewID.traceInput */,
viewType: "checked",
property: "trace" /* ModelPropID.trace */,
func: this.onCheckedChange,
controllerFunc: this.controller.fnTrace
},
{
id: "varSelect" /* ViewID.varSelect */,
func: this.onVarSelectChange
},
{
id: "varText" /* ViewID.varText */,
controllerFunc: this.controller.changeVariable
}
]
};
for (const type in eventDefs) {
if (eventDefs.hasOwnProperty(type)) {
eventDefInternalMap[type] = {};
const eventDefList = eventDefs[type], itemForType = eventDefInternalMap[type];
for (let i = 0; i < eventDefList.length; i += 1) {
itemForType[eventDefList[i].id] = eventDefList[i];
}
}
}
}
handleEvent(event) {
const target = View.getEventTarget(event), type = event.type; // click or change
let id = (target) ? target.getAttribute("id") : String(target);
if (this.fnUserAction) {
this.fnUserAction(event, id);
}
if (id) {
if (target.disabled) { // check needed for IE which also fires for disabled buttons
return; // ignore
}
if (id.startsWith("galleryItem")) {
id = "galleryItem"; // replace galleryitem<num> by galleryitem
}
if (this.eventDefInternalMap[type] && this.eventDefInternalMap[type][id]) {
const eventDef = this.eventDefInternalMap[type][id];
if (Utils.debug) {
Utils.console.debug("handleEvent: " + type + ", " + id + ":", eventDef);
}
if (eventDef.func) {
eventDef.func.call(this, eventDef, event);
}
if (eventDef.controllerFunc) {
eventDef.controllerFunc.call(this.controller, eventDef, event);
}
}
else if (!id.endsWith("Select") && !id.endsWith("Input")) { // do not print all messages; these are usually handled by change
Utils.console.log("handleEvent: " + type + ", " + id + ": No handler");
}
}
else if (Utils.debug) {
Utils.console.log("handleEvent: " + type + ": unknown target:", target.tagName, target.id);
}
if (type === "click") { // special
if (id !== "cpcCanvas" /* ViewID.cpcCanvas */ && id !== "textText" /* ViewID.textText */) {
this.controller.onWindowClick(event);
}
}
}
}
/* eslint-disable array-element-newline */
const cpcCharset = [
[0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff], // 0x00
[0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0], // 0x01
[0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff], // 0x02
[0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff], // 0x03
[0x0c, 0x18, 0x30, 0x7e, 0x0c, 0x18, 0x30, 0x00], // 0x04
[0xff, 0xc3, 0xe7, 0xdb, 0xdb, 0xe7, 0xc3, 0xff], // 0x05
[0x00, 0x01, 0x03, 0x06, 0xcc, 0x78, 0x30, 0x00], // 0x06
[0x3c, 0x66, 0xc3, 0xc3, 0xff, 0x24, 0xe7, 0x00], // 0x07
[0x00, 0x00, 0x30, 0x60, 0xff, 0x60, 0x30, 0x00], // 0x08
[0x00, 0x00, 0x0c, 0x06, 0xff, 0x06, 0x0c, 0x00], // 0x09
[0x18, 0x18, 0x18, 0x18, 0xdb, 0x7e, 0x3c, 0x18], // 0x0a
[0x18, 0x3c, 0x7e, 0xdb, 0x18, 0x18, 0x18, 0x18], // 0x0b
[0x18, 0x5a, 0x3c, 0x99, 0xdb, 0x7e, 0x3c, 0x18], // 0x0c
[0x00, 0x03, 0x33, 0x63, 0xfe, 0x60, 0x30, 0x00], // 0x0d
[0x3c, 0x66, 0xff, 0xdb, 0xdb, 0xff, 0x66, 0x3c], // 0x0e
[0x3c, 0x66, 0xc3, 0xdb, 0xdb, 0xc3, 0x66, 0x3c], // 0x0f
[0xff, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xff], // 0x10
[0x3c, 0x7e, 0xdb, 0xdb, 0xdf, 0xc3, 0x66, 0x3c], // 0x11
[0x3c, 0x66, 0xc3, 0xdf, 0xdb, 0xdb, 0x7e, 0x3c], // 0x12
[0x3c, 0x66, 0xc3, 0xfb, 0xdb, 0xdb, 0x7e, 0x3c], // 0x13
[0x3c, 0x7e, 0xdb, 0xdb, 0xfb, 0xc3, 0x66, 0x3c], // 0x14
[0x00, 0x01, 0x33, 0x1e, 0xce, 0x7b, 0x31, 0x00], // 0x15
[0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xe7], // 0x16
[0x03, 0x03, 0x03, 0xff, 0x03, 0x03, 0x03, 0x00], // 0x17
[0xff, 0x66, 0x3c, 0x18, 0x18, 0x3c, 0x66, 0xff], // 0x18
[0x18, 0x18, 0x3c, 0x3c, 0x3c, 0x3c, 0x18, 0x18], // 0x19
[0x3c, 0x66, 0x66, 0x30, 0x18, 0x00, 0x18, 0x00], // 0x1a
[0x3c, 0x66, 0xc3, 0xff, 0xc3, 0xc3, 0x66, 0x3c], // 0x1b
[0xff, 0xdb, 0xdb, 0xdb, 0xfb, 0xc3, 0xc3, 0xff], // 0x1c
[0xff, 0xc3, 0xc3, 0xfb, 0xdb, 0xdb, 0xdb, 0xff], // 0x1d
[0xff, 0xc3, 0xc3, 0xdf, 0xdb, 0xdb, 0xdb, 0xff], // 0x1e
[0xff, 0xdb, 0xdb, 0xdb, 0xdf, 0xc3, 0xc3, 0xff], // 0x1f
[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x20
[0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00], // 0x21
[0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x22
[0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00], // 0x23
[0x18, 0x3e, 0x58, 0x3c, 0x1a, 0x7c, 0x18, 0x00], // 0x24
[0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00], // 0x25
[0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00], // 0x26
[0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x27
[0x0c, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00], // 0x28
[0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00], // 0x29
[0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00], // 0x2a
[0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00], // 0x2b
[0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30], // 0x2c
[0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00], // 0x2d
[0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00], // 0x2e
[0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00], // 0x2f
[0x7c, 0xc6, 0xce, 0xd6, 0xe6, 0xc6, 0x7c, 0x00], // 0x30
[0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00], // 0x31
[0x3c, 0x66, 0x06, 0x3c, 0x60, 0x66, 0x7e, 0x00], // 0x32
[0x3c, 0x66, 0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00], // 0x33
[0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00], // 0x34
[0x7e, 0x62, 0x60, 0x7c, 0x06, 0x66, 0x3c, 0x00], // 0x35
[0x3c, 0x66, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00], // 0x36
[0x7e, 0x66, 0x06, 0x0c, 0x18, 0x18, 0x18, 0x00], // 0x37
[0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00], // 0x38
[0x3c, 0x66, 0x66, 0x3e, 0x06, 0x66, 0x3c, 0x00], // 0x39
[0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00], // 0x3a
[0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30], // 0x3b
[0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x00], // 0x3c
[0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00], // 0x3d
[0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00], // 0x3e
[0x3c, 0x66, 0x66, 0x0c, 0x18, 0x00, 0x18, 0x00], // 0x3f
[0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x7c, 0x00], // 0x40
[0x18, 0x3c, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x00], // 0x41
[0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00], // 0x42
[0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00], // 0x43
[0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00], // 0x44
[0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00], // 0x45
[0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00], // 0x46
[0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00], // 0x47
[0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00], // 0x48
[0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00], // 0x49
[0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00], // 0x4a
[0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00], // 0x4b
[0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00], // 0x4c
[0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00], // 0x4d
[0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00], // 0x4e
[0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00], // 0x4f
[0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00], // 0x50
[0x38, 0x6c, 0xc6, 0xc6, 0xda, 0xcc, 0x76, 0x00], // 0x51
[0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00], // 0x52
[0x3c, 0x66, 0x60, 0x3c, 0x06, 0x66, 0x3c, 0x00], // 0x53
[0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00], // 0x54
[0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00], // 0x55
[0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00], // 0x56
[0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00], // 0x57
[0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0xc6, 0x00], // 0x58
[0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x3c, 0x00], // 0x59
[0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00], // 0x5a
[0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00], // 0x5b
[0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00], // 0x5c
[0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00], // 0x5d
[0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00], // 0x5e
[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff], // 0x5f
[0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x60
[0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00], // 0x61
[0xe0, 0x60, 0x7c, 0x66, 0x66, 0x66, 0xdc, 0x00], // 0x62
[0x00, 0x00, 0x3c, 0x66, 0x60, 0x66, 0x3c, 0x00], // 0x63
[0x1c, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00], // 0x64
[0x00, 0x00, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00], // 0x65
[0x1c, 0x36, 0x30, 0x78, 0x30, 0x30, 0x78, 0x00], // 0x66
[0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x7c], // 0x67
[0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00], // 0x68
[0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00], // 0x69
[0x06, 0x00, 0x0e, 0x06, 0x06, 0x66, 0x66, 0x3c], // 0x6a
[0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00], // 0x6b
[0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00], // 0x6c
[0x00, 0x00, 0x6c, 0xfe, 0xd6, 0xd6, 0xc6, 0x00], // 0x6d
[0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x00], // 0x6e
[0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00], // 0x6f
[0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0], // 0x70
[0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e], // 0x71
[0x00, 0x00, 0xdc, 0x76, 0x60, 0x60, 0xf0, 0x00], // 0x72
[0x00, 0x00, 0x3c, 0x60, 0x3c, 0x06, 0x7c, 0x00], // 0x73
[0x30, 0x30, 0x7c, 0x30, 0x30, 0x36, 0x1c, 0x00], // 0x74
[0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00], // 0x75
[0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00], // 0x76
[0x00, 0x00, 0xc6, 0xd6, 0xd6, 0xfe, 0x6c, 0x00], // 0x77
[0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00], // 0x78
[0x00, 0x00, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x7c], // 0x79
[0x00, 0x00, 0x7e, 0x4c, 0x18, 0x32, 0x7e, 0x00], // 0x7a
[0x0e, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0e, 0x00], // 0x7b
[0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // 0x7c
[0x70, 0x18, 0x18, 0x0e, 0x18, 0x18, 0x70, 0x00], // 0x7d
[0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x7e
[0xcc, 0x33, 0xcc, 0x33, 0xcc, 0x33, 0xcc, 0x33], // 0x7f
[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x80
[0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00], // 0x81
[0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00], // 0x82
[0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00], // 0x83
[0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0], // 0x84
[0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0], // 0x85
[0x0f, 0x0f, 0x0f, 0x0f, 0xf0, 0xf0, 0xf0, 0xf0], // 0x86
[0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0], // 0x87
[0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f], // 0x88
[0xf0, 0xf0, 0xf0, 0xf0, 0x0f, 0x0f, 0x0f, 0x0f], // 0x89
[0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f], // 0x8a
[0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f], // 0x8b
[0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff], // 0x8c
[0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff], // 0x8d
[0x0f, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff], // 0x8e
[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff], // 0x8f
[0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00], // 0x90
[0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00], // 0x91
[0x00, 0x00, 0x00, 0x1f, 0x1f, 0x00, 0x00, 0x00], // 0x92
[0x18, 0x18, 0x18, 0x1f, 0x0f, 0x00, 0x00, 0x00], // 0x93
[0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18], // 0x94
[0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18], // 0x95
[0x00, 0x00, 0x00, 0x0f, 0x1f, 0x18, 0x18, 0x18], // 0x96
[0x18, 0x18, 0x18, 0x1f, 0x1f, 0x18, 0x18, 0x18], // 0x97
[0x00, 0x00, 0x00, 0xf8, 0xf8, 0x00, 0x00, 0x00], // 0x98
[0x18, 0x18, 0x18, 0xf8, 0xf0, 0x00, 0x00, 0x00], // 0x99
[0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00], // 0x9a
[0x18, 0x18, 0x18, 0xff, 0xff, 0x00, 0x00, 0x00], // 0x9b
[0x00, 0x00, 0x00, 0xf0, 0xf8, 0x18, 0x18, 0x18], // 0x9c
[0x18, 0x18, 0x18, 0xf8, 0xf8, 0x18, 0x18, 0x18], // 0x9d
[0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x18, 0x18], // 0x9e
[0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18], // 0x9f
[0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00], // 0xa0
[0x0c, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00], // 0xa1
[0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0xa2
[0x3c, 0x66, 0x60, 0xf8, 0x60, 0x66, 0xfe, 0x00], // 0xa3
[0x38, 0x44, 0xba, 0xa2, 0xba, 0x44, 0x38, 0x00], // 0xa4
[0x7e, 0xf4, 0xf4, 0x74, 0x34, 0x34, 0x34, 0x00], // 0xa5
[0x1e, 0x30, 0x38, 0x6c, 0x38, 0x18, 0xf0, 0x00], // 0xa6
[0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00], // 0xa7
[0x40, 0xc0, 0x44, 0x4c, 0x54, 0x1e, 0x04, 0x00], // 0xa8
[0x40, 0xc0, 0x4c, 0x52, 0x44, 0x08, 0x1e, 0x00], // 0xa9
[0xe0, 0x10, 0x62, 0x16, 0xea, 0x0f, 0x02, 0x00], // 0xaa
[0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x7e, 0x00], // 0xab
[0x18, 0x18, 0x00, 0x7e, 0x00, 0x18, 0x18, 0x00], // 0xac
[0x00, 0x00, 0x00, 0x7e, 0x06, 0x06, 0x00, 0x00], // 0xad
[0x18, 0x00, 0x18, 0x30, 0x66, 0x66, 0x3c, 0x00], // 0xae
[0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // 0xaf
[0x00, 0x00, 0x73, 0xde, 0xcc, 0xde, 0x73, 0x00], // 0xb0
[0x7c, 0xc6, 0xc6, 0xfc, 0xc6, 0xc6, 0xf8, 0xc0], // 0xb1
[0x00, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00], // 0xb2
[0x3c, 0x60, 0x60, 0x3c, 0x66, 0x66, 0x3c, 0x00], // 0xb3
[0x00, 0x00, 0x1e, 0x30, 0x7c, 0x30, 0x1e, 0x00], // 0xb4
[0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0x6c, 0x38, 0x00], // 0xb5
[0x00, 0xc0, 0x60, 0x30, 0x38, 0x6c, 0xc6, 0x00], // 0xb6
[0x00, 0x00, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60], // 0xb7
[0x00, 0x00, 0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x00], // 0xb8
[0x00, 0x00, 0x00, 0x7e, 0xd8, 0xd8, 0x70, 0x00], // 0xb9
[0x03, 0x06, 0x0c, 0x3c, 0x66, 0x3c, 0x60, 0xc0], // 0xba
[0x03, 0x06, 0x0c, 0x66, 0x66, 0x3c, 0x60, 0xc0], // 0xbb
[0x00, 0xe6, 0x3c, 0x18, 0x38, 0x6c, 0xc7, 0x00], // 0xbc
[0x00, 0x00, 0x66, 0xc3, 0xdb, 0xdb, 0x7e, 0x00], // 0xbd
[0xfe, 0xc6, 0x60, 0x30, 0x60, 0xc6, 0xfe, 0x00], // 0xbe
[0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x6c, 0xee, 0x00], // 0xbf
[0x18, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x00], // 0xc0
[0x18, 0x0c, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00], // 0xc1
[0x00, 0x00, 0x00, 0x01, 0x03, 0x06, 0x0c, 0x18], // 0xc2
[0x00, 0x00, 0x00, 0x80, 0xc0, 0x60, 0x30, 0x18], // 0xc3
[0x18, 0x3c, 0x66, 0xc3, 0x81, 0x00, 0x00, 0x00], // 0xc4
[0x18, 0x0c, 0x06, 0x03, 0x03, 0x06, 0x0c, 0x18], // 0xc5
[0x00, 0x00, 0x00, 0x81, 0xc3, 0x66, 0x3c, 0x18], // 0xc6
[0x18, 0x30, 0x60, 0xc0, 0xc0, 0x60, 0x30, 0x18], // 0xc7
[0x18, 0x30, 0x60, 0xc1, 0x83, 0x06, 0x0c, 0x18], // 0xc8
[0x18, 0x0c, 0x06, 0x83, 0xc1, 0x60, 0x30, 0x18], // 0xc9
[0x18, 0x3c, 0x66, 0xc3, 0xc3, 0x66, 0x3c, 0x18], // 0xca
[0xc3, 0xe7, 0x7e, 0x3c, 0x3c, 0x7e, 0xe7, 0xc3], // 0xcb
[0x03, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xc0], // 0xcc
[0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x07, 0x03], // 0xcd
[0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0x33, 0x33], // 0xce
[0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55], // 0xcf
[0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0xd0
[0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03], // 0xd1
[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff], // 0xd2
[0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0], // 0xd3
[0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80], // 0xd4
[0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01], // 0xd5
[0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff], // 0xd6
[0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff], // 0xd7
[0xaa, 0x55, 0xaa, 0x55, 0x00, 0x00, 0x00, 0x00], // 0xd8
[0x0a, 0x05, 0x0a, 0x05, 0x0a, 0x05, 0x0a, 0x05], // 0xd9
[0x00, 0x00, 0x00, 0x00, 0xaa, 0x55, 0xaa, 0x55], // 0xda
[0xa0, 0x50, 0xa0, 0x50, 0xa0, 0x50, 0xa0, 0x50], // 0xdb
[0xaa, 0x54, 0xa8, 0x50, 0xa0, 0x40, 0x80, 0x00], // 0xdc
[0xaa, 0x55, 0x2a, 0x15, 0x0a, 0x05, 0x02, 0x01], // 0xdd
[0x01, 0x02, 0x05, 0x0a, 0x15, 0x2a, 0x55, 0xaa], // 0xde
[0x00, 0x80, 0x40, 0xa0, 0x50, 0xa8, 0x54, 0xaa], // 0xdf
[0x7e, 0xff, 0x99, 0xff, 0xbd, 0xc3, 0xff, 0x7e], // 0xe0
[0x7e, 0xff, 0x99, 0xff, 0xc3, 0xbd, 0xff, 0x7e], // 0xe1
[0x38, 0x38, 0xfe, 0xfe, 0xfe, 0x10, 0x38, 0x00], // 0xe2
[0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00], // 0xe3
[0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00], // 0xe4
[0x10, 0x38, 0x7c, 0xfe, 0xfe, 0x10, 0x38, 0x00], // 0xe5
[0x00, 0x3c, 0x66, 0xc3, 0xc3, 0x66, 0x3c, 0x00], // 0xe6
[0x00, 0x3c, 0x7e, 0xff, 0xff, 0x7e, 0x3c, 0x00], // 0xe7
[0x00, 0x7e, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00], // 0xe8
[0x00, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x00], // 0xe9
[0x0f, 0x07, 0x0d, 0x78, 0xcc, 0xcc, 0xcc, 0x78], // 0xea
[0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18], // 0xeb
[0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x7c, 0x38], // 0xec
[0x18, 0x1c, 0x1e, 0x1b, 0x18, 0x78, 0xf8, 0x70], // 0xed
[0x99, 0x5a, 0x24, 0xc3, 0xc3, 0x24, 0x5a, 0x99], // 0xee
[0x10, 0x38, 0x38, 0x38, 0x38, 0x38, 0x7c, 0xd6], // 0xef
[0x18, 0x3c, 0x7e, 0xff, 0x18, 0x18, 0x18, 0x18], // 0xf0
[0x18, 0x18, 0x18, 0x18, 0xff, 0x7e, 0x3c, 0x18], // 0xf1
[0x10, 0x30, 0x70, 0xff, 0xff, 0x70, 0x30, 0x10], // 0xf2
[0x08, 0x0c, 0x0e, 0xff, 0xff, 0x0e, 0x0c, 0x08], // 0xf3
[0x00, 0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00], // 0xf4
[0x00, 0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00], // 0xf5
[0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00], // 0xf6
[0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00], // 0xf7
[0x38, 0x38, 0x92, 0x7c, 0x10, 0x28, 0x28, 0x28], // 0xf8
[0x38, 0x38, 0x10, 0xfe, 0x10, 0x28, 0x44, 0x82], // 0xf9
[0x38, 0x38, 0x12, 0x7c, 0x90, 0x28, 0x24, 0x22], // 0xfa
[0x38, 0x38, 0x90, 0x7c, 0x12, 0x28, 0x48, 0x88], // 0xfb
[0x00, 0x3c, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x00], // 0xfc
[0x3c, 0xff, 0xff, 0x18, 0x0c, 0x18, 0x30, 0x18], // 0xfd
[0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18], // 0xfe
[0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00] //  0xff
];
/* eslint-enable array-element-newline */
class Random {
x;
constructor(seed) {
this.init(seed);
}
init(seed) {
this.x = seed || 1; // do not use 0
}
random() {
const m = 2147483647, // prime number 2^31-1; modulus, do not change!
a = 16807, // 7^5, one primitive root; multiplier
q = 127773, // m div a
r = 2836; // m mod a
let x = this.x; // last random value
x = a * (x % q) - r * ((x / q) | 0); // eslint-disable-line no-bitwise
if (x <= 0) {
x += m; // x is new random number
}
this.x = x;
return x / m;
}
}
class CpcVmRsx {
rsxPermanent = {};
rsxTemporary = {};
callRsx(vm, name, ...args) {
const fn = this.rsxTemporary[name] || this.rsxPermanent[name];
if (fn) {
fn.apply(vm, args);
}
return Boolean(fn);
}
registerRsx(rsxModule, permanent) {
const rsxRegister = permanent ? this.rsxPermanent : this.rsxTemporary, rsxCommands = rsxModule.getRsxCommands();
for (const command in rsxCommands) {
if (rsxCommands.hasOwnProperty(command)) {
rsxRegister[command] = rsxCommands[command];
}
}
}
resetRsx() {
this.rsxTemporary = {};
}
}
class CpcVm {
options;
quiet = false;
onClickKey;
fnOpeninHandler; // = undefined;
fnCloseinHandler;
fnCloseoutHandler;
fnLoadHandler;
fnRunHandler;
fnOnCanvasClickHandler;
fnInputCallbackHandler;
fnLineInputCallbackHandler;
fnRandomizeCallbackHandler;
canvas;
keyboard;
soundClass;
variables;
random;
stopEntry;
inputValues; // values to input into script
inFile; // file handling
outFile; // file handling
inkeyTimeMs = 0; // next time of frame fly (if >0, next time when inkey$ can be checked without inserting "waitFrame")
gosubStack = []; // stack of line numbers for gosub/return
maxGosubStackLength = 83; // maximum nesting of GOSUB on a real CPC
mem; // for peek, poke
dataList; // array for BASIC data lines (continuous)
dataIndex = 0; // current index
dataLineIndex = {
0: 0 // for line 0: index 0
};
labelList; // for resume next
sourceMap = {};
windowDataList; // window data for window 0..7,8,9
timerList; // BASIC timer 0..3 (3 has highest priority)
sqTimer; // Sound queue timer 0..2
soundData;
crtcData;
crtcReg = 0;
printControlBuf = "";
startTime = 0;
lastRnd = 0; // last random number
nextFrameTime = 0;
initialStop = 5;
stopCount = 0;
line = 0;
startLine = 0;
errorGotoLine = 0;
errorResumeLine = 0;
breakGosubLine = 0;
breakResumeLine = 0;
outBuffer = "";
errorCode = 0; // last error code (Err)
errorLine = 0; // line of last error (Erl)
degFlag = false; // degree or radians
tronFlag1 = false; // trace flag
ramSelect = 0;
screenPage = 3; // 16K screen page, 3=0xc000..0xffff
minCharHimem = CpcVm.maxHimem;
maxCharHimem = CpcVm.maxHimem;
himemValue = CpcVm.maxHimem;
minCustomChar = 256;
timerPriority = -1; // priority of running task: -1=low (min priority to start new timers)
zoneValue = 13; // print tab zone value
modeValue = -1;
progEnd = CpcVm.progStart + 3; // initially 370
rsx = new CpcVmRsx();
static frameTimeMs = 1000 / 50; // 50 Hz => 20 ms
static timerCount = 4; // number of timers
static sqTimerCount = 3; // sound queue timers
static streamCount = 10; // 0..7 window, 8 printer, 9 cassette
static progStart = 367;
static maxHimem = 42747; // high memory limit (42747 after symbol after 256)
static emptyParas = {};
static modeData = [
{
pens: 16 // number of pens (see also Canvas: modeData)
},
{
pens: 4
},
{
pens: 2
},
{
pens: 16
}
];
static winData = [
{
left: 0,
right: 19,
top: 0,
bottom: 24
},
{
left: 0,
right: 39,
top: 0,
bottom: 24
},
{
left: 0,
right: 79,
top: 0,
bottom: 24
},
{
left: 0, // mode 3 not available on CPC
right: 79,
top: 0,
bottom: 49
}
];
static utf8ToCpc = {
8364: 128,
8218: 130,
402: 131,
8222: 132,
8230: 133,
8224: 134,
8225: 135,
710: 136,
8240: 137,
352: 138,
8249: 139,
338: 140,
381: 142,
8216: 145,
8217: 146,
8220: 147,
8221: 148,
8226: 149,
8211: 150,
8212: 151,
732: 152,
8482: 153,
353: 154,
8250: 155,
339: 156,
382: 158,
376: 159
};
static controlCodeParameterCount = [
0, // 0x00
1, // 0x01
0, // 0x02
0, // 0x03
1, // 0x04
1, // 0x05
0, // 0x06
0, // 0x07
0, // 0x08
0, // 0x09
0, // 0x0a
0, // 0x0b
0, // 0x0c
0, // 0x0d
1, // 0x0e
1, // 0x0f
0, // 0x10
0, // 0x11
0, // 0x12
0, // 0x13
0, // 0x14
0, // 0x15
1, // 0x16
1, // 0x17
0, // 0x18
9, // 0x19
4, // 0x1a
0, // 0x1b
3, // 0x1c
2, // 0x1d
0, // 0x1e
2 //  0x1f
];
static errors = [
"Improper argument", // 0
"Unexpected NEXT", // 1
"Syntax Error", // 2
"Unexpected RETURN", // 3
"DATA exhausted", // 4
"Improper argument", // 5
"Overflow", // 6
"Memory full", // 7
"Line does not exist", // 8
"Subscript out of range", // 9
"Array already dimensioned", // 10
"Division by zero", // 11
"Invalid direct command", // 12
"Type mismatch", // 13
"String space full", // 14
"String too long", // 15
"String expression too complex", // 16
"Cannot CONTinue", // 17
"Unknown user function", // 18
"RESUME missing", // 19
"Unexpected RESUME", // 20
"Direct command found", // 21
"Operand missing", // 22
"Line too long", // 23
"EOF met", // 24
"File type error", // 25
"NEXT missing", // 26
"File already open", // 27
"Unknown command", // 28
"WEND missing", // 29
"Unexpected WEND", // 30
"File not open", // 31,
"Broken", // 32 "Broken in" (derr=146: xxx not found)
"Unknown error" // 33...
];
static stopPriority = {
"": 0, // nothing
direct: 0, // direct input mode
timer: 20, // timer expired
waitFrame: 40, // FRAME command: wait for frame fly
waitKey: 41, // wait for key (higher priority that waitFrame)
waitSound: 43, // wait for sound queue
waitInput: 45, // wait for input: INPUT, LINE INPUT, RANDOMIZE without parameter
fileCat: 45, // CAT
fileDir: 45, // |DIR
fileEra: 45, // |ERA
fileRen: 45, // |REN
error: 50, // BASIC error, ERROR command
onError: 50, // ON ERROR GOTO active, hide error
stop: 60, // STOP or END command
"break": 80, // break pressed
escape: 85, // escape key, set in controller
renumLines: 85, // RENUMber program
deleteLines: 85, // delete lines
editLine: 85, // edit line
end: 90, // end of program
list: 90, // LIST program
fileLoad: 90, // CHAIN, CHAIN MERGE, LOAD, MERGE, OPENIN, RUN
fileSave: 90, // OPENOUT, SAVE
"new": 90, // NEW, remove program, variables
run: 95,
parse: 95, // set in controller
parseRun: 95, // parse and run, used in controller
reset: 99 // reset system
};
constructor(options) {
this.fnOpeninHandler = this.vmOpeninCallback.bind(this);
this.fnCloseinHandler = this.vmCloseinCallback.bind(this);
this.fnCloseoutHandler = this.vmCloseoutCallback.bind(this);
this.fnLoadHandler = this.vmLoadCallback.bind(this);
this.fnRunHandler = this.vmRunCallback.bind(this);
this.fnOnCanvasClickHandler = this.onCanvasClickCallback.bind(this);
this.fnInputCallbackHandler = this.vmInputCallback.bind(this);
this.fnLineInputCallbackHandler = this.vmLineInputCallback.bind(this);
this.fnRandomizeCallbackHandler = this.vmRandomizeCallback.bind(this);
this.options = {};
this.setOptions(options);
this.canvas = this.setCanvas(options.canvas);
this.keyboard = options.keyboard;
this.soundClass = options.sound;
this.variables = options.variables;
this.quiet = Boolean(options.quiet);
this.onClickKey = options.onClickKey;
this.random = new Random();
this.stopCount = this.initialStop;
this.stopEntry = {
reason: "", // stop reason
priority: 0, // stop priority (higher number means higher priority which can overwrite lower priority)
paras: {}
};
this.inputValues = []; // values to input into script
this.inFile = {
open: false,
command: "",
name: "",
line: 0,
start: undefined,
fileData: [],
fnFileCallback: undefined,
first: 0,
last: 0,
memorizedExample: ""
};
this.outFile = {
open: false,
command: "",
name: "",
line: 0,
start: 0,
fileData: [],
fnFileCallback: undefined,
stream: 0,
typeString: "",
length: 0,
entry: 0
}; // file handling
this.gosubStack = []; // stack of line numbers for gosub/return
this.mem = []; // for peek, poke
this.dataList = []; // array for BASIC data lines (continuous)
this.labelList = [];
this.windowDataList = []; // window data for window 0..7,8,9
for (let i = 0; i < CpcVm.streamCount; i += 1) {
this.windowDataList[i] = {};
}
this.timerList = []; // BASIC timer 0..3 (3 has highest priority)
for (let i = 0; i < CpcVm.timerCount; i += 1) {
this.timerList[i] = {};
}
this.soundData = [];
this.sqTimer = []; // Sound queue timer 0..2
for (let i = 0; i < CpcVm.sqTimerCount; i += 1) {
this.sqTimer[i] = {};
}
this.crtcData = [];
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
vmReset() {
this.startTime = Date.now();
this.vmResetRandom();
this.nextFrameTime = Date.now() + CpcVm.frameTimeMs; // next time of frame fly
this.stopCount = this.initialStop;
this.line = 0; // current line number (or label)
this.startLine = 0; // line to start
this.errorGotoLine = 0;
this.errorResumeLine = 0;
this.breakGosubLine = 0;
this.breakResumeLine = 0;
this.inputValues.length = 0;
this.vmResetInFileHandling();
this.vmResetControlBuffer();
this.outBuffer = ""; // console output
this.vmStop("", 0, true);
this.vmResetData();
this.errorCode = 0; // last error code
this.errorLine = 0; // line of last error
this.gosubStack.length = 0;
this.degFlag = false; // degree or radians
this.tronFlag1 = false;
this.screenPage = 3; // 16K screen page, 3=0xc000..0xffff
this.crtcReg = 0;
this.crtcData.length = 0;
this.vmResetMemory();
this.symbolAfter(240); // set also minCustomChar
this.vmResetTimers();
this.timerPriority = -1; // priority of running task: -1=low (min priority to start new timers)
this.zoneValue = 13; // print tab zone value
this.defreal("a", "z"); // init vartypes
this.vmResetPenPaperWindowData();
this.mode(1); // including vmResetWindowData() without pen and paper
this.canvas.reset();
this.keyboard.reset();
this.soundClass.reset();
this.soundData.length = 0;
this.inkeyTimeMs = 0; // if >0, next time when inkey$ can be checked without inserting "waitFrame"
this.rsx.resetRsx(); // remove temporary rsx
}
vmResetMemory() {
this.mem.length = 0; // clear memory (for PEEK, POKE)
this.ramSelect = 0; // for banking with 16K banks in the range 0x4000-0x7fff (0=default; 1...=additional)
this.minCharHimem = CpcVm.maxHimem;
this.maxCharHimem = CpcVm.maxHimem;
this.himemValue = CpcVm.maxHimem;
this.minCustomChar = 256;
this.progEnd = CpcVm.progStart + 3;
}
vmResetRandom() {
this.random.init();
this.lastRnd = 0;
}
vmResetTimers() {
const data = {
line: 0, // gosub line when timer expires
repeat: false, // flag if timer is repeating (every) or one time (after)
intervalMs: 0, // interval or timeout
active: false, // flag if timer is active
nextTimeMs: 0, // next expiration time
handlerRunning: false, // flag if handler (subroutine) is running
stackIndexReturn: 0, // index in gosub stack with return, if handler is running
savedPriority: 0 // priority befora calling the handler
}, timer = this.timerList, sqTimer = this.sqTimer;
for (let i = 0; i < CpcVm.timerCount; i += 1) {
Object.assign(timer[i], data);
}
for (let i = 0; i < CpcVm.sqTimerCount; i += 1) {
Object.assign(sqTimer[i], data);
}
}
vmResetPenPaperWindowData() {
const penPaperData = {
pen: 1,
paper: 0
}, windowDataList = this.windowDataList;
for (let i = 0; i < windowDataList.length - 2; i += 1) { // for window streams
Object.assign(windowDataList[i], penPaperData);
}
}
vmResetWindowData(resetPenPaper) {
if (resetPenPaper) {
this.vmResetPenPaperWindowData();
}
const data = {
pos: 0, // current text position in line
vpos: 0,
textEnabled: true, // text enabled
tag: false, // tag=text at graphics
transparent: false, // transparent mode
cursorOn: false, // system switch
cursorEnabled: true // user switch
}, printData = {
pos: 0,
vpos: 0,
right: 132 // override
}, cassetteData = {
pos: 0,
vpos: 0,
right: 255 // override
}, winData = CpcVm.winData[this.modeValue], windowDataList = this.windowDataList, modeDataPens = CpcVm.modeData[this.modeValue].pens;
for (let i = 0; i < windowDataList.length - 2; i += 1) { // for window streams
const modeWinData = Object.assign(windowDataList[i], winData, data);
modeWinData.pen %= modeDataPens;
modeWinData.paper %= modeDataPens; // limit also paper to number of pens
}
Object.assign(windowDataList[8], winData, printData); // printer
Object.assign(windowDataList[9], winData, cassetteData); // cassette
}
vmResetControlBuffer() {
this.printControlBuf = ""; // collected control characters for PRINT
}
static vmResetFileHandling(file) {
file.open = false;
file.command = ""; // to be sure
file.name = "";
file.line = 0;
file.start = undefined; // to be sure
file.fileData.length = 0;
}
vmResetInFileHandling() {
const inFile = this.inFile;
CpcVm.vmResetFileHandling(inFile);
inFile.first = 0;
inFile.last = 0;
}
vmResetOutFileHandling() {
const outFile = this.outFile;
CpcVm.vmResetFileHandling(outFile);
outFile.stream = 0;
outFile.typeString = "";
outFile.length = 0;
outFile.entry = 0;
}
vmResetData() {
this.dataList.length = 0; // array for BASIC data lines (continuous)
this.dataIndex = 0; // current index
this.dataLineIndex = {
0: 0 // for line 0: index 0
};
}
vmResetInks() {
this.canvas.setDefaultInks();
this.canvas.setSpeedInk(10, 10);
}
vmReset4Run() {
const stream = 0;
this.clearInput();
this.closein();
this.closeout();
this.cursor(stream, 0);
this.labelList.length = 0;
this.gosubStack.length = 0;
this.restore(); // restore data line index
this.errorGotoLine = 0;
this.errorResumeLine = 0;
this.soundClass.resetQueue();
this.soundData.length = 0;
}
vmPutProgramInMem(tokens) {
const addr = CpcVm.progStart + 1, // 368=0x170
tokensLen = addr + tokens.length > 0xffff ? 0xffff - addr : tokens.length; // prevent overflow
this.progEnd = addr + tokensLen;
for (let i = 0; i < tokensLen; i += 1) {
const code = CpcVm.vmGetCharCodeAt(tokens, i);
this.poke(addr + i, code);
}
if (tokensLen < tokens.length) {
if (!this.quiet) {
Utils.console.warn("vmPutProgramInMem: program too large (" + tokens.length + "), truncated by", tokens.length - tokensLen, "to fit in memory");
}
}
return tokensLen;
}
setCanvas(canvas) {
this.canvas = canvas;
if (this.canvas) {
this.canvas.setOptions({
onCanvasClick: this.fnOnCanvasClickHandler
});
}
return canvas;
}
vmGetLoadHandler() {
return this.fnLoadHandler;
}
vmGetMem() {
return this.mem;
}
onCanvasClickCallback(event, x, y, xTxt, yTxt) {
const height = 400;
let char = -1;
x -= this.canvas.getXOrigin();
y = height - 1 - (y + this.canvas.getYOrigin());
if (this.canvas.getXpos() === 1000 && this.canvas.getYpos() === 1000) { // only activate move if pos is 1000, 1000
this.canvas.move(x, y);
}
if (this.onClickKey) {
for (let stream = 0; stream < CpcVm.streamCount - 2; stream += 1) { // check all window streams
const win = this.windowDataList[stream];
char = this.canvas.readChar(xTxt, yTxt, win.pen, win.paper);
if (char > 0 && char !== 32) {
break; // found some char
}
}
if ((char < 0 || char === 32 || char === 143) && event.detail === 2) { // no (useful) char but mouse double click?
char = 13; // use CR
}
if (char >= 0) { // call click handler (put char in keyboard input buffer)
this.onClickKey(String.fromCharCode(char));
}
}
if (Utils.debug > 0) {
Utils.console.debug("onCanvasClickCallback: x", x, "y", y, "xTxt", xTxt, "yTxt", yTxt, "char", char);
}
}
vmRegisterRsx(rsxModule, permanent) {
this.rsx.registerRsx(rsxModule, permanent);
}
vmGetAllVariables() {
return this.variables.getAllVariables();
}
vmGetAllVarTypes() {
return this.variables.getAllVarTypes();
}
vmGetVariableByIndex(index) {
return this.variables.getVariableByIndex(index);
}
vmSetStartLine(line) {
this.startLine = line;
}
vmSetLabels(labels) {
this.labelList.length = 0;
Object.assign(this.labelList, labels);
}
vmOnBreakContSet() {
return this.breakGosubLine < 0; // on break cont
}
vmOnBreakHandlerActive() {
return Boolean(this.breakResumeLine);
}
vmEscape() {
let stop = true;
if (this.breakGosubLine > 0) { // on break gosub n
if (!this.breakResumeLine) { // do not nest break gosub
this.breakResumeLine = Number(this.line);
this.vmGosub(this.line, this.breakGosubLine);
}
stop = false;
}
else if (this.breakGosubLine < 0) { // on break cont
stop = false;
} // else: on break stop
return stop;
}
vmAssertNumber(n, err) {
if (typeof n !== "number") {
throw this.vmComposeError(Error(), 13, err + " " + n); // Type mismatch
}
}
vmAssertString(s, err) {
if (typeof s !== "string") {
throw this.vmComposeError(Error(), 13, err + " " + s); // Type mismatch
}
}
vmAssertInRange(n, min, max, err) {
this.vmAssertNumber(n, err);
if (n < min || n > max) {
if (!this.quiet) {
Utils.console.warn("vmAssertInRange: number not in range:", min + "<=" + n + "<=" + max);
}
throw this.vmComposeError(Error(), 5, err + " " + n); // 5=Improper argument
}
return n;
}
vmRound(n, err) {
this.vmAssertNumber(n, err || "?");
return (n >= 0) ? (n + 0.5) | 0 : (n - 0.5) | 0; // eslint-disable-line no-bitwise
}
vmInRangeRound(n, min, max, err) {
n = this.vmRound(n, err);
if (n < min || n > max) {
if (!this.quiet) {
Utils.console.warn("vmInRangeRound: number not in range:", min + "<=" + n + "<=" + max);
}
throw this.vmComposeError(Error(), n < -32768 || n > 32767 ? 6 : 5, err + " " + n); // 6=Overflow, 5=Improper argument
}
return n;
}
vmInRange16(n, err) {
const min = -32768, max = 32767;
if (n < min || n > max) {
if (!this.quiet) {
Utils.console.warn("vmInRange16: number not in range:", min + "<=" + n + "<=" + max);
}
throw this.vmComposeError(Error(), n < min || n > max ? 6 : 5, err + " " + n); // 6=Overflow, 5=Improper argument
}
return n;
}
vmLineInRange(n, err) {
const min = 1, max = 65535, num2 = this.vmRound(n, err);
if (n !== num2) { // fractional number? => integer expected
throw this.vmComposeError(Error(), 23, err + " " + n); // Line too long
}
if (n < min || n > max) {
if (!this.quiet) {
Utils.console.warn("vmLineInRange: number not in range:", min + "<=" + n + "<=" + max);
}
throw this.vmComposeError(Error(), 5, err + " " + n); // 5=Improper argument
}
return n;
}
vmRound2Complement(n, err) {
n = this.vmInRangeRound(n, -32768, 65535, err);
if (n < 0) { // undo two's complement
n += 65536;
}
return n;
}
vmGetLetterCode(s, err) {
this.vmAssertString(s, err);
s = s.toLowerCase();
if (s.length !== 1 || s < "a" || s > "z") { // single letter?
throw this.vmComposeError(Error(), 2, err + " " + s); // Syntax Error
}
return s.charCodeAt(0);
}
vmDetermineVarType(varType) {
return (varType.length > 1) ? varType.charAt(1) : this.variables.getVarType(varType.charAt(0));
}
vmAssertNumberType(varType) {
const type = this.vmDetermineVarType(varType);
if (type !== "I" && type !== "R") { // not integer or real?
throw this.vmComposeError(Error(), 13, "type " + type); // "Type mismatch"
}
}
vmAssign(varType, value) {
const type = this.vmDetermineVarType(varType);
if (type === "R") { // real
this.vmAssertNumber(value, "=");
}
else if (type === "I") { // integer
value = this.vmRound(value, "="); // round number to integer
}
else if (type === "$") { // string
if (typeof value !== "string") {
if (!this.quiet) {
Utils.console.warn("vmAssign: expected string but got:", value);
}
throw this.vmComposeError(Error(), 13, "type " + type + "=" + value); // "Type mismatch"
}
}
return value;
}
vmGoto(line, _msg) {
this.line = line;
}
fnCheckSqTimer() {
let timerExpired = false;
if (this.timerPriority < 2) {
for (let i = 0; i < CpcVm.sqTimerCount; i += 1) {
const timer = this.sqTimer[i];
if (timer.active && !timer.handlerRunning && (this.soundClass.sq(i) & 0x07)) { // eslint-disable-line no-bitwise
this.vmGosub(this.line, timer.line);
timer.handlerRunning = true;
timer.stackIndexReturn = this.gosubStack.length;
timer.repeat = false; // one shot
timerExpired = true;
break; // found expired timer
}
}
}
return timerExpired;
}
vmCheckTimer(time) {
let timerExpired = false;
for (let i = CpcVm.timerCount - 1; i > this.timerPriority; i -= 1) { // check timers starting with highest priority first
const timer = this.timerList[i];
if (timer.active && !timer.handlerRunning && time > timer.nextTimeMs) { // timer expired?
this.vmGosub(this.line, timer.line);
timer.handlerRunning = true;
timer.stackIndexReturn = this.gosubStack.length;
timer.savedPriority = this.timerPriority;
this.timerPriority = i;
if (!timer.repeat) { // not repeating
timer.active = false;
}
else {
const delta = time - timer.nextTimeMs;
timer.nextTimeMs += timer.intervalMs * Math.ceil(delta / timer.intervalMs);
}
timerExpired = true;
break; // found expired timer
}
else if (i === 2) { // for priority 2 we check the sq timers which also have priority 2
if (this.fnCheckSqTimer()) {
break; // found expired timer
}
}
}
return timerExpired;
}
vmCheckTimerHandlers() {
for (let i = CpcVm.timerCount - 1; i >= 0; i -= 1) {
const timer = this.timerList[i];
if (timer.handlerRunning) {
if (timer.stackIndexReturn > this.gosubStack.length) {
timer.handlerRunning = false;
this.timerPriority = timer.savedPriority; // restore priority
timer.stackIndexReturn = 0;
}
}
}
}
vmCheckSqTimerHandlers() {
let timerReloaded = false;
for (let i = CpcVm.sqTimerCount - 1; i >= 0; i -= 1) {
const timer = this.sqTimer[i];
if (timer.handlerRunning) {
if (timer.stackIndexReturn > this.gosubStack.length) {
timer.handlerRunning = false;
this.timerPriority = timer.savedPriority; // restore priority
timer.stackIndexReturn = 0;
if (!timer.repeat) { // not reloaded
timer.active = false;
}
else {
timerReloaded = true;
}
}
}
}
return timerReloaded;
}
vmCheckNextFrame(time) {
if (time >= this.nextFrameTime) { // next time of frame fly
const delta = time - this.nextFrameTime;
if (delta > CpcVm.frameTimeMs) {
this.nextFrameTime += CpcVm.frameTimeMs * Math.ceil(delta / CpcVm.frameTimeMs);
}
else {
this.nextFrameTime += CpcVm.frameTimeMs;
}
this.canvas.updateSpeedInk();
this.vmCheckTimer(time); // check BASIC timers and sound queue
this.soundClass.scheduler(); // on a real CPC it is 100 Hz, we use 50 Hz
}
}
vmGetTimeUntilFrame(time) {
time = time || Date.now();
return this.nextFrameTime - time;
}
vmLoopCondition() {
const time = Date.now();
if (time >= this.nextFrameTime) {
this.vmCheckNextFrame(time);
this.stopCount -= 1;
if (this.stopCount <= 0) { // do not stop too often because of just timer reason because setTimeout is expensive
this.stopCount = this.initialStop;
this.vmStop("timer", 20);
}
}
return this.stopEntry.reason === "";
}
vmDefineVarTypes(type, err, first, last) {
const firstNum = this.vmGetLetterCode(first, err), lastNum = last ? this.vmGetLetterCode(last, err) : firstNum;
for (let i = firstNum; i <= lastNum; i += 1) {
const varChar = String.fromCharCode(i);
this.variables.setVarType(varChar, type);
}
}
vmStop(reason, priority, force, paras) {
const defaultPriority = CpcVm.stopPriority[reason];
if (defaultPriority === undefined) {
Utils.console.warn("Programming error: vmStop: Unknown reason:", reason);
}
priority = priority || 0;
if (priority !== 0) {
priority = defaultPriority;
}
if (force || priority >= this.stopEntry.priority) {
this.stopEntry.priority = priority;
this.stopEntry.reason = reason;
this.stopEntry.paras = paras || CpcVm.emptyParas;
}
}
vmNotImplemented(name) {
if (Utils.debug > 0) {
Utils.console.debug("Not implemented:", name);
}
}
vmUsingStringFormat(format, arg) {
const padChar = " ", re1 = /^\\ *\\$/;
let str;
if (format === "&") {
str = arg;
}
else if (format === "!") {
str = arg.charAt(0);
}
else if (re1.test(format)) { // "\...\"
const padLen = format.length - arg.length, pad = (padLen > 0) ? padChar.repeat(padLen) : "";
str = arg + pad; // string left aligned
}
else { // no string format
throw this.vmComposeError(Error(), 13, "USING format " + format); // "Type mismatch"
}
return str;
}
vmUsingNumberFormat(format, arg) {
const padChar = " ", re1 = /^\\ *\\$/;
let str;
if (format === "&" || format === "!" || re1.test(format)) { // string format for number?
throw this.vmComposeError(Error(), 13, "USING format " + format); // "Type mismatch"
}
if (format.indexOf(".") < 0) { // no decimal point?
str = arg.toFixed(0);
}
else { // assume ###.##
const formatParts = format.split(".", 2), decimals = formatParts[1].length;
arg = Number(Math.round(Number(arg + "e" + decimals)) + "e-" + decimals);
str = arg.toFixed(decimals);
}
if (format.indexOf(",") >= 0) { // contains comma => insert thousands separator
str = Utils.numberWithCommas(str);
}
const padLen = format.length - str.length, pad = (padLen > 0) ? padChar.repeat(padLen) : "";
str = pad + str;
if (str.length > format.length) {
str = "%" + str; // mark too long
}
return str;
}
vmUsingFormat(format, arg) {
return typeof arg === "string" ? this.vmUsingStringFormat(format, arg) : this.vmUsingNumberFormat(format, arg);
}
vmGetStopObject() {
return this.stopEntry;
}
vmGetInFileObject() {
return this.inFile;
}
vmGetKeyboard() {
return this.keyboard;
}
vmGetOutFileObject() {
return this.outFile;
}
vmAdaptFilename(name, err) {
this.vmAssertString(name, err);
name = name.replace(/ /g, ""); // remove spaces
if (name[0] === "!") {
name = name.substring(1); // remove preceding "!"
}
const index = name.indexOf(":");
if (index >= 0) {
name = name.substring(index + 1); // remove user and drive letter including ":"
}
if (name.endsWith(".")) {
name = name.substring(0, name.length - 1); // remove training "."
}
name = name.toLowerCase();
if (!name) {
throw this.vmComposeError(Error(), 32, "Bad filename: " + name);
}
return name;
}
vmGetSoundData() {
return this.soundData;
}
vmSetSourceMap(sourceMap) {
this.sourceMap = sourceMap;
}
vmTrace() {
if (this.tronFlag1) {
const stream = 0;
this.print(stream, "[" + String(this.line) + "]");
}
}
vmGetOutBuffer() {
return this.outBuffer;
}
vmPrint2OutBuffer(s) {
this.outBuffer += CpcVm.vmWithControlCodes(s);
}
vmDrawMovePlot(type, gPen, gColMode) {
if (gPen !== undefined) {
gPen = this.vmInRangeRound(gPen, 0, 15, type);
this.canvas.setGPen(gPen);
}
if (gColMode !== undefined) {
gColMode = this.vmInRangeRound(gColMode, 0, 3, type);
this.canvas.setGColMode(gColMode);
}
}
vmAfterEveryGosub(type, interval, timer, line) {
interval = this.vmInRangeRound(interval, 0, 32767, type); // more would be overflow
timer = this.vmInRangeRound(timer || 0, 0, 3, type);
line = this.vmLineInRange(line, type + " GOSUB");
const timerEntry = this.timerList[timer];
if (interval) {
const intervalMs = interval * CpcVm.frameTimeMs; // convert to ms
timerEntry.intervalMs = intervalMs;
timerEntry.line = line;
timerEntry.repeat = type === "EVERY";
timerEntry.active = true;
timerEntry.nextTimeMs = Date.now() + intervalMs;
}
else { // interval 0 => switch running timer off
timerEntry.active = false;
}
}
vmCopyFromScreen(source, dest) {
for (let i = 0; i < 0x4000; i += 1) {
let byte = this.canvas.getByte(source + i); // get byte from screen memory
if (byte === null) { // byte not visible on screen?
byte = this.mem[source + i] || 0; // get it from our memory
}
this.mem[dest + i] = byte;
}
}
vmCopyToScreen(source, dest) {
for (let i = 0; i < 0x4000; i += 1) {
const byte = this.mem[source + i] || 0; // get it from our memory
this.canvas.setByte(dest + i, byte);
}
}
vmSetScreenBase(byte) {
byte = this.vmInRangeRound(byte, 0, 255, "screenBase");
const page = byte >> 6, // eslint-disable-line no-bitwise
oldPage = this.screenPage;
if (page !== oldPage) {
let addr = oldPage << 14; // eslint-disable-line no-bitwise
this.vmCopyFromScreen(addr, addr);
this.screenPage = page;
addr = page << 14; // eslint-disable-line no-bitwise
this.vmCopyToScreen(addr, addr);
}
}
vmSetScreenOffset(offset) {
this.canvas.setScreenOffset(offset);
}
vmSetTransparentMode(stream, transparent) {
this.windowDataList[stream].transparent = Boolean(transparent);
}
abs(n) {
this.vmAssertNumber(n, "ABS");
return Math.abs(n);
}
addressOf(variable) {
this.vmAssertString(variable, "@");
const varIndex = this.variables.getVariableIndex(variable);
if (varIndex < 0) {
throw this.vmComposeError(Error(), 5, "@" + variable); // Improper argument
}
return varIndex;
}
afterGosub(interval, timer, line) {
this.vmAfterEveryGosub("AFTER", interval, timer, line);
}
static vmGetCharCodeAt(s, i) {
const code = s.charCodeAt(i);
if (code < 0x100 || code >= 0x200) {
return code;
}
return code & 0xFF; // eslint-disable-line no-bitwise
}
static vmWithControlCodes(s) {
let out = "";
for (let i = 0; i < s.length; i += 1) {
out += String.fromCharCode(CpcVm.vmGetCharCodeAt(s, i));
}
return out;
}
/*
private static vmGetCpcCharCode(code: number): number {
return code & 0xFF; // eslint-disable-line no-bitwise
}
*/
static vmGetCpcCharCode(code) {
if (code > 0xff) { // map some UTF-8 character codes
if (CpcVm.utf8ToCpc[code]) {
code = CpcVm.utf8ToCpc[code];
}
else if (code <= 0x1FF) {
code &= 0xFF; // eslint-disable-line no-bitwise
}
}
return code;
}
asc(s) {
this.vmAssertString(s, "ASC");
if (!s.length) {
throw this.vmComposeError(Error(), 5, "ASC"); // Improper argument
}
return CpcVm.vmGetCpcCharCode(s.charCodeAt(0));
}
atn(n) {
this.vmAssertNumber(n, "ATN");
n = Math.atan(n);
return this.degFlag ? Utils.toDegrees(n) : n;
}
auto(line, increment) {
line = line === undefined ? 10 : this.vmLineInRange(line, "AUTO");
increment = increment === undefined ? 10 : this.vmLineInRange(increment, "AUTO");
this.vmNotImplemented("AUTO " + line + "," + increment);
}
bin$(n, pad) {
n = this.vmRound2Complement(n, "BIN$");
pad = this.vmInRangeRound(pad || 0, 0, 16, "BIN$");
return n.toString(2).padStart(pad, "0");
}
border(ink1, ink2) {
ink1 = this.vmInRangeRound(ink1, 0, 31, "BORDER");
if (ink2 === undefined) {
ink2 = ink1;
}
else {
ink2 = this.vmInRangeRound(ink2, 0, 31, "BORDER");
}
this.canvas.setBorder(ink1, ink2);
}
vmMcSetMode(mode) {
mode = this.vmInRangeRound(mode, 0, 3, "MCSetMode");
const canvasMode = this.canvas.getMode();
if (mode !== canvasMode) {
const addr = this.screenPage << 14; // eslint-disable-line no-bitwise
this.vmCopyFromScreen(addr, addr); // read bytes from screen memory into memory
this.canvas.changeMode(mode); // change mode and interpretation of bytes
this.vmCopyToScreen(addr, addr); // write bytes back to screen memory
this.canvas.changeMode(canvasMode); // keep mode
}
}
vmTxtInverse(stream) {
const win = this.windowDataList[stream], tmpPen = win.pen;
this.pen(stream, win.paper);
this.paper(stream, tmpPen);
}
updateColorsImmediately(addr) {
const inkList = [];
for (let i = 0; i < 17; i += 1) {
/* eslint-disable no-bitwise */
const byte = this.peek((addr + i) & 0xffff), color = byte & 0x1f;
/* eslint-enable no-bitwise */
inkList[i] = color;
}
this.canvas.updateColorsAndCanvasImmediately(inkList);
}
call(addr, ...args) {
addr = this.vmRound2Complement(addr, "CALL");
if (args.length > 32) { // more that 32 arguments?
throw this.vmComposeError(Error(), 2, "CALL "); // Syntax Error
}
for (let i = 0; i < args.length; i += 1) {
if (typeof args[i] === "number") {
args[i] = this.vmRound2Complement(args[i], "CALL"); // even if the args itself are not used here
}
}
switch (addr) {
case 0xbb00: // KM Initialize (ROM &19E0)
this.keyboard.resetCpcKeysExpansions();
this.call(0xbb03); // KM Reset
break;
case 0xbb03: // KM Reset (ROM &1AE1)
this.clearInput();
this.keyboard.resetExpansionTokens();
break;
case 0xbb0c: // KM Char Return (ROM &1A77), depending on number of args
this.keyboard.putKeyInBuffer(String.fromCharCode(args.length), true); // with trigger onkeydown
break;
case 0xbb06: // KM Wait Char (ROM &1A3C); since we do not return a character, we do the same as call &bb18
case 0xbb18: // KM Wait Key (ROM &1B56)
if (this.inkey$() === "") { // no key?
this.vmStop("waitKey", 30); // wait for key
}
break;
case 0xbb4e: // TXT Initialize (ROM &1078)
this.canvas.resetCustomChars();
this.vmResetPenPaperWindowData(); // reset pen and paper
this.vmResetWindowData(); // reset windows
this.vmResetControlBuffer();
break;
case 0xbb51: // TXT Reset (ROM &11088)
this.vmResetControlBuffer();
break;
case 0xbb5a: // TXT Output (ROM &1400), depending on number of args
this.print(0, String.fromCharCode(args.length));
break;
case 0xbb5d: // TXT WR Char (ROM &1334), depending on number of args
this.vmDrawUndrawCursor(0);
this.vmPrintChars(0, String.fromCharCode(args.length));
this.vmDrawUndrawCursor(0);
break;
case 0xbb6c: // TXT Clear Window (ROM &1540)
this.cls(0);
break;
case 0xbb7b: // TXT Cursor Enable (ROM &1289); user switch (cursor enabled)
this.cursor(0, undefined, 1);
break;
case 0xbb7e: // TXT Cursor Disable (ROM &129A); user switch
this.cursor(0, undefined, 0);
break;
case 0xbb81: // TXT Cursor On (ROM &1279); system switch (cursor on)
this.cursor(0, 1);
break;
case 0xbb84: // TXT Cursor Off (ROM &1281); system switch
this.cursor(0, 0);
break;
case 0xbb8a: // TXT Place Cursor (ROM &1268)
case 0xbb8d: // TXT Remove Cursor (ROM &1268); same as place cursor
this.vmPlaceRemoveCursor(0); // 0=stream
break;
case 0xbb90: // TXT Set Pen (ROM &12A9), depending on number of args
this.pen(0, args.length % 16);
break;
case 0xbb96: // TXT Set Paper (ROM &12AE); depending on number of args
this.paper(0, args.length % 16);
break;
case 0xbb9c: // TXT Inverse (ROM &12C9), same as print chr$(24);
this.vmTxtInverse(0);
break;
case 0xbb9f: // TXT Set Back (ROM &137A), depending on number of args
this.vmSetTransparentMode(0, args.length);
break;
case 0xbbdb: // GRA Clear Window (ROM &17C5)
this.canvas.clearGraphicsWindow();
break;
case 0xbbde: // GRA Set Pen (ROM &17F6), depending on number of args
this.graphicsPen(args.length % 16);
break;
case 0xbbe4: // GRA Set Paper (ROM &17FD), depending on number of args
this.graphicsPaper(args.length % 16);
break;
case 0xbbfc: // GRA WR Char (ROM &1945), depending on number of args
this.canvas.printGChar(args.length);
break;
case 0xbbff: // SCR Initialize (ROM &0AA0)
this.vmSetScreenBase(0xc0);
this.modeValue = 1;
this.canvas.setMode(this.modeValue); // does not clear canvas
this.canvas.clearFullWindow(); // (SCR Mode Clear)
this.vmResetInks();
break;
case 0xbc02: // SCR Reset (ROM &0AB1)
this.vmResetInks();
break;
case 0xbc06: // SCR SET BASE (&BC08, ROM &0B45); We use &BC06 to load reg A from reg E (not for CPC 664!)
case 0xbc07: // Works on all CPC 464/664/6128
this.vmSetScreenBase(args[0]);
break;
case 0xbc0e: // SCR SET MODE (ROM &0ACE), depending on number of args
this.mode(args.length % 4); // 3 is valid also on CPC
break;
case 0xbca7: // SOUND Reset (ROM &1E68)
this.soundClass.reset();
break;
case 0xbcb6: // SOUND Hold (ROM &1ECB)
this.vmNotImplemented("CALL &BCBC");
break;
case 0xbcb9: // SOUND Continue (ROM &1EE6)
this.vmNotImplemented("CALL &BCB9");
break;
case 0xbd19: // MC Wait Flyback (ROM &07BA)
this.frame();
break;
case 0xbd1c: // MC Set Mode (ROM &0776) just set mode, depending on number of args
this.vmMcSetMode(args.length % 4);
break;
/*
case 0xbd22: // MC Clear Inks (ROM &0786), ink table address in DE (last parameter)
break;
*/
case 0xbd25: // MC Set Inks (ROM &0799), ink table address in DE (last parameter), experimental
this.updateColorsImmediately(args[0]);
break;
case 0xbd3d: // KM Flush (ROM ?; CPC 664/6128)
this.clearInput();
break;
case 0xbd49: // GRA Set First (ROM ?; CPC 664/6128), depending on number of args
this.canvas.setMaskFirst(args.length % 2);
break;
case 0xbd4c: // GRA Set Mask (ROM ?; CPC 664/6128), depending on number of args
this.canvas.setMask(args.length);
break;
case 0xbd52: // GRA Fill (ROM ?; CPC 664/6128), depending on number of args
this.fill(args.length % 16);
break;
case 0xbd5b: // KL RAM SELECT (CPC 6128 only)
this.vmSetRamSelect(args.length);
break;
default:
if (!this.rsx.callRsx(this, "&" + addr.toString(16).toLowerCase().padStart(4, "0"), ...args)) { // maybe user defined addr
if (Utils.debug > 0) {
Utils.console.debug("Ignored: CALL", addr, args);
}
}
break;
}
}
callRsx(name, ...args) {
if (args.length > 32) { // more that 32 arguments?
throw this.vmComposeError(Error(), 2, "RSX "); // Syntax Error
}
for (let i = 0; i < args.length; i += 1) {
if (typeof args[i] === "number") {
args[i] = this.vmRound2Complement(args[i], "RSX"); // even if the args itself are not used here
}
}
if (!this.rsx.callRsx(this, name, ...args)) {
throw this.vmComposeError(Error(), 28, "|" + name); // Unknown command
}
}
cat() {
const stream = 0, fileParas = {
command: "cat",
stream: stream,
fileMask: "",
line: this.line // unused
};
this.vmStop("fileCat", 45, false, fileParas);
}
chain(name, line, first, last) {
const inFile = this.inFile;
name = this.vmAdaptFilename(name, "CHAIN");
this.closein();
inFile.line = line === undefined ? 0 : this.vmInRangeRound(line, 0, 65535, "CHAIN"); // here we do rounding of line number
inFile.first = first === undefined ? 0 : this.vmAssertInRange(first, 1, 65535, "CHAIN"); // first and last are not needed
inFile.last = last === undefined ? 0 : this.vmAssertInRange(last, 1, 65535, "CHAIN");
inFile.open = true;
inFile.command = "chain";
inFile.name = name;
inFile.fnFileCallback = this.fnCloseinHandler;
this.vmStop("fileLoad", 90);
}
chainMerge(name, line, first, last) {
const inFile = this.inFile;
name = this.vmAdaptFilename(name, "CHAIN MERGE");
this.closein();
inFile.line = line === undefined ? 0 : this.vmInRangeRound(line, 0, 65535, "CHAIN MERGE"); // here we do rounding of line number;
inFile.first = first === undefined ? 0 : this.vmAssertInRange(first, 1, 65535, "CHAIN MERGE");
inFile.last = last === undefined ? 0 : this.vmAssertInRange(last, 1, 65535, "CHAIN MERGE");
inFile.open = true;
inFile.command = "chainMerge";
inFile.name = name;
inFile.fnFileCallback = this.fnCloseinHandler;
this.vmStop("fileLoad", 90);
}
chr$(n) {
n = this.vmInRangeRound(n, 0, 255, "CHR$");
return String.fromCharCode(n);
}
cint(n) {
return this.vmInRangeRound(n, -32768, 32767, "CINT");
}
clear() {
this.vmResetTimers();
this.ei();
this.vmSetStartLine(0);
this.breakGosubLine = 0;
this.breakResumeLine = 0;
this.errorGotoLine = 0;
this.errorResumeLine = 0;
this.gosubStack.length = 0;
this.variables.initAllVariables();
this.defreal("a", "z");
this.restore(); // restore data line index
this.rad();
this.soundClass.resetQueue();
this.soundData.length = 0;
this.vmResetInFileHandling();
this.vmResetOutFileHandling();
}
clearInput() {
this.keyboard.clearInput();
}
clg(gPaper) {
if (gPaper !== undefined) {
gPaper = this.vmInRangeRound(gPaper, 0, 15, "CLG");
this.canvas.setGPaper(gPaper);
}
this.canvas.clearGraphicsWindow();
}
vmCloseinCallback() {
const inFile = this.inFile;
CpcVm.vmResetFileHandling(inFile);
}
closein() {
if (this.inFile.open) {
this.vmCloseinCallback(); // close directly
}
}
vmCloseoutCallback() {
const outFile = this.outFile;
CpcVm.vmResetFileHandling(outFile);
}
closeout() {
const outFile = this.outFile;
if (outFile.open) {
if (outFile.command !== "openout") {
if (!this.quiet) {
Utils.console.warn("closeout: command=", outFile.command); // should not occur
}
}
if (!outFile.fileData.length) { // openout without data?
this.vmCloseoutCallback(); // close directly
}
else { // data to save
outFile.command = "closeout";
outFile.start = 0;
outFile.length = 0; // will be set during fileSave
outFile.fnFileCallback = this.fnCloseoutHandler;
this.vmStop("fileSave", 90); // must stop directly after closeout
}
}
}
cls(stream) {
stream = this.vmInRangeRound(stream, 0, 7, "CLS");
const win = this.windowDataList[stream];
this.vmDrawUndrawCursor(stream); // why, if we clear anyway?
this.canvas.clearTextWindow(win.left, win.right, win.top, win.bottom, win.paper); // cls window
win.pos = 0;
win.vpos = 0;
if (!stream) {
this.outBuffer = ""; // clear also console, if stream===0
}
}
commaTab(stream) {
stream = this.vmInRangeRound(stream, 0, 9, "commaTab");
this.vmMoveCursor2AllowedPos(stream);
const zone = this.zoneValue, win = this.windowDataList[stream];
let count = zone - (win.pos % zone);
if (win.pos) { // <>0: not begin of line
if (win.pos + count + zone > (win.right + 1 - win.left)) {
win.pos += count + zone;
this.vmMoveCursor2AllowedPos(stream);
count = 0;
}
}
return " ".repeat(count);
}
cont() {
if (!this.startLine) {
throw this.vmComposeError(Error(), 17, "CONT"); // cannot continue
}
this.vmGoto(this.startLine, "CONT");
this.startLine = 0;
}
copychr$(stream) {
stream = this.vmInRangeRound(stream, 0, 7, "COPYCHR$");
this.vmMoveCursor2AllowedPos(stream);
this.vmDrawUndrawCursor(stream); // undraw
const win = this.windowDataList[stream], charCode = this.canvas.readChar(win.pos + win.left, win.vpos + win.top, win.pen, win.paper), char = (charCode >= 0) ? String.fromCharCode(charCode) : " "; // if not detected (-1), use space
this.vmDrawUndrawCursor(stream); // draw
return char;
}
cos(n) {
this.vmAssertNumber(n, "COS");
return Math.cos((this.degFlag) ? Utils.toRadians(n) : n);
}
creal(n) {
this.vmAssertNumber(n, "CREAL");
return n;
}
vmPlaceRemoveCursor(stream) {
const win = this.windowDataList[stream];
this.vmMoveCursor2AllowedPos(stream);
this.canvas.drawCursor(win.pos + win.left, win.vpos + win.top, win.pen, win.paper);
}
vmDrawUndrawCursor(stream) {
const win = this.windowDataList[stream];
if (win.cursorOn && win.cursorEnabled) {
this.vmPlaceRemoveCursor(stream);
}
}
cursor(stream, cursorOn, cursorEnabled) {
stream = this.vmInRangeRound(stream, 0, 7, "CURSOR");
const win = this.windowDataList[stream];
if (cursorOn !== undefined) { // system
cursorOn = this.vmInRangeRound(cursorOn, 0, 1, "CURSOR");
this.vmDrawUndrawCursor(stream); // undraw
win.cursorOn = Boolean(cursorOn);
this.vmDrawUndrawCursor(stream); // draw
}
if (cursorEnabled !== undefined) { // user
cursorEnabled = this.vmInRangeRound(cursorEnabled, 0, 1, "CURSOR");
this.vmDrawUndrawCursor(stream); // undraw
win.cursorEnabled = Boolean(cursorEnabled);
this.vmDrawUndrawCursor(stream); // draw
}
}
data(line, ...args) {
this.vmLineInRange(line, "DATA");
if (!this.dataLineIndex[line]) {
this.dataLineIndex[line] = this.dataList.length; // set current index for the line
}
for (let i = 0; i < args.length; i += 1) {
this.dataList.push(args[i]);
}
}
dec$(n, frmt) {
const formatRegExp = /^[+\-$*#,.^]*$/;
this.vmAssertNumber(n, "DEC$");
this.vmAssertString(frmt, "DEC$");
if (!formatRegExp.test(frmt)) { // only allowed characters: + - $  * # , . ^
throw this.vmComposeError(Error(), 5, "DEC$ " + frmt); // Improper argument
}
return this.vmUsingNumberFormat(frmt, n);
}
defint(first, last) {
this.vmDefineVarTypes("I", "DEFINT", first, last);
}
defreal(first, last) {
this.vmDefineVarTypes("R", "DEFREAL", first, last);
}
defstr(first, last) {
this.vmDefineVarTypes("$", "DEFSTR", first, last);
}
deg() {
this.degFlag = true;
}
"delete"(first, last) {
if (first === undefined) {
first = 1;
last = last === undefined ? 65535 : this.vmInRangeRound(last, 1, 65535, "DELETE");
}
else {
first = this.vmInRangeRound(first, 1, 65535, "DELETE");
if (last === undefined) { // just one parameter?
last = first;
}
else { // range
last = this.vmInRangeRound(last, 1, 65535, "DELETE");
}
}
this.vmStop("deleteLines", 85, false, {
command: "DELETE",
stream: 0, // unused
first: first,
last: last,
line: this.line // unused
});
}
derr() {
return 0; // "[Not implemented yet: derr]"
}
di() {
this.timerPriority = 3; // increase priority
}
dim(varName, ...args) {
const dimensions = [];
this.vmAssertString(varName, "DIM");
for (let i = 0; i < args.length; i += 1) {
const size = this.vmInRangeRound(args[i], 0, 32767, "DIM") + 1; // for basic we have sizes +1
dimensions.push(size);
}
this.variables.dimVariable(varName, dimensions);
}
draw(x, y, gPen, gColMode) {
x = this.vmInRangeRound(x, -32768, 32767, "DRAW");
y = this.vmInRangeRound(y, -32768, 32767, "DRAW");
this.vmDrawMovePlot("DRAW", gPen, gColMode);
this.canvas.draw(x, y);
}
drawr(x, y, gPen, gColMode) {
x = this.vmInRangeRound(x, -32768, 32767, "DRAWR") + this.canvas.getXpos();
y = this.vmInRangeRound(y, -32768, 32767, "DRAWR") + this.canvas.getYpos();
this.vmDrawMovePlot("DRAWR", gPen, gColMode);
this.canvas.draw(x, y);
}
edit(line) {
const lineParas = {
command: "edit",
stream: 0, // unused
first: line,
last: 0, // unused,
line: this.line // unused
};
this.vmStop("editLine", 85, false, lineParas);
}
ei() {
this.timerPriority = -1; // decrease priority
}
end(label) {
this.stop(label);
}
ent(toneEnv, ...args) {
toneEnv = this.vmInRangeRound(toneEnv, -15, 15, "ENT");
const envData = [];
let arg, repeat = false;
if (toneEnv < 0) {
toneEnv = -toneEnv;
repeat = true;
}
if (toneEnv) { // not 0
for (let i = 0; i < args.length; i += 3) { // starting with 1: 3 parameters per section
if (args[i] !== undefined) {
arg = {
steps: this.vmInRangeRound(args[i], 0, 239, "ENT"), // number of steps: 0..239
diff: this.vmInRangeRound(args[i + 1], -128, 127, "ENT"), // size (period change) of steps: -128..+127
time: this.vmInRangeRound(args[i + 2], 0, 255, "ENT"), // time per step: 0..255 (0=256)
repeat: repeat
}; // as ToneEnvData1
}
else { // special handling
arg = {
period: this.vmInRangeRound(args[i + 1], 0, 4095, "ENT"), // absolute period
time: this.vmInRangeRound(args[i + 2], 0, 255, "ENT") // time: 0..255 (0=256)
}; // as ToneEnvData2
}
envData.push(arg);
}
this.soundClass.setToneEnv(toneEnv, envData);
}
else { // 0
if (!this.quiet) {
Utils.console.warn("ENT: toneEnv", toneEnv);
}
throw this.vmComposeError(Error(), 5, "ENT " + toneEnv); // Improper argument
}
}
env(volEnv, ...args) {
volEnv = this.vmInRangeRound(volEnv, 1, 15, "ENV");
const envData = [];
let arg;
for (let i = 0; i < args.length; i += 3) { // starting with 1: 3 parameters per section
if (args[i] !== undefined) {
arg = {
steps: this.vmInRangeRound(args[i], 0, 127, "ENV"), // number of steps: 0..127
/* eslint-disable no-bitwise */
diff: this.vmInRangeRound(args[i + 1], -128, 127, "ENV") & 0x0f, // size (volume) of steps: moved to range 0..15
/* eslint-enable no-bitwise */
time: this.vmInRangeRound(args[i + 2], 0, 255, "ENV") // time per step: 0..255 (0=256)
}; // as VolEnvData1
if (!arg.time) { // (0=256)
arg.time = 256;
}
}
else { // special handling for register parameters
arg = {
register: this.vmInRangeRound(args[i + 1], 0, 15, "ENV"), // register: 0..15
period: this.vmInRangeRound(args[i + 2], -32768, 65535, "ENV")
}; // as VolEnvData2
}
envData.push(arg);
}
this.soundClass.setVolEnv(volEnv, envData);
}
eof() {
const inFile = this.inFile;
let eof = -1;
if (inFile.open && inFile.fileData.length) {
eof = 0;
}
return eof;
}
vmFindArrayVariable(name) {
let typeChar = name.charAt(name.length - 1); // last character
if (typeChar === "I" || typeChar === "R" || typeChar === "$") { // explicit type specified?
name = name.slice(0, -1); // remove type char
}
else {
typeChar = this.vmDetermineVarType(name.charAt(0)); // determine type char
}
name += "A";
const fnArrayVarFilter = function (variable) {
return (variable.indexOf(name) === 0 && (variable.charAt(variable.length - 1) === typeChar)) ? variable : null; // find array var(A)*<typeChar>
};
let names = this.variables.getAllVariableNames();
names = names.filter(fnArrayVarFilter);
return names;
}
erase(...args) {
if (!args.length) {
throw this.vmComposeError(Error(), 2, "ERASE"); // Syntax Error
}
for (let i = 0; i < args.length; i += 1) {
this.vmAssertString(args[i], "ERASE");
const names = this.vmFindArrayVariable(args[i]);
if (names.length) {
for (let j = 0; j < names.length; j += 1) {
const name = names[j];
this.variables.initVariable(name);
}
}
else {
if (!this.quiet) {
Utils.console.warn("erase: Array variable not found:", args[i]);
}
throw this.vmComposeError(Error(), 5, "ERASE " + args[i]); // Improper argument
}
}
}
erl() {
const errorLine = parseInt(String(this.errorLine), 10); // in CpcLoco we have an error label here, so return number only
return errorLine || 0;
}
err() {
return this.errorCode;
}
vmComposeError(error, err, errInfo) {
const errors = CpcVm.errors, errorString = errors[err] || errors[errors.length - 1]; // maybe Unknown error
this.errorCode = err;
this.errorLine = this.line;
const errorWithInfo = errorString + " in " + this.errorLine + (errInfo ? (": " + errInfo) : "");
let hidden = false; // hide errors wich are catched
if (this.errorGotoLine && !this.errorResumeLine) {
this.errorResumeLine = this.errorLine;
this.vmGoto(this.errorGotoLine, "onError");
this.vmStop("onError", 50);
hidden = true;
}
else {
this.vmStop("error", 50);
}
if (!this.quiet) {
Utils.console.log("BASIC error(" + err + "):", errorWithInfo + (hidden ? " (hidden: " + hidden + ")" : ""));
}
const traceLine = this.line, sourceMapEntry = this.sourceMap[traceLine], pos = sourceMapEntry && sourceMapEntry[0], len = sourceMapEntry && sourceMapEntry[1];
return Utils.composeError("CpcVm", error, errorString, errInfo, pos, len, this.line, hidden);
}
error(err, errInfo) {
err = this.vmInRangeRound(err, 0, 255, "ERROR"); // could trigger another error
throw this.vmComposeError(Error(), err, errInfo);
}
everyGosub(interval, timer, line) {
this.vmAfterEveryGosub("EVERY", interval, timer, line);
}
exp(n) {
this.vmAssertNumber(n, "EXP");
return Math.exp(n);
}
fill(gPen) {
gPen = this.vmInRangeRound(gPen, 0, 15, "FILL");
this.canvas.fill(gPen);
}
fix(n) {
this.vmAssertNumber(n, "FIX");
return Math.trunc(n); // (ES6: Math.trunc)
}
frame() {
this.vmStop("waitFrame", 40);
}
fre(arg) {
if (typeof arg !== "number" && typeof arg !== "string") {
throw this.vmComposeError(Error(), 2, "FRE"); // Syntax Error
}
return this.himemValue - this.progEnd;
}
vmGosub(retLabel, n) {
this.vmGoto(n, "gosub (ret=" + retLabel + ")");
this.gosubStack.push(retLabel);
}
gosub(retLabel, n) {
this.vmLineInRange(n, "GOSUB");
if (this.gosubStack.length >= this.maxGosubStackLength) { // limit stack size (not necessary in JS, but...)
throw this.vmComposeError(Error(), 7, "GOSUB " + n); // Memory full
}
this.vmGosub(retLabel, n);
}
"goto"(line) {
this.vmLineInRange(line, "GOTO");
this.vmGoto(line, "goto");
}
graphicsPaper(gPaper) {
gPaper = this.vmInRangeRound(gPaper, 0, 15, "GRAPHICS PAPER");
this.canvas.setGPaper(gPaper);
}
graphicsPen(gPen, transparentMode) {
if (gPen === undefined && transparentMode === undefined) {
throw this.vmComposeError(Error(), 22, "GRAPHICS PEN"); // Operand missing
}
if (gPen !== undefined) {
gPen = this.vmInRangeRound(gPen, 0, 15, "GRAPHICS PEN");
this.canvas.setGPen(gPen);
}
if (transparentMode !== undefined) {
transparentMode = this.vmInRangeRound(transparentMode, 0, 1, "GRAPHICS PEN");
this.canvas.setGTransparentMode(Boolean(transparentMode));
}
}
hex$(n, pad) {
n = this.vmRound2Complement(n, "HEX$");
pad = this.vmInRangeRound(pad || 0, 0, 16, "HEX$");
return n.toString(16).toUpperCase().padStart(pad, "0");
}
himem() {
return this.himemValue;
}
ink(pen, ink1, ink2) {
pen = this.vmInRangeRound(pen, 0, 15, "INK");
ink1 = this.vmInRangeRound(ink1, 0, 31, "INK");
if (ink2 === undefined) {
ink2 = ink1;
}
else {
ink2 = this.vmInRangeRound(ink2, 0, 31, "INK");
}
this.canvas.setInk(pen, ink1, ink2);
}
inkey(key) {
key = this.vmInRangeRound(key, 0, 79, "INKEY");
return this.keyboard.getKeyState(key);
}
inkey$() {
const key = this.keyboard.getKeyFromBuffer();
if (key !== "") { // some key pressed?
this.inkeyTimeMs = 0;
}
else { // no key
const now = Date.now();
if (this.inkeyTimeMs && now < this.inkeyTimeMs) { // last inkey without key was in range of frame fly?
this.frame(); // then insert a frame fly
}
this.inkeyTimeMs = now + CpcVm.frameTimeMs; // next time of frame fly
}
return key;
}
inp(port) {
port = this.vmRound2Complement(port, "INP"); // two's complement of 16 bit address
let byte = (port & 0xff);
byte |= 0xff; // we return always the same 0xff
return byte;
}
vmSetInputValues(inputValues) {
this.inputValues = inputValues;
}
vmGetNextInput() {
const inputValues = this.inputValues, value = inputValues.shift();
return value;
}
vmInputCallback() {
const inputParas = this.vmGetStopObject().paras, stream = inputParas.stream, input = inputParas.input, inputValues = input.split(","), convertedInputValues = [], types = inputParas.types;
let inputOk = true;
if (Utils.debug > 0) {
Utils.console.debug("vmInputCallback:", input);
}
if (types && (inputValues.length === types.length)) {
for (let i = 0; i < types.length; i += 1) {
const varType = types[i], type = this.vmDetermineVarType(varType), value = inputValues[i];
if (type !== "$") { // not a string?
const valueNumber = this.vmVal(value); // convert to number (also binary, hex), empty string gets 0
if (isNaN(valueNumber)) {
inputOk = false;
}
convertedInputValues.push(valueNumber);
}
else {
convertedInputValues.push(value);
}
}
}
else {
inputOk = false;
}
this.cursor(stream, 0);
if (!inputOk) {
this.print(stream, "?Redo from start\r\n");
inputParas.input = "";
this.print(stream, inputParas.message);
this.cursor(stream, 1);
}
else {
this.vmSetInputValues(convertedInputValues);
}
return inputOk;
}
fnFileInputGetString(fileData) {
let line = fileData[0].replace(/^\s+/, ""), // remove preceding whitespace
value;
if (line.charAt(0) === '"') { // quoted string?
const index = line.indexOf('"', 1); // closing quotes in this line?
if (index >= 0) {
value = line.substring(1, index + 1 - 1); // take string without quotes
line = line.substring(index + 1);
line = line.replace(/^\s*,/, ""); // multiple args => remove next comma
}
else if (fileData.length > 1) { // no closing quotes in this line => try to combine with next line
fileData.shift(); // remove line
line += "\n" + fileData[0]; // combine lines
}
else {
throw this.vmComposeError(Error(), 13, "INPUT #9: no closing quotes: " + line);
}
}
else { // unquoted string
const index = line.indexOf(","); // multiple args?
if (index >= 0) {
value = line.substring(0, index); // take arg
line = line.substring(index + 1);
}
else {
value = line; // take line
line = "";
}
}
fileData[0] = line;
return value;
}
fnFileInputGetNumber(fileData) {
let line = fileData[0].replace(/^\s+/, ""), // remove preceding whitespace
index = line.indexOf(","), // multiple args?
value;
if (index >= 0) {
value = line.substring(0, index); // take arg
line = line.substring(index + 1);
}
else {
index = line.indexOf(" "); // space?
if (index >= 0) {
value = line.substring(0, index); // take item until space
line = line.substring(index);
line = line.replace(/^\s*/, ""); // remove spaces after number
}
else {
value = line; // take line
line = "";
}
}
const nValue = this.vmVal(value); // convert to number (also binary, hex)
if (isNaN(nValue)) { // eslint-disable-line max-depth
throw this.vmComposeError(Error(), 13, "INPUT #9 " + nValue + ": " + value); // Type mismatch
}
fileData[0] = line;
return nValue;
}
vmInputNextFileItem(type) {
const fileData = this.inFile.fileData;
let value;
while (fileData.length && value === undefined) {
if (type === "$") {
value = this.fnFileInputGetString(fileData);
}
else { // number type
value = this.fnFileInputGetNumber(fileData);
}
if (!fileData[0].length) {
fileData.shift(); // remove empty line
}
}
return value;
}
vmInputFromFile(types) {
const inputValues = [];
for (let i = 0; i < types.length; i += 1) {
const varType = types[i], type = this.vmDetermineVarType(varType), value = this.vmInputNextFileItem(type);
inputValues[i] = this.vmAssign(varType, value);
}
this.vmSetInputValues(inputValues);
}
input(stream, noCRLF, msg, ...args) {
stream = this.vmInRangeRound(stream, 0, 9, "INPUT");
if (stream < 8) {
this.print(stream, msg);
this.vmStop("waitInput", 45, false, {
command: "input",
stream: stream,
message: msg,
noCRLF: noCRLF,
fnInputCallback: this.fnInputCallbackHandler,
types: args,
input: "",
line: this.line // to repeat in case of break
});
this.cursor(stream, 1);
}
else if (stream === 8) {
this.vmSetInputValues(["I am the printer!"]);
}
else if (stream === 9) {
if (!this.inFile.open) {
throw this.vmComposeError(Error(), 31, "INPUT #" + stream); // File not open
}
else if (this.eof()) {
throw this.vmComposeError(Error(), 24, "INPUT #" + stream); // EOF met
}
this.vmInputFromFile(args); // remaining arguments
}
}
instr(p1, p2, p3) {
const startPos = typeof p1 === "number" ? this.vmInRangeRound(p1, 1, 255, "INSTR") - 1 : 0, // p1=startpos
str = typeof p1 === "number" ? p2 : p1, search = typeof p1 === "number" ? p3 : p2;
this.vmAssertString(str, "INSTR");
this.vmAssertString(search, "INSTR");
if (startPos >= str.length) {
return 0; // not found
}
if (!search.length) {
return startPos + 1;
}
return CpcVm.vmWithControlCodes(str).indexOf(CpcVm.vmWithControlCodes(search), startPos) + 1;
}
"int"(n) {
this.vmAssertNumber(n, "INT");
return Math.floor(n);
}
joy(joy) {
joy = this.vmInRangeRound(joy, 0, 1, "JOY");
return this.keyboard.getJoyState(joy);
}
key(token, s) {
token = this.vmRound(token, "KEY");
if (token >= 128 && token <= 159) {
token -= 128;
}
token = this.vmInRangeRound(token, 0, 31, "KEY"); // round again, but we want the check
this.vmAssertString(s, "KEY");
this.keyboard.setExpansionToken(token, s);
}
keyDef(cpcKey, repeat, normal, shift, ctrl) {
const options = {
cpcKey: this.vmInRangeRound(cpcKey, 0, 79, "KEY DEF"),
repeat: this.vmInRangeRound(repeat, 0, 1, "KEY DEF"),
normal: (normal !== undefined) ? this.vmInRangeRound(normal, 0, 255, "KEY DEF") : undefined,
shift: (shift !== undefined) ? this.vmInRangeRound(shift, 0, 255, "KEY DEF") : undefined,
ctrl: (ctrl !== undefined) ? this.vmInRangeRound(ctrl, 0, 255, "KEY DEF") : undefined
};
this.keyboard.setCpcKeyExpansion(options);
}
left$(s, len) {
this.vmAssertString(s, "LEFT$");
len = this.vmInRangeRound(len, 0, 255, "LEFT$");
return s.substring(0, len);
}
len(s) {
this.vmAssertString(s, "LEN");
return s.length;
}
vmLineInputCallback() {
const inputParas = this.vmGetStopObject().paras, input = inputParas.input;
if (Utils.debug > 0) {
Utils.console.debug("vmLineInputCallback:", input);
}
this.vmSetInputValues([input]);
this.cursor(inputParas.stream, 0);
return true;
}
lineInput(stream, noCRLF, msg, varType) {
stream = this.vmInRangeRound(stream, 0, 9, "LINE INPUT");
if (stream < 8) {
this.vmAssertString(varType, "LINE INPUT");
this.print(stream, msg);
const type = this.vmDetermineVarType(varType);
if (type !== "$") { // not string?
this.print(stream, "\r\n");
throw this.vmComposeError(Error(), 13, "LINE INPUT " + type); // Type mismatch
}
this.cursor(stream, 1);
this.vmStop("waitInput", 45, false, {
command: "lineinput",
stream: stream,
message: msg,
noCRLF: noCRLF,
fnInputCallback: this.fnLineInputCallbackHandler,
input: "",
line: this.line // to repeat in case of break
});
}
else if (stream === 8) {
this.vmSetInputValues(["I am the printer!"]);
}
else if (stream === 9) {
if (!this.inFile.open) {
throw this.vmComposeError(Error(), 31, "LINE INPUT #" + stream); // File not open
}
else if (this.eof()) {
throw this.vmComposeError(Error(), 24, "LINE INPUT #" + stream); // EOF met
}
this.vmSetInputValues(this.inFile.fileData.splice(0, arguments.length - 3)); // always 1 element
}
}
list(stream, first, last) {
stream = this.vmInRangeRound(stream, 0, 9, "LIST");
if (first === undefined) {
first = 1;
if (last === undefined) { // no first and last parameter?
last = 65535;
}
}
else {
first = this.vmInRangeRound(first, 1, 65535, "LIST");
if (last === undefined) { // just one parameter?
last = first;
}
else { // range
last = this.vmInRangeRound(last, 1, 65535, "LIST");
}
}
if (stream === 9) {
if (!this.outFile.open) { // catch here
throw this.vmComposeError(Error(), 31, "LIST #" + stream); // File not open
}
}
this.vmStop("list", 90, false, {
command: "list",
stream: stream,
first: first,
last: last,
line: this.line // unused
});
}
vmLoadCallback(input, meta) {
const inFile = this.inFile;
let putInMemory = false;
if (input !== null && meta) {
if (meta.typeString === "B" || meta.typeString === "S" || inFile.start !== undefined) { // only for binary files or when a load address is specified (feature)
const start = inFile.start !== undefined ? inFile.start : Number(meta.start);
let length = Number(meta.length); // we do not really need the length from metadata
if (isNaN(length)) {
length = input.length; // only valid after atob()
}
if (Utils.debug > 1) {
Utils.console.debug("vmLoadCallback:", inFile.name + ": putting data in memory", start, "-", start + length);
}
if (meta.typeString === "S") {
for (let i = 0; i < length; i += 1) {
this.vmSetMem(start + i, input.charCodeAt(i)); // set snapshot data directly without memory mapping
}
const addr = this.screenPage << 14; // eslint-disable-line no-bitwise
this.vmCopyToScreen(addr, addr);
}
else {
for (let i = 0; i < length; i += 1) {
this.poke((start + i) & 0xffff, input.charCodeAt(i)); // eslint-disable-line no-bitwise
}
}
putInMemory = true;
}
}
this.closein();
return putInMemory;
}
load(name, start) {
const inFile = this.inFile;
name = this.vmAdaptFilename(name, "LOAD");
if (start !== undefined) {
start = this.vmRound2Complement(start, "LOAD");
}
this.closein();
inFile.open = true;
inFile.command = "load";
inFile.name = name;
inFile.start = start;
inFile.fnFileCallback = this.fnLoadHandler;
this.vmStop("fileLoad", 90);
}
vmLocate(stream, pos, vpos) {
const win = this.windowDataList[stream];
win.pos = pos - 1;
win.vpos = vpos - 1;
}
locate(stream, pos, vpos) {
stream = this.vmInRangeRound(stream, 0, 7, "LOCATE");
pos = this.vmInRangeRound(pos, 1, 255, "LOCATE");
vpos = this.vmInRangeRound(vpos, 1, 255, "LOCATE");
this.vmDrawUndrawCursor(stream); // undraw
this.vmLocate(stream, pos, vpos);
this.vmDrawUndrawCursor(stream); // draw
}
log(n) {
this.vmAssertNumber(n, "LOG");
if (n <= 0) {
throw this.vmComposeError(Error(), 6, "LOG " + n);
}
return Math.log(n);
}
log10(n) {
this.vmAssertNumber(n, "LOG10");
if (n <= 0) {
throw this.vmComposeError(Error(), 6, "LOG10 " + n);
}
return Math.log10(n);
}
static fnLowerCase(match) {
return match.toLowerCase();
}
lower$(s) {
this.vmAssertString(s, "LOWER$");
s = s.replace(/[A-Z]/g, CpcVm.fnLowerCase); // replace only characters A-Z
return s;
}
mask(mask, first) {
if (mask === undefined && first === undefined) {
throw this.vmComposeError(Error(), 22, "MASK"); // Operand missing
}
if (mask !== undefined) {
mask = this.vmInRangeRound(mask, 0, 255, "MASK");
this.canvas.setMask(mask);
}
if (first !== undefined) {
first = this.vmInRangeRound(first, 0, 1, "MASK");
this.canvas.setMaskFirst(first);
}
}
max(...args) {
if (!args.length) {
throw this.vmComposeError(Error(), 22, "MAX"); // Operand missing
}
else if (args.length === 1) { // if just one argument, return it, even if it is a string
if (typeof args[0] !== "number" && !this.quiet) {
Utils.console.warn("MAX: Not a number:", args[0]);
}
return args[0];
}
for (let i = 0; i < args.length; i += 1) {
this.vmAssertNumber(args[i], "MAX");
}
return Math.max.apply(null, args);
}
memory(n) {
n = this.vmRound2Complement(n, "MEMORY");
if (n < this.progEnd || n > this.minCharHimem) {
throw this.vmComposeError(Error(), 7, "MEMORY " + n); // Memory full
}
this.himemValue = n;
}
merge(name) {
const inFile = this.inFile;
name = this.vmAdaptFilename(name, "MERGE");
this.closein();
inFile.open = true;
inFile.command = "merge";
inFile.name = name;
inFile.fnFileCallback = this.fnCloseinHandler;
this.vmStop("fileLoad", 90);
}
mid$(s, start, len) {
this.vmAssertString(s, "MID$");
start = this.vmInRangeRound(start, 1, 255, "MID$");
if (len !== undefined) {
len = this.vmInRangeRound(len, 0, 255, "MID$");
}
return s.substr(start - 1, len); // or: s.substring(start - 1, len === undefined ? len : start - 1 + len);
}
mid$Assign(s, start, len, newString) {
this.vmAssertString(s, "MID$");
this.vmAssertString(newString, "MID$");
start = this.vmInRangeRound(start, 1, 255, "MID$") - 1;
len = (len !== undefined) ? this.vmInRangeRound(len, 0, 255, "MID$") : newString.length;
if (len > newString.length) {
len = newString.length;
}
if (len > s.length - start) {
len = s.length - start;
}
s = s.substring(0, start) + newString.substring(0, len) + s.substring(start + len);
return s;
}
min(...args) {
if (!args.length) {
throw this.vmComposeError(Error(), 22, "MIN"); // Operand missing
}
else if (args.length === 1) { // if just one argument, return it, even if it is a string
if (typeof args[0] !== "number" && !this.quiet) {
Utils.console.warn("MIN: Not a number:", args[0]);
}
return args[0];
}
for (let i = 0; i < args.length; i += 1) {
this.vmAssertNumber(args[i], "MIN");
}
return Math.min.apply(null, args);
}
vmChangeMode(mode) {
this.modeValue = mode;
const winData = CpcVm.winData[this.modeValue];
for (let i = 0; i < CpcVm.streamCount - 2; i += 1) { // for window streams
const win = this.windowDataList[i];
Object.assign(win, winData);
}
this.canvas.changeMode(mode);
}
mode(mode) {
mode = this.vmInRangeRound(mode, 0, 3, "MODE");
this.modeValue = mode;
this.vmResetWindowData(); // do not reset pen and paper but limit them to the mode
this.outBuffer = ""; // clear console
this.canvas.setMode(mode); // does not clear canvas
this.canvas.clearFullWindow(); // always with paper 0 (SCR MODE CLEAR)
}
move(x, y, gPen, gColMode) {
x = this.vmInRangeRound(x, -32768, 32767, "MOVE");
y = this.vmInRangeRound(y, -32768, 32767, "MOVE");
this.vmDrawMovePlot("MOVE", gPen, gColMode);
this.canvas.move(x, y);
}
mover(x, y, gPen, gColMode) {
x = this.vmInRangeRound(x, -32768, 32767, "MOVER") + this.canvas.getXpos();
y = this.vmInRangeRound(y, -32768, 32767, "MOVER") + this.canvas.getYpos();
this.vmDrawMovePlot("MOVER", gPen, gColMode);
this.canvas.move(x, y);
}
"new"() {
this.progEnd = CpcVm.progStart + 3;
this.clear();
const lineParas = {
command: "new",
stream: 0, // unused
first: 0, // unused
last: 0, // unused
line: this.line // unused
};
this.vmStop("new", 90, false, lineParas);
}
onBreakCont() {
this.breakGosubLine = -1;
this.breakResumeLine = 0;
}
onBreakGosub(line) {
this.breakGosubLine = this.vmLineInRange(line, "ON BREAK GOSUB");
this.breakResumeLine = 0;
}
onBreakStop() {
this.breakGosubLine = 0;
this.breakResumeLine = 0;
}
onErrorGoto(line) {
this.errorGotoLine = (line !== 0) ? this.vmLineInRange(line, "ON ERROR GOTO") : 0;
if (!line && this.errorResumeLine) { // line=0 but an error to resume?
throw this.vmComposeError(Error(), this.errorCode, "ON ERROR GOTO without RESUME from " + this.errorLine);
}
}
onGosub(retLabel, n, ...args) {
n = this.vmInRangeRound(n, 0, 255, "ON GOSUB");
let line;
if (!n || n > args.length) { // out of range? => continue with line after onGosub
if (Utils.debug > 1) {
Utils.console.debug("onGosub: out of range: n=" + n + " in " + this.line);
}
line = retLabel;
}
else {
line = this.vmLineInRange(args[n - 1], "ON GOSUB"); // n=1...
if (this.gosubStack.length >= this.maxGosubStackLength) { // limit stack size (not necessary in JS, but...)
throw this.vmComposeError(Error(), 7, "ON GOSUB " + n); // Memory full
}
this.gosubStack.push(retLabel);
}
this.vmGoto(line, "onGosub (n=" + n + ", ret=" + retLabel + ", line=" + line + ")");
}
onGoto(retLabel, n, ...args) {
n = this.vmInRangeRound(n, 0, 255, "ON GOTO");
let line;
if (!n || n > args.length) { // out of range? => continue with line after onGoto
if (Utils.debug > 1) {
Utils.console.debug("onGoto: out of range: n=" + n + " in " + this.line);
}
line = retLabel;
}
else {
line = this.vmLineInRange(args[n - 1], "ON GOTO");
}
this.vmGoto(line, "onGoto (n=" + n + ", ret=" + retLabel + ", line=" + line + ")");
}
static fnChannel2ChannelIndex(channel) {
if (channel === 4) {
channel = 2;
}
else {
channel -= 1;
}
return channel;
}
onSqGosub(channel, line) {
channel = this.vmInRangeRound(channel, 1, 4, "ON SQ GOSUB");
if (channel === 3) {
throw this.vmComposeError(Error(), 5, "ON SQ GOSUB " + channel); // Improper argument
}
channel = CpcVm.fnChannel2ChannelIndex(channel);
const sqTimer = this.sqTimer[channel];
sqTimer.line = this.vmLineInRange(line, "ON SQ GOSUB");
sqTimer.active = true;
sqTimer.repeat = true; // means reloaded for sq
}
vmOpeninCallback(input) {
if (input !== null) {
const inFile = this.inFile, eolStr = input.indexOf("\r\n") > 0 ? "\r\n" : "\n"; // heuristic: if CRLF found, use it as split
if (input.endsWith(eolStr)) {
input = input.substring(0, input.length - eolStr.length); // remove last eol marker (also for data files)
}
inFile.fileData = input.split(eolStr);
}
else {
this.closein();
}
}
openin(name) {
name = this.vmAdaptFilename(name, "OPENIN");
const inFile = this.inFile;
if (!inFile.open) {
if (name) {
inFile.open = true;
inFile.command = "openin";
inFile.name = name;
inFile.fnFileCallback = this.fnOpeninHandler;
this.vmStop("fileLoad", 90);
}
}
else {
throw this.vmComposeError(Error(), 27, "OPENIN " + inFile.name); // file already open
}
}
openout(name) {
const outFile = this.outFile;
if (outFile.open) {
throw this.vmComposeError(Error(), 27, "OPENOUT " + outFile.name); // file already open
}
name = this.vmAdaptFilename(name, "OPENOUT");
outFile.open = true;
outFile.command = "openout";
outFile.name = name;
outFile.fileData.length = 0; // no data yet
outFile.typeString = "A"; // ASCII
}
origin(xOff, yOff, xLeft, xRight, yTop, yBottom) {
xOff = this.vmInRangeRound(xOff, -32768, 32767, "ORIGIN");
yOff = this.vmInRangeRound(yOff, -32768, 32767, "ORIGIN");
this.canvas.setOrigin(xOff, yOff);
if (xLeft !== undefined) {
xLeft = this.vmInRangeRound(xLeft, -32768, 32767, "ORIGIN");
xRight = this.vmInRangeRound(xRight, -32768, 32767, "ORIGIN");
yTop = this.vmInRangeRound(yTop, -32768, 32767, "ORIGIN");
yBottom = this.vmInRangeRound(yBottom, -32768, 32767, "ORIGIN");
this.canvas.setGWindow(xLeft, xRight, yTop, yBottom);
}
}
vmSetRamSelect(bank) {
if (!bank) {
this.ramSelect = 0;
}
else if (bank >= 4) {
this.ramSelect = bank - 3; // bank 4 gets position 1
}
}
vmSetCrtcData(crtcReg, byte) {
const crtcData = this.crtcData;
crtcData[crtcReg] = byte;
if (crtcReg === 12 || crtcReg === 13) { // screen offset changed
const offset = (((crtcData[12] || 0) & 0x03) << 9) | ((crtcData[13] || 0) << 1); // eslint-disable-line no-bitwise
this.vmSetScreenOffset(offset);
if (crtcReg === 12) { // scren base?
this.vmSetScreenBase((byte << 2) & 0xc0); // eslint-disable-line no-bitwise
}
}
}
out(port, byte) {
port = this.vmRound2Complement(port, "OUT");
byte = this.vmInRangeRound(byte, 0, 255, "OUT");
const portHigh = port >> 8; // eslint-disable-line no-bitwise
if (portHigh === 0x7f) { // 7Fxx = RAM select
this.vmSetRamSelect(byte - 0xc0);
}
else if (portHigh === 0xbc) { // limited support for CRTC 12, 13
this.crtcReg = byte % 14;
}
else if (portHigh === 0xbd) {
this.vmSetCrtcData(this.crtcReg, byte);
}
else if (Utils.debug > 0) {
Utils.console.debug("OUT", Number(port).toString(16), byte, ": unknown port");
}
}
paper(stream, paper) {
stream = this.vmInRangeRound(stream, 0, 7, "PAPER");
paper = this.vmInRangeRound(paper, 0, 15, "PAPER");
const win = this.windowDataList[stream], modeData = CpcVm.modeData[this.modeValue];
win.paper = paper % modeData.pens; // limit to available pens
}
vmGetCharDataByte(addr) {
const dataPos = (addr - 1 - this.minCharHimem) % 8, char = this.minCustomChar + (addr - 1 - dataPos - this.minCharHimem) / 8, charData = this.canvas.getCharData(char);
return charData[dataPos];
}
vmSetCharDataByte(addr, byte) {
const dataPos = (addr - 1 - this.minCharHimem) % 8, char = this.minCustomChar + (addr - 1 - dataPos - this.minCharHimem) / 8, charData = this.canvas.getCharData(char), charDataCopy = charData.slice(); // we need a copy to not modify original data
charDataCopy[dataPos] = byte; // change one byte
this.canvas.setCustomChar(char, charDataCopy);
}
peek(addr) {
addr = this.vmRound2Complement(addr, "PEEK");
const page = addr >> 14; // eslint-disable-line no-bitwise
let byte;
if (page === this.screenPage) { // screen memory page?
byte = this.canvas.getByte(addr); // get byte from screen memory
if (byte === null) { // byte not visible on screen?
byte = this.mem[addr] || 0; // get it from our memory
}
}
else if (page === 1 && this.ramSelect) { // memory mapped RAM with page 1=0x4000..0x7fff?
addr = (this.ramSelect - 1) * 0x4000 + 0x10000 + addr;
byte = this.mem[addr] || 0;
}
else if (addr > this.minCharHimem && addr <= this.maxCharHimem) { // character map; TODO: can also be in memory mapped area
byte = this.vmGetCharDataByte(addr);
}
else {
byte = this.mem[addr] || 0;
}
return byte;
}
pen(stream, pen, transparent) {
stream = this.vmInRangeRound(stream, 0, 7, "PEN");
if (pen !== undefined) {
const win = this.windowDataList[stream], modeData = CpcVm.modeData[this.modeValue];
pen = this.vmInRangeRound(pen, 0, 15, "PEN");
win.pen = pen % modeData.pens; // limit to available pens
}
if (transparent !== undefined) {
transparent = this.vmInRangeRound(transparent, 0, 1, "PEN");
this.vmSetTransparentMode(stream, transparent);
}
}
pi() {
return Math.PI; // or less precise: 3.14159265
}
plot(x, y, gPen, gColMode) {
x = this.vmInRangeRound(x, -32768, 32767, "PLOT");
y = this.vmInRangeRound(y, -32768, 32767, "PLOT");
this.vmDrawMovePlot("PLOT", gPen, gColMode);
this.canvas.plot(x, y);
}
plotr(x, y, gPen, gColMode) {
x = this.vmInRangeRound(x, -32768, 32767, "PLOTR") + this.canvas.getXpos();
y = this.vmInRangeRound(y, -32768, 32767, "PLOTR") + this.canvas.getYpos();
this.vmDrawMovePlot("PLOTR", gPen, gColMode);
this.canvas.plot(x, y);
}
vmSetMem(addr, byte) {
this.mem[addr] = byte;
}
poke(addr, byte) {
addr = this.vmRound2Complement(addr, "POKE address");
byte = this.vmInRangeRound(byte, 0, 255, "POKE byte");
const page = addr >> 14; // eslint-disable-line no-bitwise
if (page === 1 && this.ramSelect) { // memory mapped RAM with page 1=0x4000..0x7fff?
addr = (this.ramSelect - 1) * 0x4000 + 0x10000 + addr;
}
else if (page === this.screenPage) { // screen memory page?
this.canvas.setByte(addr, byte); // write byte also to screen memory
}
else if (addr > this.minCharHimem && addr <= this.maxCharHimem) { // character map; TODO: can also be in memory mapped area
this.vmSetCharDataByte(addr, byte);
}
this.mem[addr] = byte;
}
pos(stream) {
stream = this.vmInRangeRound(stream, 0, 9, "POS");
let pos;
if (stream < 8) {
pos = this.vmGetAllowedPosOrVpos(stream, false) + 1; // get allowed pos
}
else if (stream === 8) { // printer position (starting with 1)
pos = 1; // TODO
}
else { // stream 9: number of characters written since last CR (\r), \n in CpcEmu, starting with one)
const win = this.windowDataList[stream];
pos = win.pos + 1;
}
return pos;
}
vmGetAllowedPosOrVpos(stream, vpos) {
const win = this.windowDataList[stream], left = win.left, right = win.right, top = win.top, bottom = win.bottom;
let x = win.pos, y = win.vpos;
if (x > (right - left)) {
y += 1;
x = 0;
}
if (x < 0) {
y -= 1;
x = right - left;
}
if (!vpos) {
return x;
}
if (y < 0) {
y = 0;
}
if (y > (bottom - top)) {
y = bottom - top;
}
return y;
}
vmMoveCursor2AllowedPos(stream) {
const win = this.windowDataList[stream], left = win.left, right = win.right, top = win.top, bottom = win.bottom;
let x = win.pos, y = win.vpos;
if (x > (right - left)) {
y += 1;
x = 0;
this.vmPrint2OutBuffer("\n");
}
if (x < 0) {
y -= 1;
x = right - left;
}
if (y < 0) {
y = 0;
if (stream < 8) {
this.canvas.windowScrollDown(left, right, top, bottom, win.paper);
}
}
if (y > (bottom - top)) {
y = bottom - top;
if (stream < 8) {
this.canvas.windowScrollUp(left, right, top, bottom, win.paper);
}
}
win.pos = x;
win.vpos = y;
}
vmPrintChars(stream, str) {
const win = this.windowDataList[stream];
if (!win.textEnabled) {
if (Utils.debug > 0) {
Utils.console.debug("vmPrintChars: text output disabled:", str);
}
return;
}
this.vmMoveCursor2AllowedPos(stream);
if (win.pos && (win.pos + str.length > (win.right + 1 - win.left))) {
win.pos = 0;
win.vpos += 1; // "\r\n", newline if string does not fit in line
}
for (let i = 0; i < str.length; i += 1) {
const char = CpcVm.vmGetCpcCharCode(str.charCodeAt(i));
this.vmMoveCursor2AllowedPos(stream);
this.canvas.printChar(char, win.pos + win.left, win.vpos + win.top, win.pen, win.paper, win.transparent);
win.pos += 1;
}
}
vmControlSymbol(para) {
const paraList = [];
for (let i = 0; i < para.length; i += 1) {
paraList.push(para.charCodeAt(i));
}
while (paraList.length < 9) { // fill up with 0 (1xchar, 8xchardata)
paraList.push(0);
}
const char = paraList[0];
if (char >= this.minCustomChar) {
this.symbol.apply(this, paraList);
}
else if (Utils.debug > 0) {
Utils.console.debug("vmControlSymbol: define SYMBOL ignored:", char);
}
}
vmControlWindow(para, stream) {
const paraList = [];
for (let i = 0; i < para.length; i += 1) {
let value = para.charCodeAt(i) + 1; // control ranges start with 0!
value %= 256;
if (!value) {
value = 1; // avoid error
}
paraList.push(value);
}
this.window(stream, paraList[0], paraList[1], paraList[2], paraList[3]);
}
vmHandleControlCode(code, para, stream) {
const win = this.windowDataList[stream], out = ""; // no controls for text window
switch (code) {
case 0x00: // NUL, ignore
break;
case 0x01: // SOH 0-255
this.vmPrintChars(stream, para);
break;
case 0x02: // STX
win.cursorEnabled = false; // cursor disable (user)
break;
case 0x03: // ETX
win.cursorEnabled = true; // cursor enable (user)
break;
case 0x04: // EOT 0-3 (on CPC: 0-2, 3 is ignored; really mod 4)
this.mode(para.charCodeAt(0) & 0x03); // eslint-disable-line no-bitwise
break;
case 0x05: // ENQ
this.vmPrintGraphChars(para);
break;
case 0x06: // ACK
win.cursorEnabled = true;
win.textEnabled = true;
break;
case 0x07: // BEL
this.sound(135, 90, 20, 12, 0, 0, 0);
break;
case 0x08: // BS
this.vmMoveCursor2AllowedPos(stream);
win.pos -= 1;
break;
case 0x09: // TAB
this.vmMoveCursor2AllowedPos(stream);
win.pos += 1;
break;
case 0x0a: // LF
this.vmMoveCursor2AllowedPos(stream);
win.vpos += 1;
break;
case 0x0b: // VT
this.vmMoveCursor2AllowedPos(stream);
win.vpos -= 1;
break;
case 0x0c: // FF
this.cls(stream);
break;
case 0x0d: // CR
this.vmMoveCursor2AllowedPos(stream);
win.pos = 0;
break;
case 0x0e: // SO
this.paper(stream, para.charCodeAt(0) & 0x0f); // eslint-disable-line no-bitwise
break;
case 0x0f: // SI
this.pen(stream, para.charCodeAt(0) & 0x0f); // eslint-disable-line no-bitwise
break;
case 0x10: // DLE
this.vmMoveCursor2AllowedPos(stream);
this.canvas.fillTextBox(win.left + win.pos, win.top + win.vpos, 1, 1, win.paper); // clear character under cursor
break;
case 0x11: // DC1
this.vmMoveCursor2AllowedPos(stream);
this.canvas.fillTextBox(win.left, win.top + win.vpos, win.pos + 1, 1, win.paper); // clear line up to cursor
break;
case 0x12: // DC2
this.vmMoveCursor2AllowedPos(stream);
this.canvas.fillTextBox(win.left + win.pos, win.top + win.vpos, win.right - win.left + 1 - win.pos, 1, win.paper); // clear line from cursor
break;
case 0x13: // DC3
this.vmMoveCursor2AllowedPos(stream);
this.canvas.fillTextBox(win.left, win.top, win.right - win.left + 1, win.top - win.vpos, win.paper); // clear window up to cursor line -1
this.canvas.fillTextBox(win.left, win.top + win.vpos, win.pos + 1, 1, win.paper); // clear line up to cursor (DC1)
break;
case 0x14: // DC4
this.vmMoveCursor2AllowedPos(stream);
this.canvas.fillTextBox(win.left + win.pos, win.top + win.vpos, win.right - win.left + 1 - win.pos, 1, win.paper); // clear line from cursor (DC2)
this.canvas.fillTextBox(win.left, win.top + win.vpos + 1, win.right - win.left + 1, win.bottom - win.top - win.vpos, win.paper); // clear window from cursor line +1
break;
case 0x15: // NAK
win.cursorEnabled = false;
win.textEnabled = false;
break;
case 0x16: // SYN
this.vmSetTransparentMode(stream, para.charCodeAt(0) & 0x01); // eslint-disable-line no-bitwise
break;
case 0x17: // ETB
this.canvas.setGColMode(para.charCodeAt(0) % 4);
break;
case 0x18: // CAN
this.vmTxtInverse(stream);
break;
case 0x19: // EM
this.vmControlSymbol(para);
break;
case 0x1a: // SUB
this.vmControlWindow(para, stream);
break;
case 0x1b: // ESC, ignored
break;
case 0x1c: // FS
this.ink(para.charCodeAt(0) & 0x0f, para.charCodeAt(1) & 0x1f, para.charCodeAt(2) & 0x1f); // eslint-disable-line no-bitwise
break;
case 0x1d: // GS
this.border(para.charCodeAt(0) & 0x1f, para.charCodeAt(1) & 0x1f); // eslint-disable-line no-bitwise
break;
case 0x1e: // RS
win.pos = 0;
win.vpos = 0;
break;
case 0x1f: // US
this.vmLocate(stream, CpcVm.vmGetCharCodeAt(para, 0), CpcVm.vmGetCharCodeAt(para, 1));
break;
default:
Utils.console.warn("vmHandleControlCode: Unknown control code:", code);
break;
}
return out;
}
vmPrintCharsOrControls(stream, str) {
let buf = "", out = "", i = 0;
while (i < str.length) {
const code = CpcVm.vmGetCharCodeAt(str, i);
i += 1;
if (code <= 0x1f) { // control code?
if (out !== "") {
this.vmPrintChars(stream, out); // print chars collected so far
out = "";
}
const paraCount = CpcVm.controlCodeParameterCount[code];
if (i + paraCount <= str.length) {
out += this.vmHandleControlCode(code, str.substring(i, i + paraCount), stream);
i += paraCount;
}
else {
buf = str.substring(i - 1); // not enough parameters, put code in buffer and wait for more
i = str.length;
}
}
else {
out += String.fromCharCode(code);
}
}
if (out !== "") {
this.vmPrintChars(stream, out); // print chars collected so far
}
return buf;
}
vmPrintGraphChars(str) {
for (let i = 0; i < str.length; i += 1) {
const char = CpcVm.vmGetCpcCharCode(str.charCodeAt(i));
this.canvas.printGChar(char);
}
}
print(stream, ...args) {
stream = this.vmInRangeRound(stream, 0, 9, "PRINT");
const win = this.windowDataList[stream];
if (stream < 8) {
if (!win.tag) {
this.vmDrawUndrawCursor(stream); // undraw
}
}
else if (stream === 9) {
if (!this.outFile.open) {
throw this.vmComposeError(Error(), 31, "PRINT #" + stream); // File not open
}
this.outFile.stream = stream;
}
let buf = this.printControlBuf;
for (let i = 0; i < args.length; i += 1) {
const arg = args[i];
let str;
if (typeof arg === "object") { // delayed call for spc(), tab(), commaTab() with side effect (position)
const specialArgs = arg.args;
switch (arg.type) {
case "commaTab":
str = this.commaTab(stream);
break;
case "spc":
str = this.spc(stream, specialArgs[0]);
break;
case "tab":
str = this.tab(stream, specialArgs[0]);
break;
default:
throw this.vmComposeError(Error(), 5, "PRINT " + arg.type); // Improper argument
}
}
else if (typeof arg === "number") {
str = ((arg >= 0) ? " " : "") + Utils.toPrecision9(arg) + " ";
}
else { // e.g. string
str = String(arg);
}
if (stream < 8) {
if (win.tag) {
this.vmPrintGraphChars(str);
}
else {
if (buf.length) {
str = buf + str;
}
buf = this.vmPrintCharsOrControls(stream, str);
}
this.vmPrint2OutBuffer(str); // console
}
else if (stream === 8) { // printer?
this.vmPrint2OutBuffer(str); // put also in console
}
else { // stream === 9
const lastCrPos = buf.lastIndexOf("\r");
if (lastCrPos >= 0) {
win.pos = str.length - lastCrPos; // number of characters written since last CR (\r)
}
else {
win.pos += str.length;
}
if (str === "\r\n") {
win.pos = 0;
}
if (win.pos >= win.right) {
str = "\r\n" + str; // e.g. after tab(256)
win.pos = 0;
}
buf += str;
}
}
if (stream < 8) {
if (!win.tag) {
this.vmDrawUndrawCursor(stream); // draw cursor
this.printControlBuf = buf; // maybe some parameters missing
}
}
else if (stream === 9) {
this.outFile.fileData.push(buf);
}
}
rad() {
this.degFlag = false;
}
static vmHashCode(s) {
let hash = 0;
/* eslint-disable no-bitwise */
for (let i = 0; i < s.length; i += 1) {
hash += s.charCodeAt(i);
hash += hash << 10;
hash ^= hash >> 6;
}
hash += hash << 3;
hash ^= hash >> 11;
hash += hash << 15;
/* eslint-enable no-bitwise */
return hash;
}
vmRandomizeCallback() {
const inputParas = this.vmGetStopObject().paras, input = inputParas.input, value = this.vmVal(input); // convert to number (also binary, hex)
let inputOk = true;
if (Utils.debug > 0) {
Utils.console.debug("vmRandomizeCallback:", input);
}
if (isNaN(value)) {
inputOk = false;
inputParas.input = "";
this.print(inputParas.stream, inputParas.message);
}
else {
this.vmSetInputValues([value]);
}
return inputOk;
}
randomize(n) {
const rndInit = 0x89656c07, // an arbitrary 32 bit number <> 0 (this one is used by the CPC)
stream = 0;
if (n === undefined) { // no argument? input...
const msg = "Random number seed ? ";
this.print(stream, msg);
const inputParas = {
command: "randomize",
stream: stream,
message: msg,
fnInputCallback: this.fnRandomizeCallbackHandler,
input: "",
line: this.line // to repeat in case of break
};
this.vmStop("waitInput", 45, false, inputParas);
}
else { // n can also be floating point, so compute a hash value of n
this.vmAssertNumber(n, "RANDOMIZE");
n = CpcVm.vmHashCode(String(n));
if (n === 0) {
n = rndInit;
}
if (Utils.debug > 1) {
Utils.console.debug("randomize:", n);
}
this.random.init(n);
}
}
read(varType) {
this.vmAssertString(varType, "READ");
const type = this.vmDetermineVarType(varType);
let item;
if (this.dataIndex < this.dataList.length) {
const dataItem = this.dataList[this.dataIndex];
this.dataIndex += 1;
if (dataItem === undefined) { // empty arg?
item = type === "$" ? "" : 0; // set arg depending on expected type
}
else if (type !== "$") { // not string expected? => convert to number (also binary, hex)
item = this.val(String(dataItem));
}
else {
item = dataItem;
}
item = this.vmAssign(varType, item); // maybe rounding for type I
}
else {
throw this.vmComposeError(Error(), 4, "READ"); // DATA exhausted
}
return item;
}
release(channelMask) {
channelMask = this.vmInRangeRound(channelMask, 0, 7, "RELEASE");
this.soundClass.release(channelMask);
}
remain(timerNumber) {
timerNumber = this.vmInRangeRound(timerNumber, 0, 3, "REMAIN");
const timerEntry = this.timerList[timerNumber];
let remain = 0;
if (timerEntry.active) {
remain = timerEntry.nextTimeMs - Date.now();
remain /= CpcVm.frameTimeMs;
timerEntry.active = false; // switch off timer
}
return remain;
}
renum(newLine = 10, oldLine = 1, step = 10, keep = 65535) {
newLine = this.vmInRangeRound(newLine, 1, 65535, "RENUM");
oldLine = this.vmInRangeRound(oldLine, 1, 65535, "RENUM");
step = this.vmInRangeRound(step, 1, 65535, "RENUM");
keep = this.vmInRangeRound(keep, 1, 65535, "RENUM");
const lineRenumParas = {
command: "renum",
stream: 0, // unused
line: this.line, // unused
newLine: newLine,
oldLine: oldLine,
step: step,
keep: keep // keep lines
};
this.vmStop("renumLines", 85, false, lineRenumParas);
}
restore(line) {
line = line === undefined ? 0 : this.vmLineInRange(line, "RESTORE");
const dataLineIndex = this.dataLineIndex;
if (line in dataLineIndex) {
this.dataIndex = dataLineIndex[line];
}
else {
if (Utils.debug > 0) {
Utils.console.debug("restore: search for dataLine >", line);
}
for (const dataLine in dataLineIndex) { // linear search a data line > line
if (dataLineIndex.hasOwnProperty(dataLine)) {
if (Number(dataLine) >= line) {
dataLineIndex[line] = dataLineIndex[dataLine]; // set data index also for line
break;
}
}
}
if (line in dataLineIndex) { // now found a data line?
this.dataIndex = dataLineIndex[line];
}
else {
if (Utils.debug > 0) {
Utils.console.debug("restore", line + ": No DATA found starting at line");
}
this.dataIndex = this.dataList.length;
}
}
}
resume(line) {
if (this.errorGotoLine) {
const label = line === undefined ? this.errorResumeLine : this.vmLineInRange(line, "RESUME");
this.vmGoto(label, "resume");
this.errorResumeLine = 0;
}
else {
throw this.vmComposeError(Error(), 20, String(line)); // Unexpected RESUME
}
}
resumeNext() {
if (!this.errorGotoLine || !this.errorResumeLine) {
throw this.vmComposeError(Error(), 20, "RESUME NEXT"); // Unexpected RESUME
}
const resumeLineIndex = this.labelList.indexOf(this.errorResumeLine);
if (resumeLineIndex < 0) {
Utils.console.error("resumeNext: line not found: " + this.errorResumeLine);
this.errorResumeLine = 0;
return;
}
const line = this.labelList[resumeLineIndex + 1]; // get next line
this.vmGoto(line, "resumeNext");
this.errorResumeLine = 0;
}
"return"() {
const line = this.gosubStack.pop();
if (line === undefined) {
throw this.vmComposeError(Error(), 3, ""); // Unexpected Return [in <line>]
}
else {
this.vmGoto(line, "return");
}
if (line === this.breakResumeLine) { // end of break handler?
this.breakResumeLine = 0; // can start another one
}
this.vmCheckTimerHandlers(); // if we are at end of a BASIC timer handler, delete handler flag
if (this.vmCheckSqTimerHandlers()) { // same for sq timers, timer reloaded?
this.fnCheckSqTimer(); // next one early
}
}
right$(s, len) {
this.vmAssertString(s, "RIGHT$");
len = this.vmInRangeRound(len, 0, 255, "RIGHT$");
return s.substring(s.length - len);
}
rnd(n) {
if (n !== undefined) {
this.vmAssertNumber(n, "RND");
}
let x;
if (n === undefined || n > 0) {
x = this.random.random();
this.lastRnd = x;
}
else if (n < 0) {
x = this.lastRnd || this.random.random();
}
else { // n === 0
x = this.lastRnd || this.random.random();
}
return x;
}
round(n, decimals) {
this.vmAssertNumber(n, "ROUND");
decimals = this.vmInRangeRound(decimals || 0, -39, 39, "ROUND");
const maxDecimals = 20 - Math.floor(Math.log10(n)); // limit for JS
if (decimals >= 0 && decimals > maxDecimals) {
decimals = maxDecimals;
}
return Math.sign(n) * Number(Math.round(Number(Math.abs(n) + "e" + decimals)) + "e" + ((decimals >= 0) ? "-" + decimals : "+" + -decimals));
}
vmRunCallback(input, meta) {
const inFile = this.inFile, putInMemory = input !== null && meta && (meta.typeString === "B" || inFile.start !== undefined);
if (input !== null) {
const lineParas = {
command: "run",
stream: 0, // unused
first: inFile.line,
last: 0, // unused
line: this.line
};
this.vmStop("run", 95, false, lineParas);
}
this.closein();
return putInMemory;
}
run(numOrString) {
const inFile = this.inFile;
if (typeof numOrString === "string") { // filename?
const name = this.vmAdaptFilename(numOrString, "RUN");
this.closein();
inFile.open = true;
inFile.command = "run";
inFile.name = name;
inFile.start = undefined;
inFile.fnFileCallback = this.fnRunHandler;
this.vmStop("fileLoad", 90);
}
else { // line number or no argument = undefined
if (numOrString !== undefined) {
this.vmLineInRange(numOrString, "RUN");
}
const lineParas = {
command: "run",
stream: 0, // unused
first: numOrString || 0,
last: 0, // unused
line: this.line
};
this.vmStop("run", 95, false, lineParas);
}
}
save(name, type, start, length, entry) {
const outFile = this.outFile;
name = this.vmAdaptFilename(name, "SAVE");
if (!type) {
type = "T"; // default is tokenized BASIC
}
else {
type = String(type).toUpperCase();
}
const fileData = outFile.fileData;
fileData.length = 0;
if (type === "B") { // binary
start = this.vmRound2Complement(start, "SAVE");
length = this.vmRound2Complement(length, "SAVE");
if (entry !== undefined) {
entry = this.vmRound2Complement(entry, "SAVE");
}
for (let i = 0; i < length; i += 1) {
const address = (start + i) & 0xffff; // eslint-disable-line no-bitwise
fileData[i] = String.fromCharCode(this.peek(address));
}
}
else if ((type === "A" || type === "T" || type === "P") && start === undefined) {
start = 368; // BASIC start
}
else {
throw this.vmComposeError(Error(), 2, "SAVE " + type); // Syntax Error
}
outFile.open = true;
outFile.command = "save";
outFile.name = name;
outFile.typeString = type;
outFile.start = start;
outFile.length = length || 0;
outFile.entry = entry || 0;
outFile.fnFileCallback = this.fnCloseoutHandler; // we use closeout handler to reset out file handling
this.vmStop("fileSave", 90); // must stop directly after save
}
sgn(n) {
this.vmAssertNumber(n, "SGN");
return Math.sign(n);
}
sin(n) {
this.vmAssertNumber(n, "SIN");
return Math.sin((this.degFlag) ? Utils.toRadians(n) : n);
}
sound(state, period, duration, volume, volEnv, toneEnv, noise) {
state = this.vmInRangeRound(state, 1, 255, "SOUND");
period = this.vmInRangeRound(period, 0, 4095, "SOUND ,");
const soundData = {
state: state,
period: period,
duration: (duration !== undefined) ? this.vmInRangeRound(duration, -32768, 32767, "SOUND ,,") : 20,
volume: (volume !== undefined) ? this.vmInRangeRound(volume, 0, 15, "SOUND ,,,") : 12,
volEnv: (volEnv !== undefined) ? this.vmInRangeRound(volEnv, 0, 15, "SOUND ,,,,") : 0,
toneEnv: (toneEnv !== undefined) ? this.vmInRangeRound(toneEnv, 0, 15, "SOUND ,,,,,") : 0,
noise: (noise !== undefined) ? this.vmInRangeRound(noise, 0, 31, "SOUND ,,,,,,") : 0
};
if (this.soundClass.testCanQueue(state)) {
this.soundClass.sound(soundData);
}
else {
this.soundData.push(soundData);
this.vmStop("waitSound", 43);
for (let i = 0; i < 3; i += 1) {
if (state & (1 << i)) { // eslint-disable-line no-bitwise
const sqTimer = this.sqTimer[i];
sqTimer.active = false; // set onSq timer to inactive
}
}
}
}
space$(n) {
n = this.vmInRangeRound(n, 0, 255, "SPACE$");
return " ".repeat(n);
}
spc(stream, n) {
stream = this.vmInRangeRound(stream, 0, 9, "SPC");
n = this.vmInRangeRound(n, -32768, 32767, "SPC");
let str = "";
if (n >= 0) {
const win = this.windowDataList[stream], width = win.right - win.left + 1;
if (width) {
n %= width;
}
str = " ".repeat(n);
}
else if (!this.quiet) {
Utils.console.log("SPC: negative number ignored:", n);
}
return str;
}
speedInk(time1, time2) {
time1 = this.vmInRangeRound(time1, 1, 255, "SPEED INK");
time2 = this.vmInRangeRound(time2, 1, 255, "SPEED INK");
this.canvas.setSpeedInk(time1, time2);
}
speedKey(delay, repeat) {
delay = this.vmInRangeRound(delay, 1, 255, "SPEED KEY");
repeat = this.vmInRangeRound(repeat, 1, 255, "SPEED KEY");
this.vmNotImplemented("SPEED KEY " + delay + " " + repeat);
}
speedWrite(n) {
n = this.vmInRangeRound(n, 0, 1, "SPEED WRITE");
this.vmNotImplemented("SPEED WRITE " + n);
}
sq(channel) {
channel = this.vmInRangeRound(channel, 1, 4, "SQ");
if (channel === 3) {
throw this.vmComposeError(Error(), 5, "SQ " + channel); // Improper argument
}
channel = CpcVm.fnChannel2ChannelIndex(channel);
const sq = this.soundClass.sq(channel), sqTimer = this.sqTimer[channel];
if (!(sq & 0x07) && sqTimer.active) { // eslint-disable-line no-bitwise
sqTimer.active = false; // set onSq timer to inactive
}
return sq;
}
sqr(n) {
this.vmAssertNumber(n, "SQR");
if (n < 0) {
throw this.vmComposeError(Error(), 5, "SQR " + n); // Improper argument
}
return Math.sqrt(n);
}
stop(label) {
this.vmGoto(label, "stop");
this.vmStop("stop", 60);
}
str$(n) {
this.vmAssertNumber(n, "STR$");
return ((n >= 0) ? " " : "") + String(n);
}
string$(len, chr) {
len = this.vmInRangeRound(len, 0, 255, "STRING$");
if (typeof chr === "number") {
chr = this.vmInRangeRound(chr, 0, 255, "STRING$");
chr = String.fromCharCode(chr); // chr$
}
else { // expect string
this.vmAssertString(chr, "STRING$");
chr = chr.charAt(0); // only one char
}
return chr.repeat(len);
}
symbol(char, ...args) {
char = this.vmInRangeRound(char, this.minCustomChar, 255, "SYMBOL");
const charData = [];
for (let i = 0; i < args.length; i += 1) { // get available args
const bitMask = this.vmInRangeRound(args[i], 0, 255, "SYMBOL");
charData.push(bitMask);
}
while (charData.length < 8) { // fill up with 0 (1xchar, 8xchardata)
charData.push(0);
}
this.canvas.setCustomChar(char, charData);
}
symbolAfter(char) {
char = this.vmInRangeRound(char, 0, 256, "SYMBOL AFTER");
if (this.minCustomChar < 256) { // symbol after <256 set?
if (this.minCharHimem !== this.himemValue) { // himem changed?
throw this.vmComposeError(Error(), 5, "SYMBOL AFTER " + char); // Improper argument
}
}
else {
this.maxCharHimem = this.himemValue; // no characters defined => use current himem
}
let minCharHimem = this.maxCharHimem - (256 - char) * 8;
if (minCharHimem < this.progEnd) {
throw this.vmComposeError(Error(), 7, "SYMBOL AFTER " + minCharHimem); // Memory full
}
this.himemValue = minCharHimem;
this.canvas.resetCustomChars();
if (char === 256) { // maybe move up again
minCharHimem = CpcVm.maxHimem;
this.maxCharHimem = minCharHimem;
}
this.minCustomChar = char;
this.minCharHimem = minCharHimem;
}
tab(stream, n) {
stream = this.vmInRangeRound(stream, 0, 9, "TAB");
n = this.vmInRangeRound(n, -32768, 32767, "TAB");
let str = "";
if (n > 0) {
n -= 1;
const win = this.windowDataList[stream], width = win.right - win.left + 1;
if (width) {
n %= width;
}
let count = n - win.pos;
if (count < 0) { // does it fit until tab position?
win.pos = win.right + 1;
this.vmMoveCursor2AllowedPos(stream);
count = n; // set tab in next line
}
str = " ".repeat(count);
}
else if (!this.quiet) {
Utils.console.log("TAB: no tab for value", n);
}
return str;
}
tag(stream) {
stream = this.vmInRangeRound(stream, 0, 7, "TAG");
const win = this.windowDataList[stream];
win.tag = true;
}
tagoff(stream) {
stream = this.vmInRangeRound(stream, 0, 7, "TAGOFF");
const win = this.windowDataList[stream];
win.tag = false;
}
tan(n) {
this.vmAssertNumber(n, "TAN");
return Math.tan((this.degFlag) ? Utils.toRadians(n) : n);
}
test(x, y) {
x = this.vmInRangeRound(x, -32768, 32767, "TEST");
y = this.vmInRangeRound(y, -32768, 32767, "TEST");
return this.canvas.test(x, y);
}
testr(x, y) {
x = this.vmInRangeRound(x, -32768, 32767, "TESTR") + this.canvas.getXpos();
y = this.vmInRangeRound(y, -32768, 32767, "TESTR") + this.canvas.getYpos();
return this.canvas.test(x, y);
}
time() {
return ((Date.now() - this.startTime) * 300 / 1000) | 0; // eslint-disable-line no-bitwise
}
troff() {
this.tronFlag1 = false;
}
tron() {
this.tronFlag1 = true;
}
unt(n) {
n = this.vmInRangeRound(n, -32768, 65535, "UNT");
if (n > 32767) { // two's complement
n -= 65536;
}
return n;
}
static fnUpperCase(match) {
return match.toUpperCase();
}
upper$(s) {
this.vmAssertString(s, "UPPER$");
return s.replace(/[a-z]/g, CpcVm.fnUpperCase); // replace only characters a-z
}
using(format, ...args) {
const reFormat = /(_|!|&|\\ *\\|(?:\*\*|\$\$|\*\*\$)?\+?(?:#|,)+\.?#*(?:\^\^\^\^)?[+-]?)/g, formatList = [];
this.vmAssertString(format, "USING");
let index = 0, match;
while ((match = reFormat.exec(format)) !== null) {
let nonFormChars = format.substring(index, match.index); // non-format characters at the beginning
if (match[0] === "_") { // underscore "_" is escape character
nonFormChars += format.charAt(match.index + 1) || "_"; // add escaped character
}
if (formatList.length % 2) { // odd?
formatList[formatList.length - 1] += nonFormChars;
}
else {
formatList.push(nonFormChars);
}
if (match[0] === "_") { // underscore "_" is escape character
reFormat.lastIndex += 1;
index = reFormat.lastIndex;
}
else {
formatList.push(match[0]);
index = match.index + match[0].length;
}
}
if (index < format.length) { // non-format characters at the end
const nonFormCharsEnd = format.substring(index);
if (formatList.length % 2) { // odd?
formatList[formatList.length - 1] += nonFormCharsEnd;
}
else {
formatList.push(nonFormCharsEnd);
}
}
if (formatList.length < 2) {
if (!this.quiet) {
Utils.console.warn("USING: empty or invalid format:", format);
}
throw this.vmComposeError(Error(), 5, "USING format " + format); // Improper argument
}
let formatIndex = 0, s = "";
for (let i = 0; i < args.length; i += 1) { // start with 1
formatIndex %= formatList.length;
if (formatIndex === 0) {
s += formatList[formatIndex]; // non-format characters at the beginning of the format string
formatIndex += 1;
}
if (formatIndex < formatList.length) {
const arg = args[i];
s += this.vmUsingFormat(formatList[formatIndex], arg); // format characters
formatIndex += 1;
}
if (formatIndex < formatList.length) {
s += formatList[formatIndex]; // following non-format characters
formatIndex += 1;
}
}
return s;
}
vmVal(s) {
let num = 0;
s = s.trim().toLowerCase();
if (s[0] === "&") {
if (s[1] === "x") { // binary &x
num = parseInt(s.slice(2), 2);
}
else {
if (s[1] === "h") { // hex &h
num = parseInt(s.slice(2), 16);
}
else { // hex &
num = parseInt(s.slice(1), 16);
}
if (num > 32767) { // two's complement
num -= 65536;
}
}
if (isNaN(num)) {
throw this.vmComposeError(Error(), 13, "VAL " + s); // Type mismatch
}
}
else if (s !== "") { // not empty string?
num = parseFloat(s);
if (isNaN(num)) {
if (s[0] === "-" || s[0] === ".") { // this characters must follow a valid number
throw this.vmComposeError(Error(), 13, "VAL " + s); // Type mismatch
}
}
}
return num;
}
val(s) {
this.vmAssertString(s, "VAL");
s = s.replace(/ /g, ""); // remove spaces
let num = this.vmVal(s);
if (isNaN(num)) {
num = 0;
}
return num;
}
vpos(stream) {
stream = this.vmInRangeRound(stream, 0, 7, "VPOS");
return this.vmGetAllowedPosOrVpos(stream, true) + 1;
}
wait(port, mask, inv) {
port = this.vmRound2Complement(port, "WAIT");
mask = this.vmInRangeRound(mask, 0, 255, "WAIT");
if (inv !== undefined) {
/* inv = */ this.vmInRangeRound(inv, 0, 255, "WAIT");
}
if ((port & 0xff00) === 0xf500) { // eslint-disable-line no-bitwise
if (mask === 1) {
this.frame();
}
}
}
width(width) {
width = this.vmInRangeRound(width, 1, 255, "WIDTH");
const win = this.windowDataList[8];
win.right = win.left + width;
}
static forceInRange(num, min, max) {
if (num < min) {
num = min;
}
else if (num > max) {
num = max;
}
return num;
}
window(stream, left, right, top, bottom) {
stream = this.vmInRangeRound(stream, 0, 7, "WINDOW");
left = this.vmInRangeRound(left, 1, 255, "WINDOW");
right = this.vmInRangeRound(right, 1, 255, "WINDOW");
top = this.vmInRangeRound(top, 1, 255, "WINDOW");
bottom = this.vmInRangeRound(bottom, 1, 255, "WINDOW");
const win = this.windowDataList[stream], winData = CpcVm.winData[this.modeValue];
win.left = CpcVm.forceInRange(Math.min(left, right) - 1, winData.left, winData.right);
win.right = CpcVm.forceInRange(Math.max(left, right) - 1, winData.left, winData.right);
win.top = CpcVm.forceInRange(Math.min(top, bottom) - 1, winData.top, winData.bottom);
win.bottom = CpcVm.forceInRange(Math.max(top, bottom) - 1, winData.top, winData.bottom);
win.pos = 0;
win.vpos = 0;
}
windowSwap(stream1, stream2) {
stream1 = this.vmInRangeRound(stream1, 0, 7, "WINDOW SWAP");
stream2 = this.vmInRangeRound(stream2 || 0, 0, 7, "WINDOW SWAP");
const temp = this.windowDataList[stream1];
this.windowDataList[stream1] = this.windowDataList[stream2];
this.windowDataList[stream2] = temp;
}
write(stream, ...args) {
stream = this.vmInRangeRound(stream, 0, 9, "WRITE");
const writeArgs = [];
let str;
for (let i = 0; i < args.length; i += 1) {
const arg = args[i];
if (typeof arg === "number") {
str = Utils.toPrecision9(arg);
}
else {
str = '"' + String(arg) + '"';
}
writeArgs.push(str);
}
str = writeArgs.join(",");
if (stream < 8) {
const win = this.windowDataList[stream];
if (win.tag) {
this.vmPrintGraphChars(str + "\r\n");
}
else {
this.vmDrawUndrawCursor(stream); // undraw
this.vmPrintCharsOrControls(stream, str);
this.vmPrintCharsOrControls(stream, "\r\n");
this.vmDrawUndrawCursor(stream); // draw
}
this.vmPrint2OutBuffer(str + "\n"); // console
}
else if (stream === 8) { // printer?
this.vmPrint2OutBuffer(str + "\n"); // console
}
else if (stream === 9) {
this.outFile.stream = stream;
if (!this.outFile.open) {
throw this.vmComposeError(Error(), 31, "WRITE #" + stream); // File not open
}
this.outFile.fileData.push(str + "\r\n"); // real CPC use CRLF
}
}
xpos() {
return this.canvas.getXpos();
}
ypos() {
return this.canvas.getYpos();
}
zone(n) {
this.zoneValue = this.vmInRangeRound(n, 1, 255, "ZONE");
}
vmTestGetTimerList() {
return this.timerList;
}
vmTestGetWindowDataList() {
return this.windowDataList;
}
/* eslint-disable no-invalid-this */
vmInternal = {
getTimerList: this.vmTestGetTimerList,
getWindowDataList: this.vmTestGetWindowDataList,
commaTab: this.commaTab,
spc: this.spc,
tab: this.tab
};
}
class Diff {
static composeError(error, message, value, pos) {
return Utils.composeError("Diff", error, message, value, pos, undefined, 0);
}
static inRange(x, l, r) {
return (l <= x && x <= r) || (r <= x && x <= l);
}
static fnEquals(a, b) {
return a === b;
}
static customIndexOf(arr, item, start, fnEquals) {
for (let i2 = start; i2 < arr.length; i2 += 1) {
if (fnEquals(item, arr[i2])) {
return i2;
}
}
return -1;
}
/* can we use it here? need to define aA, aB, lcsAtoms, findMidSnake():
private static lcs(startA: number, endA: number, startB: number, endB: number) {
const N = endA - startA + 1,
M = endB - startB + 1;
if (N > 0 && M > 0) {
const middleSnake = findMidSnake(startA, endA, startB, endB),
x = middleSnake[0][0],
y = middleSnake[0][1],
u = middleSnake[1][0],
v = middleSnake[1][1],
D = middleSnake[2];
if (D > 1) {
Diff.lcs(startA, x - 1, startB, y - 1);
if (x <= u) {
[].push.apply(lcsAtoms, aA.slice(x, u + 1));
}
lcs(u + 1, endA, v + 1, endB);
} else if (M > N) {
[].push.apply(lcsAtoms, aA.slice(startA, endA + 1));
} else {
[].push.apply(lcsAtoms, aB.slice(startB, endB + 1));
}
}
}
*/
static fnLCS(aA, aB, equals) {
const // Takes X-component as argument, diagonal as context, returns array-pair of form x, y
toPoint = function (x) {
return [
x,
x - this // eslint-disable-line no-invalid-this
]; // XXX context is not the best way to pass diagonal
},
findMidSnake = function (startA, endA, startB, endB) {
const iN = endA - startA + 1, iM = endB - startB + 1, max = iN + iM, delta = iN - iM, hhalfMaxCeil = (max + 1) / 2 | 0, // eslint-disable-line no-bitwise
oV = {},
oU = {};
let overlap, iD;
oV[1] = 0;
oU[delta - 1] = iN;
for (iD = 0; iD <= hhalfMaxCeil; iD += 1) {
for (let k = -iD; k <= iD && !overlap; k += 2) {
let x;
if (k === -iD || (k !== iD && oV[k - 1] < oV[k + 1])) {
x = oV[k + 1];
}
else {
x = oV[k - 1] + 1;
}
let y = x - k;
if (isNaN(y) || x > iN || y > iM) {
continue;
}
const xx = x;
while (x < iN && y < iM // if there are atoms to compare
&& equals(aA[startA + x], aB[startB + y])) {
x += 1;
y += 1;
}
oV[k] = x;
if ((delta & 1) === 1 && Diff.inRange(k, delta - (iD - 1), delta + (iD - 1))) { // eslint-disable-line no-bitwise
if (oV[k] >= oU[k]) {
overlap = [
xx,
x
].map(toPoint, k); // XXX ES5
}
}
}
let SES;
if (overlap) {
SES = iD * 2 - 1;
}
for (let k = -iD; k <= iD && !overlap; k += 2) {
const K = k + delta;
let x;
if (k === iD || (k !== -iD && oU[K - 1] < oU[K + 1])) {
x = oU[K - 1];
}
else {
x = oU[K + 1] - 1;
}
let y = x - K;
if (isNaN(y) || x < 0 || y < 0) {
continue;
}
const xx = x;
while (x > 0 && y > 0 && equals(aA[startA + x - 1], aB[startB + y - 1])) {
x -= 1;
y -= 1;
}
oU[K] = x;
if (delta % 2 === 0 && Diff.inRange(K, -iD, iD)) {
if (oU[K] <= oV[K]) {
overlap = [
x,
xx
].map(toPoint, K); // XXX ES5
}
}
}
if (overlap) {
SES = SES || iD * 2;
for (let i = 0; i < 2; i += 1) {
for (let j = 0; j < 2; j += 1) {
overlap[i][j] += [
startA,
startB
][j] - i;
}
}
return overlap.concat([
SES,
(max - SES) / 2
]);
}
}
throw Diff.composeError(Error(), "Programming error in findMidSnake", "", 0); // should not occur
}, lcsAtoms = [], lcs = function (startA, endA, startB, endB) {
const N = endA - startA + 1, M = endB - startB + 1;
if (N > 0 && M > 0) {
const middleSnake = findMidSnake(startA, endA, startB, endB),
x = middleSnake[0][0], y = middleSnake[0][1], u = middleSnake[1][0], v = middleSnake[1][1], D = middleSnake[2];
if (D > 1) {
lcs(startA, x - 1, startB, y - 1);
if (x <= u) {
[].push.apply(lcsAtoms, aA.slice(x, u + 1));
}
lcs(u + 1, endA, v + 1, endB);
}
else if (M > N) {
[].push.apply(lcsAtoms, aA.slice(startA, endA + 1));
}
else {
[].push.apply(lcsAtoms, aB.slice(startB, endB + 1));
}
}
};
lcs(0, aA.length - 1, 0, aB.length - 1);
return lcsAtoms;
}
static diff(aA, aB) {
const diff = [], fnEquals = Diff.fnEquals;
let i = 0, j = 0, iN = aA.length, iM = aB.length, iK = 0;
while (i < iN && j < iM && fnEquals(aA[i], aB[j])) {
i += 1;
j += 1;
}
while (i < iN && j < iM && fnEquals(aA[iN - 1], aB[iM - 1])) {
iN -= 1;
iM -= 1;
iK += 1;
}
[].push.apply(diff, aA.slice(0, i).map(function (atom2) {
return {
operation: "none",
atom: atom2
};
}));
const lcs = Diff.fnLCS(aA.slice(i, iN), aB.slice(j, iM), fnEquals);
for (let k = 0; k < lcs.length; k += 1) {
const atom = lcs[k], ni = Diff.customIndexOf(aA, atom, i, fnEquals), nj = Diff.customIndexOf(aB, atom, j, fnEquals);
[].push.apply(diff, aA.slice(i, ni).map(function (atom2) {
return {
operation: "delete",
atom: atom2
};
}));
[].push.apply(diff, aB.slice(j, nj).map(function (atom2) {
return {
operation: "add",
atom: atom2
};
}));
diff.push({
operation: "none",
atom: atom
});
i = ni + 1;
j = nj + 1;
}
[].push.apply(diff, aA.slice(i, iN).map(function (atom2) {
return {
operation: "delete",
atom: atom2
};
}));
[].push.apply(diff, aB.slice(j, iM).map(function (atom2) {
return {
operation: "add",
atom: atom2
};
}));
[].push.apply(diff, aA.slice(iN, iN + iK).map(function (atom2) {
return {
operation: "none",
atom: atom2
};
}));
return diff;
}
static testDiff(text1, text2) {
const textParts1 = text1.split("\n"), textParts2 = text2.split("\n");
let diff = Diff.diff(textParts1, textParts2).map(function (o) {
let result = "";
if (o.operation === "add") {
result = "+ " + o.atom;
}
else if (o.operation === "delete") {
result = "- " + o.atom;
} // else "none"
return result;
}).join("\n");
diff = diff.replace(/\n\n+/g, "\n");
return diff;
}
}
class DiskImage {
options;
diskInfo;
formatDescriptor;
constructor(options) {
this.diskInfo = DiskImage.getInitialDiskInfo();
this.options = {
data: "",
quiet: false
};
this.setOptions(options);
}
getOptions() {
return this.options;
}
setOptions(options) {
const currentData = this.options.data;
Object.assign(this.options, options);
if (this.options.data !== currentData) { // changed?
this.diskInfo.ident = ""; // invalidate diskinfo
this.diskInfo.trackInfo.ident = ""; // invalidate trackinfo
}
}
static twoHeads = "2h";
static formatDescriptors = {
data: {
tracks: 40, // number of tracks (1-85)
heads: 1, // number of heads/sides (1-2)
bps: 2, // Bytes per Sector (1-5)
spt: 9, // Sectors per Track (1-18)
gap3: 0x4e, // gap between ID and data
fill: 0xe5, // filler byte
firstSector: 0xc1, // first sector number
bls: 1024, // BLS: data block allocaton size (1024, 2048, 4096, 8192, 16384)
al0: 0xc0, // bit significant representation of reserved directory blocks 0..7 (0x80=0, 0xc00=0 and 1,,...)
al1: 0x00, // bit significant representation of reserved directory blocks 8..15 (0x80=8,...)
off: 0 // number of reserved tracks (also the track where the directory starts)
},
data42t: {
parentRef: "data",
tracks: 42
},
data2h: {
parentRef: "data",
heads: 2
},
system: {
parentRef: "data",
firstSector: 0x41,
off: 2
},
system2h: {
parentRef: "system",
heads: 2
},
vortex: {
parentRef: "data",
tracks: 80,
heads: 2,
firstSector: 0x01
},
"3dos": {
parentRef: "data",
firstSector: 0x00
},
parados80: {
parentRef: "data",
tracks: 80,
firstSector: 0x91,
spt: 10,
bls: 2048
},
big780k: {
parentRef: "data",
al0: 0x80, // block 0 reserved
tracks: 80,
off: 1,
firstSector: 0x01
},
big780k2h: {
parentRef: "big780k",
heads: 2
}
};
static getInitialDiskInfo() {
const diskInfo = {
ident: "",
creator: "",
tracks: 0,
heads: 0,
trackSize: 0,
trackInfo: {
ident: "",
sectorInfoList: []
},
trackSizes: [],
trackInfoPosList: [],
extended: false
};
return diskInfo;
}
getFormatDescriptor() {
const formatDescriptor = this.formatDescriptor;
if (!formatDescriptor) {
throw this.composeError(Error(), "getFormatDescriptor: formatDescriptor:", String(formatDescriptor));
}
return formatDescriptor;
}
composeError(error, message, value, pos) {
const len = 0;
return Utils.composeError("DiskImage", error, this.options.diskName + ": " + message, value, pos || 0, len);
}
static diskInfoIdentMap = {
"MV - CPC": 1,
EXTENDED: 2
};
static testDiskIdent(ident) {
const diskType = DiskImage.diskInfoIdentMap[ident] || 0;
return diskType;
}
readUtf(pos, len) {
const out = this.options.data.substring(pos, pos + len);
if (out.length !== len) {
throw this.composeError(new Error(), "End of File", "", pos);
}
return out;
}
readUInt8(pos) {
const num = this.options.data.charCodeAt(pos);
if (isNaN(num)) {
throw this.composeError(new Error(), "End of File", String(num), pos);
}
return num;
}
readUInt16(pos) {
return this.readUInt8(pos) + this.readUInt8(pos + 1) * 256;
}
static uInt8ToString(value) {
return String.fromCharCode(value);
}
static uInt16ToString(value) {
return DiskImage.uInt8ToString(value & 0xff) + DiskImage.uInt8ToString((value >> 8) & 0xff); // eslint-disable-line no-bitwise
}
static uInt24ToString(value) {
return DiskImage.uInt16ToString(value & 0xffff) + DiskImage.uInt8ToString(value >> 16); // eslint-disable-line no-bitwise
}
static diskInfoSize = 0x100;
readDiskInfo(diskInfo, pos) {
const ident = this.readUtf(pos, 8), // check first 8 characters as characteristic
diskType = DiskImage.testDiskIdent(ident);
if (!diskType) {
throw this.composeError(Error(), "Ident not found", ident, pos);
}
diskInfo.extended = (diskType === 2);
diskInfo.ident = ident + this.readUtf(pos + 8, 34 - 8); // read remaining ident
if (diskInfo.ident.substring(34 - 11, 34 - 11 + 9) !== "Disk-Info") { // some tools use "Disk-Info  " instead of "Disk-Info\r\n", so compare without "\r\n"
if (!this.options.quiet) {
Utils.console.warn(this.composeError({}, "Disk ident not found", diskInfo.ident.substring(34 - 11, 34 - 11 + 9), pos + 34 - 11).message);
}
}
diskInfo.creator = this.readUtf(pos + 34, 14);
diskInfo.tracks = this.readUInt8(pos + 48);
diskInfo.heads = this.readUInt8(pos + 49);
diskInfo.trackSize = this.readUInt16(pos + 50);
const trackSizes = [], trackInfoPosList = [], trackSizeCount = diskInfo.tracks * diskInfo.heads; // number of track sizes
let trackInfoPos = DiskImage.diskInfoSize;
pos += 52; // track sizes high bytes start at offset 52 (0x35)
for (let i = 0; i < trackSizeCount; i += 1) {
trackInfoPosList.push(trackInfoPos);
const trackSize = diskInfo.trackSize || (this.readUInt8(pos + i) * 256); // take common track size or read individual track size (extended)
trackSizes.push(trackSize);
trackInfoPos += trackSize;
}
diskInfo.trackSizes = trackSizes;
diskInfo.trackInfoPosList = trackInfoPosList;
diskInfo.trackInfo.ident = ""; // make sure it is invalid
if (Utils.debug > 1) {
Utils.console.debug("readDiskInfo: extended=" + diskInfo.extended + ", tracks=" + diskInfo.tracks + ", heads=" + diskInfo.heads + ", trackSize=" + diskInfo.trackSize);
}
}
static createDiskInfoAsString(diskInfo) {
const diskInfoString = diskInfo.ident // 34
+ diskInfo.creator // 14
+ DiskImage.uInt8ToString(diskInfo.tracks)
+ DiskImage.uInt8ToString(diskInfo.heads)
+ DiskImage.uInt16ToString(diskInfo.trackSize)
+ DiskImage.uInt8ToString(0).repeat(204); // unused
return diskInfoString;
}
static trackInfoSize = 0x100;
readTrackInfo(trackInfo, pos) {
const trackInfoSize = DiskImage.trackInfoSize, sectorInfoList = trackInfo.sectorInfoList, trackDataPos = pos + trackInfoSize;
trackInfo.ident = this.readUtf(pos, 12);
if (trackInfo.ident.substring(0, 10) !== "Track-Info") { // some tools use "Track-Info  " instead of "Track-Info\r\n", so compare without "\r\n"
if (!this.options.quiet) {
Utils.console.warn(this.composeError({}, "Track ident not found", trackInfo.ident.substring(0, 10), pos).message);
}
}
trackInfo.track = this.readUInt8(pos + 16);
trackInfo.head = this.readUInt8(pos + 17);
trackInfo.dataRate = this.readUInt8(pos + 18);
trackInfo.recMode = this.readUInt8(pos + 19);
trackInfo.bps = this.readUInt8(pos + 20);
trackInfo.spt = this.readUInt8(pos + 21);
trackInfo.gap3 = this.readUInt8(pos + 22);
trackInfo.fill = this.readUInt8(pos + 23);
sectorInfoList.length = trackInfo.spt;
const sectorNum2Index = {};
trackInfo.sectorNum2Index = sectorNum2Index;
pos += 24; // start sector info
let sectorPos = trackDataPos;
for (let i = 0; i < trackInfo.spt; i += 1) {
const sectorInfo = sectorInfoList[i] || {}; // reuse SectorInfo object if possible
sectorInfoList[i] = sectorInfo;
sectorInfo.dataPos = sectorPos;
sectorInfo.track = this.readUInt8(pos);
sectorInfo.head = this.readUInt8(pos + 1);
sectorInfo.sector = this.readUInt8(pos + 2);
sectorInfo.bps = this.readUInt8(pos + 3);
sectorInfo.state1 = this.readUInt8(pos + 4);
sectorInfo.state2 = this.readUInt8(pos + 5);
const sectorSize = this.readUInt16(pos + 6) || (0x0080 << trackInfo.bps); // eslint-disable-line no-bitwise
sectorInfo.sectorSize = sectorSize;
sectorPos += sectorSize;
sectorNum2Index[sectorInfo.sector] = i;
pos += 8;
}
}
static createTrackInfoAsString(trackInfo) {
const sectorInfoList = trackInfo.sectorInfoList;
let trackInfoString = trackInfo.ident // 12
+ DiskImage.uInt8ToString(0).repeat(4) // 4 unused
+ DiskImage.uInt8ToString(trackInfo.track)
+ DiskImage.uInt8ToString(trackInfo.head)
+ DiskImage.uInt8ToString(trackInfo.dataRate)
+ DiskImage.uInt8ToString(trackInfo.recMode)
+ DiskImage.uInt8ToString(trackInfo.bps)
+ DiskImage.uInt8ToString(trackInfo.spt)
+ DiskImage.uInt8ToString(trackInfo.gap3)
+ DiskImage.uInt8ToString(trackInfo.fill);
for (let i = 0; i < trackInfo.spt; i += 1) {
const sectorInfo = sectorInfoList[i], sectorinfoString = DiskImage.uInt8ToString(sectorInfo.track)
+ DiskImage.uInt8ToString(sectorInfo.head)
+ DiskImage.uInt8ToString(sectorInfo.sector)
+ DiskImage.uInt8ToString(sectorInfo.bps)
+ DiskImage.uInt8ToString(sectorInfo.state1)
+ DiskImage.uInt8ToString(sectorInfo.state2)
+ DiskImage.uInt16ToString(0); // We use 0 (sectorInfo.sectorSize only needed for extended format)
trackInfoString += sectorinfoString;
}
trackInfoString += DiskImage.uInt8ToString(0).repeat(DiskImage.trackInfoSize - trackInfoString.length);
return trackInfoString;
}
seekTrack(diskInfo, track, head) {
if (!diskInfo.ident) {
this.readDiskInfo(diskInfo, 0);
}
const trackInfo = diskInfo.trackInfo;
if (trackInfo.ident && trackInfo.track === track && trackInfo.head === head) { // already positionend?
return;
}
const trackInfoPos = diskInfo.trackInfoPosList[track * diskInfo.heads + head];
if (trackInfoPos === undefined) {
throw this.composeError(new Error(), "Track not found", String(track));
}
this.readTrackInfo(trackInfo, trackInfoPos);
}
static sectorNum2Index(trackInfo, sector) {
const sectorIndex = trackInfo.sectorNum2Index[sector];
return sectorIndex;
}
static seekSector(sectorInfoList, sectorIndex) {
return sectorInfoList[sectorIndex];
}
readSector(trackInfo, sector) {
const sectorIndex = DiskImage.sectorNum2Index(trackInfo, sector);
if (sectorIndex === undefined) {
throw this.composeError(Error(), "Track " + trackInfo.track + ": Sector not found", String(sector), 0);
}
const sectorInfo = DiskImage.seekSector(trackInfo.sectorInfoList, sectorIndex), out = this.readUtf(sectorInfo.dataPos, sectorInfo.sectorSize);
return out;
}
writeSector(trackInfo, sector, sectorData) {
const sectorIndex = DiskImage.sectorNum2Index(trackInfo, sector);
if (sectorIndex === undefined) {
throw this.composeError(Error(), "Track " + trackInfo.track + ": Sector not found", String(sector), 0);
}
const sectorInfo = DiskImage.seekSector(trackInfo.sectorInfoList, sectorIndex), data = this.options.data;
if (sectorData.length !== sectorInfo.sectorSize) {
Utils.console.error(this.composeError({}, "sectordata.length " + sectorData.length + " <> sectorSize " + sectorInfo.sectorSize, String(0)));
}
this.options.data = data.substring(0, sectorInfo.dataPos) + sectorData + data.substring(sectorInfo.dataPos + sectorInfo.sectorSize);
}
composeFormatDescriptor(format) {
const derivedFormatDescriptor = DiskImage.formatDescriptors[format];
if (!derivedFormatDescriptor) {
throw this.composeError(Error(), "Unknown format", format);
}
let formatDescriptor;
if (derivedFormatDescriptor.parentRef) {
const parentFormatDescriptor = this.composeFormatDescriptor(derivedFormatDescriptor.parentRef); // recursive
formatDescriptor = Object.assign({}, parentFormatDescriptor, derivedFormatDescriptor);
}
else {
formatDescriptor = Object.assign({}, derivedFormatDescriptor); // get a copy
}
return formatDescriptor;
}
determineFormat(diskInfo) {
const trackInfo = diskInfo.trackInfo, track = 0, head = 0;
this.seekTrack(diskInfo, track, head);
let firstSector = 0xff;
for (let i = 0; i < trackInfo.spt; i += 1) {
const sector = trackInfo.sectorInfoList[i].sector;
if (sector < firstSector) {
firstSector = sector;
}
}
let format = "";
if (firstSector === 0xc1) {
format = "data";
}
else if (firstSector === 0x41) {
format = "system";
}
else if ((firstSector === 0x91) && (diskInfo.tracks === 80)) { // parados80
format = "parados80";
}
else if ((firstSector === 0x01) && (diskInfo.tracks === 80)) { // big780k (usually diskInfo.heads: 2)
format = "big780k";
}
else {
throw this.composeError(Error(), "Unknown format with sector", String(firstSector));
}
if (diskInfo.heads > 1) { // maybe 2 heads
format += DiskImage.twoHeads; // e.g. "data": "data2h"
}
if (Utils.debug > 1) {
Utils.console.debug("determineFormat: format=", format);
}
return format;
}
createImage(format) {
const formatDescriptor = this.composeFormatDescriptor(format), sectorInfoList = [], sectorSize = (0x80 << formatDescriptor.bps), // eslint-disable-line no-bitwise
sectorInfo = {
track: 0,
head: 0,
sector: 0,
bps: formatDescriptor.bps,
state1: 0,
state2: 0,
sectorSize: sectorSize,
dataPos: 0
}, trackInfo = {
ident: "Track-Info\r\n",
track: 0,
head: 0,
dataRate: 0,
recMode: 0,
bps: formatDescriptor.bps,
spt: formatDescriptor.spt,
gap3: formatDescriptor.gap3,
fill: formatDescriptor.fill,
sectorInfoList: sectorInfoList,
sectorNum2Index: {}
}, diskInfo = {
ident: "MV - CPCEMU Disk-File\r\nDisk-Info\r\n", // 34
creator: (this.options.creator || "cpclocots").padEnd(14, " "), // 14
tracks: formatDescriptor.tracks,
heads: formatDescriptor.heads,
trackSize: DiskImage.trackInfoSize + formatDescriptor.spt * sectorSize, // eslint-disable-line no-bitwise
trackInfo: trackInfo,
trackSizes: [], // only for extended DSK format
trackInfoPosList: [],
extended: false
}, emptySectorData = DiskImage.uInt8ToString(formatDescriptor.fill).repeat(sectorSize);
for (let i = 0; i < trackInfo.spt; i += 1) {
const sectorInfoClone = {
...sectorInfo
};
sectorInfoClone.sector = formatDescriptor.firstSector + i;
trackInfo.sectorNum2Index[sectorInfoClone.sector] = i;
sectorInfoList.push(sectorInfoClone);
}
let image = DiskImage.createDiskInfoAsString(diskInfo), trackInfoPos = DiskImage.diskInfoSize;
for (let track = 0; track < formatDescriptor.tracks; track += 1) {
for (let head = 0; head < formatDescriptor.heads; head += 1) {
trackInfo.track = track;
trackInfo.head = head;
diskInfo.trackInfoPosList.push(trackInfoPos);
for (let sector = 0; sector < trackInfo.spt; sector += 1) {
const sectorInfo2 = sectorInfoList[sector];
sectorInfo2.track = track;
sectorInfo2.head = head;
sectorInfo2.dataPos = trackInfoPos + DiskImage.trackInfoSize + sector * sectorInfo2.sectorSize;
}
const trackAsString = DiskImage.createTrackInfoAsString(trackInfo);
image += trackAsString;
for (let sector = 0; sector < formatDescriptor.spt; sector += 1) {
image += emptySectorData;
}
trackInfoPos += diskInfo.trackSize;
}
}
this.diskInfo = diskInfo;
this.formatDescriptor = formatDescriptor;
return image;
}
formatImage(format) {
const image = this.createImage(format);
this.options.data = image;
return image;
}
static fnRemoveHighBit7(str) {
let out = "";
for (let i = 0; i < str.length; i += 1) {
const char = str.charCodeAt(i);
out += String.fromCharCode(char & 0x7f); // eslint-disable-line no-bitwise
}
return out;
}
readDirectoryExtents(extents, pos, endPos) {
while (pos < endPos) {
const extent = {
user: this.readUInt8(pos),
name: this.readUtf(pos + 1, 8),
ext: this.readUtf(pos + 9, 3), // extension with flags
extent: this.readUInt8(pos + 12),
lastRecBytes: this.readUInt8(pos + 13),
extentHi: this.readUInt8(pos + 14), // used for what?
records: this.readUInt8(pos + 15),
blocks: []
};
pos += 16;
const blocks = extent.blocks;
for (let i = 0; i < 16; i += 1) {
const block = this.readUInt8(pos + i);
blocks.push(block);
}
pos += 16;
extents.push(extent);
}
return extents;
}
static createDirectoryExtentAsString(extent) {
let extentString = DiskImage.uInt8ToString(extent.user)
+ extent.name
+ extent.ext
+ DiskImage.uInt8ToString(extent.extent)
+ DiskImage.uInt8ToString(extent.lastRecBytes)
+ DiskImage.uInt8ToString(extent.extentHi)
+ DiskImage.uInt8ToString(extent.records), blockString = "";
for (let i = 0; i < extent.blocks.length; i += 1) {
blockString += DiskImage.uInt8ToString(extent.blocks[i]);
}
extentString += blockString;
return extentString;
}
static createSeveralDirectoryExtentsAsString(extents, first, last) {
let extentString = "";
for (let i = first; i < last; i += 1) {
extentString += DiskImage.createDirectoryExtentAsString(extents[i]);
}
return extentString;
}
static fnSortByExtentNumber(a, b) {
return a.extent - b.extent;
}
static sortFileExtents(dir) {
for (const name in dir) {
if (dir.hasOwnProperty(name)) {
const fileExtents = dir[name];
fileExtents.sort(DiskImage.fnSortByExtentNumber);
}
}
}
static prepareDirectoryList(extents, fill, reFilePattern) {
const dir = {};
for (let i = 0; i < extents.length; i += 1) {
const extent = extents[i];
if (fill === null || extent.user !== fill) {
const name = DiskImage.fnRemoveHighBit7(extent.name) + "." + DiskImage.fnRemoveHighBit7(extent.ext); // and extent.user?
if (!reFilePattern || reFilePattern.test(name)) {
if (!(name in dir)) {
dir[name] = [];
}
dir[name].push(extent);
}
}
}
DiskImage.sortFileExtents(dir);
return dir;
}
static convertBlock2Sector(formatDescriptor, block) {
const spt = formatDescriptor.spt, blockSectors = formatDescriptor.bls / 512, // usually 2
logSec = block * blockSectors, // directory is in block 0-1
pos = {
track: Math.floor(logSec / spt) + formatDescriptor.off,
head: 0, // currently always 0
sector: (logSec % spt) + formatDescriptor.firstSector
};
return pos;
}
readAllDirectoryExtents(diskInfo, formatDescriptor, extents) {
const directorySectors = 4, // could be determined from al0,al1
off = formatDescriptor.off, firstSector = formatDescriptor.firstSector, trackInfo = diskInfo.trackInfo, sectorInfoList = trackInfo.sectorInfoList;
this.seekTrack(diskInfo, off, 0);
for (let i = 0; i < directorySectors; i += 1) {
const sectorIndex = DiskImage.sectorNum2Index(trackInfo, firstSector + i);
if (sectorIndex === undefined) {
throw this.composeError(Error(), "Cannot read directory at track " + off + " sector", String(firstSector));
}
const sectorInfo = DiskImage.seekSector(sectorInfoList, sectorIndex);
this.readDirectoryExtents(extents, sectorInfo.dataPos, sectorInfo.dataPos + sectorInfo.sectorSize);
}
return extents;
}
writeAllDirectoryExtents(diskInfo, formatDescriptor, extents) {
const directoryBlocks = 2, // could be determined from al0,al1
extentsPerBlock = extents.length / directoryBlocks;
for (let i = 0; i < directoryBlocks; i += 1) {
const blockData = DiskImage.createSeveralDirectoryExtentsAsString(extents, i * extentsPerBlock, (i + 1) * extentsPerBlock);
this.writeBlock(diskInfo, formatDescriptor, i, blockData);
}
}
readDirectory() {
const diskInfo = this.diskInfo, format = this.determineFormat(diskInfo), formatDescriptor = this.composeFormatDescriptor(format), extents = [];
this.formatDescriptor = formatDescriptor;
this.readAllDirectoryExtents(diskInfo, formatDescriptor, extents);
return DiskImage.prepareDirectoryList(extents, this.formatDescriptor.fill);
}
static nextSector(formatDescriptor, pos) {
pos.sector += 1;
if (pos.sector >= formatDescriptor.firstSector + formatDescriptor.spt) {
pos.track += 1;
pos.sector = formatDescriptor.firstSector;
}
}
readBlock(diskInfo, formatDescriptor, block) {
const blockSectors = formatDescriptor.bls / 512, // usually 2
pos = DiskImage.convertBlock2Sector(formatDescriptor, block);
let out = "";
if (pos.track >= diskInfo.tracks) {
Utils.console.error(this.composeError({}, "Block " + block + ": Track out of range", String(pos.track)));
}
if (pos.head >= diskInfo.heads) {
Utils.console.error(this.composeError({}, "Block " + block + ": Head out of range", String(pos.track)));
}
for (let i = 0; i < blockSectors; i += 1) {
this.seekTrack(diskInfo, pos.track, pos.head);
out += this.readSector(diskInfo.trackInfo, pos.sector);
DiskImage.nextSector(formatDescriptor, pos);
}
return out;
}
writeBlock(diskInfo, formatDescriptor, block, blockData) {
const blockSectors = formatDescriptor.bls / 512, // usually 2
sectorSize = (0x80 << formatDescriptor.bps), // eslint-disable-line no-bitwise
pos = DiskImage.convertBlock2Sector(formatDescriptor, block);
if (pos.track >= diskInfo.tracks) {
Utils.console.error(this.composeError({}, "Block " + block + ": Track out of range", String(pos.track)));
}
if (pos.head >= diskInfo.heads) {
Utils.console.error(this.composeError({}, "Block " + block + ": Head out of range", String(pos.track)));
}
if (blockData.length !== (blockSectors * sectorSize)) {
Utils.console.error(this.composeError({}, "blockData.length " + blockData.length + " <> blockSize " + (blockSectors * sectorSize), String(0)));
}
for (let i = 0; i < blockSectors; i += 1) {
this.seekTrack(diskInfo, pos.track, pos.head);
const sectorData = blockData.substring(i * sectorSize, (i + 1) * sectorSize);
this.writeSector(diskInfo.trackInfo, pos.sector, sectorData);
DiskImage.nextSector(formatDescriptor, pos);
}
}
readExtents(diskInfo, formatDescriptor, fileExtents) {
const recPerBlock = formatDescriptor.bls / 128; // usually 8
let out = "";
for (let i = 0; i < fileExtents.length; i += 1) {
const extent = fileExtents[i], blocks = extent.blocks;
let records = extent.records;
if (extent.extent > 0) {
if (recPerBlock > 8) { // fast hack for parados: adapt records
records += extent.extent * 128;
}
}
for (let blockIndex = 0; blockIndex < blocks.length; blockIndex += 1) {
let block = this.readBlock(diskInfo, formatDescriptor, blocks[blockIndex]);
if (records < recPerBlock) { // block with some remaining data
block = block.substring(0, 0x80 * records);
}
out += block;
records -= recPerBlock;
if (records <= 0) {
break;
}
}
}
return out;
}
readFile(fileExtents) {
const diskInfo = this.diskInfo, formatDescriptor = this.getFormatDescriptor();
let out = this.readExtents(diskInfo, formatDescriptor, fileExtents);
const header = DiskImage.parseAmsdosHeader(out);
let realLen;
if (header) {
const amsdosHeaderLength = 0x80;
realLen = header.length + amsdosHeaderLength;
}
if (realLen === undefined) { // no real length: ASCII: find EOF (0x1a) in last record
const fileLen = out.length, lastRecPos = fileLen > 0x80 ? (fileLen - 0x80) : 0, index = out.indexOf(String.fromCharCode(0x1a), lastRecPos);
if (index >= 0) {
realLen = index;
if (Utils.debug > 0) {
Utils.console.debug("readFile: ASCII file length " + fileLen + " truncated to " + realLen);
}
}
}
if (realLen !== undefined) { // now real length (from header or ASCII)?
out = out.substring(0, realLen);
}
return out;
}
static getFreeExtents(extents, fill) {
const freeExtents = [];
for (let i = 0; i < extents.length; i += 1) {
if (extents[i].user === fill) {
freeExtents.push(i);
}
}
return freeExtents;
}
static getBlockMask(extents, fill, dsm, al0, al1) {
const blockMask = [];
for (let i = 0; i < dsm - 1; i += 1) {
blockMask[i] = false;
}
let mask = 0x80;
for (let i = 0; i < 8; i += 1) {
if (al0 & mask) { // eslint-disable-line no-bitwise
blockMask[i] = true; // mark reserved block
}
mask >>= 1; // eslint-disable-line no-bitwise
}
mask = 0x80;
for (let i = 8; i < 16; i += 1) {
if (al1 & mask) { // eslint-disable-line no-bitwise
blockMask[i] = true; // mark reserved block
}
mask >>= 1; // eslint-disable-line no-bitwise
}
for (let i = 0; i < extents.length; i += 1) {
const extent = extents[i], blockList = extent.blocks;
if (extent.user !== fill) {
for (let blockindex = 0; blockindex < blockList.length; blockindex += 1) {
const block = blockList[blockindex];
if (block) {
if (blockMask[block]) { // eslint-disable-line max-depth
Utils.console.warn("getBlockMask: Block number already in use: ", block);
}
blockMask[block] = true;
}
else {
break; // block=0 -> no more for this extent
}
}
}
}
return blockMask;
}
static getFreeBlocks(blockMask, dsm) {
const freeBlocks = [];
for (let i = 0; i < dsm; i += 1) {
if (!blockMask[i]) {
freeBlocks.push(i);
}
}
return freeBlocks;
}
static getFilenameAndExtension(filename) {
let [name1, ext1] = filename.split("."); // eslint-disable-line array-element-newline
name1 = name1.substring(0, 8).toUpperCase().padEnd(8, " ");
ext1 = ext1.substring(0, 3).toUpperCase().padEnd(3, " ");
return [name1, ext1]; // eslint-disable-line array-element-newline
}
writeFile(filename, data) {
const diskInfo = this.diskInfo, formatDescriptor = this.getFormatDescriptor(), extents = [];
this.readAllDirectoryExtents(diskInfo, formatDescriptor, extents);
const fill = formatDescriptor.fill, freeExtents = DiskImage.getFreeExtents(extents, formatDescriptor.fill), sectors = (formatDescriptor.tracks - formatDescriptor.off) * formatDescriptor.spt, ssize = 0x80 << formatDescriptor.bps, // eslint-disable-line no-bitwise
dsm = ((sectors * ssize) / formatDescriptor.bls) | 0, // eslint-disable-line no-bitwise
al0 = formatDescriptor.al0, al1 = formatDescriptor.al1, blockMask = DiskImage.getBlockMask(extents, fill, dsm, al0, al1), freeBlocks = DiskImage.getFreeBlocks(blockMask, dsm);
if (Utils.debug > 0) {
Utils.console.debug("writeFile: freeExtents=", freeExtents.length, ", freeBlocks=", freeBlocks);
}
if (!freeBlocks.length) {
Utils.console.warn("writeFile: " + filename + ": No space left!");
return false;
}
if (!freeExtents.length) {
Utils.console.warn("writeFile: " + filename + ": Directory full!");
return false;
}
const [name1, ext1] = DiskImage.getFilenameAndExtension(filename), // eslint-disable-line array-element-newline
fileSize = data.length, bls = formatDescriptor.bls, requiredBlocks = ((fileSize + bls - 1) / bls) | 0; // eslint-disable-line no-bitwise
if (requiredBlocks > freeBlocks.length) {
const requiredKB = ((requiredBlocks * bls) / 1024) | 0, // eslint-disable-line no-bitwise
freeKB = ((freeBlocks.length * bls) / 1024) | 0; // eslint-disable-line no-bitwise
Utils.console.warn("writeFile: " + filename + ": Not enough space left (" + requiredKB + "K > " + freeKB + "K). Ignoring.");
return false;
}
const blocksPerExtent = 16, requiredExtents = ((requiredBlocks + blocksPerExtent - 1) / blocksPerExtent) | 0; // eslint-disable-line no-bitwise
if (requiredExtents > freeExtents.length) {
Utils.console.warn("writeFile: " + filename + ": Directory full!");
return false;
}
let size = fileSize, extent, extentCnt = 0, blockCnt = 0;
while (size > 0) {
if (!extent || (blockCnt >= 16)) {
const records = ((size + 0x80 - 1) / 0x80) | 0; // eslint-disable-line no-bitwise
extent = extents[freeExtents[extentCnt]];
extent.user = 0;
extent.name = name1;
extent.ext = ext1;
extent.extent = extentCnt;
extent.lastRecBytes = 0; // ($size >= 0x80) ? 0 : $size;
extent.extentHi = 0;
extent.records = (records > 0x80) ? 0x80 : records;
extent.blocks.length = 0;
for (let i = 0; i < 16; i += 1) {
extent.blocks[i] = 0;
}
extentCnt += 1;
blockCnt = 0;
}
const thisSize = (size > bls) ? bls : size;
let dataChunk = data.substring(fileSize - size, fileSize - size + thisSize);
if (thisSize < bls) {
dataChunk += DiskImage.uInt8ToString(0x1a); // add EOF (0x1a)
const remain = bls - thisSize - 1;
dataChunk += DiskImage.uInt8ToString(formatDescriptor.fill).repeat(remain); // fill up last block with fill byte
}
const block = freeBlocks[(extentCnt - 1) * 16 + blockCnt];
this.writeBlock(diskInfo, formatDescriptor, block, dataChunk);
extent.blocks[blockCnt] = block;
blockCnt += 1;
size -= thisSize;
}
this.writeAllDirectoryExtents(diskInfo, formatDescriptor, extents);
return true;
}
static isSectorEmpty(data, index, size, fill) {
const endIndex = (index + size) <= data.length ? index + size : data.length - index;
let isEmpty = true;
for (let i = index; i < endIndex; i += 1) {
if (data.charCodeAt(i) !== fill) {
isEmpty = false;
break;
}
}
return isEmpty;
}
stripEmptyTracks() {
const diskInfo = this.diskInfo, format = this.determineFormat(diskInfo), formatDescriptor = this.composeFormatDescriptor(format), tracks = diskInfo.tracks, firstDataTrack = formatDescriptor.off, head = 0;
let data = this.options.data;
this.formatDescriptor = formatDescriptor;
for (let track = firstDataTrack; track < tracks; track += 1) {
this.seekTrack(diskInfo, track, head);
const trackInfo = diskInfo.trackInfo, fill = diskInfo.trackInfo.fill, sectorInfoList = trackInfo.sectorInfoList;
let isEmpty = true;
for (let i = 0; i < trackInfo.spt; i += 1) {
const sectorInfo = sectorInfoList[i];
if (!DiskImage.isSectorEmpty(data, sectorInfo.dataPos, sectorInfo.sectorSize, fill)) {
isEmpty = false;
break;
}
}
if (isEmpty) {
diskInfo.tracks = track; // set new number of tracks
const trackDataPos = sectorInfoList[0].dataPos;
data = DiskImage.createDiskInfoAsString(diskInfo) + data.substring(DiskImage.diskInfoSize, trackDataPos - DiskImage.trackInfoSize); // set new track count and remove empty track and rest
this.options.data = data;
break;
}
}
return data;
}
/* eslint-disable array-element-newline */
static protectTable = [
[0xe2, 0x9d, 0xdb, 0x1a, 0x42, 0x29, 0x39, 0xc6, 0xb3, 0xc6, 0x90, 0x45, 0x8a], // 13 bytes
[0x49, 0xb1, 0x36, 0xf0, 0x2e, 0x1e, 0x06, 0x2a, 0x28, 0x19, 0xea] // 11 bytes
];
/* eslint-enable array-element-newline */
static unOrProtectData(data) {
const table1 = DiskImage.protectTable[0], table2 = DiskImage.protectTable[1];
let out = "";
for (let i = 0; i < data.length; i += 1) {
let byte = data.charCodeAt(i);
byte ^= table1[(i & 0x7f) % table1.length] ^ table2[(i & 0x7f) % table2.length]; // eslint-disable-line no-bitwise
out += String.fromCharCode(byte);
}
return out;
}
static computeChecksum(data) {
let sum = 0;
for (let i = 0; i < data.length; i += 1) {
sum += data.charCodeAt(i);
}
return sum;
}
static hasAmsdosHeader(data) {
let hasHeader = false;
if (data.length >= 0x80) {
const computed = DiskImage.computeChecksum(data.substring(0, 66)), sum = data.charCodeAt(67) + data.charCodeAt(68) * 256;
hasHeader = computed === sum;
}
return hasHeader;
}
static parseAmsdosHeader(data) {
const typeMap = {
0: "T", // tokenized BASIC (T=not official)
1: "P", // protected BASIC (also tokenized)
2: "B", // Binary
8: "G", // GENA3 Assember (G=not official)
0x16: "A" // ASCII
};
let header;
if (DiskImage.hasAmsdosHeader(data)) {
header = {
user: data.charCodeAt(0),
name: data.substring(1, 1 + 8),
ext: data.substring(9, 9 + 3),
typeNumber: data.charCodeAt(18),
start: data.charCodeAt(21) + data.charCodeAt(22) * 256,
pseudoLen: data.charCodeAt(24) + data.charCodeAt(25) * 256,
entry: data.charCodeAt(26) + data.charCodeAt(27) * 256,
length: data.charCodeAt(64) + data.charCodeAt(65) * 256 + data.charCodeAt(66) * 65536,
typeString: ""
};
header.typeString = typeMap[header.typeNumber] || typeMap[16]; // default: ASCII
}
return header;
}
static combineAmsdosHeader(header) {
const typeMap = {
T: 0, // tokenized BASIC (T=not official)
P: 1, // protected BASIC
B: 2, // Binary
G: 8, // GENA3 Assember (G=not official)
A: 0x16 // ASCII
};
let type = header.typeNumber;
if (header.typeString) { // overwrite type form type
type = typeMap[header.typeString];
if (type === undefined) {
type = typeMap.A;
}
}
let length = header.pseudoLen || header.length; // logical length;
if (length > 0xffff) { // 16 bit
length = 0xffff;
}
const data1 = DiskImage.uInt8ToString(header.user || 0)
+ (header.name || "").padEnd(8, " ")
+ (header.ext || "").padEnd(3, " ")
+ DiskImage.uInt16ToString(0)
+ DiskImage.uInt16ToString(0)
+ DiskImage.uInt8ToString(0) // block number (unused)
+ DiskImage.uInt8ToString(0) // last block (unused)
+ DiskImage.uInt8ToString(type)
+ DiskImage.uInt16ToString(0) // data location (unused)
+ DiskImage.uInt16ToString(header.start || 0)
+ DiskImage.uInt8ToString(0x00) // first block (unused; always 0x00 or 0xff?)
+ DiskImage.uInt16ToString(length) // logical length
+ DiskImage.uInt16ToString(header.entry || 0)
+ "\x00".repeat(36)
+ DiskImage.uInt24ToString(header.length), checksum = DiskImage.computeChecksum(data1), data = data1
+ DiskImage.uInt16ToString(checksum)
+ "\x00".repeat(59);
return data;
}
static createAmsdosHeader(parameter) {
const header = {
user: 0,
name: "",
ext: "",
typeNumber: 0,
start: 0,
pseudoLen: 0,
entry: 0,
length: 0,
typeString: "",
...parameter
};
return header;
}
}
class Snapshot {
options;
pos = 0;
constructor(options) {
this.options = {
quiet: false
};
this.setOptions(options);
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
composeError(error, message, value, pos) {
const len = 0;
return Utils.composeError("DiskImage", error, this.options.name + ": " + message, value, pos || 0, len);
}
static testSnapIdent(ident) {
return ident === "MV - SNA";
}
readUInt8() {
const num = this.options.data.charCodeAt(this.pos);
if (isNaN(num)) {
throw this.composeError(new Error(), "End of File", String(num), this.pos);
}
this.pos += 1;
return num;
}
readUInt16() {
return this.readUInt8() + this.readUInt8() * 256;
}
readUInt8Array(len) {
const arr = [];
for (let i = 0; i < len; i += 1) {
arr.push(this.readUInt8());
}
return arr;
}
readUtf(len) {
const out = this.options.data.substring(this.pos, this.pos + len);
if (out.length !== len) {
throw this.composeError(new Error(), "End of File", "", this.pos);
}
this.pos += len;
return out;
}
getSnapshotInfo() {
this.pos = 0;
const info = {
ident: this.readUtf(8),
unused1: this.readUtf(8),
version: this.readUInt8(),
z80: {
AF: this.readUInt16(),
BC: this.readUInt16(),
DE: this.readUInt16(),
HL: this.readUInt16(),
IR: this.readUInt16(),
IFF: this.readUInt16(),
IX: this.readUInt16(),
IY: this.readUInt16(),
SP: this.readUInt16(),
PC: this.readUInt16(),
M: this.readUInt8(),
AF2: this.readUInt16(),
BC2: this.readUInt16(),
DE2: this.readUInt16(),
HL2: this.readUInt16()
},
ga: {
inknum: this.readUInt8(),
inkval: this.readUInt8Array(17),
multi: this.readUInt8()
},
ramconf: this.readUInt8(),
crtc: {
index: this.readUInt8(),
reg: this.readUInt8Array(18)
},
romnum: this.readUInt8(),
ppi: {
portA: this.readUInt8(),
portB: this.readUInt8(),
portC: this.readUInt8(),
portCtl: this.readUInt8()
},
psg: {
index: this.readUInt8(),
reg: this.readUInt8Array(16)
},
memsize: this.readUInt8()
};
return info;
}
getMemory() {
return this.options.data.substring(0x100); // memory dump without snapshot header
}
}
class ZipFile {
options;
data;
entryTable = {};
constructor(options) {
this.options = {};
this.setOptions(options, true);
}
getOptions() {
return this.options;
}
setOptions(options, force) {
const currentData = this.options.data;
Object.assign(this.options, options);
if (force || (this.options.data !== currentData)) {
this.data = this.options.data;
this.entryTable = this.readZipDirectory();
}
}
getZipDirectory() {
return this.entryTable;
}
composeError(error, message, value, pos) {
message = this.options.zipName + ": " + message; // put zipname in message
return Utils.composeError("ZipFile", error, message, value, pos);
}
subArr(begin, length) {
const data = this.data, end = begin + length;
return data.slice ? data.slice(begin, end) : data.subarray(begin, end); // array.slice on Uint8Array not for IE11
}
readUTF(offset, len) {
const callSize = 25000; // use call window to avoid "maximum call stack error" for e.g. size 336461
let out = "";
while (len) {
const chunkLen = Math.min(len, callSize), nums = this.subArr(offset, chunkLen);
out += String.fromCharCode.apply(null, nums); // on Chrome this is faster than single character processing
offset += chunkLen;
len -= chunkLen;
}
return out;
}
readUInt(i) {
const data = this.data;
return (data[i + 3] << 24) | (data[i + 2] << 16) | (data[i + 1] << 8) | data[i]; // eslint-disable-line no-bitwise
}
readUShort(i) {
const data = this.data;
return ((data[i + 1]) << 8) | data[i]; // eslint-disable-line no-bitwise
}
readEocd(eocdPos) {
const eocd = {
signature: this.readUInt(eocdPos),
entries: this.readUShort(eocdPos + 10), // total number of central directory records
cdfhOffset: this.readUInt(eocdPos + 16), // offset of start of central directory, relative to start of archive
cdSize: this.readUInt(eocdPos + 20) // size of central directory (just for information)
};
return eocd;
}
readCdfh(pos) {
const cdfh = {
signature: this.readUInt(pos),
version: this.readUShort(pos + 6), // version needed to extract (minimum)
flag: this.readUShort(pos + 8), // General purpose bit flag
compressionMethod: this.readUShort(pos + 10), // compression method
modificationTime: this.readUShort(pos + 12), // File last modification time (DOS time)
crc: this.readUInt(pos + 16), // CRC-32 of uncompressed data
compressedSize: this.readUInt(pos + 20), // compressed size
size: this.readUInt(pos + 24), // Uncompressed size
fileNameLength: this.readUShort(pos + 28), // file name length
extraFieldLength: this.readUShort(pos + 30), // extra field length
fileCommentLength: this.readUShort(pos + 32), // file comment length
localOffset: this.readUInt(pos + 42), // relative offset of local file header
name: "",
isDirectory: false,
extra: [],
comment: "",
timestamp: 0,
dataStart: 0
};
return cdfh;
}
readZipDirectory() {
const eocdLen = 22, // End of central directory (EOCD)
maxEocdCommentLen = 0xffff, eocdSignature = 0x06054B50, // EOCD signature: "PK\x05\x06"
cdfhSignature = 0x02014B50, // Central directory file header signature: PK\x01\x02"
cdfhLen = 46, // Central directory file header length
lfhSignature = 0x04034b50, // Local file header signature
lfhLen = 30, // Local file header length
data = this.data, entryTable = {};
let i = data.length - eocdLen + 1, // +1 because of loop
eocd;
const n = Math.max(0, i - maxEocdCommentLen);
while (i >= n) {
i -= 1;
if (this.readUInt(i) === eocdSignature) {
eocd = this.readEocd(i);
if (this.readUInt(eocd.cdfhOffset) === cdfhSignature) {
break; // looks good, so we assume that we have found the EOCD
}
}
}
if (!eocd) {
throw this.composeError(Error(), "Zip: File ended abruptly: EOCD not found", "", (i >= 0) ? i : 0);
}
const entries = eocd.entries;
let offset = eocd.cdfhOffset;
for (i = 0; i < entries; i += 1) {
const cdfh = this.readCdfh(offset);
if (cdfh.signature !== cdfhSignature) {
throw this.composeError(Error(), "Zip: Bad CDFH signature", "", offset);
}
if (!cdfh.fileNameLength) {
throw this.composeError(Error(), "Zip Entry name missing", "", offset);
}
offset += cdfhLen;
cdfh.name = this.readUTF(offset, cdfh.fileNameLength);
offset += cdfh.fileNameLength;
cdfh.isDirectory = cdfh.name.charAt(cdfh.name.length - 1) === "/";
cdfh.extra = this.subArr(offset, cdfh.extraFieldLength);
offset += cdfh.extraFieldLength;
cdfh.comment = this.readUTF(offset, cdfh.fileCommentLength);
offset += cdfh.fileCommentLength;
if ((cdfh.flag & 1) === 1) { // eslint-disable-line no-bitwise
throw this.composeError(Error(), "Zip encrypted entries not supported", "", i);
}
const dostime = cdfh.modificationTime;
cdfh.timestamp = new Date(((dostime >> 25) & 0x7F) + 1980, ((dostime >> 21) & 0x0F) - 1, (dostime >> 16) & 0x1F, (dostime >> 11) & 0x1F, (dostime >> 5) & 0x3F, (dostime & 0x1F) << 1).getTime(); // eslint-disable-line no-bitwise
if (this.readUInt(cdfh.localOffset) !== lfhSignature) {
Utils.console.error("Zip: readZipDirectory: LFH signature not found at offset", cdfh.localOffset);
}
const lfhExtrafieldLength = this.readUShort(cdfh.localOffset + 28); // extra field length
cdfh.dataStart = cdfh.localOffset + lfhLen + cdfh.name.length + lfhExtrafieldLength;
entryTable[cdfh.name] = cdfh;
}
return entryTable;
}
static fnInflateConstruct(codes, lens2, n) {
let i;
for (i = 0; i <= 0xF; i += 1) {
codes.count[i] = 0;
}
for (i = 0; i < n; i += 1) {
codes.count[lens2[i]] += 1;
}
if (codes.count[0] === n) {
return 0;
}
let left = 1;
for (i = 1; i <= 0xF; i += 1) {
if ((left = (left << 1) - codes.count[i]) < 0) { // eslint-disable-line no-bitwise
return left;
}
}
const offs = [
undefined,
0
];
for (i = 1; i < 0xF; i += 1) {
offs[i + 1] = offs[i] + codes.count[i];
}
for (i = 0; i < n; i += 1) {
if (lens2[i] !== 0) {
codes.symbol[offs[lens2[i]]] = i; // TTT
offs[lens2[i]] += 1; // TTT
}
}
return left;
}
static fnConstructFixedHuffman(lens, lenCode, distCode) {
let symbol;
for (symbol = 0; symbol < 0x90; symbol += 1) {
lens[symbol] = 8;
}
for (; symbol < 0x100; symbol += 1) {
lens[symbol] = 9;
}
for (; symbol < 0x118; symbol += 1) {
lens[symbol] = 7;
}
for (; symbol < 0x120; symbol += 1) {
lens[symbol] = 8;
}
ZipFile.fnInflateConstruct(lenCode, lens, 0x120);
for (symbol = 0; symbol < 0x1E; symbol += 1) {
lens[symbol] = 5;
}
ZipFile.fnInflateConstruct(distCode, lens, 0x1E);
}
inflate(offset, compressedSize, finalSize) {
/* eslint-disable array-element-newline */
const startLens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], lExt = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], dists = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], dExt = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], dynamicTableOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
/* eslint-enable array-element-newline */
that = this, // eslint-disable-line @typescript-eslint/no-this-alias
data = this.data, bufEnd = offset + compressedSize, outBuf = new Uint8Array(finalSize);
let inCnt = offset, // read position
outCnt = 0, // bytes written to outbuf
bitCnt = 0, // helper to keep track of where we are in #bits
bitBuf = 0, distCode, lenCode, lens;
const fnBits = function (need) {
let out = bitBuf;
while (bitCnt < need) {
if (inCnt === bufEnd) {
throw that.composeError(Error(), "Zip: inflate: Data overflow", that.options.zipName, -1);
}
out |= data[inCnt] << bitCnt; // eslint-disable-line no-bitwise
inCnt += 1;
bitCnt += 8;
}
bitBuf = out >> need; // eslint-disable-line no-bitwise
bitCnt -= need;
return out & ((1 << need) - 1); // eslint-disable-line no-bitwise
}, fnDecode = function (codes) {
let code = 0, first = 0, i = 0;
for (let j = 1; j <= 0xF; j += 1) {
code |= fnBits(1); // eslint-disable-line no-bitwise
const count = codes.count[j];
if (code < first + count) {
return codes.symbol[i + (code - first)];
}
i += count;
first += count;
first <<= 1; // eslint-disable-line no-bitwise
code <<= 1; // eslint-disable-line no-bitwise
}
return null;
}, fnInflateStored = function () {
bitBuf = 0;
bitCnt = 0;
if (inCnt + 4 > bufEnd) {
throw that.composeError(Error(), "Zip: inflate: Data overflow", "", inCnt);
}
let len = that.readUShort(inCnt);
inCnt += 2;
if (data[inCnt] !== (~len & 0xFF) || data[inCnt + 1] !== ((~len >> 8) & 0xFF)) { // eslint-disable-line no-bitwise
throw that.composeError(Error(), "Zip: inflate: Bad length", "", inCnt);
}
inCnt += 2;
if (inCnt + len > bufEnd) {
throw that.composeError(Error(), "Zip: inflate: Data overflow", "", inCnt);
}
while (len) {
outBuf[outCnt] = data[inCnt];
outCnt += 1;
inCnt += 1;
len -= 1;
}
}, fnConstructDynamicHuffman = function () {
const nLen = fnBits(5) + 257, nDist = fnBits(5) + 1, nCode = fnBits(4) + 4;
if (nLen > 0x11E || nDist > 0x1E) {
throw that.composeError(Error(), "Zip: inflate: length/distance code overflow", "", 0);
}
let i;
for (i = 0; i < nCode; i += 1) {
lens[dynamicTableOrder[i]] = fnBits(3);
}
for (; i < 19; i += 1) {
lens[dynamicTableOrder[i]] = 0;
}
if (ZipFile.fnInflateConstruct(lenCode, lens, 19) !== 0) {
throw that.composeError(Error(), "Zip: inflate: length codes incomplete", "", 0);
}
for (i = 0; i < nLen + nDist;) {
let symbol = fnDecode(lenCode); // TTT
/* eslint-disable max-depth */
if (symbol < 16) {
lens[i] = symbol;
i += 1;
}
else {
let len = 0;
if (symbol === 16) {
if (i === 0) {
throw that.composeError(Error(), "Zip: inflate: repeat lengths with no first length", "", 0);
}
len = lens[i - 1];
symbol = 3 + fnBits(2);
}
else if (symbol === 17) {
symbol = 3 + fnBits(3);
}
else {
symbol = 11 + fnBits(7);
}
if (i + symbol > nLen + nDist) {
throw that.composeError(Error(), "Zip: inflate: more lengths than specified", "", 0);
}
while (symbol) {
lens[i] = len;
symbol -= 1;
i += 1;
}
}
/* eslint-enable max-depth */
}
const err1 = ZipFile.fnInflateConstruct(lenCode, lens, nLen), err2 = ZipFile.fnInflateConstruct(distCode, lens.slice(nLen), nDist);
if ((err1 < 0 || (err1 > 0 && nLen - lenCode.count[0] !== 1))
|| (err2 < 0 || (err2 > 0 && nDist - distCode.count[0] !== 1))) {
throw that.composeError(Error(), "Zip: inflate: bad literal or length codes", "", 0);
}
}, fnInflateHuffmann = function () {
let symbol;
do { // decode deflated data
symbol = fnDecode(lenCode); // TTT
if (symbol < 256) {
outBuf[outCnt] = symbol;
outCnt += 1;
}
if (symbol > 256) {
symbol -= 257;
if (symbol > 28) {
throw that.composeError(Error(), "Zip: inflate: Invalid length/distance", "", 0);
}
let len = startLens[symbol] + fnBits(lExt[symbol]);
symbol = fnDecode(distCode); // TTT
const dist = dists[symbol] + fnBits(dExt[symbol]);
if (dist > outCnt) {
throw that.composeError(Error(), "Zip: inflate: distance out of range", "", 0);
}
while (len) {
outBuf[outCnt] = outBuf[outCnt - dist];
len -= 1;
outCnt += 1;
}
}
} while (symbol !== 256);
};
let last;
do { // The actual inflation
last = fnBits(1);
const type = fnBits(2);
switch (type) {
case 0: // STORED
fnInflateStored();
break;
case 1:
case 2: // fixed (=1) or dynamic (=2) huffman
lenCode = {
count: [],
symbol: []
};
distCode = {
count: [],
symbol: []
};
lens = [];
if (type === 1) { // construct fixed huffman tables
ZipFile.fnConstructFixedHuffman(lens, lenCode, distCode);
}
else { // construct dynamic huffman tables
fnConstructDynamicHuffman();
}
fnInflateHuffmann();
break;
default:
throw this.composeError(Error(), "Zip: inflate: unsupported compression type" + type, "", 0);
}
} while (!last);
return outBuf;
}
readData(name) {
const cdfh = this.entryTable[name];
if (!cdfh) {
throw this.composeError(Error(), "Zip: readData: file does not exist:" + name, "", 0);
}
let dataUTF8 = "";
if (cdfh.compressionMethod === 0) { // stored
dataUTF8 = this.readUTF(cdfh.dataStart, cdfh.size);
}
else if (cdfh.compressionMethod === 8) { // deflated
const fileData = this.inflate(cdfh.dataStart, cdfh.compressedSize, cdfh.size), savedData = this.data;
this.data = fileData; // we need to switch this.data
dataUTF8 = this.readUTF(0, fileData.length);
this.data = savedData; // restore
}
else {
throw this.composeError(Error(), "Zip: readData: compression method not supported:" + cdfh.compressionMethod, "", 0);
}
if (dataUTF8.length !== cdfh.size) { // assert
Utils.console.error("Zip: readData: different length 2!");
}
return dataUTF8;
}
}
class FileHandler {
options;
static metaIdent = "CpcLoco";
processFileImports = true;
diskImage;
constructor(options) {
this.options = {};
this.setOptions(options);
}
setOptions(options) {
Object.assign(this.options, options);
}
getDiskImage() {
if (!this.diskImage) {
this.diskImage = new DiskImage({
data: "" // will be set later
});
}
return this.diskImage;
}
static fnLocalStorageName(name, defaultExtension) {
if (name.indexOf(".") < 0) { // no dot inside name?
name += "." + (defaultExtension || ""); // append dot or default extension
}
return name;
}
static getMetaIdent() {
return FileHandler.metaIdent;
}
static joinMeta(meta) {
return [
FileHandler.metaIdent,
meta.typeString,
meta.start,
meta.length,
meta.entry,
meta.encoding
].join(";");
}
static reRegExpIsText = new RegExp(/^\d+ |^[\t\r\n\x1a\x20-\x7e]*$/); // eslint-disable-line no-control-regex
processDskFile(data, name, imported) {
try {
const dsk = this.getDiskImage();
dsk.setOptions({
data: data,
diskName: name
});
const dir = dsk.readDirectory(), diskFiles = Object.keys(dir);
for (let i = 0; i < diskFiles.length; i += 1) {
const fileName = diskFiles[i];
try { // eslint-disable-line max-depth
data = dsk.readFile(dir[fileName]);
this.fnLoad2(data, fileName, "", imported); // recursive
}
catch (e) {
Utils.console.error(e);
if (e instanceof Error) { // eslint-disable-line max-depth
this.options.outputError(e, true);
}
}
}
}
catch (e) {
Utils.console.error(e);
if (e instanceof Error) {
this.options.outputError(e, true);
}
}
}
processZipFile(uint8Array, name, imported) {
let zip;
try {
zip = new ZipFile({
data: uint8Array, // rather data
zipName: name
});
}
catch (e) {
Utils.console.error(e);
if (e instanceof Error) {
this.options.outputError(e, true);
}
}
if (zip) {
const zipDirectory = zip.getZipDirectory(), entries = Object.keys(zipDirectory);
for (let i = 0; i < entries.length; i += 1) {
const name2 = entries[i];
if (name2.startsWith("__MACOSX/")) { // MacOS X creates some extra folder in ZIP files
Utils.console.log("processZipFile: Ignoring file:", name2);
}
else {
let data2;
try {
data2 = zip.readData(name2);
}
catch (e) {
Utils.console.error(e);
if (e instanceof Error) { // eslint-disable-line max-depth
this.options.outputError(e, true);
}
}
if (data2) {
this.fnLoad2(data2, name2, "", imported); // type not known but without meta
}
}
}
}
}
fnLoad2(data, name, type, imported) {
let header;
if (type === "" && !(data instanceof Uint8Array)) { // detetermine type
header = DiskImage.parseAmsdosHeader(data);
if (header) {
type = "H"; // with header
data = data.substring(0x80); // remove header
}
else if (FileHandler.reRegExpIsText.test(data)) {
type = "A";
}
else if (Snapshot.testSnapIdent(data.substring(0, 8))) { // snapshot file?
type = "S";
}
else if (DiskImage.testDiskIdent(data.substring(0, 8))) { // disk image file?
type = "X";
}
}
switch (type) {
case "A": // "text/plain"
case "B": // binary?
header = DiskImage.createAmsdosHeader({
typeString: type,
length: data.length
});
break;
case "H": // with header?
break;
case "S": // sna file?
header = DiskImage.createAmsdosHeader({
typeString: type,
length: data.length
}); // currently we store it
break;
case "X": // dsk file?
if (this.processFileImports) {
this.processDskFile(data, name, imported); // we know data is string
}
else {
header = DiskImage.createAmsdosHeader({
typeString: type,
length: data.length
});
}
break;
case "Z": // zip file?
if (this.processFileImports) {
this.processZipFile(data instanceof Uint8Array ? data : Utils.string2Uint8Array(data), name, imported);
}
else {
header = DiskImage.createAmsdosHeader({
typeString: type,
length: data.length
});
}
break;
default:
Utils.console.warn("fnLoad2: " + name + ": Unknown file type: " + type + ", assuming B");
header = DiskImage.createAmsdosHeader({
typeString: "B",
length: data.length
});
break;
}
if (header) { // do we have a header? (means we should store it as a file in storage...)
const storageName = FileHandler.fnLocalStorageName(this.options.adaptFilename(name, "FILE")), meta = FileHandler.joinMeta(header), dataAsString = data instanceof Uint8Array ? Utils.uint8Array2string(data) : data;
try {
Utils.localStorage.setItem(storageName, meta + "," + dataAsString);
this.options.updateStorageDatabase("set", storageName);
Utils.console.log("fnOnLoad: file: " + storageName + " meta: " + meta + " imported");
imported.push(name);
}
catch (e) { // maybe quota exceeded
Utils.console.error(e);
if (e instanceof Error) {
if (e.name === "QuotaExceededError") {
e.shortMessage = storageName + ": Quota exceeded";
}
this.options.outputError(e, true);
}
}
}
}
}
class FileSelect {
options;
fnOnErrorHandler;
fnOnLoadHandler;
fnOnFileSelectHandler;
files;
fileIndex = 0;
imported = []; // imported file names
file; // current file
constructor(options) {
this.fnOnLoadHandler = this.fnOnLoad.bind(this);
this.fnOnErrorHandler = this.fnOnError.bind(this);
this.fnOnFileSelectHandler = this.fnOnFileSelect.bind(this);
this.options = {};
this.setOptions(options);
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
fnReadNextFile(reader) {
if (this.files && this.fileIndex < this.files.length) {
const file = this.files[this.fileIndex];
this.fileIndex += 1;
const lastModified = file.lastModified, lastModifiedDate = lastModified ? new Date(lastModified) : file.lastModifiedDate, // lastModifiedDate deprecated, but for old IE
text = file.name + " " + (file.type || "n/a") + " " + file.size + " " + (lastModifiedDate ? lastModifiedDate.toLocaleDateString() : "n/a");
Utils.console.log(text);
if (file.type === "text/plain") {
reader.readAsText(file);
}
else if (file.type === "application/x-zip-compressed" || file.type === "application/zip") { // on Mac OS it is "application/zip"
reader.readAsArrayBuffer(file);
}
else {
reader.readAsDataURL(file);
}
this.file = file;
}
else {
this.options.fnEndOfImport(this.imported);
}
}
fnOnLoad(event) {
if (!this.file) {
Utils.console.error("fnOnLoad: Programming error: No file");
return;
}
const file = this.file, name = file.name, reader = event.target;
let data = (reader && reader.result) || null, type = file.type;
if ((type === "application/x-zip-compressed" || type === "application/zip") && data instanceof ArrayBuffer) { // on Mac OS it is "application/zip"
type = "Z";
this.options.fnLoad2(new Uint8Array(data), name, type, this.imported);
}
else if (typeof data === "string") {
if (type === "text/plain") { // "text/plain"
type = "A";
}
else if (data.indexOf("data:") === 0) {
const index = data.indexOf(",");
if (index >= 0) {
const info1 = data.substring(0, index);
data = data.substring(index + 1);
if (info1.indexOf("base64") >= 0) {
data = Utils.atob(data); // decode base64
}
if (info1.indexOf("text/") >= 0) {
type = "A";
}
}
}
this.options.fnLoad2(data, name, type, this.imported);
}
else {
Utils.console.warn("Error loading file", name, "with type", type, " unexpected data:", data);
}
if (reader) {
this.fnReadNextFile(reader);
}
}
fnOnError(event) {
const reader = event.target, filename = (this.file && this.file.name) || "unknown";
let msg = "fnOnError: " + filename;
if (reader && reader.error) {
msg += ": " + String(reader.error);
}
Utils.console.error(msg);
if (reader) {
this.fnReadNextFile(reader);
}
}
fnOnFileSelect(event) {
event.stopPropagation();
event.preventDefault();
const dataTransfer = event.dataTransfer, files = dataTransfer ? dataTransfer.files : View.getEventTarget(event).files; // dataTransfer for drag&drop, target.files for file input
if (!files || !files.length) {
Utils.console.error("fnHandleFileSelect: No files!");
return;
}
this.files = files;
this.fileIndex = 0;
this.imported.length = 0;
if (window.FileReader) {
const reader = new window.FileReader();
reader.onerror = this.fnOnErrorHandler;
reader.onload = this.fnOnLoadHandler;
this.fnReadNextFile(reader);
}
else {
Utils.console.warn("fnHandleFileSelect: FileReader API not supported.");
}
}
addFileSelectHandler(element, type) {
element.addEventListener(type, this.fnOnFileSelectHandler, false);
}
}
class InputStack {
input = [];
stackPosition = -1;
reset() {
this.input.length = 0;
this.stackPosition = -1;
}
getInput() {
return this.input[this.stackPosition];
}
clearRedo() {
this.input = this.input.slice(0, this.stackPosition + 1);
}
save(input) {
this.clearRedo();
this.input.push(input);
this.stackPosition += 1;
}
canUndoKeepOne() {
return this.stackPosition > 0;
}
undo() {
this.stackPosition -= 1;
return this.getInput();
}
canRedo() {
return this.stackPosition < this.input.length - 1;
}
redo() {
this.stackPosition += 1;
return this.getInput();
}
}
class Keyboard {
fnKeydownOrKeyupHandler;
options;
keyBuffer = []; // buffered pressed keys
expansionTokens = []; // strings for expansion tokens 0..31 (in reality: 128..159)
cpcKeyExpansions; // cpc keys to expansion tokens for normal, shift, ctrl; also repeat
active = false; // flag if keyboard is active/focused, set from outside
key2CpcKey;
codeStringsRemoved = false;
pressedKeys = {}; // currently pressed browser keys
simulatedNumLock; // simulated num lock for Mac OS
constructor(options) {
this.fnKeydownOrKeyupHandler = this.onKeydownOrKeyup.bind(this);
this.options = {};
this.setOptions(options);
this.key2CpcKey = Keyboard.key2CpcKey;
this.cpcKeyExpansions = {
normal: {},
shift: {},
ctrl: {},
repeat: {}
}; // cpc keys to expansion tokens for normal, shift, ctrl; also repeat
const view = this.options.view;
view.addEventListenerById("keydown", this.fnKeydownOrKeyupHandler, "cpcArea" /* ViewID.cpcArea */);
view.addEventListenerById("keyup", this.fnKeydownOrKeyupHandler, "cpcArea" /* ViewID.cpcArea */);
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
static key2CpcKey = {
"38ArrowUp": 0,
"39ArrowRight": 1,
"40ArrowDown": 2,
"105Numpad9": 3,
"120F9": 3,
"102Numpad6": 4,
"117F6": 4,
"99Numpad3": 5,
"114F3": 5,
"13NumpadEnter": 6,
"110NumpadDecimal": 7,
"37ArrowLeft": 8,
"18AltLeft": 9,
"103Numpad7": 10,
"118F7": 10,
"104Numpad8": 11,
"119F8": 11,
"101Numpad5": 12,
"116F5": 12,
"97Numpad1": 13,
"112F1": 13,
"98Numpad2": 14,
"113F2": 14,
"96Numpad0": 15,
"121F10": 15,
"46Delete": 16,
"187BracketRight": 17,
"171BracketRight": 17,
"221BracketRight": 17,
"13Enter": 18,
"191Backslash": 19,
"163Backslash": 19,
"220Backslash": 19,
"100Numpad4": 20,
"115F4": 20,
"16ShiftLeft": 21,
"16ShiftRight": 21,
"220Backquote": 22,
"160Backquote": 22,
"192Backquote": 22,
"17ControlLeft": 23,
"17ControlRight": 23,
"221Equal": 24,
"192Equal": 24,
"187Equal": 24,
"219Minus": 25,
"63Minus": 25,
"189Minus": 25,
"186BracketLeft": 26,
"59BracketLeft": 26,
"219BracketLeft": 26,
"80KeyP": 27,
"222Quote": 28,
"192Quote": 28,
"192Semicolon": 29,
"186Semicolon": 29,
"189Slash": 30,
"173Slash": 30,
"191Slash": 30,
"190Period": 31,
"48Digit0": 32,
"57Digit9": 33,
"79KeyO": 34,
"73KeyI": 35,
"76KeyL": 36,
"75KeyK": 37,
"77KeyM": 38,
"188Comma": 39,
"56Digit8": 40,
"55Digit7": 41,
"85KeyU": 42,
"90KeyY": 43,
"89KeyY": 43,
"72KeyH": 44,
"74KeyJ": 45,
"78KeyN": 46,
"32Space": 47,
"54Digit6": 48,
"53Digit5": 49,
"82KeyR": 50,
"84KeyT": 51,
"71KeyG": 52,
"70KeyF": 53,
"66KeyB": 54,
"86KeyV": 55,
"52Digit4": 56,
"51Digit3": 57,
"69KeyE": 58,
"87KeyW": 59,
"83KeyS": 60,
"68KeyD": 61,
"67KeyC": 62,
"88KeyX": 63,
"49Digit1": 64,
"50Digit2": 65,
"27Escape": 66,
"81KeyQ": 67,
"9Tab": 68,
"65KeyA": 69,
"20CapsLock": 70,
"89KeyZ": 71,
"90KeyZ": 71,
"38Numpad8": 72,
"40Numpad2": 73,
"37Numpad4": 74,
"39Numpad6": 75,
"12Numpad5": 76,
"45Numpad0": 76,
"46NumpadDecimal": 77,
"8Backspace": 79,
"36Numpad7": 80,
"33Numpad9": 81,
"35Numpad1": 82,
"34Numpad3": 83,
"226IntlBackslash": 85,
"60IntlBackslash": 85,
"220IntlBackslash": 85,
"111NumpadDivide": 86,
"106NumpadMultiply": 87,
"109NumpadSubtract": 88,
"107NumpadAdd": 89
};
static specialKeys = {
Alt: String.fromCharCode(224), // Copy
ArrowUp: String.fromCharCode(240),
ArrowDown: String.fromCharCode(241),
ArrowLeft: String.fromCharCode(242),
ArrowRight: String.fromCharCode(243),
ArrowUpShift: String.fromCharCode(244),
ArrowDownShift: String.fromCharCode(245),
ArrowLeftShift: String.fromCharCode(246),
ArrowRightShift: String.fromCharCode(247),
ArrowUpCtrl: String.fromCharCode(248),
ArrowDownCtrl: String.fromCharCode(249),
ArrowLeftCtrl: String.fromCharCode(250),
ArrowRightCtrl: String.fromCharCode(251),
Backspace: String.fromCharCode(127),
Delete: String.fromCharCode(16),
Enter: "\r",
JoyUp: String.fromCharCode(11),
JoyDown: String.fromCharCode(10),
JoyLeft: String.fromCharCode(8),
JoyRight: String.fromCharCode(9),
Clear: "X", // joy fire 2
Spacebar: " ", // for IE
Tab: String.fromCharCode(9),
: ";",
: "+",
: ":",
: "*",
: "@",
: "|",
: "-",
DeadBackquote: "^",
"": "",
DeadEqual: String.fromCharCode(161), // tick
"": String.fromCharCode(161), // IE: tick
DeadEqualShift: "`" // backtick
};
/* eslint-disable array-element-newline */
static joyKeyCodes = [
[72, 73, 74, 75, 76, 77],
[48, 49, 50, 51, 52, 53]
];
/* eslint-enable array-element-newline */
reset() {
this.options.fnOnKeyDown = undefined;
this.clearInput();
this.pressedKeys = {}; // currently pressed browser keys
this.resetExpansionTokens();
this.resetCpcKeysExpansions();
}
clearInput() {
this.keyBuffer.length = 0;
}
resetExpansionTokens() {
const expansionTokens = this.expansionTokens;
for (let i = 0; i <= 9; i += 1) {
expansionTokens[i] = String(i);
}
expansionTokens[10] = ".";
expansionTokens[11] = "\r";
expansionTokens[12] = 'RUN"\r';
for (let i = 13; i <= 31; i += 1) {
expansionTokens[i] = "0";
}
}
resetCpcKeysExpansions() {
const cpcKeyExpansions = this.cpcKeyExpansions;
cpcKeyExpansions.normal = {
15: 0 + 128, // F0
13: 1 + 128, // F1
14: 2 + 128, // F2
5: 3 + 128, // F3
20: 4 + 128, // F4
12: 5 + 128, // F5
4: 6 + 128, // F6
10: 7 + 128, // F7
11: 8 + 128, // F8
3: 9 + 128, // F9
7: 10 + 128, // F.
6: 11 + 128 // Enter
};
cpcKeyExpansions.shift = {};
cpcKeyExpansions.ctrl = {
6: 12 + 128 // ctrl+Enter
};
cpcKeyExpansions.repeat = {};
}
setActive(active) {
this.active = active;
}
removeCodeStringsFromKeymap() {
const key2CpcKey = this.key2CpcKey, newMap = {};
if (Utils.debug > 1) {
Utils.console.log("removeCodeStringsFromKeymap: Unfortunately not all keys can be used.");
}
for (const key in key2CpcKey) {
if (key2CpcKey.hasOwnProperty(key)) {
const keyCode = parseInt(key, 10); // get just the number
newMap[keyCode] = key2CpcKey[key];
}
}
this.key2CpcKey = newMap;
}
fnPressCpcKey(event, cpcKeyCode, pressedKey, key) {
const shiftKey = event.shiftKey, ctrlKey = event.ctrlKey, pressedKeys = this.pressedKeys, cpcKeyExpansions = this.cpcKeyExpansions, specialKeys = Keyboard.specialKeys, cpcKey = String(cpcKeyCode);
let cpcKeyEntry = pressedKeys[cpcKey];
if (!cpcKeyEntry) {
pressedKeys[cpcKey] = {
keys: {},
shift: false,
ctrl: false
};
cpcKeyEntry = pressedKeys[cpcKey];
}
const keyAlreadyPressed = cpcKeyEntry.keys[pressedKey];
cpcKeyEntry.keys[pressedKey] = true;
cpcKeyEntry.shift = shiftKey;
cpcKeyEntry.ctrl = ctrlKey;
if (Utils.debug > 1) {
Utils.console.log("fnPressCpcKey: pressedKey=" + pressedKey + ", key=" + key + ", affected cpc key=" + cpcKey);
}
const repeat = cpcKeyExpansions.repeat;
if (keyAlreadyPressed && ((cpcKey in repeat) && !repeat[cpcKey])) {
key = ""; // repeat off => ignore key
}
else {
let expansions;
if (ctrlKey) {
expansions = cpcKeyExpansions.ctrl;
}
else if (shiftKey) {
expansions = cpcKeyExpansions.shift;
}
else {
expansions = cpcKeyExpansions.normal;
}
if (cpcKey in expansions) {
const expKey = expansions[cpcKey];
if (expKey >= 128 && expKey <= 159) {
key = this.expansionTokens[expKey - 128];
for (let i = 0; i < key.length; i += 1) {
this.putKeyInBuffer(key.charAt(i));
}
}
else { // ascii code
key = String.fromCharCode(expKey);
this.putKeyInBuffer(key.charAt(0));
}
key = ""; // already done, ignore key form keyboard
}
}
const shiftCtrlKey = key + (shiftKey ? "Shift" : "") + (ctrlKey ? "Ctrl" : "");
if (shiftCtrlKey in specialKeys) {
key = specialKeys[shiftCtrlKey];
}
else if (key in specialKeys) {
key = specialKeys[key];
}
else if (ctrlKey) {
if (key >= "a" && key <= "z") { // map keys with ctrl to control codes (problem: some control codes are browser functions, e.g. w: close window)
key = String.fromCharCode(key.charCodeAt(0) - 96); // ctrl+a => \x01
}
}
if (key.length === 1) { // put normal keys in buffer, ignore special keys with more than 1 character
this.putKeyInBuffer(key);
}
if (cpcKeyCode === 66 && this.options.fnOnEscapeHandler) { // or: key === "Escape" or "Esc" (on IE)
this.options.fnOnEscapeHandler(key, pressedKey);
}
if (this.options.fnOnKeyDown) { // special handler?
this.options.fnOnKeyDown();
}
}
fnReleaseCpcKey(event, cpcKeyCode, pressedKey, key) {
const shiftKey = event.shiftKey, ctrlKey = event.ctrlKey, pressedKeys = this.pressedKeys, cpcKey = pressedKeys[cpcKeyCode];
if (Utils.debug > 1) {
Utils.console.log("fnReleaseCpcKey: pressedKey=" + pressedKey + ", key=" + key + ", affected cpc key=" + cpcKeyCode + ", keys:", (cpcKey ? cpcKey.keys : "undef."));
}
if (!cpcKey) {
Utils.console.warn("fnReleaseCpcKey: cpcKey was not pressed:", cpcKeyCode);
}
else {
delete cpcKey.keys[pressedKey];
if (!Object.keys(cpcKey.keys).length) {
delete pressedKeys[cpcKeyCode];
}
else {
cpcKey.shift = shiftKey;
cpcKey.ctrl = ctrlKey;
}
}
}
static keyIdentifier2Char(event) {
const identifier = event.keyIdentifier, // eslint-disable-line @typescript-eslint/no-explicit-any
shiftKey = event.shiftKey;
let char = "";
if ((/^U\+/i).test(identifier || "")) { // unicode string?
char = String.fromCharCode(parseInt(identifier.substr(2), 16));
if (char === "\0") { // ignore
char = "";
}
char = shiftKey ? char.toUpperCase() : char.toLowerCase(); // do we get keys in unicode always in uppercase?
}
else {
char = identifier; // take it, could be "Enter"
}
return char;
}
static numPadOffKeyMap = {
"96Numpad0": "45Numpad0",
"97Numpad1": "35Numpad1",
"98Numpad2": "40Numpad2",
"99Numpad3": "34Numpad3",
"100Numpad4": "37Numpad4",
"101Numpad5": "12Numpad5",
"102Numpad6": "39Numpad6",
"103Numpad7": "36Numpad7",
"104Numpad8": "38Numpad8",
"105Numpad9": "33Numpad9",
"110NumpadDecimal": "46NumpadDecimal"
};
fnKeyboardKeydown(event) {
const keyCode = event.which || event.keyCode;
let pressedKey = String(keyCode) + (event.code ? event.code : ""), // event.code available for e.g. Chrome, Firefox
key = event.key || Keyboard.keyIdentifier2Char(event) || ""; // SliTaz web browser has not key but keyIdentifier
if (!event.code && !this.codeStringsRemoved) { // event.code not available on e.g. IE, Edge
this.removeCodeStringsFromKeymap(); // remove code information from the mapping. Not all keys can be detected any more
this.codeStringsRemoved = true;
}
if (Utils.debug > 1) {
Utils.console.log("fnKeyboardKeydown: keyCode=" + keyCode + " pressedKey=" + pressedKey + " key='" + key + "' " + key.charCodeAt(0) + " loc=" + event.location + " ", event);
}
if (pressedKey in this.key2CpcKey) {
const numTabOffKey = this.simulatedNumLock === false ? Keyboard.numPadOffKeyMap[pressedKey] : undefined;
if (numTabOffKey) {
pressedKey = numTabOffKey;
}
let cpcKey = this.key2CpcKey[pressedKey];
if (cpcKey === 85) { // map virtual cpc key 85 to 22 (english keyboard)
cpcKey = 22;
}
if (cpcKey === 72) {
key = "JoyUp";
}
else if (cpcKey === 73) {
key = "JoyDown";
}
else if (cpcKey === 74) {
key = "JoyLeft";
}
else if (cpcKey === 75) {
key = "JoyRight";
}
else if (key === "Dead") { // Chrome, FF
key += event.code + (event.shiftKey ? "Shift" : ""); // special handling => "DeadBackquote" or "DeadEqual"; and "Shift"
}
else if (key === "Unidentified") { // IE, Edge
if (keyCode === 220) {
key = event.shiftKey ? "" : "DeadBackquote";
}
else if (keyCode === 221) {
key = "DeadEqual" + (event.shiftKey ? "Shift" : "");
}
else if (keyCode === 226) { // "|"
key = "|";
}
}
else if (key.length === 2) {
if (key.charAt(0) === "^" || key.charAt(0) === "" || key.charAt(0) === "`") { // IE, Edge? prefix key
key = key.substring(1); // remove prefix
}
}
this.fnPressCpcKey(event, cpcKey, pressedKey, key);
}
else if (key.length === 1) { // put normal keys in buffer, ignore special keys with more than 1 character
this.putKeyInBuffer(key);
Utils.console.log("fnKeyboardKeydown: Partly unhandled key", pressedKey + ":", key);
}
else if (pressedKey === "12NumLock") { // key = "Clear"; MacOS
this.simulatedNumLock = this.simulatedNumLock !== undefined ? !this.simulatedNumLock : false;
if (Utils.debug > 1) {
Utils.console.log("fnKeyboardKeydown: simulatedNumLock=" + this.simulatedNumLock);
}
}
else {
Utils.console.log("fnKeyboardKeydown: Unhandled key", pressedKey + ":", key);
}
}
fnKeyboardKeyup(event) {
const keyCode = event.which || event.keyCode, key = event.key || Keyboard.keyIdentifier2Char(event) || ""; // SliTaz web browser has not key but keyIdentifier
let pressedKey = String(keyCode) + (event.code ? event.code : ""); // event.code available for e.g. Chrome, Firefox
if (Utils.debug > 1) {
Utils.console.log("fnKeyboardKeyup: keyCode=" + keyCode + " pressedKey=" + pressedKey + " key='" + key + "' " + key.charCodeAt(0) + " loc=" + event.location + " ", event);
}
if (pressedKey in this.key2CpcKey) {
const numTabOffKey = this.simulatedNumLock === false ? Keyboard.numPadOffKeyMap[pressedKey] : undefined;
if (numTabOffKey) {
pressedKey = numTabOffKey;
}
let cpcKey = this.key2CpcKey[pressedKey];
if (cpcKey === 85) { // map virtual cpc key 85 to 22 (english keyboard)
cpcKey = 22;
}
this.fnReleaseCpcKey(event, cpcKey, pressedKey, key);
}
else if (pressedKey === "12NumLock") { // key = "Clear"; MacOS
if (Utils.debug > 1) {
Utils.console.log("fnKeyboardKeyup: simulatedNumLock=" + this.simulatedNumLock);
}
}
else {
Utils.console.log("fnKeyboardKeyup: Unhandled key", pressedKey + ":", key);
}
}
getKeyFromBuffer() {
const keyBuffer = this.keyBuffer, key = keyBuffer.length ? keyBuffer.shift() : "";
return key;
}
putKeyInBuffer(key, triggerOnKeyDown) {
this.keyBuffer.push(key);
if (triggerOnKeyDown) {
const keyDownHandler = this.options.fnOnKeyDown;
if (keyDownHandler) {
keyDownHandler();
}
}
}
putKeysInBuffer(input) {
for (let i = 0; i < input.length; i += 1) {
const key = input.charAt(i);
this.keyBuffer.push(key);
}
}
getKeyState(cpcKeyCode) {
const pressedKeys = this.pressedKeys;
let state = -1;
if (cpcKeyCode in pressedKeys) {
const cpcKeyEntry = pressedKeys[cpcKeyCode];
state = 0 + (cpcKeyEntry.shift ? 32 : 0) + (cpcKeyEntry.ctrl ? 128 : 0);
}
return state;
}
getJoyState(joy) {
const joyKeyList = Keyboard.joyKeyCodes[joy];
let value = 0;
/* eslint-disable no-bitwise */
for (let i = 0; i < joyKeyList.length; i += 1) {
if (this.getKeyState(joyKeyList[i]) !== -1) {
value |= (1 << i);
}
}
if (joy === 0) {
if (this.getKeyState(80) !== -1) { // up left
value |= 1 + 4;
}
if (this.getKeyState(81) !== -1) { // up right
value |= 1 + 8;
}
if (this.getKeyState(82) !== -1) { // down left
value |= 2 + 4;
}
if (this.getKeyState(83) !== -1) { // down right
value |= 2 + 8;
}
}
/* eslint-enable no-bitwise */
return value;
}
setExpansionToken(token, string) {
this.expansionTokens[token] = string;
}
setCpcKeyExpansion(options) {
const cpcKeyExpansions = this.cpcKeyExpansions, cpcKey = options.cpcKey;
cpcKeyExpansions.repeat[cpcKey] = options.repeat;
if (options.normal !== undefined) {
cpcKeyExpansions.normal[cpcKey] = options.normal;
}
if (options.shift !== undefined) {
cpcKeyExpansions.shift[cpcKey] = options.shift;
}
if (options.ctrl !== undefined) {
cpcKeyExpansions.ctrl[cpcKey] = options.ctrl;
}
}
onKeydownOrKeyup(event) {
if (this.active) {
if (event.type === "keydown") {
this.fnKeyboardKeydown(event);
}
else if (event.type === "keyup") {
this.fnKeyboardKeyup(event);
}
else {
Utils.console.error("onKeydownOrKeyup: Unknown type:", event.type);
}
event.preventDefault();
return false;
}
return undefined;
}
}
class NoCanvas {
options;
constructor(options) {
this.options = {};
this.setOptions(options);
this.reset();
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
reset() {
}
resetCustomChars() {
}
setScreenOffset(_offset) {
}
updateColorsAndCanvasImmediately(_inkList) {
}
updateSpeedInk() {
}
setCustomChar(_char, _charData) {
}
getCharData(_char) {
return [];
}
setDefaultInks() {
}
onCanvasClick(_event) {
}
getXpos() {
return 0;
}
getYpos() {
return 0;
}
getByte(_addr) {
return 0;
}
setByte(_addr, _byte) {
}
draw(_x, _y) {
}
move(_x, _y) {
}
plot(_x, _y) {
}
test(_x, _y) {
return 0;
}
setInk(_pen, _ink1, _ink2) {
return false;
}
setBorder(_ink1, _ink2) {
}
setGPen(_gPen) {
}
setGPaper(_gPaper) {
}
setGTransparentMode(_transparent) {
}
printGChar(_char) {
}
drawCursor(_x, _y, _pen, _paper) {
}
fill(_fillPen) {
}
setOrigin(_xOrig, _yOrig) {
}
getXOrigin() {
return 0;
}
getYOrigin() {
return 0;
}
setGWindow(_xLeft, _xRight, _yTop, _yBottom) {
}
setGColMode(_gColMode) {
}
clearGraphicsWindow() {
}
setSpeedInk(_time1, _time2) {
}
setMask(_mask) {
}
setMaskFirst(_maskFirst) {
}
getMode() {
return 0;
}
changeMode(_mode) {
}
takeScreenShot() {
return "";
}
startUpdateCanvas() {
}
stopUpdateCanvas() {
}
onWindowClick(_event) {
}
fillTextBox(_left, _top, _width, _height, _paper) {
}
printChar(_char, _x, _y, _pen, _paper, _transparent) {
}
readChar(_x, _y, _pen, _paper) {
return 0;
}
clearTextWindow(_left, _right, _top, _bottom, _paper) {
}
setMode(_mode) {
}
clearFullWindow() {
}
windowScrollUp(_left, _right, _top, _bottom, _paper) {
}
windowScrollDown(_left, _right, _top, _bottom, _paper) {
}
}
class TextCanvas {
options;
fnUpdateCanvasHandler;
fnUpdateCanvas2Handler;
fps = 15; // FPS for canvas update
isRunning = false;
animationTimeoutId;
animationFrame;
cpcAreaBox;
textText;
borderWidth = 1;
cols;
rows;
needUpdate = false;
textBuffer = []; // textbuffer characters at row,column
hasFocus = false; // canvas has focus
customCharset = {};
constructor(options) {
this.options = {};
this.setOptions(options);
this.textText = View.getElementByIdAs(this.options.canvasID);
this.cpcAreaBox = View.getElementById1("cpcArea" /* ViewID.cpcArea */);
this.fnUpdateCanvasHandler = this.updateCanvas.bind(this);
this.fnUpdateCanvas2Handler = this.updateCanvas2.bind(this);
this.cols = parseFloat(this.textText.getAttribute("cols") || "0");
this.rows = parseFloat(this.textText.getAttribute("rows") || "0");
this.animationTimeoutId = undefined;
this.animationFrame = undefined;
this.reset();
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
static cpc2Unicode = "................................ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]\u2195_`abcdefghijklmnopqrstuvwxyz{|}~\u2591\u00A0\u2598\u259D\u2580.\u258C....\u2590.\u2584..\u2588\u00B7\u2575\u2576\u2514\u2577\u2502\u250C\u251C\u2574\u2518\u2500\u2534\u2510\u2524\u252C\u253C^\u00B4\u00A8\u00A3\u00A9\u00B6\u00A7\u2018\u00BC\u00BD\u00BE\u00B1\u00F7\u00AC\u00BF\u00A1\u03B1\u03B2\u03B3\u03B4\u03B5\u03B8\u03BB\u03BC\u03C0\u03C3\u03C6\u03C8\u03C7\u03C9\u03A3\u03A9\u1FBA0\u1FBA1\u1FBA3\u1FBA2\u1FBA7\u1FBA5\u1FBA6\u1FBA4\u1FBA8\u1FBA9\u1FBAE\u2573\u2571\u2572\u1FB95\u2592\u23BA\u23B9\u23BD\u23B8....\u1FB8E\u1FB8D\u1FB8F\u1FB8C\u1FB9C\u1FB9D\u1FB9E\u1FB9F\u263A.\u2663\u2666\u2665\u2660\u25CB\u25CF\u25A1\u25A0\u2642\u2640";
static winData = [
{
left: 0,
right: 19,
top: 0,
bottom: 24
},
{
left: 0,
right: 39,
top: 0,
bottom: 24
},
{
left: 0,
right: 79,
top: 0,
bottom: 24
},
{
left: 0, // mode 3 not available on CPC
right: 79,
top: 0,
bottom: 49
}
];
reset() {
this.resetTextBuffer();
this.setNeedUpdate();
}
resetCustomChars() {
}
setScreenOffset(_offset) {
}
updateColorsAndCanvasImmediately(_inkList) {
}
updateSpeedInk() {
}
setCustomChar(char, charData) {
this.customCharset[char] = charData;
}
getCharData(char) {
return this.customCharset[char] || this.options.charset[char];
}
setDefaultInks() {
}
getXpos() {
return 0;
}
getYpos() {
return 0;
}
getByte(_addr) {
return 0;
}
setByte(_addr, _byte) {
}
draw(_x, _y) {
}
move(_x, _y) {
}
plot(_x, _y) {
}
test(_x, _y) {
return 0;
}
setInk(_pen, _ink1, _ink2) {
return false;
}
setBorder(_ink1, _ink2) {
}
setGPen(_gPen) {
}
setGPaper(_gPaper) {
}
setGTransparentMode(_transparent) {
}
printGChar(_char) {
}
drawCursor(_x, _y, _pen, _paper) {
}
fill(_fillPen) {
}
setOrigin(_xOrig, _yOrig) {
}
getXOrigin() {
return 0;
}
getYOrigin() {
return 0;
}
setGWindow(_xLeft, _xRight, _yTop, _yBottom) {
}
setGColMode(_gColMode) {
}
clearGraphicsWindow() {
}
setSpeedInk(_time1, _time2) {
}
setMask(_mask) {
}
setMaskFirst(_maskFirst) {
}
getMode() {
return 0;
}
changeMode(_mode) {
}
takeScreenShot() {
return "";
}
resetTextBuffer() {
this.textBuffer.length = 0;
}
setNeedUpdate() {
this.needUpdate = true;
}
updateCanvas2() {
if (!this.isRunning) {
return; // ignore remaining timeouts, if stopped
}
this.animationFrame = requestAnimationFrame(this.fnUpdateCanvasHandler);
if (this.textText.offsetParent) { // text area visible?
if (this.needUpdate) {
this.needUpdate = false;
this.updateTextWindow();
}
}
}
updateCanvas() {
this.animationTimeoutId = window.setTimeout(this.fnUpdateCanvas2Handler, 1000 / this.fps); // ts (node)
}
startUpdateCanvas() {
if (!this.isRunning && this.textText.offsetParent !== null) { // animation off and canvas visible in DOM? (with noteJS it is currently undefined)
this.isRunning = true;
this.updateCanvas();
}
}
stopUpdateCanvas() {
if (this.isRunning) {
this.isRunning = false;
if (this.animationFrame) {
cancelAnimationFrame(this.animationFrame);
this.animationFrame = undefined;
}
clearTimeout(this.animationTimeoutId);
this.animationTimeoutId = undefined;
}
}
updateTextWindow() {
const textBuffer = this.textBuffer, cpc2Unicode = TextCanvas.cpc2Unicode;
let out = "";
for (let y = 0; y < textBuffer.length; y += 1) {
const textBufferRow = textBuffer[y];
if (textBufferRow) {
for (let x = 0; x < textBufferRow.length; x += 1) {
out += cpc2Unicode[textBufferRow[x] || 32];
}
}
out += "\n";
}
this.textText.value = out;
}
setFocusOnCanvas() {
this.cpcAreaBox.style.background = "#463c3c";
if (this.textText) {
this.textText.focus();
}
this.hasFocus = true;
}
getMousePos(event, canvasWidth, canvasHeight) {
const rect = this.textText.getBoundingClientRect(), pos = {
x: (event.clientX - this.borderWidth - rect.left) / (rect.right - rect.left - this.borderWidth * 2) * canvasWidth,
y: (event.clientY - this.borderWidth - rect.top) / (rect.bottom - rect.top - this.borderWidth * 2) * canvasHeight
};
return pos;
}
canvasClickAction(event) {
const canvasWidth = 640, canvasHeight = 400, pos = this.getMousePos(event, canvasWidth, canvasHeight),
/* eslint-disable no-bitwise */
x = pos.x | 0, // force integer
y = pos.y | 0;
/* eslint-enable no-bitwise */
if (this.options.onCanvasClick) {
const charWidth = canvasWidth / this.cols, charHeight = canvasHeight / this.rows,
/* eslint-disable no-bitwise */
xTxt = (x / charWidth) | 0, yTxt = (y / charHeight) | 0;
/* eslint-enable no-bitwise */
this.options.onCanvasClick(event, x, y, xTxt, yTxt);
}
}
onCanvasClick(event) {
if (!this.hasFocus) {
this.setFocusOnCanvas();
}
else {
this.canvasClickAction(event);
}
event.stopPropagation();
}
onWindowClick(_event) {
if (this.hasFocus) {
this.hasFocus = false;
this.cpcAreaBox.style.background = "";
}
}
fillTextBox(left, top, width, height, _paper) {
this.clearTextBufferBox(left, top, width, height);
}
clearTextBufferBox(left, top, width, height) {
const textBuffer = this.textBuffer;
for (let y = top; y < top + height; y += 1) {
const textBufferRow = textBuffer[y];
if (textBufferRow) {
for (let x = left; x < left + width; x += 1) {
delete textBufferRow[x];
}
}
}
this.setNeedUpdate();
}
copyTextBufferBoxUp(left, top, width, height, left2, top2) {
const textBuffer = this.textBuffer;
for (let y = 0; y < height; y += 1) {
const sourceRow = textBuffer[top + y];
let destinationRow = textBuffer[top2 + y];
if (sourceRow) {
if (!destinationRow) {
destinationRow = [];
textBuffer[top2 + y] = destinationRow;
}
for (let x = 0; x < width; x += 1) {
destinationRow[left2 + x] = sourceRow[left + x];
}
}
else if (destinationRow) {
delete textBuffer[top2 + y]; // no sourceRow => clear destinationRow
}
}
this.setNeedUpdate();
}
copyTextBufferBoxDown(left, top, width, height, left2, top2) {
const textBuffer = this.textBuffer;
for (let y = height - 1; y >= 0; y -= 1) {
const sourceRow = textBuffer[top + y];
let destinationRow = textBuffer[top2 + y];
if (sourceRow) {
if (!destinationRow) {
destinationRow = [];
textBuffer[top2 + y] = destinationRow;
}
for (let x = 0; x < width; x += 1) {
destinationRow[left2 + x] = sourceRow[left + x];
}
}
else if (destinationRow) {
delete textBuffer[top2 + y]; // no sourceRow => clear destinationRow
}
}
this.setNeedUpdate();
}
putCharInTextBuffer(char, x, y) {
const textBuffer = this.textBuffer;
if (!textBuffer[y]) {
textBuffer[y] = [];
}
this.textBuffer[y][x] = char;
this.setNeedUpdate();
}
getCharFromTextBuffer(x, y) {
const textBuffer = this.textBuffer;
let char;
if (textBuffer[y]) {
char = this.textBuffer[y][x]; // can be undefined, if not set
}
return char;
}
printChar(char, x, y, _pen, _paper, _transparent) {
this.putCharInTextBuffer(char, x, y);
}
readChar(x, y, _pen, _paper) {
let char = this.getCharFromTextBuffer(x, y);
if (char === undefined) {
char = -1; // not detected
}
return char;
}
clearTextWindow(left, right, top, bottom, _paper) {
const width = right + 1 - left, height = bottom + 1 - top;
this.fillTextBox(left, top, width, height);
}
setMode(mode) {
const winData = TextCanvas.winData[mode], cols = winData.right + 1, rows = winData.bottom + 1;
if (this.cols !== cols) {
this.cols = cols;
this.textText.setAttribute("cols", String(cols));
}
if (this.rows !== rows) {
this.rows = rows;
this.textText.setAttribute("rows", String(rows));
}
}
clearFullWindow() {
this.resetTextBuffer();
this.setNeedUpdate();
}
windowScrollUp(left, right, top, bottom, _paper) {
const width = right + 1 - left, height = bottom + 1 - top;
if (height > 1) { // scroll part
this.copyTextBufferBoxUp(left, top + 1, width, height - 1, left, top);
}
this.fillTextBox(left, bottom, width, 1);
}
windowScrollDown(left, right, top, bottom, _paper) {
const width = right + 1 - left, height = bottom + 1 - top;
if (height > 1) { // scroll part
this.copyTextBufferBoxDown(left, top, width, height - 1, left, top + 1);
}
this.fillTextBox(left, top, width, 1);
}
}
class VirtualKeyboard {
fnVirtualKeyboardKeydownHandler;
fnVirtualKeyboardKeyupOrKeyoutHandler;
fnKeydownOrKeyupHandler;
options;
eventNames;
shiftLock = false;
numLock = false;
constructor(options) {
this.fnVirtualKeyboardKeydownHandler = this.onVirtualKeyboardKeydown.bind(this);
this.fnVirtualKeyboardKeyupOrKeyoutHandler = this.onVirtualKeyboardKeyupOrKeyout.bind(this);
this.fnKeydownOrKeyupHandler = this.onKeydownOrKeyup.bind(this); // for real Enter and Space
this.options = {};
this.setOptions(options);
const view = this.options.view;
this.eventNames = this.options.view.fnAttachPointerEvents("kbdAreaInner" /* ViewID.kbdAreaInner */, this.fnVirtualKeyboardKeydownHandler, undefined, this.fnVirtualKeyboardKeyupOrKeyoutHandler);
view.addEventListenerById("keydown", this.fnKeydownOrKeyupHandler, "kbdAreaInner" /* ViewID.kbdAreaInner */);
view.addEventListenerById("keyup", this.fnKeydownOrKeyupHandler, "kbdAreaInner" /* ViewID.kbdAreaInner */);
this.virtualKeyboardCreate();
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
static cpcKey2Key = [
{
keys: "38ArrowUp", // 0: cursor up
key: "ArrowUp",
text: "\u2191",
title: "Cursor up"
},
{
keys: "39ArrowRight", // 1: cursor right
key: "ArrowRight",
text: "\u2192",
title: "Cursor right",
style: 1
},
{
keys: "40ArrowDown", // 2: cursor down
key: "ArrowDown",
text: "\u2193",
title: "Cursor down"
},
{
keys: "105Numpad9,120F9", // 3: numpad f9
key: "9",
text: "f9",
style: 1,
numLockCpcKey: 81 // joy 0 up+right
},
{
keys: "102Numpad6,117F6", // 4: numpad f6
key: "6",
text: "f6",
style: 1,
numLockCpcKey: 75 // joy 0 right
},
{
keys: "99Numpad3,114F3", // 5: numpad f3
key: "3",
text: "f3",
style: 1,
numLockCpcKey: 83 // joy 0 down+right
},
{
keys: "13NumpadEnter", // 6: numpad enter
key: "Enter",
style: 4
},
{
keys: "110NumpadDecimal", // 7: numpad .
key: ".",
numLockCpcKey: 77 // joy 0 fire 1
},
{
keys: "37ArrowLeft", // 8: cursor left
key: "ArrowLeft",
text: "\u2190",
title: "Cursor left",
style: 1
},
{
keys: "18AltLeft", // 9: copy
key: "Alt",
text: "Copy",
style: 2
},
{
keys: "103Numpad7,118F7", // 10: numpad f7
key: "7",
text: "f7",
style: 1,
numLockCpcKey: 80 // joy 0 up+left
},
{
keys: "104Numpad8,119F8", // 11: numpad f8
key: "8",
text: "f8",
style: 1,
numLockCpcKey: 72 // joy 0 up
},
{
keys: "101Numpad5,116F5", // 12: numpad f5
key: "5",
text: "f5",
style: 1,
numLockCpcKey: 76 // joy 0 fire 2
},
{
keys: "97Numpad1,112F1", // 13: numpad f1
key: "1",
text: "f1",
style: 1,
numLockCpcKey: 82 // joy 0 down+left
},
{
keys: "98Numpad2,113F2", // 14: numpad f2
key: "2",
text: "f2",
style: 1,
numLockCpcKey: 73 // joy 0 down
},
{
keys: "96Numpad0,121F10", // 15: numpad f0
key: "0",
text: "f0",
style: 1
},
{
keys: "46Delete", // 16: clr
key: "Delete",
text: "Clr",
title: "Clear",
style: 1
},
{
keys: "187BracketRight,171BracketRight,221BracketRight", // 17: [ { (Chrome: 187; FF: 171); EN: 221BracketRight
key: "[",
keyShift: "{"
},
{
keys: "13Enter", // 18: return
key: "Enter",
text: "Ret",
title: "Return",
style: 2
},
{
keys: "191Backslash,163Backslash,220Backslash", // 19: ] } => # ' (Chrome: 191; FF: 163); EN: 220Backslash
key: "]",
keyShift: "}"
},
{
keys: "100Numpad4,115F4", // 20: numpad f4
key: "4",
text: "f4",
style: 1,
numLockCpcKey: 74 // joy 0 left
},
{
keys: "16ShiftLeft,16ShiftRight", // 21: shift left, shift right (2 keys!)
key: "Shift",
style: 4
},
{
keys: "220Backquote,160Backquote,192Backquote", // 22: \ ` (different location, key!; Chrome: 220; FF: 160); EN: 192Backquote, 226IntlBackslash?
key: "\\",
keyShift: "`"
},
{
keys: "17ControlLeft,17ControlRight", // 23: Note: alt-gr also triggers ctrl-left and alt-gr!
key: "Control",
text: "Ctrl",
title: "Control",
style: 4
},
{
keys: "221Equal,192Equal,187Equal", // 24: ^  (pound: \u00A3) (Chrome: 221; FF: 192); EN: 187Equal
key: "^",
keyShift: ""
},
{
keys: "219Minus,63Minus,189Minus", // 25: - = (Chrome: 219; FF: 63); EN: 189Minus
key: "-",
keyShift: "="
},
{
keys: "186BracketLeft,59BracketLeft,219BracketLeft", // 26: @ | (Chrome: 168; FF: 59); EN: 219BracketLeft
key: "@",
keyShift: "|",
style: 1
},
{
keys: "80KeyP", // 27: P
key: "p",
keyShift: "P"
},
{
keys: "222Quote,192Quote", // 28: ; + (same on Chrome, FF); Android Bluetooth EN: 192Quote
key: ";",
keyShift: "+"
},
{
keys: "192Semicolon,186Semicolon", // 29: : * (same on Chrome, FF); EN: 186Semicolon
key: ":",
keyShift: "*"
},
{
keys: "189Slash,173Slash,191Slash", // 30: / ? (Chrome: 189; FF: 173); EN: 191Slash
key: "/",
keyShift: "?"
},
{
keys: "190Period", // 31: . <
key: ".",
keyShift: "<"
},
{
keys: "48Digit0", // 32: 0 _
key: "0",
keyShift: "_"
},
{
keys: "57Digit9", // 33: 9 )
key: "9",
keyShift: ")"
},
{
keys: "79KeyO", // 34:
key: "o",
keyShift: "O"
},
{
keys: "73KeyI", // 35:
key: "i",
keyShift: "I"
},
{
keys: "76KeyL", // 36:
key: "l",
keyShift: "L"
},
{
keys: "75KeyK", // 37:
key: "k",
keyShift: "K"
},
{
keys: "77KeyM", // 38:
key: "m",
keyShift: "M"
},
{
keys: "188Comma", // 39: , >
key: ",",
keyShift: ">"
},
{
keys: "56Digit8", // 40: 8 (
key: "8",
keyShift: "("
},
{
keys: "55Digit7", // 41: 7 '
key: "7",
keyShift: "'"
},
{
keys: "85KeyU", // 42:
key: "u",
keyShift: "U"
},
{
keys: "90KeyY,89KeyY", // 43:
key: "y",
keyShift: "Y"
},
{
keys: "72KeyH", // 44:
key: "h",
keyShift: "H"
},
{
keys: "74KeyJ", // 45:
key: "j",
keyShift: "J"
},
{
keys: "78KeyN", // 46:
key: "n",
keyShift: "N"
},
{
keys: "32Space", // 47: space
key: " ",
text: "Space",
style: 5
},
{
keys: "54Digit6", // 48: 6 &
key: "6",
keyShift: "("
},
{
keys: "53Digit5", // 49: 5 %
key: "5",
keyShift: "%"
},
{
keys: "82KeyR", // 50:
key: "r",
keyShift: "R"
},
{
keys: "84KeyT", // 51:
key: "t",
keyShift: "T"
},
{
keys: "71KeyG", // 52:
key: "g",
keyShift: "G"
},
{
keys: "70KeyF", // 53:
key: "f",
keyShift: "F"
},
{
keys: "66KeyB", // 54:
key: "b",
keyShift: "B"
},
{
keys: "86KeyV", // 55:
key: "v",
keyShift: "V"
},
{
keys: "52Digit4", // 56: 4 $
key: "4",
keyShift: "$"
},
{
keys: "51Digit3", // 57: 3 #
key: "3",
keyShift: "#"
},
{
keys: "69KeyE", // 58:
key: "e",
keyShift: "E"
},
{
keys: "87KeyW", // 59:
key: "w",
keyShift: "W"
},
{
keys: "83KeyS", // 60:
key: "s",
keyShift: "S"
},
{
keys: "68KeyD", // 61:
key: "d",
keyShift: "D"
},
{
keys: "67KeyC", // 62:
key: "c",
keyShift: "C"
},
{
keys: "88KeyX", // 63:
key: "x",
keyShift: "X"
},
{
keys: "49Digit1", // 64: 1 !
key: "1",
keyShift: "!"
},
{
keys: "50Digit2", // 65: 2 "
key: "2",
keyShift: "\""
},
{
keys: "27Escape", // 66: esc
key: "Escape",
text: "Esc",
title: "Escape",
style: 1
},
{
keys: "81KeyQ", // 67:
key: "q",
keyShift: "Q"
},
{
keys: "9Tab", // 68:
key: "Tab",
style: 2
},
{
keys: "65KeyA", // 69:
key: "a",
keyShift: "A"
},
{
keys: "20CapsLock", // 70: caps lock
key: "CapsLock",
text: "Caps",
title: "Caps Lock",
style: 3
},
{
keys: "89KeyZ,90KeyZ", // 71: DE,EN
key: "z",
keyShift: "Z"
},
{
keys: "38Numpad8", // 72: joy 0 up (arrow up)
key: "JoyUp",
text: "\u21D1",
title: "Joy up"
},
{
keys: "40Numpad2", // 73: joy 0 down
key: "JoyDown",
text: "\u21D3",
title: "Joy down"
},
{
keys: "37Numpad4", // 74: joy 0 left
key: "JoyLeft",
text: "\u21D0",
title: "Joy left"
},
{
keys: "39Numpad6", // 75: joy 0 right
key: "JoyRight",
text: "\u21D2",
title: "Joy right"
},
{
keys: "12Numpad5,45Numpad0", // 76: joy 0 fire 2 (clear,...)
key: "X",
text: "\u29BF",
title: "Joy fire"
},
{
keys: "46NumpadDecimal", // 77: joy 0 fire 1
key: "Z",
text: "\u25E6",
title: "Joy fire 1"
},
{
keys: "", // 78: ""? not null? (joy 0 fire 3?)
key: ""
},
{
keys: "8Backspace", // 79: del
key: "Backspace", // 79: del
text: "Del",
title: "Delete",
style: 1
},
{
keys: "36Numpad7", // 80: joy 0 up+left
key: "",
text: "\u21D6",
title: "Joy up+left"
},
{
keys: "33Numpad9", // 81: joy 0 up+right
key: "",
text: "\u21D7",
title: "Joy up+right"
},
{
keys: "35Numpad1", // 82: joy 0 down+left
key: "",
text: "\u21D9",
title: "Joy down+leftt"
},
{
keys: "34Numpad3", // 83: joy 0 down+right
key: "",
text: "\u21D8",
title: "Joy down+right"
},
{
keys: "", // 84: (not null?)
key: ""
},
{
keys: "226IntlBackslash,60IntlBackslash,220IntlBackslash", // 85: < > | // key not on CPC! (Chrome: 226, FF: 60);  Android Bluetooth EN: 220IntlBackslash
key: ""
},
{
keys: "111NumpadDivide", // 86:
key: ""
},
{
keys: "106NumpadMultiply", // 87:
key: ""
},
{
keys: "109NumpadSubtract", // 88:
key: ""
},
{
keys: "107NumpadAdd", // 89:
key: ""
},
{
keys: "",
key: "", // 90: special num lock key to switch between joystick and numpad
text: "Num",
title: "Num / Joy",
style: 1
}
];
/* eslint-disable array-element-newline */
static virtualKeyboardAlpha = [
[66, 64, 65, 57, 56, 49, 48, 41, 40, 33, 32, 25, 24, 16, 79],
[68, 67, 59, 58, 50, 51, 43, 42, 35, 34, 27, 26, 17, 18],
[70, 69, 60, 61, 53, 52, 44, 45, 37, 36, 29, 28, 19, 90], // 90=virtual numpad button
[
21, 71, 63, 62, 55, 54, 46, 38, 39, 31, 30, 22,
{
key: 21, // right shift has same code and style
style: 2
}
],
[23, 9, 47, 6]
];
static virtualKeyboardNum = [
[10, 11, 3],
[20, 12, 4],
[13, 14, 5],
[15, 0, 7],
[8, 2, 1]
];
/* eslint-enable array-element-newline */
reset() {
this.virtualKeyboardAdaptKeys(false, false);
}
mapNumLockCpcKey(cpcKey) {
const key = VirtualKeyboard.cpcKey2Key[cpcKey];
if (key.numLockCpcKey) {
cpcKey = key.numLockCpcKey;
}
return cpcKey;
}
fnVirtualGetAscii(cpcKey, shiftKey, numLock) {
const keyEntry = VirtualKeyboard.cpcKey2Key[cpcKey];
let key, text, title;
if (numLock && keyEntry.keyNumLock) {
key = keyEntry.keyNumLock;
text = keyEntry.textNumLock || key;
title = keyEntry.titleNumLock || text;
}
else if (shiftKey && keyEntry.keyShift) {
key = keyEntry.keyShift;
text = keyEntry.textShift || key;
title = keyEntry.titleShift || text;
}
else {
key = keyEntry.key;
text = keyEntry.text || key;
title = keyEntry.title || text;
}
return {
key: key,
text: text,
title: title
};
}
createButtonRow(id, options) {
const place = View.getElementById1(id);
if (place.insertAdjacentElement) {
const buttonList = document.createElement("div");
buttonList.className = "displayFlex";
for (let i = 0; i < options.length; i += 1) {
const item = options[i], button = document.createElement("button");
button.innerText = item.text;
button.setAttribute("title", item.title);
button.className = item.className;
button.setAttribute("data-key", String(item.key));
buttonList.insertAdjacentElement("beforeend", button);
}
place.insertAdjacentElement("beforeend", buttonList);
}
else { // Polyfill for old browsers
let html = "<div class=displayFlex>\n";
for (let i = 0; i < options.length; i += 1) {
const item = options[i];
html += '<button title="' + item.title + '" class="' + item.className + '" data-key="' + item.key + '">' + item.text + "</button>\n";
}
html += "</div>";
place.innerHTML += html;
}
return this;
}
virtualKeyboardCreatePart(id, virtualKeyboard) {
const keyArea = View.getElementById1(id), shiftLock = this.shiftLock, numLock = this.numLock, cpcKey2Key = VirtualKeyboard.cpcKey2Key, buttons = keyArea.getElementsByTagName("button");
if (!buttons.length) { // not yet created?
for (let row = 0; row < virtualKeyboard.length; row += 1) {
const rowList = virtualKeyboard[row], optionsList = [];
for (let col = 0; col < rowList.length; col += 1) {
let cpcKeyEntry;
if (typeof rowList[col] === "number") {
cpcKeyEntry = {
key: rowList[col]
};
}
else { // object
cpcKeyEntry = rowList[col];
}
const cpcKey = numLock ? this.mapNumLockCpcKey(cpcKeyEntry.key) : cpcKeyEntry.key, keyEntry = cpcKey2Key[cpcKeyEntry.key], ascii = this.fnVirtualGetAscii(cpcKey, shiftLock, numLock), className = "kbdButton" + (cpcKeyEntry.style || keyEntry.style || "") + ((col === rowList.length - 1) ? " kbdNoRightMargin" : ""), options = {
key: cpcKey,
text: ascii.text,
title: ascii.title,
className: className
};
optionsList.push(options);
}
this.createButtonRow(id, optionsList);
}
}
}
virtualKeyboardCreate() {
this.virtualKeyboardCreatePart("kbdAlpha" /* ViewID.kbdAlpha */, VirtualKeyboard.virtualKeyboardAlpha);
this.virtualKeyboardCreatePart("kbdNum" /* ViewID.kbdNum */, VirtualKeyboard.virtualKeyboardNum);
}
virtualKeyboardAdaptKeys(shiftLock, numLock) {
const keyArea = View.getElementById1("kbdAreaInner" /* ViewID.kbdAreaInner */), buttons = keyArea.getElementsByTagName("button"); // or: keyArea.childNodes and filter
for (let i = 0; i < buttons.length; i += 1) {
const button = buttons[i];
let cpcKey = Number(button.getAttribute("data-key"));
if (numLock) {
cpcKey = this.mapNumLockCpcKey(cpcKey);
}
const ascii = this.fnVirtualGetAscii(cpcKey, shiftLock, numLock);
if (ascii.key !== button.innerText) {
button.innerText = ascii.text;
button.title = ascii.title;
}
}
}
fnVirtualGetPressedKey(cpcKey) {
const key = VirtualKeyboard.cpcKey2Key[cpcKey];
let pressedKey = "";
if (key) {
pressedKey = key.keys;
if (pressedKey.indexOf(",") >= 0) { // maybe more
pressedKey = pressedKey.substring(0, pressedKey.indexOf(",")); // take the first
}
}
return pressedKey;
}
onVirtualKeyboardKeydown(event) {
const node = View.getEventTarget(event), cpcKey = node.getAttribute("data-key");
if (Utils.debug > 1) {
Utils.console.debug("onVirtualKeyboardKeydown: event", String(event), "type:", event.type, "title:", node.title, "cpcKey:", cpcKey);
}
if (cpcKey !== null) {
let cpcKeyCode = Number(cpcKey);
if (this.numLock) {
cpcKeyCode = this.mapNumLockCpcKey(cpcKeyCode);
}
const pressedKey = this.fnVirtualGetPressedKey(cpcKeyCode), ascii = this.fnVirtualGetAscii(cpcKeyCode, this.shiftLock || event.shiftKey, this.numLock);
this.options.fnPressCpcKey(event, cpcKeyCode, pressedKey, ascii.key);
}
if (this.eventNames.out) {
this.options.view.addEventListener(this.eventNames.out, this.fnVirtualKeyboardKeyupOrKeyoutHandler, node);
}
event.preventDefault();
return false;
}
fnVirtualKeyboardKeyupOrKeyout(event) {
const node = View.getEventTarget(event), cpcKey = node.getAttribute("data-key");
if (cpcKey !== null) {
let cpcKeyCode = Number(cpcKey);
if (this.numLock) {
cpcKeyCode = this.mapNumLockCpcKey(cpcKeyCode);
}
const pressedKey = this.fnVirtualGetPressedKey(cpcKeyCode), ascii = this.fnVirtualGetAscii(cpcKeyCode, this.shiftLock || event.shiftKey, this.numLock);
this.options.fnReleaseCpcKey(event, cpcKeyCode, pressedKey, ascii.key);
if (cpcKeyCode === 70) { // Caps Lock?
this.shiftLock = !this.shiftLock;
this.virtualKeyboardAdaptKeys(this.shiftLock, this.numLock);
}
else if (cpcKeyCode === 90) { // Num lock
this.numLock = !this.numLock;
this.virtualKeyboardAdaptKeys(this.shiftLock, this.numLock);
}
}
}
onVirtualKeyboardKeyupOrKeyout(event) {
const node = View.getEventTarget(event);
if (Utils.debug > 1) {
Utils.console.debug("onVirtualKeyboardKeyupOrKeyout: event", String(event), "type:", event.type, "title:", node.title, "cpcKey:", node.getAttribute("data-key"));
}
this.fnVirtualKeyboardKeyupOrKeyout(event);
if (this.eventNames.out) {
this.options.view.removeEventListener(this.eventNames.out, this.fnVirtualKeyboardKeyupOrKeyoutHandler, node); // do not need out event any more for this key
}
event.preventDefault();
return false;
}
static keyIdentifier2Char(event) {
const identifier = event.keyIdentifier, // eslint-disable-line @typescript-eslint/no-explicit-any
shiftKey = event.shiftKey;
let char = "";
if ((/^U\+/i).test(identifier || "")) { // unicode string?
char = String.fromCharCode(parseInt(identifier.substr(2), 16));
if (char === "\0") { // ignore
char = "";
}
char = shiftKey ? char.toUpperCase() : char.toLowerCase(); // do we get keys in unicode always in uppercase?
}
else {
char = identifier; // take it, could be "Enter"
}
return char;
}
onKeydownOrKeyup(event) {
const key = event.key || VirtualKeyboard.keyIdentifier2Char(event) || "", // SliTaz web browser has not key but keyIdentifier (also in Keyboard)
activeElement = window.document.activeElement;
if (key === "Enter" || key === " ") { // enter or space
const simPointerEvent = {
type: event.type,
target: activeElement, // active selected element
preventDefault: function () {
}
};
if (event.type === "keydown") {
this.onVirtualKeyboardKeydown(simPointerEvent);
}
else if (event.type === "keyup") {
this.onVirtualKeyboardKeyupOrKeyout(simPointerEvent);
}
else {
Utils.console.error("onKeydownOrKeyup: Unknown type:", event.type);
}
event.preventDefault();
return false;
}
return undefined;
}
}
class Sound {
options;
isSoundOn = false;
isActivatedByUserFlag = false;
contextNotAvailable = false;
contextStartTime = 0;
context;
mergerNode;
gainNodes = [];
oscillators = []; // 3 oscillators left, middle, right
queues = []; // node queues and info for the three channels
fScheduleAheadTime = 0.1; // 100 ms
volEnv = [];
toneEnv = [];
debugLogList;
constructor(options) {
this.options = {};
this.setOptions(options);
for (let i = 0; i < 3; i += 1) {
this.queues[i] = {
soundData: [],
fNextNoteTime: 0,
onHold: false,
rendevousMask: 0
};
}
if (Utils.debug > 1) {
this.debugLogList = []; // access: CpcLoco.controller.sound.debugLog
}
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
reset() {
const oscillators = this.oscillators, volEnvData = {
steps: 1,
diff: 0,
time: 200
};
this.resetQueue();
for (let i = 0; i < 3; i += 1) {
if (oscillators[i]) {
this.stopOscillator(i);
}
}
this.volEnv.length = 0;
this.setVolEnv(0, [volEnvData]); // set default ENV (should not be changed)
this.toneEnv.length = 0;
if (this.debugLogList) {
this.debugLogList.length = 0;
}
}
stopOscillator(n) {
const oscillators = this.oscillators, oscillatorNode = oscillators[n];
if (oscillatorNode) {
oscillatorNode.frequency.value = 0;
oscillatorNode.stop();
oscillatorNode.disconnect();
oscillators[n] = undefined;
}
}
debugLog(msg) {
if (this.debugLogList) {
this.debugLogList.push([
this.context ? this.context.currentTime : 0,
msg
]);
}
}
resetQueue() {
const queues = this.queues;
for (let i = 0; i < queues.length; i += 1) {
const queue = queues[i];
queue.soundData.length = 0;
queue.fNextNoteTime = 0;
queue.onHold = false;
queue.rendevousMask = 0;
}
}
createSoundContext() {
const channelMap2Cpc = [
0,
2,
1
];
let context;
try {
context = new this.options.AudioContextConstructor(); // may produce exception if not available
const mergerNode = context.createChannelMerger(6); // create mergerNode with 6 inputs; we are using the first 3 for left, right, center
this.mergerNode = mergerNode; // set as side effect
for (let i = 0; i < 3; i += 1) {
const gainNode = context.createGain();
gainNode.connect(mergerNode, 0, channelMap2Cpc[i]); // connect output #0 of gainNode i to input #j of the mergerNode
this.gainNodes[i] = gainNode;
}
}
catch (e) {
Utils.console.warn("createSoundContext:", e);
this.contextNotAvailable = true;
}
const oldContextStartTime = this.contextStartTime;
this.contextStartTime = Date.now() / 1000;
if (oldContextStartTime && context) { // was there a start time set before?
const correctionTime = context.currentTime + (this.contextStartTime - oldContextStartTime), queues = this.queues;
for (let i = 0; i < 3; i += 1) {
if (queues[i].soundData.length) {
queues[i].fNextNoteTime -= correctionTime;
}
}
}
return context;
}
playNoise(oscillator, fTime, fDuration, noise) {
const context = this.context, bufferSize = context.sampleRate * fDuration, // set the time of the note
buffer = context.createBuffer(1, bufferSize, context.sampleRate), // create an empty buffer
data = buffer.getChannelData(0), // get data
noiseNode = context.createBufferSource(); // create a buffer source for noise data
for (let i = 0; i < bufferSize; i += 1) {
data[i] = Math.random() * 2 - 1; // -1..1
}
noiseNode.buffer = buffer;
if (noise > 1) {
const bandHz = 20000 / noise, bandpass = context.createBiquadFilter();
bandpass.type = "bandpass";
bandpass.frequency.value = bandHz;
noiseNode.connect(bandpass).connect(this.gainNodes[oscillator]);
}
else {
noiseNode.connect(this.gainNodes[oscillator]);
}
noiseNode.start(fTime);
noiseNode.stop(fTime + fDuration);
}
simulateApplyVolEnv(volData, duration, volEnvRepeat) {
let time = 0;
for (let loop = 0; loop < volEnvRepeat; loop += 1) {
for (let part = 0; part < volData.length; part += 1) {
const group = volData[part];
if (group.steps !== undefined) {
const group1 = group, volTime = group1.time;
let volSteps = group1.steps;
if (!volSteps) { // steps=0
volSteps = 1;
}
for (let i = 0; i < volSteps; i += 1) {
time += volTime;
if (duration && time >= duration) { // eslint-disable-line max-depth
loop = volEnvRepeat; // stop early if longer than specified duration
part = volData.length;
break;
}
}
}
else { // register
const group2 = group, register = group2.register, period = group2.period, volTime = period;
if (register === 0) {
time += volTime;
}
else {
}
}
}
}
if (duration === 0) {
duration = time;
}
return duration;
}
applyVolEnv(volData, gain, fTime, volume, duration, volEnvRepeat) {
const maxVolume = 15, i100ms2sec = 100; // time duration unit: 1/100 sec=10 ms, convert to sec
let time = 0;
for (let loop = 0; loop < volEnvRepeat; loop += 1) {
for (let part = 0; part < volData.length; part += 1) {
const group = volData[part];
if (group.steps !== undefined) {
const group1 = group, volDiff = group1.diff, volTime = group1.time;
let volSteps = group1.steps;
if (!volSteps) { // steps=0
volSteps = 1;
volume = 0; // we will set volDiff as absolute volume
}
for (let i = 0; i < volSteps; i += 1) {
volume = (volume + volDiff) % (maxVolume + 1);
const fVolume = volume / maxVolume;
gain.setValueAtTime(fVolume * fVolume, fTime + time / i100ms2sec);
time += volTime;
if (duration && time >= duration) { // eslint-disable-line max-depth
loop = volEnvRepeat; // stop early if longer than specified duration
part = volData.length;
break;
}
}
}
else { // register
const group2 = group, register = group2.register, period = group2.period, volTime = period;
if (register === 0) {
volume = 15;
let fVolume = volume / maxVolume;
gain.setValueAtTime(fVolume * fVolume, fTime + time / i100ms2sec);
time += volTime;
fVolume = 0;
gain.linearRampToValueAtTime(fVolume, fTime + time / i100ms2sec); // or: exponentialRampToValueAtTime?
}
else {
}
}
}
}
if (duration === 0) {
duration = time;
}
return duration;
}
applyToneEnv(toneData, frequency, fTime, period, duration) {
const i100ms2sec = 100, // time duration unit: 1/100 sec=10 ms, convert to sec
repeat = toneData[0], toneEnvRepeat = repeat ? 5 : 1; // we use at most 5
let time = 0;
for (let loop = 0; loop < toneEnvRepeat; loop += 1) {
for (let part = 0; part < toneData.length; part += 1) {
const group = toneData[part];
if (group.steps !== undefined) {
const group1 = group, toneSteps = group1.steps || 1, // steps 0 => 1
toneDiff = group1.diff, toneTime = group1.time;
for (let i = 0; i < toneSteps; i += 1) {
const fFrequency = (period >= 3) ? 62500 / period : 0;
frequency.setValueAtTime(fFrequency, fTime + time / i100ms2sec);
period += toneDiff;
time += toneTime;
if (duration && time >= duration) { // eslint-disable-line max-depth
loop = toneEnvRepeat; // stop early if longer than specified duration
part = toneData.length;
break;
}
}
}
else { // absolute period
const group2 = group, toneTime = group2.time;
period = group2.period;
const fFrequency = (period >= 3) ? 62500 / period : 0;
frequency.setValueAtTime(fFrequency, fTime + time / i100ms2sec);
time += toneTime;
}
}
}
}
simulateScheduleNote(soundData) {
let duration = soundData.duration, volEnv = soundData.volEnv, volEnvRepeat = 1;
if (duration < 0) { // <0: repeat volume envelope?
volEnvRepeat = Math.min(5, -duration); // we limit repeat to 5 times sice we precompute duration
duration = 0;
}
if (volEnv || !duration) { // some volume envelope or duration 0?
if (!this.volEnv[volEnv]) {
volEnv = 0; // envelope not defined => use default envelope 0
}
duration = this.simulateApplyVolEnv(this.volEnv[volEnv], duration, volEnvRepeat);
}
const i100ms2sec = 100, // time duration unit: 1/100 sec=10 ms, convert to sec
fDuration = duration / i100ms2sec;
return fDuration;
}
scheduleNote(oscillator, fTime, soundData) {
if (Utils.debug > 1) {
this.debugLog("scheduleNote: " + oscillator + " " + fTime);
}
if (!this.isSoundOn) {
return this.simulateScheduleNote(soundData);
}
const context = this.context, oscillatorNode = context.createOscillator();
oscillatorNode.type = "square";
oscillatorNode.frequency.value = (soundData.period >= 3) ? 62500 / soundData.period : 0;
oscillatorNode.connect(this.gainNodes[oscillator]);
if (fTime < context.currentTime) {
if (Utils.debug) {
Utils.console.debug("Test: sound: scheduleNote:", fTime, "<", context.currentTime);
}
}
const volume = soundData.volume, gain = this.gainNodes[oscillator].gain, maxVolume = 15, fVolume = volume / maxVolume;
gain.setValueAtTime(fVolume * fVolume, fTime); // start volume
let duration = soundData.duration, volEnv = soundData.volEnv, volEnvRepeat = 1;
if (duration < 0) { // <0: repeat volume envelope?
volEnvRepeat = Math.min(5, -duration); // we limit repeat to 5 times sice we precompute duration
duration = 0;
}
if (volEnv || !duration) { // some volume envelope or duration 0?
if (!this.volEnv[volEnv]) {
volEnv = 0; // envelope not defined => use default envelope 0
}
duration = this.applyVolEnv(this.volEnv[volEnv], gain, fTime, volume, duration, volEnvRepeat);
}
const toneEnv = soundData.toneEnv;
if (toneEnv && this.toneEnv[toneEnv]) { // some tone envelope?
this.applyToneEnv(this.toneEnv[toneEnv], oscillatorNode.frequency, fTime, soundData.period, duration);
}
const i100ms2sec = 100, // time duration unit: 1/100 sec=10 ms, convert to sec
fDuration = duration / i100ms2sec;
oscillatorNode.start(fTime);
oscillatorNode.stop(fTime + fDuration);
this.oscillators[oscillator] = oscillatorNode;
if (soundData.noise) {
this.playNoise(oscillator, fTime, fDuration, soundData.noise);
}
return fDuration;
}
testCanQueue(state) {
let canQueue = true;
if (this.isSoundOn && !this.isActivatedByUserFlag) { // sound on but not yet activated? -> say cannot queue
canQueue = false;
/* eslint-disable no-bitwise */
}
else if (!(state & 0x80)) { // 0x80: flush
const queues = this.queues;
if ((state & 0x01 && queues[0].soundData.length >= 4)
|| (state & 0x02 && queues[1].soundData.length >= 4)
|| (state & 0x04 && queues[2].soundData.length >= 4)) {
canQueue = false;
}
}
/* eslint-enable no-bitwise */
return canQueue;
}
sound(soundData) {
const queues = this.queues, state = soundData.state;
for (let i = 0; i < 3; i += 1) {
if ((state >> i) & 0x01) { // eslint-disable-line no-bitwise
const queue = queues[i];
if (state & 0x80) { // eslint-disable-line no-bitwise
queue.soundData.length = 0; // flush queue
queue.fNextNoteTime = 0;
this.stopOscillator(i);
}
queue.soundData.push(soundData); // just a reference
if (Utils.debug > 1) {
this.debugLog("sound: " + i + " " + state + ":" + queue.soundData.length);
}
this.updateQueueStatus(i, queue);
}
}
this.scheduler(); // schedule early to allow SQ busy check immediately (can channels go out of sync by this?)
}
setVolEnv(volEnv, volEnvData) {
this.volEnv[volEnv] = volEnvData;
}
setToneEnv(toneEnv, toneEnvData) {
this.toneEnv[toneEnv] = toneEnvData;
}
updateQueueStatus(i, queue) {
const soundData = queue.soundData;
if (soundData.length) {
/* eslint-disable no-bitwise */
queue.onHold = Boolean(soundData[0].state & 0x40); // check if next note on hold
queue.rendevousMask = (soundData[0].state & 0x07); // get channel bits
queue.rendevousMask &= ~(1 << i); // mask out our channel
queue.rendevousMask |= (soundData[0].state >> 3) & 0x07; // and combine rendevous
/* eslint-enable no-bitwise */
}
else {
queue.onHold = false;
queue.rendevousMask = 0;
}
}
scheduler() {
if (!this.isActivatedByUserFlag) {
return;
}
const context = this.context, fCurrentTime = context ? context.currentTime : Date.now() / 1000 - this.contextStartTime, // use Date.now() when sound is off
queues = this.queues;
let canPlayMask = 0;
for (let i = 0; i < 3; i += 1) {
const queue = queues[i];
while (queue.soundData.length && !queue.onHold && queue.fNextNoteTime < fCurrentTime + this.fScheduleAheadTime) { // something to schedule and not on hold and time reached
if (!queue.rendevousMask) { // no rendevous needed, schedule now
if (queue.fNextNoteTime < fCurrentTime) {
queue.fNextNoteTime = fCurrentTime;
}
const soundData = queue.soundData.shift();
queue.fNextNoteTime += this.scheduleNote(i, queue.fNextNoteTime, soundData);
this.updateQueueStatus(i, queue); // check if next note on hold
}
else { // need rendevous
canPlayMask |= (1 << i); // eslint-disable-line no-bitwise
break;
}
}
}
if (!canPlayMask) { // no channel can play
return;
}
for (let i = 0; i < 3; i += 1) {
const queue = queues[i];
if ((canPlayMask >> i) & 0x01 && ((queue.rendevousMask & canPlayMask) === queue.rendevousMask)) { // eslint-disable-line no-bitwise
if (queue.fNextNoteTime < fCurrentTime) {
queue.fNextNoteTime = fCurrentTime;
}
const soundData = queue.soundData.shift();
queue.fNextNoteTime += this.scheduleNote(i, queue.fNextNoteTime, soundData);
this.updateQueueStatus(i, queue); // check if next note on hold
}
}
}
release(releaseMask) {
const queues = this.queues;
if (!queues.length) {
return;
}
if (Utils.debug > 1) {
this.debugLog("release: " + releaseMask);
}
for (let i = 0; i < 3; i += 1) {
const queue = queues[i], soundData = queue.soundData;
if (((releaseMask >> i) & 0x01) && soundData.length && queue.onHold) { // eslint-disable-line no-bitwise
queue.onHold = false; // release
}
}
this.scheduler(); // extra schedule now so that following sound instructions are not releases early
}
sq(n) {
const queues = this.queues, queue = queues[n], soundData = queue.soundData, context = this.context;
let sq = 4 - soundData.length;
if (sq < 0) {
sq = 0;
}
/* eslint-disable no-bitwise */
sq |= (queue.rendevousMask << 3);
if (this.oscillators[n] && queues[n].fNextNoteTime > context.currentTime) { // note still playing?
sq |= 0x80; // eslint-disable-line no-bitwise
}
else if (soundData.length && (soundData[0].state & 0x40)) {
sq |= 0x40;
}
/* eslint-enable no-bitwise */
return sq;
}
setActivatedByUser() {
this.isActivatedByUserFlag = true;
if (!this.contextStartTime) { // not yet started?
this.contextStartTime = Date.now() / 1000; // set it
}
}
isActivatedByUser() {
return this.isActivatedByUserFlag;
}
soundOn() {
if (!this.isSoundOn) {
if (!this.context && !this.contextNotAvailable) { // try to create context
this.context = this.createSoundContext(); // still undefined in case of exception
}
if (this.context) { // maybe not available
this.mergerNode.connect(this.context.destination);
}
this.isSoundOn = true;
if (Utils.debug) {
Utils.console.debug("soundOn: Sound switched on");
}
}
return Boolean(this.context); // true if sound is available
}
soundOff() {
if (this.isSoundOn) {
if (this.context) {
this.mergerNode.disconnect(this.context.destination);
}
this.isSoundOn = false;
if (Utils.debug) {
Utils.console.debug("soundOff: Sound switched off");
}
}
}
}
class ArrayProxy {
constructor(len) {
return new Proxy(new Array(len), this);
}
get(target, prop) {
if (typeof prop === "string" && !isNaN(Number(prop))) {
const numProp = Number(prop);
if (numProp < 0 || numProp >= target.length) {
throw Utils.composeVmError("Variables", Error(), 9, prop); // Subscript out of range
}
}
return target[prop];
}
set(target, prop, value) {
if (!isNaN(Number(prop))) {
const numProp = Number(prop);
if (numProp < 0 || numProp >= target.length) {
throw Utils.composeVmError("Variables", Error(), 9, prop); // Subscript out of range
}
}
target[prop] = value;
return true;
}
}
class Variables {
options;
variables;
varTypes; // default variable types for variables starting with letters a-z
constructor(options) {
this.options = {
arrayBounds: false
};
this.setOptions(options);
this.variables = {};
this.varTypes = {}; // default variable types for variables starting with letters a-z
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
}
removeAllVariables() {
const variables = this.variables;
for (const name in variables) { // eslint-disable-line guard-for-in
delete variables[name];
}
}
getAllVariables() {
return this.variables;
}
getAllVarTypes() {
return this.varTypes;
}
createNDimArray(dims, initVal) {
const that = this, fnCreateRec = function (index) {
const len = dims[index], arr = that.options.arrayBounds ? new ArrayProxy(len) : new Array(len);
index += 1;
if (index < dims.length) { // more dimensions?
for (let i = 0; i < len; i += 1) {
arr[i] = fnCreateRec(index); // recursive call
}
}
else { // one dimension
for (let i = 0; i < len; i += 1) {
arr[i] = initVal;
}
}
return arr;
}, ret = fnCreateRec(0);
return ret;
}
determineStaticVarType(name) {
if (name.indexOf("v.") === 0) { // preceding variable object?
name = name.substring(2); // remove preceding "v."
}
if (name.indexOf('v["') === 0) { // preceding variable object?
name = name.substring(3); // remove preceding 'v["'
}
let nameType = name.charAt(0); // take first character to determine variable type later
if (nameType === "_") { // ignore underscore (do not clash with keywords)
nameType = name.charAt(1);
}
const bracketPos = name.indexOf("["), typePos = bracketPos >= 0 ? bracketPos - 1 : name.length - 1, typeChar = name.charAt(typePos); // check character before array bracket
if (typeChar === "I" || typeChar === "R" || typeChar === "$") { // explicit type specified?
nameType += typeChar;
}
return nameType;
}
getVarDefault(varName, dimensions) {
let isString = varName.includes("$");
if (!isString) { // check dynamic varType...
let first = varName.charAt(0);
if (first === "_") { // ignore underscore (do not clash with keywords)
first = first.charAt(1);
}
isString = (this.getVarType(first) === "$");
}
let value = isString ? "" : 0, arrayIndices = varName.split("A").length - 1;
if (arrayIndices) {
if (!dimensions) {
dimensions = [];
if (arrayIndices > 3) { // on CPC up to 3 dimensions 0..10 without dim
arrayIndices = 3;
}
for (let i = 0; i < arrayIndices; i += 1) {
dimensions.push(11);
}
}
const valueArray = this.createNDimArray(dimensions, value);
value = valueArray;
}
return value;
}
initVariable(name) {
this.variables[name] = this.getVarDefault(name);
}
dimVariable(name, dimensions) {
this.variables[name] = this.getVarDefault(name, dimensions);
}
getAllVariableNames() {
return Object.keys(this.variables);
}
getVariableIndex(name) {
const varNames = this.getAllVariableNames(), pos = varNames.indexOf(name);
return pos;
}
initAllVariables() {
const variables = this.getAllVariableNames();
for (let i = 0; i < variables.length; i += 1) {
this.initVariable(variables[i]);
}
}
getVariable(name) {
return this.variables[name];
}
setVariable(name, value) {
this.variables[name] = value;
}
getVariableByIndex(index) {
const variables = this.getAllVariableNames(), name = variables[index];
return this.variables[name];
}
variableExist(name) {
return name in this.variables;
}
getVarType(varChar) {
return this.varTypes[varChar];
}
setVarType(varChar, type) {
this.varTypes[varChar] = type;
}
}
class DragElement {
fnDragStartHandler;
fnDragMoveHandler;
fnDragEndHandler;
options;
containerId = "window" /* ViewID.window */;
initialX = 0;
initialY = 0;
currentX = 0;
currentY = 0;
dragInfo;
dragItem;
constructor(options) {
this.fnDragStartHandler = this.dragStart.bind(this);
this.fnDragMoveHandler = this.dragMove.bind(this);
this.fnDragEndHandler = this.dragEnd.bind(this);
this.options = {};
this.setOptions(options);
}
getOptions() {
return this.options;
}
setOptions(options) {
Object.assign(this.options, options);
const entries = this.options.entries;
for (const key in entries) {
if (entries.hasOwnProperty(key)) {
const item = entries[key];
if (item.enabled) {
this.options.view.fnAttachPointerEvents(item.itemId, this.fnDragStartHandler);
}
else {
this.options.view.fnDetachPointerEvents(item.itemId, this.fnDragStartHandler);
}
}
}
}
dragStart(event) {
const node = View.getEventTarget(event), entries = this.options.entries;
let entry = entries[node.id];
if (!entry) {
const parentElement = node.parentElement;
if (parentElement && entries[parentElement.id]) {
entry = entries[parentElement.id];
this.dragItem = parentElement;
}
else {
return;
}
}
else {
this.dragItem = node;
}
this.dragInfo = entry;
const dragInfo = this.dragInfo, clientObject = (event.type === "touchstart") ? event.touches[0] : event; // special handling for TouchEvent (otherwise MouseEvent or similar PointerEvent)
this.initialX = clientObject.clientX - dragInfo.xOffset;
this.initialY = clientObject.clientY - dragInfo.yOffset;
this.options.view.fnAttachPointerEvents(this.containerId, undefined, this.fnDragMoveHandler, this.fnDragEndHandler);
if (Utils.debug > 0) {
Utils.console.debug("dragStart: " + dragInfo.itemId + ": x=" + this.initialX + ", y=" + this.initialY);
}
}
static setDragTranslate(xPos, yPos, el) {
el.style.transform = "translate3d(" + xPos + "px, " + yPos + "px, 0)";
}
dragMove(event) {
const dragInfo = this.dragInfo;
if (dragInfo) {
event.preventDefault();
const clientObject = (event.type === "touchstart") ? event.touches[0] : event;
this.currentX = clientObject.clientX - this.initialX;
this.currentY = clientObject.clientY - this.initialY;
dragInfo.xOffset = this.currentX;
dragInfo.yOffset = this.currentY;
DragElement.setDragTranslate(this.currentX, this.currentY, this.dragItem);
}
}
dragEnd(_event) {
const dragInfo = this.dragInfo;
if (dragInfo) {
this.options.view.fnDetachPointerEvents(this.containerId, undefined, this.fnDragMoveHandler, this.fnDragEndHandler);
if (Utils.debug > 0) {
Utils.console.debug("dragEnd: " + dragInfo.itemId + ": x=" + this.currentX + ", y=" + this.currentY);
}
}
}
}
class RsxAmsdos {
static fnGetParameterAsString(vm, stringOrAddress) {
let string = ""; // for undefined
if (typeof stringOrAddress === "number") { // assuming addressOf
string = String(vm.vmGetVariableByIndex(stringOrAddress) || "");
}
else if (typeof stringOrAddress === "string") {
string = stringOrAddress;
}
return string;
}
static dir(fileMask) {
const stream = 0;
let fileMaskString = RsxAmsdos.fnGetParameterAsString(this, fileMask);
if (fileMaskString) {
fileMaskString = this.vmAdaptFilename(fileMaskString, "|DIR");
}
const fileParas = {
stream: stream,
command: "|dir",
fileMask: fileMaskString,
line: this.line
};
this.vmStop("fileDir", 45, false, fileParas);
}
static era(fileMask) {
const stream = 0;
let fileMaskString = RsxAmsdos.fnGetParameterAsString(this, fileMask);
fileMaskString = this.vmAdaptFilename(fileMaskString, "|ERA");
const fileParas = {
stream: stream,
command: "|era",
fileMask: fileMaskString,
line: this.line
};
this.vmStop("fileEra", 45, false, fileParas);
}
static ren(newName, oldName) {
const stream = 0;
let newName2 = RsxAmsdos.fnGetParameterAsString(this, newName), oldName2 = RsxAmsdos.fnGetParameterAsString(this, oldName);
newName2 = this.vmAdaptFilename(newName2, "|REN");
oldName2 = this.vmAdaptFilename(oldName2, "|REN");
const fileParas = {
stream: stream,
command: "|ren",
fileMask: "", // unused
newName: newName2,
oldName: oldName2,
line: this.line
};
this.vmStop("fileRen", 45, false, fileParas);
}
static rsxCommands = {
a: function () {
this.vmNotImplemented("|A");
},
b: function () {
this.vmNotImplemented("|B");
},
cpm: function () {
this.vmNotImplemented("|CPM");
},
dir: RsxAmsdos.dir,
disc: function () {
this.vmNotImplemented("|DISC");
},
"disc.in": function () {
this.vmNotImplemented("|DISC.IN");
},
"disc.out": function () {
this.vmNotImplemented("|DISC.OUT");
},
drive: function () {
this.vmNotImplemented("|DRIVE");
},
era: RsxAmsdos.era,
ren: RsxAmsdos.ren,
tape: function () {
this.vmNotImplemented("|TAPE");
},
"tape.in": function () {
this.vmNotImplemented("|TAPE.IN");
},
"tape.out": function () {
this.vmNotImplemented("|TAPE.OUT");
},
user: function () {
this.vmNotImplemented("|USER");
}
};
getRsxCommands() {
return RsxAmsdos.rsxCommands;
}
}
class RsxCpcLoco {
static rsxCommands = {
basic() {
Utils.console.log("basic: |BASIC");
this.vmStop("reset", 90);
},
mode: function (mode) {
mode = this.vmInRangeRound(Number(mode), 0, 3, "|MODE");
this.vmChangeMode(mode);
},
renum: function (...args) {
this.renum.apply(this, args);
}
};
getRsxCommands() {
return RsxCpcLoco.rsxCommands;
}
}
import { Z80Disass } from "./Z80Disass"; // test
class Controller {
fnRunLoopHandler;
fnWaitKeyHandler;
fnWaitInputHandler;
fnOnEscapeHandler;
fnDirectInputHandler;
fnPutKeyInBufferHandler;
fnOnDragoverHandler;
fnOnUserActionHandler;
fnWaitForContinueHandler;
fnEditLineCallbackHandler;
fnScript = undefined; // eslint-disable-line @typescript-eslint/ban-types
timeoutHandlerActive = false;
nextLoopTimeOut = 0; // next timeout for the main loop
initialLoopTimeout = 0;
inputSet = false;
variables;
basicFormatter; // for renum
basicTokenizer; // to decode tokenized BASIC
codeGeneratorToken; // to encode tokenized BASIC
codeGeneratorBasic; // for pretty print
model;
view;
commonEventHandler;
basicLexer;
basicParser;
codeGeneratorJs;
canvases = {};
canvas;
inputStack = new InputStack();
keyboard;
virtualKeyboard;
dragElement;
sound = new Sound({
AudioContextConstructor: window.AudioContext
});
vm;
noStop;
savedStop; // backup of stop object
fileHandler;
fileSelect;
hasStorageDatabase;
z80Disass;
constructor(model, view) {
this.fnRunLoopHandler = this.fnRunLoop.bind(this);
this.fnWaitKeyHandler = this.fnWaitKey.bind(this);
this.fnWaitInputHandler = this.fnWaitInput.bind(this);
this.fnOnEscapeHandler = this.fnOnEscape.bind(this);
this.fnDirectInputHandler = this.fnDirectInput.bind(this);
this.fnPutKeyInBufferHandler = this.fnPutKeysInBuffer.bind(this);
this.fnOnDragoverHandler = Controller.fnOnDragover;
this.fnOnUserActionHandler = this.onUserAction.bind(this);
this.fnWaitForContinueHandler = this.fnWaitForContinue.bind(this);
this.fnEditLineCallbackHandler = this.fnEditLineCallback.bind(this);
this.model = model;
this.view = view;
this.commonEventHandler = new CommonEventHandler({
model: model,
view: view,
controller: this
});
this.view.addEventListener("click", this.commonEventHandler);
this.view.addEventListener("change", this.commonEventHandler);
this.commonEventHandler.initToggles();
this.canvas = this.setCanvasType(model.getProperty("canvasType" /* ModelPropID.canvasType */));
this.variables = new Variables({
arrayBounds: model.getProperty("arrayBounds" /* ModelPropID.arrayBounds */)
});
this.fnSpeed();
this.commonEventHandler.onKbdLayoutSelectChange(this.commonEventHandler.getEventDefById("change", "kbdLayoutSelect" /* ViewID.kbdLayoutSelect */));
this.keyboard = new Keyboard({
view: this.view,
fnOnEscapeHandler: this.fnOnEscapeHandler
});
if (this.model.getProperty("showKbd" /* ModelPropID.showKbd */)) { // maybe we need to draw virtual keyboard
this.getVirtualKeyboard();
}
this.commonEventHandler.fnSetUserAction(this.fnOnUserActionHandler); // check first user action, also if sound is not yet on
this.vm = new CpcVm({
canvas: this.canvas,
keyboard: this.keyboard,
sound: this.sound,
variables: this.variables,
onClickKey: this.fnPutKeyInBufferHandler
});
this.vm.vmReset();
this.vm.vmRegisterRsx(new RsxAmsdos(), true);
this.vm.vmRegisterRsx(new RsxCpcLoco(), true);
this.noStop = Object.assign({}, this.vm.vmGetStopObject());
this.savedStop = {
reason: "",
priority: 0,
paras: {
command: "",
stream: 0,
line: 0,
first: 0, // unused
last: 0 // unused
}
}; // backup of stop object
this.setStopObject(this.noStop);
this.basicParser = new BasicParser({
basicVersion: this.model.getProperty("basicVersion" /* ModelPropID.basicVersion */)
});
this.basicLexer = new BasicLexer({
keywords: this.basicParser.getKeywords()
});
this.codeGeneratorJs = new CodeGeneratorJs({
lexer: this.basicLexer,
parser: this.basicParser,
trace: model.getProperty("trace" /* ModelPropID.trace */),
implicitLines: model.getProperty("implicitLines" /* ModelPropID.implicitLines */),
integerOverflow: model.getProperty("integerOverflow" /* ModelPropID.integerOverflow */)
});
if (model.getProperty("sound" /* ModelPropID.sound */)) { // activate sound needs user action
this.setSoundActive(); // activate in waiting state
}
this.initDropZone();
const example = model.getProperty("example" /* ModelPropID.example */);
view.setSelectValue("exampleSelect" /* ViewID.exampleSelect */, example);
this.hasStorageDatabase = this.initDatabases();
if (model.getProperty("showCpc" /* ModelPropID.showCpc */)) {
this.canvas.startUpdateCanvas();
}
if (model.getProperty("dragElements" /* ModelPropID.dragElements */)) {
this.fnDragElementsActive(true);
}
}
static codeGenJsBasicParserOptions = {
keepBrackets: false,
keepColons: false,
keepDataComma: false,
keepTokens: false
};
static codeGenTokenBasicParserOptions = {
keepTokens: true,
keepBrackets: true,
keepColons: true,
keepDataComma: true
};
static formatterBasicParserOptions = {
keepBrackets: false,
keepColons: false,
keepDataComma: false,
keepTokens: false
};
static getUniqueDbKey(name, databases) {
let key = name, index = 2;
while (databases[key]) {
key = name + index;
index += 1;
}
return key;
}
initDatabases() {
const model = this.model, databases = {}, databaseDirs = model.getProperty("databaseDirs" /* ModelPropID.databaseDirs */).split(",");
let hasStorageDatabase = false;
for (let i = 0; i < databaseDirs.length; i += 1) {
const databaseDir = databaseDirs[i], parts1 = databaseDir.split("="), databaseSrc = parts1[0], assignedName = parts1.length > 1 ? parts1[1] : "", parts2 = databaseSrc.split("/"), name = assignedName || parts2[parts2.length - 1], key = Controller.getUniqueDbKey(name, databases);
databases[key] = {
text: key,
title: databaseSrc,
src: databaseSrc
};
if (databaseDir === "storage") {
hasStorageDatabase = true;
}
}
this.model.addDatabases(databases);
this.setDatabaseSelectOptions();
return hasStorageDatabase;
}
onUserAction( /* event, id */) {
this.commonEventHandler.fnSetUserAction(undefined); // deactivate user action
this.sound.setActivatedByUser();
this.setSoundActive();
}
addIndex(_dir, input) {
for (const value in input) {
if (input.hasOwnProperty(value)) {
const item = input[value];
for (let i = 0; i < item.length; i += 1) {
this.model.setExample(item[i]);
}
}
}
}
addItem(key, input) {
if (!key) { // maybe ""
key = (document.currentScript && document.currentScript.getAttribute("data-key")) || this.model.getProperty("example" /* ModelPropID.example */);
}
input = input.replace(/^\n/, "").replace(/\n$/, ""); // remove preceding and trailing newlines
const implicitLines = this.model.getProperty("implicitLines" /* ModelPropID.implicitLines */), linesOnLoad = this.model.getProperty("linesOnLoad" /* ModelPropID.linesOnLoad */);
if (input.startsWith("REM ") && !implicitLines && linesOnLoad) {
input = Controller.addLineNumbers(input);
}
const example = this.model.getExample(key);
example.key = key; // maybe changed
example.script = input;
example.loaded = true;
Utils.console.log("addItem:", key);
return key;
}
addRsx(key, RsxConstructor) {
if (!key) { // maybe ""
key = (document.currentScript && document.currentScript.getAttribute("data-key")) || this.model.getProperty("example" /* ModelPropID.example */);
}
const example = this.model.getExample(key);
example.key = key; // maybe changed
example.rsx = new RsxConstructor();
example.loaded = true;
Utils.console.log("addItem:", key);
return key;
}
setDatabaseSelectOptions() {
const items = [], databases = this.model.getAllDatabases(), database = this.model.getProperty("database" /* ModelPropID.database */);
for (const value in databases) {
if (databases.hasOwnProperty(value)) {
const db = databases[value], item = {
value: value,
text: db.text,
title: db.title,
selected: value === database
};
items.push(item);
}
}
this.view.setSelectOptions("databaseSelect" /* ViewID.databaseSelect */, items);
}
static getPathFromExample(example) {
const index = example.lastIndexOf("/");
let path = "";
if (index >= 0) {
path = example.substring(0, index);
}
return path;
}
static getNameFromExample(example) {
const index = example.lastIndexOf("/");
let name = example;
if (index >= 0) {
name = example.substring(index + 1);
}
return name;
}
setDirectorySelectOptions() {
const items = [], allExamples = this.model.getAllExamples(), examplePath = Controller.getPathFromExample(this.model.getProperty("example" /* ModelPropID.example */)), directorySeen = {};
for (const key in allExamples) {
if (allExamples.hasOwnProperty(key)) {
const exampleEntry = allExamples[key], value = Controller.getPathFromExample(exampleEntry.key);
if (!directorySeen[value]) {
const item = {
value: value,
text: value,
title: value,
selected: value === examplePath
};
items.push(item);
directorySeen[value] = true;
}
}
}
this.view.setSelectOptions("directorySelect" /* ViewID.directorySelect */, items);
}
setExampleSelectOptions() {
const maxTitleLength = 160, maxTextLength = 60, // (32 visible?)
items = [], exampleName = Controller.getNameFromExample(this.model.getProperty("example" /* ModelPropID.example */)), allExamples = this.model.getAllExamples(), directoryName = this.view.getSelectValue("directorySelect" /* ViewID.directorySelect */), selectDataFiles = this.model.getProperty("selectDataFiles" /* ModelPropID.selectDataFiles */);
let exampleSelected = false;
for (const key in allExamples) {
if (allExamples.hasOwnProperty(key) && (Controller.getPathFromExample(key) === directoryName)) {
const exampleEntry = allExamples[key], exampleName2 = Controller.getNameFromExample(exampleEntry.key);
if (selectDataFiles || (exampleEntry.meta !== "D")) { // skip data files
const title = (exampleName2 + ": " + exampleEntry.title).substring(0, maxTitleLength), item = {
value: exampleName2,
title: title,
text: title.substring(0, maxTextLength),
selected: exampleName2 === exampleName
};
if (item.selected) {
exampleSelected = true;
}
items.push(item);
}
}
}
if (!exampleSelected && items.length) {
items[0].selected = true; // if example is not found, select first element
}
this.view.setSelectOptions("exampleSelect" /* ViewID.exampleSelect */, items);
}
setGalleryAreaInputs() {
const database = this.model.getDatabase(), directory = this.view.getSelectValue("directorySelect" /* ViewID.directorySelect */), options = this.view.getSelectOptions("exampleSelect" /* ViewID.exampleSelect */), inputs = [];
for (let i = 0; i < options.length; i += 1) {
const item = options[i], input = {
value: item.value,
title: item.title,
checked: item.selected,
imgUrl: database.src + "/" + directory + "/img/" + item.value + ".png"
};
inputs.push(input);
}
this.view.setAreaInputList("galleryAreaItems" /* ViewID.galleryAreaItems */, inputs);
}
static fnSortByStringProperties(a, b) {
const x = a.value, y = b.value;
if (x < y) {
return -1;
}
else if (x > y) {
return 1;
}
return 0;
}
setVarSelectOptions(select, variables) {
const maxVarLength = 35, varNames = variables.getAllVariableNames(), items = [];
for (let i = 0; i < varNames.length; i += 1) {
const key = varNames[i], value = variables.getVariable(key), title = key + "=" + value;
let strippedTitle = title.substring(0, maxVarLength); // limit length
if (title !== strippedTitle) {
strippedTitle += " ...";
}
const item = {
value: key,
text: strippedTitle,
title: strippedTitle,
selected: false
};
items.push(item);
}
items.sort(Controller.fnSortByStringProperties);
this.view.setSelectOptions(select, items);
}
static exportEditorText = "<editor>";
setExportSelectOptions(select) {
const dirList = Controller.fnGetStorageDirectoryEntries(), items = [], editorText = Controller.exportEditorText;
dirList.sort(); // we sort keys without editorText
dirList.unshift(editorText);
for (let i = 0; i < dirList.length; i += 1) {
const key = dirList[i], title = key, item = {
value: key,
text: title,
title: title,
selected: title === editorText
};
items.push(item);
}
this.view.setSelectOptions(select, items);
}
updateStorageDatabase(action, key) {
if (!this.hasStorageDatabase) {
return;
}
const database = this.model.getProperty("database" /* ModelPropID.database */), storage = Utils.localStorage;
let selectedExample = "", exampleChanged = false;
if (database !== "storage") {
this.model.setProperty("database" /* ModelPropID.database */, "storage"); // switch to storage database
}
else {
selectedExample = this.view.getSelectValue("exampleSelect" /* ViewID.exampleSelect */);
}
let dir;
if (!key) { // no key => get all
dir = Controller.fnGetStorageDirectoryEntries();
dir.sort();
}
else {
dir = [key];
}
for (let i = 0; i < dir.length; i += 1) {
key = dir[i];
if (action === "remove") {
this.model.removeExample(key);
}
else if (action === "set") {
let example = this.model.getExample(key);
if (selectedExample === "" || (selectedExample === key)) {
exampleChanged = true;
}
if (!example) {
const dataString = storage.getItem(key) || "", data = Controller.splitMeta(dataString);
example = {
key: key,
title: "", // or set key?
meta: data.meta.typeString // currently we take only the type
};
this.model.setExample(example);
}
}
else {
Utils.console.error("updateStorageDatabase: unknown action", action);
}
}
if (database === "storage") {
this.setDirectorySelectOptions();
if (exampleChanged) {
this.onDirectorySelectChange();
}
else {
this.setExampleSelectOptions();
}
}
else {
this.model.setProperty("database" /* ModelPropID.database */, database); // restore database
}
}
removeKeyBoardHandler() {
this.keyboard.setOptions({
fnOnKeyDown: undefined
});
}
setInputText(input, keepStack) {
this.view.setAreaValue("inputText" /* ViewID.inputText */, input);
if (!keepStack) {
this.fnInitUndoRedoButtons();
}
else {
this.fnUpdateUndoRedoButtons();
}
}
invalidateScript() {
this.fnScript = undefined;
}
fnWaitForContinue() {
const stream = 0, key = this.keyboard.getKeyFromBuffer();
if (key !== "") {
this.vm.cursor(stream, 0);
this.removeKeyBoardHandler();
this.startContinue();
}
}
fnOnEscape() {
const stop = this.vm.vmGetStopObject(), stream = 0;
if (this.vm.vmOnBreakContSet()) {
}
else if (stop.reason === "direct" || this.vm.vmOnBreakHandlerActive()) {
stop.paras.input = "";
const msg = "*Break*\r\n";
this.vm.print(stream, msg);
}
else if (stop.reason !== "escape") { // first escape?
this.vm.cursor(stream, 1);
this.keyboard.clearInput();
this.keyboard.setOptions({
fnOnKeyDown: this.fnWaitForContinueHandler
});
this.setStopObject(stop);
this.vm.vmStop("escape", 85, false, {
command: "escape",
stream: stream,
first: 0, // unused
last: 0, // unused
line: this.vm.line
});
}
else { // second escape
this.removeKeyBoardHandler();
this.vm.cursor(stream, 0);
const savedStop = this.getStopObject();
if (savedStop.reason === "waitInput") { // sepcial handling: set line to repeat input
this.vm.vmGoto(savedStop.paras.line);
}
if (!this.vm.vmEscape()) {
this.vm.vmStop("", 0, true); // continue program, in break handler?
this.setStopObject(this.noStop);
}
else {
this.vm.vmStop("stop", 0, true); // stop
const msg = "Break in " + this.vm.line + "\r\n";
this.vm.print(stream, msg);
}
}
this.startMainLoop();
}
fnWaitSound() {
const stop = this.vm.vmGetStopObject();
this.vm.vmLoopCondition(); // update nextFrameTime, timers, inks; schedule sound: free queue
if (this.sound.isActivatedByUser()) { // only if activated
const soundDataList = this.vm.vmGetSoundData();
while (soundDataList.length && this.sound.testCanQueue(soundDataList[0].state)) {
const soundData = soundDataList.shift();
this.sound.sound(soundData);
}
if (!soundDataList.length) {
if (stop.reason === "waitSound") { // only for this reason
this.vm.vmStop("", 0, true); // no more wait
}
}
}
this.nextLoopTimeOut = this.vm.vmGetTimeUntilFrame(); // wait until next frame
}
fnWaitKey() {
const key = this.keyboard.getKeyFromBuffer();
if (key !== "") { // do we have a key from the buffer already?
Utils.console.log("Wait for key:", key);
this.vm.vmStop("", 0, true);
this.removeKeyBoardHandler();
}
else {
this.fnWaitSound(); // sound and blinking events
this.keyboard.setOptions({
fnOnKeyDown: this.fnWaitKeyHandler
});
}
return key;
}
fnWaitInput() {
const stop = this.vm.vmGetStopObject(), inputParas = stop.paras, stream = inputParas.stream;
let input = inputParas.input, key;
if (input === undefined || stream === undefined) {
this.outputError(this.vm.vmComposeError(Error(), 32, "Programming Error: fnWaitInput"), true);
return;
}
do {
key = this.keyboard.getKeyFromBuffer(); // (inkey$ could insert frame if checked too often)
switch (key) {
case "": // no key?
break;
case "\r": // cr (\x0d)
break;
case "\x10": // DLE (clear character under cursor)
key = "\x07"; // currently ignore (BEL)
break;
case "\x7f": // del
if (input.length) {
input = input.slice(0, -1);
key = "\x08\x10"; // use BS and DLE
}
else {
key = "\x07"; // ignore BS, use BEL
}
break;
case "\xe0": // copy
key = this.vm.copychr$(stream);
if (key.length) {
input += key;
key = "\x09"; // TAB
}
else {
key = "\x07"; // ignore (BEL)
}
break;
case "\xf0": // cursor up
if (!input.length) {
key = "\x0b"; // VT
}
else {
key = "\x07"; // ignore (BEL)
}
break;
case "\xf1": // cursor down
if (!input.length) {
key = "\x0a"; // LF
}
else {
key = "\x07"; // ignore (BEL)
}
break;
case "\xf2": // cursor left
if (!input.length) {
key = "\x08"; // BS
}
else {
key = "\x07"; // ignore (BEL) TODO
}
break;
case "\xf3": // cursor right
if (!input.length) {
key = "\x09"; // TAB
}
else {
key = "\x07"; // ignore (BEL) TODO
}
break;
case "\xf4": // shift+cursor up
key = ""; // currently ignore
break;
case "\xf5": // shift+cursor down
key = ""; // currently ignore
break;
case "\xf6": // shift+cursor left
key = ""; // currently ignore
break;
case "\xf7": // shift+cursor right
key = ""; // currently ignore
break;
case "\xf8": // ctrl+cursor up
key = ""; // currently ignore
break;
case "\xf9": // ctrl+cursor down
key = ""; // currently ignore
break;
case "\xfa": // ctrl+cursor left
key = ""; // currently ignore
break;
case "\xfb": // ctrl+cursor right
key = ""; // currently ignore
break;
default:
input += key;
if (key < "\x20") { // control code
key = "\x01" + key; // print control code (do not execute)
}
break;
}
if (key && key !== "\r") {
this.vm.print(stream, key);
}
} while (key !== "" && key !== "\r"); // get all keys until CR or no more key
inputParas.input = input;
let inputOk = false;
if (key === "\r") {
Utils.console.log("fnWaitInput:", input, "reason", stop.reason);
if (!inputParas.noCRLF) {
this.vm.print(stream, "\r\n");
}
if (inputParas.fnInputCallback) {
inputOk = inputParas.fnInputCallback();
}
else {
inputOk = true;
}
if (inputOk) {
this.removeKeyBoardHandler();
if (stop.reason === "waitInput") { // only for this reason
this.vm.vmStop("", 0, true); // no more wait
}
else {
this.startContinue();
}
}
}
if (!inputOk) {
if (stop.reason === "waitInput") { // only for this reason
this.fnWaitSound(); // sound and blinking events
}
this.keyboard.setOptions({
fnOnKeyDown: this.fnWaitInputHandler
});
}
}
static parseLineNumber(line) {
return parseInt(line, 10); // we do not check for linenumber in range 0...65535
}
static addLineNumbers(input) {
const lineParts = input.split("\n");
let lastLine = 0;
for (let i = 0; i < lineParts.length; i += 1) {
let lineNum = parseInt(lineParts[i], 10);
if (isNaN(lineNum)) {
lineNum = lastLine + 1;
lineParts[i] = String(lastLine + 1) + " " + lineParts[i];
}
lastLine = lineNum;
}
return lineParts.join("\n");
}
splitLines(input) {
if (this.model.getProperty("implicitLines" /* ModelPropID.implicitLines */)) {
input = Controller.addLineNumbers(input);
}
const lineParts = input.split(/^(\s*\d+)/m), lines = [];
if (lineParts[0] === "") {
lineParts.shift(); // remove first empty item
}
if (lineParts.length % 2 !== 0) {
Utils.console.warn("splitLines: No line numbers?");
const error = this.vm.vmComposeError(Error(), 21, "split"); // "Direct command found"
this.outputError(error, true);
return lines;
}
for (let i = 0; i < lineParts.length; i += 2) {
const number = lineParts[i];
let content = lineParts[i + 1];
if (content.endsWith("\n")) {
content = content.substring(0, content.length - 1);
}
lines.push(number + content);
}
return lines;
}
mergeScripts(script1, script2) {
const lines1 = this.splitLines(Utils.stringTrimEnd(script1)), lines2 = this.splitLines(Utils.stringTrimEnd(script2));
let result = [], lineNumber1, lineNumber2;
while (lines1.length && lines2.length) {
lineNumber1 = lineNumber1 || Controller.parseLineNumber(lines1[0]);
lineNumber2 = lineNumber2 || Controller.parseLineNumber(lines2[0]);
if (lineNumber1 < lineNumber2) { // use line from script1
result.push(lines1.shift());
lineNumber1 = 0;
}
else { // use line from script2
const line2 = lines2.shift();
if (String(lineNumber2) !== line2) { // line not empty?
result.push(line2);
}
if (lineNumber1 === lineNumber2) { // same line number in script1 and script2
lines1.shift(); // ignore line from script1 (overwrite it)
lineNumber1 = 0;
}
lineNumber2 = 0;
}
}
result = result.concat(lines1, lines2); // put in remaining lines from one source
if (result.length >= 2) {
if (result[result.length - 2] === "" && result[result.length - 1] === "") {
result.pop(); // remove additional newline
}
}
return result.join("\n");
}
fnGetLinesInRange(script, firstLine, lastLine) {
const lines = script ? this.splitLines(script) : [];
while (lines.length && Controller.parseLineNumber(lines[0]) < firstLine) {
lines.shift();
}
if (lines.length && lines[lines.length - 1] === "") { // trailing empty line?
lines.pop(); // remove
}
while (lines.length && Controller.parseLineNumber(lines[lines.length - 1]) > lastLine) {
lines.pop();
}
return lines;
}
static fnPrepareMaskRegExp(mask) {
mask = mask.replace(/([.+^$[\]\\(){}|-])/g, "\\$1");
mask = mask.replace(/\?/g, ".");
mask = mask.replace(/\*/g, ".*");
return new RegExp("^" + mask + "$");
}
fnGetExampleDirectoryEntries(mask) {
const dir = [], allExamples = this.model.getAllExamples();
let regExp;
if (mask) {
regExp = Controller.fnPrepareMaskRegExp(mask);
}
for (const key in allExamples) {
if (allExamples.hasOwnProperty(key)) {
const example = allExamples[key], key2 = example.key, matchKey2 = key2 + ((key2.indexOf(".") < 0) ? "." : "");
if (!regExp || regExp.test(matchKey2)) {
dir.push(key2);
}
}
}
return dir;
}
static fnGetStorageDirectoryEntries(mask) {
const storage = Utils.localStorage, metaIdent = FileHandler.getMetaIdent(), dir = [];
let regExp;
if (mask) {
regExp = Controller.fnPrepareMaskRegExp(mask);
}
for (let i = 0; i < storage.length; i += 1) {
const key = storage.key(i);
if (key !== null && storage[key].startsWith(metaIdent)) { // take only CpcLoco files
const keywithOutNl = key.replace(/[\n\r]/g, ""); // support also strange names; (newer browsers support also "s" regex modifier)
if (!regExp || regExp.test(keywithOutNl)) {
dir.push(key);
}
}
}
return dir;
}
fnPrintDirectoryEntries(stream, dir, sort) {
for (let i = 0; i < dir.length; i += 1) {
const parts = dir[i].split(".");
dir[i] = parts[0].padEnd(8, " ") + "." + (parts.length >= 2 ? parts[1] : "").padEnd(3, " ");
}
if (sort) {
dir.sort();
}
this.vm.print(stream, "\r\nDrive A: user  0\r\n\r\n");
for (let i = 0; i < dir.length; i += 1) {
const key = dir[i] + "  ";
this.vm.print(stream, key);
}
this.vm.print(stream, "\r\n\r\n999K free\r\n\r\n");
}
fnFileCat(paras) {
const stream = paras.stream, dirList = Controller.fnGetStorageDirectoryEntries();
this.fnPrintDirectoryEntries(stream, dirList, true);
this.vm.vmStop("", 0, true);
}
fnFileDir(paras) {
const stream = paras.stream, example = this.model.getProperty("example" /* ModelPropID.example */), lastSlash = example.lastIndexOf("/");
let fileMask = paras.fileMask ? Controller.fnLocalStorageName(paras.fileMask) : "";
const dirList = Controller.fnGetStorageDirectoryEntries(fileMask);
let path = "";
if (lastSlash >= 0) {
path = example.substring(0, lastSlash) + "/";
fileMask = path + (fileMask ? fileMask : "*.*"); // only in same directory
}
const fileExists = {};
for (let i = 0; i < dirList.length; i += 1) {
fileExists[dirList[i]] = true;
}
const dirListEx = this.fnGetExampleDirectoryEntries(fileMask); // also from examples
for (let i = 0; i < dirListEx.length; i += 1) {
const file = dirListEx[i].substring(path.length); // remove preceding path including "/"
if (!fileExists[file]) { // ignore duplicates
fileExists[file] = true;
dirList.push(file);
}
}
this.fnPrintDirectoryEntries(stream, dirList, false);
this.vm.vmStop("", 0, true);
}
fnFileEra(paras) {
const stream = paras.stream, storage = Utils.localStorage, fileMask = Controller.fnLocalStorageName(paras.fileMask || ""), dir = Controller.fnGetStorageDirectoryEntries(fileMask);
if (!dir.length) {
this.vm.print(stream, fileMask + " not found\r\n");
}
for (let i = 0; i < dir.length; i += 1) {
const name = dir[i];
if (storage.getItem(name) !== null) {
storage.removeItem(name);
this.updateStorageDatabase("remove", name);
if (Utils.debug > 0) {
Utils.console.debug("fnEraseFile: name=" + name + ": removed from localStorage");
}
}
else {
this.vm.print(stream, name + " not found\r\n");
Utils.console.warn("fnEraseFile: file not found in localStorage:", name);
}
}
this.vm.vmStop("", 0, true);
}
fnFileRen(paras) {
const stream = paras.stream, storage = Utils.localStorage, newName = Controller.fnLocalStorageName(paras.newName), oldName = Controller.fnLocalStorageName(paras.oldName), item = storage.getItem(oldName);
if (item !== null) {
if (!storage.getItem(newName)) {
storage.setItem(newName, item);
this.updateStorageDatabase("set", newName);
storage.removeItem(oldName);
this.updateStorageDatabase("remove", oldName);
}
else {
this.vm.print(stream, oldName + " already exists\r\n");
}
}
else {
this.vm.print(stream, oldName + " not found\r\n");
}
this.vm.vmStop("", 0, true);
}
static asmGena3Convert(data) {
const fnUInt16 = function (pos2) {
return data.charCodeAt(pos2) + data.charCodeAt(pos2 + 1) * 256;
}, length = data.length;
let pos = 0, out = "";
pos += 4; // what is the meaning of these bytes?
while (pos < length) {
const lineNum = fnUInt16(pos);
pos += 2;
let index1 = data.indexOf("\r", pos); // EOL marker 0x0d
if (index1 < 0) {
index1 = length;
}
let index2 = data.indexOf("\x1c", pos); // EOL marker 0x1c
if (index2 < 0) {
index2 = length;
}
index1 = Math.min(index1, index2);
out += lineNum + " " + data.substring(pos, index1) + "\n";
pos = index1 + 1;
}
return out;
}
getBasicFormatter() {
if (!this.basicFormatter) {
this.basicFormatter = new BasicFormatter({
lexer: this.basicLexer,
parser: this.basicParser
});
}
return this.basicFormatter;
}
getBasicTokenizer() {
if (!this.basicTokenizer) {
this.basicTokenizer = new BasicTokenizer();
}
return this.basicTokenizer;
}
getCodeGeneratorBasic() {
if (!this.codeGeneratorBasic) {
this.codeGeneratorBasic = new CodeGeneratorBasic({
lexer: this.basicLexer,
parser: this.basicParser,
lowercaseVars: this.model.getProperty("prettyLowercaseVars" /* ModelPropID.prettyLowercaseVars */)
});
}
return this.codeGeneratorBasic;
}
getCodeGeneratorToken() {
if (!this.codeGeneratorToken) {
this.codeGeneratorToken = new CodeGeneratorToken({
lexer: this.basicLexer,
parser: this.basicParser,
implicitLines: this.model.getProperty("implicitLines" /* ModelPropID.implicitLines */)
});
}
return this.codeGeneratorToken;
}
decodeTokenizedBasic(input) {
const basicTokenizer = this.getBasicTokenizer();
return basicTokenizer.decode(input);
}
encodeTokenizedBasic(input, name = "test") {
const codeGeneratorToken = this.getCodeGeneratorToken();
this.basicLexer.setOptions({
keepWhiteSpace: true
});
this.basicParser.setOptions(Controller.codeGenTokenBasicParserOptions);
const output = codeGeneratorToken.generate(input);
if (output.error) {
this.outputError(output.error);
}
else if (Utils.debug > 1) {
const outputText = output.text, hex = outputText.split("").map(function (s) { return s.charCodeAt(0).toString(16).toUpperCase().padStart(2, "0"); }).join(","), decoded = this.decodeTokenizedBasic(outputText), diff = Diff.testDiff(input.toUpperCase(), decoded.toUpperCase()); // for testing
Utils.console.debug("TokenizerInput (" + name + ") [len=" + input.length + "]:\n" + input);
Utils.console.debug("TokenizerOutputHex (" + name + ") [len=" + outputText.length + "]:\n" + hex);
Utils.console.debug("TokenizerOutputDecoded (" + name + ") [len=" + decoded.length + "]:\n" + decoded);
Utils.console.debug("TokenizerDiff (" + name + ") [len=" + diff.length + "]:\n" + diff);
}
return output.text;
}
prettyPrintBasic(input, keepWhiteSpace, keepBrackets, keepColons) {
const codeGeneratorBasic = this.getCodeGeneratorBasic(), keepDataComma = true;
this.basicLexer.setOptions({
keepWhiteSpace: keepWhiteSpace
});
this.basicParser.setOptions({
keepTokens: true,
keepBrackets: keepBrackets,
keepColons: keepColons,
keepDataComma: keepDataComma
});
const output = codeGeneratorBasic.generate(input);
if (output.error) {
this.outputError(output.error);
}
return output.text;
}
static gaInk2Ink = [
13,
27,
19,
25,
1,
7,
10,
16,
28,
29,
24,
26,
6,
8,
15,
17,
30,
31,
18,
20,
0,
2,
9,
11,
4,
22,
21,
23,
3,
5,
12,
14
];
applyGaInks(inkval) {
for (let i = 0; i < inkval.length - 1; i += 1) {
this.vm.ink(i, Controller.gaInk2Ink[inkval[i]]);
}
this.vm.border(Controller.gaInk2Ink[inkval[inkval.length - 1]]);
}
applyCrtcRegs(reg) {
for (let i = 0; i < reg.length; i += 1) {
this.vm.vmSetCrtcData(i, reg[i]);
}
}
applySnapshot(input) {
const snapshot = new Snapshot({
name: "",
data: input
}), info = snapshot.getSnapshotInfo(), mode = info.ga.multi & 0x03, // eslint-disable-line no-bitwise
mem = snapshot.getMemory();
this.vm.vmChangeMode(mode);
this.applyGaInks(info.ga.inkval);
this.vm.vmSetRamSelect(info.ramconf);
this.applyCrtcRegs(info.crtc.reg);
return mem;
}
loadFileContinue(input) {
const inFile = this.vm.vmGetInFileObject();
let data;
if (input !== null && input !== undefined) {
data = Controller.splitMeta(input);
input = data.data; // maybe changed
if (data.meta.encoding === "base64") {
input = Utils.atob(input); // decode base64
}
const type = data.meta.typeString;
if (type === "T") { // tokenized basic?
input = this.decodeTokenizedBasic(input);
}
else if (type === "P") { // BASIC?
input = DiskImage.unOrProtectData(input);
input = this.decodeTokenizedBasic(input);
}
else if (type === "B") { // binary?
}
else if (type === "A") { // ASCII?
input = input.replace(/\x1a+$/, ""); // eslint-disable-line no-control-regex
}
else if (type === "G") { // Hisoft Devpac GENA3 Z80 Assember
input = Controller.asmGena3Convert(input);
}
else if (type === "S") { // Snapshot
input = this.applySnapshot(input);
}
else if (type === "X") { // (Extended) Disk image file
const fileHandler = this.getFileHandler(), imported = [];
fileHandler.fnLoad2(input, inFile.name, type, imported); // no meta in data
input = "1 ' " + imported.join(", "); // imported files
}
else if (type === "Z") { // ZIP file
const fileHandler = this.getFileHandler(), imported = [];
fileHandler.fnLoad2(input, inFile.name, type, imported);
input = "1 ' " + imported.join(", "); // imported files
}
}
const command = inFile.command, // create copy of data
inFileLine = inFile.line || 0;
let putInMemory = false, startLine = 0;
if (inFile.fnFileCallback) {
try {
putInMemory = inFile.fnFileCallback(input, data && data.meta);
}
catch (e) {
Utils.console.warn(e);
}
}
if (input === undefined) {
Utils.console.error("loadFileContinue: File " + inFile.name + ": input undefined!");
this.vm.vmStop("stop", 60, true);
this.startMainLoop();
return;
}
if (input === null) {
this.startMainLoop();
return;
}
if (data && data.meta.typeString === "S" && putInMemory) { // fast hack
input = this.decodeTokenizedBasic(input.substring(0x170));
putInMemory = false; // put input in text box
}
switch (command) {
case "openin":
break;
case "chainMerge":
input = this.mergeScripts(this.view.getAreaValue("inputText" /* ViewID.inputText */), input);
this.setInputText(input);
this.view.setAreaValue("resultText" /* ViewID.resultText */, "");
startLine = inFileLine;
this.invalidateScript();
this.fnParseChain();
break;
case "load":
if (!putInMemory) {
this.setInputText(input);
this.view.setAreaValue("resultText" /* ViewID.resultText */, "");
this.invalidateScript();
this.vm.vmStop("end", 90);
}
break;
case "merge":
input = this.mergeScripts(this.view.getAreaValue("inputText" /* ViewID.inputText */), input);
this.setInputText(input);
this.view.setAreaValue("resultText" /* ViewID.resultText */, "");
this.invalidateScript();
this.fnRemoveAllVariables();
this.vm.vmStop("end", 90);
break;
case "chain": // TODO: if we have a line number, make sure it is not optimized away when compiling
this.setInputText(input);
this.view.setAreaValue("resultText" /* ViewID.resultText */, "");
startLine = inFileLine;
this.invalidateScript();
this.fnParseChain();
break;
case "run":
if (!putInMemory) {
this.setInputText(input);
this.view.setAreaValue("resultText" /* ViewID.resultText */, "");
startLine = inFileLine;
if (!data || data.meta.typeString !== "S") { // keep memory, config for snapshots
this.fnReset();
}
this.fnParseRun();
}
else {
this.fnReset();
this.vm.clear(); // do we need this?
}
break;
default:
Utils.console.error("loadExample: Unknown command:", command);
break;
}
this.vm.vmSetStartLine(startLine);
this.startMainLoop();
}
createFnExampleLoaded(example, url, inFile) {
return (_sFullUrl, key, suppressLog) => {
if (key !== example) {
Utils.console.warn("fnExampleLoaded: Unexpected", key, "<>", example);
}
const exampleEntry = this.model.getExample(example);
if (!suppressLog) {
Utils.console.log("Example", url, (exampleEntry.meta ? exampleEntry.meta + " " : "") + "loaded");
}
this.model.setProperty("example" /* ModelPropID.example */, inFile.memorizedExample);
this.vm.vmStop("", 0, true);
if (exampleEntry.rsx) {
this.vm.vmRegisterRsx(exampleEntry.rsx, false);
}
const input = exampleEntry.script;
this.loadFileContinue(input);
};
}
createFnExampleError(example, url, inFile) {
return () => {
Utils.console.log("Example", url, "error");
this.model.setProperty("example" /* ModelPropID.example */, inFile.memorizedExample);
this.vm.vmStop("", 0, true);
const error = this.vm.vmComposeError(Error(), 32, example + " not found"); // TODO: set also derr=146 (xx not found)
if (error.hidden) {
this.vm.vmStop("", 0, true); // clear onError
}
this.outputError(error, true);
this.loadFileContinue(null);
};
}
loadExample() {
const inFile = this.vm.vmGetInFileObject(), key = this.model.getProperty("example" /* ModelPropID.example */);
let name = inFile.name;
if (name.charAt(0) === "/") { // absolute path?
name = name.substring(1); // remove "/"
inFile.memorizedExample = name; // change!
}
else {
inFile.memorizedExample = key;
const lastSlash = key.lastIndexOf("/");
if (lastSlash >= 0) {
const path = key.substring(0, lastSlash); // take path from selected example
name = path + "/" + name;
name = name.replace(/\w+\/\.\.\//, ""); // simplify 2 dots (go back) in path: "dir/.."" => ""
}
}
const example = name;
if (Utils.debug > 0) {
Utils.console.debug("loadExample: name=" + name + " (current=" + key + ")");
}
const exampleEntry = this.model.getExample(example); // already loaded
let url;
if (exampleEntry && exampleEntry.loaded) {
this.model.setProperty("example" /* ModelPropID.example */, example);
url = example;
const fnExampleLoaded = this.createFnExampleLoaded(example, url, inFile);
fnExampleLoaded("", example, true);
}
else if (example && exampleEntry) { // need to load
this.model.setProperty("example" /* ModelPropID.example */, example);
const databaseDir = this.model.getDatabase().src;
url = databaseDir + "/" + example + ".js";
Utils.loadScript(url, this.createFnExampleLoaded(example, url, inFile), this.createFnExampleError(example, url, inFile), example);
}
else { // keep original example in this error case
url = example;
if (example !== "") { // only if not empty
Utils.console.warn("loadExample: Unknown file:", example);
const fnExampleError = this.createFnExampleError(example, url, inFile);
fnExampleError();
}
else {
this.model.setProperty("example" /* ModelPropID.example */, example);
this.vm.vmStop("", 0, true);
this.loadFileContinue(""); // empty input?
}
}
}
static fnLocalStorageName(name, defaultExtension) {
if (name.indexOf(".") < 0) { // no dot inside name?
name += "." + (defaultExtension || ""); // append dot or default extension
}
return name;
}
static defaultExtensions = [
"",
"bas",
"bin"
];
static tryLoadingFromLocalStorage(name) {
const storage = Utils.localStorage;
let input = null;
if (name.indexOf(".") >= 0) { // extension specified?
input = storage.getItem(name);
}
else {
for (let i = 0; i < Controller.defaultExtensions.length; i += 1) {
const storageName = Controller.fnLocalStorageName(name, Controller.defaultExtensions[i]);
input = storage.getItem(storageName);
if (input !== null) {
break; // found
}
}
}
return input; // null=not found
}
fnFileLoad() {
const inFile = this.vm.vmGetInFileObject();
if (inFile.open) {
if (inFile.command === "chainMerge" && inFile.first && inFile.last) { // special handling to delete line numbers first
this.fnDeleteLines({
first: inFile.first,
last: inFile.last,
command: "CHAIN MERGE",
stream: 0, // unused
line: this.vm.line
});
this.vm.vmStop("fileLoad", 90); // restore
}
const name = inFile.name;
if (Utils.debug > 1) {
Utils.console.debug("fnFileLoad:", inFile.command, name, "details:", inFile);
}
const input = Controller.tryLoadingFromLocalStorage(name);
if (input !== null) {
if (Utils.debug > 0) {
Utils.console.debug("fnFileLoad:", inFile.command, name, "from localStorage");
}
this.vm.vmStop("", 0, true);
this.loadFileContinue(input);
}
else { // load from example
this.loadExample( /* name */);
}
}
else {
Utils.console.error("fnFileLoad:", inFile.name, "File not open!"); // hopefully isName is defined
}
this.nextLoopTimeOut = this.vm.vmGetTimeUntilFrame(); // wait until next frame
}
static splitMeta(input) {
let fileMeta;
if (input.indexOf(FileHandler.getMetaIdent()) === 0) { // starts with metaIdent?
const index = input.indexOf(","); // metadata separator
if (index >= 0) {
const metaString = input.substring(0, index);
input = input.substring(index + 1);
const meta = metaString.split(";");
fileMeta = {
typeString: meta[1],
start: Number(meta[2]),
length: Number(meta[3]),
entry: Number(meta[4]),
encoding: meta[5]
};
}
}
if (!fileMeta) {
fileMeta = {
typeString: ""
};
}
const metaAndData = {
meta: fileMeta,
data: input
};
return metaAndData;
}
fnFileSave() {
const outFile = this.vm.vmGetOutFileObject(), storage = Utils.localStorage;
let defaultExtension = "";
if (outFile.open) {
const type = outFile.typeString, name = outFile.name;
if (type === "P" || type === "T") {
defaultExtension = "bas";
}
else if (type === "B") {
defaultExtension = "bin";
}
const storageName = Controller.fnLocalStorageName(name, defaultExtension);
let fileData;
if (outFile.fileData.length || (type === "B") || (outFile.command === "openout")) { // type A(for openout) or B
fileData = outFile.fileData.join("");
if (!outFile.length) { // not yet set, e.g. for ASCII? (or can we set it always?)
outFile.length = fileData.length; // set length
}
}
else { // no file data (assuming type A, P or T) => get text
fileData = this.view.getAreaValue("inputText" /* ViewID.inputText */);
if (type === "T" || type === "P") {
fileData = this.encodeTokenizedBasic(fileData, storageName);
if (fileData === "") {
outFile.typeString = "A"; // override type
}
else if (type === "P") {
fileData = DiskImage.unOrProtectData(fileData);
}
}
outFile.length = fileData.length; // set length
}
if (Utils.debug > 0) {
Utils.console.debug("fnFileSave: name=" + name + ": put into localStorage");
}
const meta = FileHandler.joinMeta(outFile);
storage.setItem(storageName, meta + "," + fileData);
this.updateStorageDatabase("set", storageName);
if (outFile.fnFileCallback) {
try {
outFile.fnFileCallback(fileData); // close file
}
catch (e) {
Utils.console.warn(e);
}
}
this.vm.vmResetOutFileHandling(); // make sure it is closed
}
else {
Utils.console.error("fnFileSave: file not open!");
}
this.vm.vmStop("", 0, true); // continue
}
fnDeleteLines(paras) {
const inputText = this.view.getAreaValue("inputText" /* ViewID.inputText */), lines = this.fnGetLinesInRange(inputText, paras.first || 0, paras.last || 65535);
let error;
if (lines.length) {
for (let i = 0; i < lines.length; i += 1) {
const line = Controller.parseLineNumber(lines[i]);
if (isNaN(line)) {
error = this.vm.vmComposeError(Error(), 21, paras.command); // "Direct command found"
this.outputError(error, true);
break;
}
lines[i] = String(line); // keep just the line numbers
}
if (!error) {
let input = lines.join("\n");
input = this.mergeScripts(inputText, input); // delete input lines
this.setInputText(input);
}
}
this.vm.vmGoto(0); // reset current line
this.vm.vmStop("end", 0, true);
}
fnNew() {
const input = "";
this.setInputText(input);
this.fnRemoveAllVariables();
this.vm.vmGoto(0); // reset current line
this.vm.vmStop("end", 0, true);
this.invalidateScript();
}
fnList(paras) {
const input = this.view.getAreaValue("inputText" /* ViewID.inputText */), stream = paras.stream, lines = this.fnGetLinesInRange(input, paras.first || 0, paras.last || 65535), regExp = new RegExp(/([\x00-\x1f])/g); // eslint-disable-line no-control-regex
for (let i = 0; i < lines.length; i += 1) {
let line = lines[i];
if (stream !== 9) {
line = line.replace(regExp, "\x01$1"); // escape control characters to print them directly
}
this.vm.print(stream, line, "\r\n");
}
this.vm.vmGoto(0); // reset current line
this.vm.vmStop("end", 0, true);
}
fnReset() {
const vm = this.vm;
this.fnRemoveAllVariables();
vm.vmReset();
if (this.virtualKeyboard) {
this.virtualKeyboard.reset();
}
vm.vmStop("end", 0, true); // set "end" with priority 0, so that "compile only" still works
this.view.setAreaValue("outputText" /* ViewID.outputText */, "");
this.invalidateScript();
}
outputError(error, noSelection) {
const stream = 0;
let shortError;
if (Utils.isCustomError(error)) {
shortError = error.shortMessage || error.message;
if (!noSelection) {
const startPos = error.pos || 0, len = error.len || ((error.value !== undefined) ? String(error.value).length : 0), endPos = startPos + len;
this.view.setAreaSelection("inputText" /* ViewID.inputText */, error.pos, endPos);
}
}
else {
shortError = error.message;
}
const escapedShortError = shortError.replace(/([\x00-\x1f])/g, "\x01$1"); // eslint-disable-line no-control-regex
this.vm.print(stream, escapedShortError + "\r\n");
return shortError;
}
fnRenumLines(paras) {
const vm = this.vm, input = this.view.getAreaValue("inputText" /* ViewID.inputText */), basicFormatter = this.getBasicFormatter();
this.basicLexer.setOptions({
keepWhiteSpace: false
});
this.basicParser.setOptions(Controller.formatterBasicParserOptions);
const output = basicFormatter.renumber(input, paras.newLine || 10, paras.oldLine || 1, paras.step || 10, paras.keep || 65535);
if (output.error) {
Utils.console.warn(output.error);
this.outputError(output.error);
}
else {
this.fnPutChangedInputOnStack();
this.setInputText(output.text, true);
this.fnPutChangedInputOnStack();
}
this.vm.vmGoto(0); // reset current line
vm.vmStop("end", 0, true);
}
fnEditLineCallback() {
const inputParas = this.vm.vmGetStopObject().paras, inputText = this.view.getAreaValue("inputText" /* ViewID.inputText */);
let input = inputParas.input;
input = this.mergeScripts(inputText, input);
this.setInputText(input);
this.vm.vmSetStartLine(0);
this.vm.vmGoto(0); // to be sure
this.view.setDisabled("continueButton" /* ViewID.continueButton */, true);
this.vm.cursor(inputParas.stream, 0);
this.vm.vmStop("end", 90);
return true;
}
fnEditLine(paras) {
const input = this.view.getAreaValue("inputText" /* ViewID.inputText */), stream = paras.stream, lineNumber = paras.first || 0, lines = this.fnGetLinesInRange(input, lineNumber, lineNumber);
if (lines.length) {
const lineString = lines[0];
this.vm.print(stream, lineString);
this.vm.cursor(stream, 1);
const inputParas = {
command: paras.command,
line: paras.line,
stream: stream,
message: "",
fnInputCallback: this.fnEditLineCallbackHandler,
input: lineString
};
this.vm.vmStop("waitInput", 45, true, inputParas);
this.fnWaitInput();
}
else {
const error = this.vm.vmComposeError(Error(), 8, String(lineNumber)); // "Line does not exist"
this.outputError(error);
this.vm.vmStop("stop", 60, true);
}
}
fnParseBench(input, bench) {
let output;
for (let i = 0; i < bench; i += 1) {
let time = Date.now();
output = this.codeGeneratorJs.generate(input, this.variables);
time = Date.now() - time;
Utils.console.debug("bench size", input.length, "labels", this.codeGeneratorJs.debugGetLabelsCount(), "loop", i, ":", time, "ms");
if (output.error) {
break;
}
}
return output;
}
fnParse() {
const input = this.view.getAreaValue("inputText" /* ViewID.inputText */), bench = this.model.getProperty("bench" /* ModelPropID.bench */);
let output;
this.basicLexer.setOptions({
keepWhiteSpace: false
});
this.basicParser.setOptions(Controller.codeGenJsBasicParserOptions);
if (!bench) {
output = this.codeGeneratorJs.generate(input, this.variables);
}
else {
output = this.fnParseBench(input, bench);
}
let outputString;
if (output.error) {
outputString = this.outputError(output.error);
}
else {
outputString = output.text;
this.vm.vmSetSourceMap(this.codeGeneratorJs.getSourceMap());
const tokens = this.encodeTokenizedBasic(input);
if (Utils.debug) {
Utils.console.debug("parse: input length:", input.length, ", tokenized length:", tokens.length);
}
this.vm.vmPutProgramInMem(tokens);
}
if (outputString && outputString.length > 0) {
outputString += "\n";
}
this.view.setAreaValue("outputText" /* ViewID.outputText */, outputString);
this.invalidateScript();
this.setVarSelectOptions("varSelect" /* ViewID.varSelect */, this.variables);
this.commonEventHandler.onVarSelectChange();
return output;
}
fnPretty() {
const input = this.view.getAreaValue("inputText" /* ViewID.inputText */), keepWhiteSpace = this.view.getInputChecked("prettySpaceInput" /* ViewID.prettySpaceInput */), keepBrackets = this.view.getInputChecked("prettyBracketsInput" /* ViewID.prettyBracketsInput */), keepColons = this.view.getInputChecked("prettyColonsInput" /* ViewID.prettyColonsInput */), output = this.prettyPrintBasic(input, keepWhiteSpace, keepBrackets, keepColons);
if (output) {
this.fnPutChangedInputOnStack();
this.setInputText(output, true);
this.fnPutChangedInputOnStack();
const diff = Diff.testDiff(input.toUpperCase(), output.toUpperCase());
this.view.setAreaValue("outputText" /* ViewID.outputText */, diff);
}
}
fnAddLines() {
const input = this.view.getAreaValue("inputText" /* ViewID.inputText */), output = Controller.addLineNumbers(input);
if (output) {
this.fnPutChangedInputOnStack();
this.setInputText(output, true);
this.fnPutChangedInputOnStack();
}
}
fnRemoveLines() {
const basicFormatter = this.getBasicFormatter();
this.basicLexer.setOptions({
keepWhiteSpace: false
});
this.basicParser.setOptions(Controller.formatterBasicParserOptions);
const input = this.view.getAreaValue("inputText" /* ViewID.inputText */), output = basicFormatter.removeUnusedLines(input);
if (output.error) {
this.outputError(output.error);
}
else {
this.fnPutChangedInputOnStack();
this.setInputText(output.text, true);
this.fnPutChangedInputOnStack();
}
}
fnGetFilename(input) {
let name = "file";
const reRemMatcher = /^\d* ?(?:REM|rem) ([\w.]+)+/, matches = input.match(reRemMatcher);
if (matches !== null) {
name = matches[1];
}
else {
const example = this.model.getProperty("example" /* ModelPropID.example */);
if (example !== "") {
if (example.indexOf("/") >= 0) {
name = example.substring(example.lastIndexOf("/") + 1);
}
}
}
if (name.indexOf(".") < 0) {
name += ".bas";
}
return name;
}
fnDownload() {
const options = this.view.getSelectOptions("exportFileSelect" /* ViewID.exportFileSelect */), exportTokenized = this.view.getInputChecked("exportTokenizedInput" /* ViewID.exportTokenizedInput */), exportDSK = this.view.getInputChecked("exportDSKInput" /* ViewID.exportDSKInput */), format = this.view.getSelectValue("exportDSKFormatSelect" /* ViewID.exportDSKFormatSelect */), stripEmpty = this.view.getInputChecked("exportDSKStripEmptyInput" /* ViewID.exportDSKStripEmptyInput */), exportBase64 = this.view.getInputChecked("exportBase64Input" /* ViewID.exportBase64Input */), editorText = Controller.exportEditorText, meta = {
typeString: "A", // ASCII
start: 0x170,
length: 0,
entry: 0
};
let diskImage, name = "", data = "";
const fnExportBase64 = function () {
meta.encoding = "base64";
const metaString = FileHandler.joinMeta(meta);
data = metaString + "," + Utils.btoa(data);
name += ".b64.txt";
};
if (exportDSK) {
diskImage = this.getFileHandler().getDiskImage();
diskImage.setOptions({
diskName: "test",
data: diskImage.formatImage(format) // data or system
});
}
for (let i = 0; i < options.length; i += 1) {
const item = options[i];
if (item.selected) {
if (item.value === editorText) {
data = this.view.getAreaValue("inputText" /* ViewID.inputText */);
name = this.fnGetFilename(data);
const eolStr = data.indexOf("\r\n") > 0 ? "\r\n" : "\n"; // heuristic: if CRLF found, use it as split
if (eolStr === "\n") {
data = data.replace(/\n/g, "\r\n"); // replace LF by CRLF (not really needed if tokenized is used)
}
meta.typeString = "A"; // ASCII
meta.start = 0x170;
meta.length = data.length;
meta.entry = 0;
}
else {
name = item.value;
data = Controller.tryLoadingFromLocalStorage(name) || "";
const metaAndData = Controller.splitMeta(data);
Object.assign(meta, metaAndData.meta); // copy meta info
data = metaAndData.data;
}
if (exportTokenized && meta.typeString === "A") { // do we need to tokenize it?
const tokens = this.encodeTokenizedBasic(data);
if (!tokens) { // not successful?
return;
}
data = tokens;
meta.typeString = "T";
meta.start = 0x170;
meta.length = data.length;
meta.entry = 0;
}
if (meta.typeString !== "A" && meta.typeString !== "X" && meta.typeString !== "Z") {
const [name1, ext1] = DiskImage.getFilenameAndExtension(name), // eslint-disable-line array-element-newline
header = DiskImage.createAmsdosHeader({
name: name1,
ext: ext1,
typeString: meta.typeString,
start: meta.start,
length: meta.length,
entry: meta.entry
}), headerString = DiskImage.combineAmsdosHeader(header);
data = headerString + data;
}
if (diskImage) {
diskImage.writeFile(name, data);
const diskOptions = diskImage.getOptions();
data = diskOptions.data; // we need the modified disk image with the file(s) inside
name = name.substring(0, name.indexOf(".") + 1) + "dsk";
meta.length = data.length;
meta.typeString = "X"; // (extended) disk image
}
else {
if (exportBase64) {
fnExportBase64();
}
if (data) {
this.view.fnDownloadBlob(data, name);
}
}
}
}
if (diskImage) {
if (stripEmpty) {
data = diskImage.stripEmptyTracks();
}
if (exportBase64) {
fnExportBase64();
}
if (data) {
this.view.fnDownloadBlob(data, name);
}
}
}
selectJsError(script, e) {
const lineNumber = e.lineNumber, // only on FireFox
columnNumber = e.columnNumber;
if (lineNumber || columnNumber) { // only available on Firefox
const errLine = lineNumber - 3; // for some reason line 0 is 3
let pos = 0, line = 0;
while (pos < script.length && line < errLine) {
pos = script.indexOf("\n", pos) + 1;
line += 1;
}
pos += columnNumber;
Utils.console.warn("Info: JS Error occurred at line", lineNumber, "column", columnNumber, "pos", pos);
this.view.setAreaSelection("outputText" /* ViewID.outputText */, pos, pos + 1);
}
}
fnChain(paras) {
const script = this.view.getAreaValue("outputText" /* ViewID.outputText */), vm = this.vm;
let line = paras && paras.first || 0;
line = line || 0;
if (line === 0) {
vm.vmResetData(); // start from the beginning => also reset data! (or put it in line 0 in the script)
}
if (this.vm.vmGetOutFileObject().open) {
this.fnFileSave();
}
if (!this.fnScript) {
try {
this.fnScript = new Function("o", script); // eslint-disable-line no-new-func
}
catch (e) {
Utils.console.error(e);
if (e instanceof Error) {
this.selectJsError(script, e);
e.shortMessage = "JS " + String(e);
this.outputError(e, true);
}
this.fnScript = undefined;
}
}
vm.vmReset4Run();
if (this.fnScript) {
vm.vmStop("", 0, true);
vm.vmGoto(0); // to load DATA lines
this.vm.vmSetStartLine(line); // clear resets also startline
this.view.setDisabled("runButton" /* ViewID.runButton */, true);
this.view.setDisabled("stopButton" /* ViewID.stopButton */, false);
this.view.setDisabled("continueButton" /* ViewID.continueButton */, true);
}
if (!this.inputSet) {
this.inputSet = true;
const input = this.model.getProperty("input" /* ModelPropID.input */);
if (input !== "") {
this.view.setAreaValue("inp2Text" /* ViewID.inp2Text */, input);
const that = this, timeout = 1;
setTimeout(function () {
that.startEnter();
that.view.setAreaValue("inp2Text" /* ViewID.inp2Text */, ""); // delete input
}, timeout);
}
}
if (Utils.debug > 1) {
Utils.console.debug("End of fnRun");
}
}
fnRun(paras) {
this.vm.clear(); // init variables
this.fnChain(paras);
}
fnParseRun() {
this.fnRemoveAllVariables();
const output = this.fnParse();
if (!output.error) {
this.fnRun();
}
}
fnParseChain() {
const output = this.fnParse();
if (!output.error) {
this.fnChain();
}
}
fnRunPart1(fnScript) {
try {
fnScript(this.vm);
}
catch (e) {
if (e instanceof Error) {
if (e.name === "CpcVm" || e.name === "Variables") {
let customError = e;
if (customError.errCode !== undefined) {
customError = this.vm.vmComposeError(customError, customError.errCode, customError.value);
}
if (!customError.hidden) {
Utils.console.warn(customError);
this.outputError(customError, !customError.pos);
}
else {
Utils.console.log(customError.message);
}
}
else {
Utils.console.error(e);
this.selectJsError(this.view.getAreaValue("outputText" /* ViewID.outputText */), e);
this.vm.vmComposeError(e, 2, "JS " + String(e)); // generate Syntax Error, set also err and erl and set stop
this.outputError(e, true);
}
}
else {
Utils.console.error(e);
}
}
}
fnDirectInput() {
const inputParas = this.vm.vmGetStopObject().paras, stream = inputParas.stream;
let input = inputParas.input;
input = input.trim();
inputParas.input = "";
if (input !== "") { // direct input
this.vm.cursor(stream, 0);
const inputText = this.view.getAreaValue("inputText" /* ViewID.inputText */);
if (!isNaN(Controller.parseLineNumber(input))) { // start with number?
if (Utils.debug > 0) {
Utils.console.debug("fnDirectInput: insert line=" + input);
}
input = this.mergeScripts(inputText, input);
this.setInputText(input, true);
this.vm.vmSetStartLine(0);
this.vm.vmGoto(0); // to be sure
this.view.setDisabled("continueButton" /* ViewID.continueButton */, true);
this.vm.cursor(stream, 1);
this.updateResultText();
return false; // continue direct input
}
Utils.console.log("fnDirectInput: execute:", input);
const codeGeneratorJs = this.codeGeneratorJs;
let output, outputString;
if (inputText && (!isNaN(Controller.parseLineNumber(inputText)) || this.model.getProperty("implicitLines" /* ModelPropID.implicitLines */))) { // do we have a program starting with a line number?
const separator = inputText.endsWith("\n") ? "" : "\n";
this.basicParser.setOptions(Controller.codeGenJsBasicParserOptions);
output = codeGeneratorJs.generate(inputText + separator + input, this.variables, true); // compile both; allow direct command
if (output.error) {
const error = output.error;
if (error.pos < inputText.length + 1) { // error not in direct?
error.message = "[prg] " + error.message;
output = undefined;
}
}
}
if (!output) {
this.basicParser.setOptions(Controller.codeGenJsBasicParserOptions);
output = codeGeneratorJs.generate(input, this.variables, true); // compile direct input only
}
if (output.error) {
outputString = this.outputError(output.error, true);
}
else {
outputString = output.text;
}
if (outputString && outputString.length > 0) {
outputString += "\n";
}
this.view.setAreaValue("outputText" /* ViewID.outputText */, outputString);
if (!output.error) {
this.vm.vmSetStartLine(this.vm.line); // fast hack
this.vm.vmGoto("direct");
try {
const fnScript = new Function("o", outputString); // eslint-disable-line no-new-func
this.fnScript = fnScript;
this.vm.vmSetSourceMap(codeGeneratorJs.getSourceMap());
}
catch (e) {
Utils.console.error(e);
if (e instanceof Error) {
this.outputError(e, true);
}
}
}
if (!output.error) {
this.updateResultText();
return true;
}
const msg = inputParas.message;
this.vm.print(stream, msg);
this.vm.cursor(stream, 1);
}
this.updateResultText();
return false;
}
startWithDirectInput() {
const vm = this.vm, stream = 0, msg = "Ready\r\n";
this.vm.tagoff(stream);
this.vm.vmResetControlBuffer();
if (this.vm.pos(stream) > 1) {
this.vm.print(stream, "\r\n");
}
this.vm.print(stream, msg);
this.vm.cursor(stream, 1, 1);
vm.vmStop("direct", 0, true, {
command: "direct",
stream: stream,
message: msg,
fnInputCallback: this.fnDirectInputHandler,
input: "",
line: this.vm.line
});
this.fnWaitInput();
}
updateResultText() {
this.view.setAreaValue("resultText" /* ViewID.resultText */, this.vm.vmGetOutBuffer());
this.view.setAreaScrollTop("resultText" /* ViewID.resultText */); // scroll to bottom
}
exitLoop() {
const stop = this.vm.vmGetStopObject(), reason = stop.reason;
this.updateResultText();
this.view.setDisabled("runButton" /* ViewID.runButton */, reason === "reset");
this.view.setDisabled("stopButton" /* ViewID.stopButton */, reason !== "fileLoad" && reason !== "fileSave");
this.view.setDisabled("continueButton" /* ViewID.continueButton */, reason === "end" || reason === "fileLoad" || reason === "fileSave" || reason === "parse" || reason === "renumLines" || reason === "reset");
this.setVarSelectOptions("varSelect" /* ViewID.varSelect */, this.variables);
this.commonEventHandler.onVarSelectChange();
if (reason === "stop" || reason === "end" || reason === "error" || reason === "parse" || reason === "parseRun") {
this.startWithDirectInput();
}
}
fnWaitFrame() {
this.vm.vmStop("", 0, true);
this.nextLoopTimeOut = this.vm.vmGetTimeUntilFrame(); // wait until next frame
}
fnOnError() {
this.vm.vmStop("", 0, true); // continue
}
static fnDummy() {
}
fnTimer() {
this.vm.vmStop("", 0, true); // continue
}
fnRunLoop() {
const stop = this.vm.vmGetStopObject();
this.nextLoopTimeOut = this.initialLoopTimeout;
if (!stop.reason && this.fnScript) {
this.fnRunPart1(this.fnScript); // could change reason
}
if (stop.reason in this.handlers) {
this.handlers[stop.reason].call(this, stop.paras);
}
else {
Utils.console.warn("runLoop: Unknown run mode:", stop.reason);
this.vm.vmStop("error", 50);
}
if (stop.reason && stop.reason !== "waitSound" && stop.reason !== "waitKey" && stop.reason !== "waitInput") {
this.timeoutHandlerActive = false; // not running any more
this.exitLoop();
}
else {
setTimeout(this.fnRunLoopHandler, this.nextLoopTimeOut);
}
}
startMainLoop() {
if (!this.timeoutHandlerActive) {
this.timeoutHandlerActive = true;
setTimeout(this.fnRunLoopHandler, 0);
}
}
setStopObject(stop) {
Object.assign(this.savedStop, stop);
}
getStopObject() {
return this.savedStop;
}
startParse() {
this.removeKeyBoardHandler();
this.vm.vmStop("parse", 95);
this.startMainLoop();
}
startRenum() {
const stream = 0;
this.vm.vmStop("renumLines", 85, false, {
command: "renum",
stream: 0, // unused
newLine: Number(this.view.getInputValue("renumNewInput" /* ViewID.renumNewInput */)), // 10
oldLine: Number(this.view.getInputValue("renumStartInput" /* ViewID.renumStartInput */)), // 1
step: Number(this.view.getInputValue("renumStepInput" /* ViewID.renumStepInput */)), // 10
keep: Number(this.view.getInputValue("renumKeepInput" /* ViewID.renumKeepInput */)), // 65535, keep lines
line: this.vm.line
});
if (this.vm.pos(stream) > 1) {
this.vm.print(stream, "\r\n");
}
this.vm.print(stream, "renum\r\n");
this.startMainLoop();
}
startRun() {
this.setStopObject(this.noStop);
this.removeKeyBoardHandler();
this.vm.vmStop("run", 95);
this.startMainLoop();
}
startParseRun() {
this.setStopObject(this.noStop);
this.removeKeyBoardHandler();
this.vm.vmStop("parseRun", 95);
this.startMainLoop();
}
startBreak() {
const vm = this.vm, stop = vm.vmGetStopObject();
this.setStopObject(stop);
this.removeKeyBoardHandler();
this.vm.vmStop("break", 80);
this.startMainLoop();
}
startContinue() {
const vm = this.vm, stop = vm.vmGetStopObject(), savedStop = this.getStopObject();
this.view.setDisabled("runButton" /* ViewID.runButton */, true);
this.view.setDisabled("stopButton" /* ViewID.stopButton */, false);
this.view.setDisabled("continueButton" /* ViewID.continueButton */, true);
if (stop.reason === "break" || stop.reason === "escape" || stop.reason === "stop" || stop.reason === "direct") {
if (savedStop.paras && !savedStop.paras.fnInputCallback) { // no keyboard callback? make sure no handler is set (especially for direct->continue)
this.removeKeyBoardHandler();
}
if (stop.reason === "direct" || stop.reason === "escape") {
this.vm.cursor(stop.paras.stream, 0); // switch it off (for continue button)
}
Object.assign(stop, savedStop); // fast hack
this.setStopObject(this.noStop);
}
this.startMainLoop();
}
startReset() {
this.setStopObject(this.noStop);
this.removeKeyBoardHandler();
this.vm.vmStop("reset", 99);
this.startMainLoop();
}
startScreenshot() {
return this.canvas.takeScreenShot();
}
fnPutKeysInBuffer(keys) {
for (let i = 0; i < keys.length; i += 1) {
this.keyboard.putKeyInBuffer(keys.charAt(i));
}
const options = this.keyboard.getOptions(), keyDownHandler = options.fnOnKeyDown;
if (keyDownHandler) {
keyDownHandler();
}
}
startEnter() {
let input = this.view.getAreaValue("inp2Text" /* ViewID.inp2Text */);
input = input.replace(/\n/g, "\r"); // LF => CR
this.fnPutKeysInBuffer(input);
}
static generateFunction(par, functionString) {
if (functionString.startsWith("function anonymous(")) { // already a modified function (inside an anonymous function)?
const firstIndex = functionString.indexOf("{"), lastIndex = functionString.lastIndexOf("}");
if (firstIndex >= 0 && lastIndex >= 0) {
functionString = functionString.substring(firstIndex + 1, lastIndex - 1); // remove anonymous function
}
functionString = functionString.trim();
}
else {
functionString = "var o=CpcLoco.controller.vm, v=o.vmGetAllVariables(); v." + par + " = " + functionString;
}
const match = (/function \(([^)]*)/).exec(functionString), args = match ? match[1].split(",") : [], fnFunction = new Function(args[0], args[1], args[2], args[3], args[4], functionString); // eslint-disable-line no-new-func
return fnFunction;
}
changeVariable() {
const par = this.view.getSelectValue("varSelect" /* ViewID.varSelect */), valueString = this.view.getSelectValue("varText" /* ViewID.varText */), variables = this.variables;
let value = variables.getVariable(par);
if (typeof value === "function") {
value = Controller.generateFunction(par, valueString);
variables.setVariable(par, value);
}
else {
const varType = this.variables.determineStaticVarType(par), type = this.vm.vmDetermineVarType(varType); // do we know dynamic type?
if (type !== "$") { // not string? => convert to number
value = parseFloat(valueString);
}
else {
value = valueString;
}
try {
const value2 = this.vm.vmAssign(varType, value);
variables.setVariable(par, value2);
Utils.console.log("Variable", par, "changed:", variables.getVariable(par), "=>", value);
}
catch (e) {
Utils.console.warn(e);
}
}
this.setVarSelectOptions("varSelect" /* ViewID.varSelect */, variables);
this.commonEventHandler.onVarSelectChange(); // title change?
}
setBasicVersion(basicVersion) {
this.basicParser.setOptions({
basicVersion: basicVersion
});
this.basicLexer.setOptions({
keywords: this.basicParser.getKeywords()
});
this.invalidateScript();
}
setPalette(palette) {
const validPalette = palette === "green" || palette === "grey" ? palette : "color";
this.canvas.setOptions({
palette: validPalette
});
}
setCanvasType(canvasType) {
let canvas = this.canvas;
if (canvas) {
canvas.stopUpdateCanvas(); // stop updates on current canvas
const canvasID = canvas.getOptions().canvasID;
this.view.setHidden(canvasID, true);
}
else if (canvasType !== "graphics") {
this.view.setHidden("cpcCanvas" /* ViewID.cpcCanvas */, true);
}
const palette = this.model.getProperty("palette" /* ModelPropID.palette */);
if (this.canvases[canvasType]) {
canvas = this.canvases[canvasType];
this.canvas = canvas;
this.setPalette(palette);
}
else {
const validPalette = palette === "green" || palette === "grey" ? palette : "color";
if (canvasType === "text") {
canvas = new TextCanvas({
canvasID: "textText" /* ViewID.textText */,
charset: cpcCharset,
palette: validPalette
});
}
else if (canvasType === "none") {
canvas = new NoCanvas({
canvasID: "noCanvas" /* ViewID.noCanvas */,
charset: cpcCharset,
palette: validPalette
});
}
else { // "graphics"
const isAreaHidden = this.view.getHidden("cpcArea" /* ViewID.cpcArea */);
if (isAreaHidden) {
this.commonEventHandler.toggleAreaHiddenById("change", "showCpcInput" /* ViewID.showCpcInput */); // show: ViewID.cpcArea
}
this.view.setHidden("cpcCanvas" /* ViewID.cpcCanvas */, false);
canvas = new Canvas({
canvasID: "cpcCanvas" /* ViewID.cpcCanvas */,
charset: cpcCharset,
palette: validPalette
});
if (isAreaHidden) {
this.commonEventHandler.toggleAreaHiddenById("change", "showCpcInput" /* ViewID.showCpcInput */); // hide again: ViewID.cpcArea
}
}
this.canvases[canvasType] = canvas;
this.canvas = canvas;
}
if (this.vm) {
this.vm.setCanvas(canvas);
}
const canvasId = canvas.getOptions().canvasID;
this.view.setHidden(canvasId, false);
if (this.model.getProperty("showCpc" /* ModelPropID.showCpc */)) {
this.canvas.startUpdateCanvas();
}
return canvas;
}
setSoundActive() {
const sound = this.sound, active = this.model.getProperty("sound" /* ModelPropID.sound */);
if (active) {
sound.soundOn();
}
else {
sound.soundOff();
const stop = this.vm && this.vm.vmGetStopObject();
if (stop && stop.reason === "waitSound") {
this.vm.vmStop("", 0, true); // do not wait
}
}
}
getZ80Disass() {
if (!this.z80Disass) {
const dataArr = this.vm.vmGetMem(), data = dataArr; // fast hack: we take number array as Uint8Array
this.z80Disass = new Z80Disass({
data: data,
addr: 0
});
}
return this.z80Disass;
}
setDisassAddr(addr, endAddr) {
const z80Disass = this.getZ80Disass();
if (endAddr === undefined) {
endAddr = addr + 0x100;
}
z80Disass.setOptions({
addr: addr
});
const opts = z80Disass.getOptions(), lines = [];
while (addr < endAddr) { // currently not limited to < 0x10000
lines.push(z80Disass.disassLine());
if (opts.addr > addr) {
addr = opts.addr;
}
else {
Utils.console.error("setDisassAddr: Not increasing:", addr, opts.addr);
break;
}
}
const out = lines.join("\n") + "\n";
this.view.setAreaValue("disassText" /* ViewID.disassText */, out);
}
fnEndOfImport(imported) {
const stream = 0, vm = this.vm;
for (let i = 0; i < imported.length; i += 1) {
vm.print(stream, imported[i], " ");
}
vm.print(stream, "\r\n", imported.length + " file" + (imported.length !== 1 ? "s" : "") + " imported.\r\n");
this.updateResultText();
}
static fnOnDragover(evt) {
evt.stopPropagation();
evt.preventDefault();
if (evt.dataTransfer !== null) {
evt.dataTransfer.dropEffect = "copy"; // explicitly show this is a copy
}
}
adaptFilename(name, err) {
return this.vm.vmAdaptFilename(name, err);
}
getFileHandler() {
if (!this.fileHandler) {
this.fileHandler = new FileHandler({
adaptFilename: this.adaptFilename.bind(this),
updateStorageDatabase: this.updateStorageDatabase.bind(this),
outputError: this.outputError.bind(this),
processFileImports: this.model.getProperty("processFileImports" /* ModelPropID.processFileImports */)
});
}
return this.fileHandler;
}
getFileSelect(fileHandler) {
if (!this.fileSelect) {
this.fileSelect = new FileSelect({
fnEndOfImport: this.fnEndOfImport.bind(this),
fnLoad2: fileHandler.fnLoad2.bind(fileHandler)
});
}
return this.fileSelect;
}
initDropZone() {
const fileHandler = this.getFileHandler(), fileSelect = this.getFileSelect(fileHandler), dropZone = View.getElementById1("dropZone" /* ViewID.dropZone */);
dropZone.addEventListener("dragover", this.fnOnDragoverHandler, false);
fileSelect.addFileSelectHandler(dropZone, "drop");
const canvasID = this.canvas.getOptions().canvasID, canvasElement = View.getElementById1(canvasID);
canvasElement.addEventListener("dragover", this.fnOnDragoverHandler, false);
fileSelect.addFileSelectHandler(canvasElement, "drop");
const fileInput = View.getElementById1("fileInput" /* ViewID.fileInput */);
fileSelect.addFileSelectHandler(fileInput, "change");
}
fnUpdateUndoRedoButtons() {
this.view.setDisabled("undoButton" /* ViewID.undoButton */, !this.inputStack.canUndoKeepOne());
this.view.setDisabled("undoButton2" /* ViewID.undoButton2 */, !this.inputStack.canUndoKeepOne());
this.view.setDisabled("redoButton" /* ViewID.redoButton */, !this.inputStack.canRedo());
this.view.setDisabled("redoButton2" /* ViewID.redoButton2 */, !this.inputStack.canRedo());
}
fnInitUndoRedoButtons() {
this.inputStack.reset();
this.fnUpdateUndoRedoButtons();
}
fnPutChangedInputOnStack() {
const input = this.view.getAreaValue("inputText" /* ViewID.inputText */), stackInput = this.inputStack.getInput();
if (stackInput !== input) {
this.inputStack.save(input);
this.fnUpdateUndoRedoButtons();
}
}
startUpdateCanvas() {
this.canvas.startUpdateCanvas();
}
stopUpdateCanvas() {
this.canvas.stopUpdateCanvas();
}
getDragElement() {
if (!this.dragElement) {
this.dragElement = new DragElement({
view: this.view,
entries: {}
});
}
return this.dragElement;
}
getVirtualKeyboard() {
if (!this.virtualKeyboard) {
this.virtualKeyboard = new VirtualKeyboard({
view: this.view,
fnPressCpcKey: this.keyboard.fnPressCpcKey.bind(this.keyboard),
fnReleaseCpcKey: this.keyboard.fnReleaseCpcKey.bind(this.keyboard)
});
}
return this.virtualKeyboard;
}
dragElementsData = {
entries: {
consoleLogArea: {
itemId: "consoleLogArea" /* ViewID.consoleLogArea */,
xOffset: 0,
yOffset: 0,
enabled: false
},
cpcArea: {
itemId: "cpcArea" /* ViewID.cpcArea */,
xOffset: 0,
yOffset: 0,
enabled: false
},
disassArea: {
itemId: "disassArea" /* ViewID.disassArea */,
xOffset: 0,
yOffset: 0,
enabled: false
},
inp2Area: {
itemId: "inp2Area" /* ViewID.inp2Area */,
xOffset: 0,
yOffset: 0,
enabled: false
},
inputArea: {
itemId: "inputArea" /* ViewID.inputArea */,
xOffset: 0,
yOffset: 0,
enabled: false
},
kbdArea: {
itemId: "kbdArea" /* ViewID.kbdArea */,
xOffset: 0,
yOffset: 0,
enabled: false
},
mainArea: {
itemId: "mainArea" /* ViewID.mainArea */,
xOffset: 0,
yOffset: 0,
enabled: false
},
outputArea: {
itemId: "outputArea" /* ViewID.outputArea */,
xOffset: 0,
yOffset: 0,
enabled: false
},
resultArea: {
itemId: "resultArea" /* ViewID.resultArea */,
xOffset: 0,
yOffset: 0,
enabled: false
},
variableArea: {
itemId: "variableArea" /* ViewID.variableArea */,
xOffset: 0,
yOffset: 0,
enabled: false
}
}
};
fnDragElementsActive(enabled) {
const dragElement = this.getDragElement(), dragElementsData = this.dragElementsData;
for (const entry in dragElementsData.entries) {
if (dragElementsData.entries.hasOwnProperty(entry)) {
dragElementsData.entries[entry].enabled = enabled;
}
}
dragElement.setOptions(this.dragElementsData);
}
getVariable(par) {
return this.variables.getVariable(par);
}
undoStackElement() {
return this.inputStack.undo();
}
redoStackElement() {
return this.inputStack.redo();
}
createFnDatabaseLoaded(url) {
return (_sFullUrl, key) => {
const selectedName = this.model.getProperty("database" /* ModelPropID.database */);
if (selectedName === key) {
this.model.getDatabase().loaded = true;
}
else { // should not occur
Utils.console.warn("databaseLoaded: name changed: " + key + " => " + selectedName);
this.model.setProperty("database" /* ModelPropID.database */, key);
const database = this.model.getDatabase();
if (database) {
database.loaded = true;
}
this.model.setProperty("database" /* ModelPropID.database */, selectedName);
}
Utils.console.log("fnDatabaseLoaded: database loaded: " + key + ": " + url);
this.setDirectorySelectOptions();
this.onDirectorySelectChange();
};
}
createFnDatabaseError(url) {
return (_sFullUrl, key) => {
Utils.console.error("fnDatabaseError: database error: " + key + ": " + url);
this.setDirectorySelectOptions();
this.onDirectorySelectChange();
this.setInputText("");
this.view.setAreaValue("resultText" /* ViewID.resultText */, "Cannot load database: " + key);
};
}
onDatabaseSelectChange() {
const databaseName = this.view.getSelectValue("databaseSelect" /* ViewID.databaseSelect */);
this.model.setProperty("database" /* ModelPropID.database */, databaseName);
this.view.setSelectTitleFromSelectedOption("databaseSelect" /* ViewID.databaseSelect */);
const database = this.model.getDatabase();
if (!database) {
Utils.console.error("onDatabaseSelectChange: database not available:", databaseName);
return;
}
if (database.text === "storage") { // special handling: browser localStorage
this.updateStorageDatabase("set", ""); // set all
database.loaded = true;
}
if (database.loaded) {
this.setDirectorySelectOptions();
this.onDirectorySelectChange();
}
else {
this.setInputText("#loading database " + databaseName + "...");
const exampleIndex = this.model.getProperty("exampleIndex" /* ModelPropID.exampleIndex */), url = database.src + "/" + exampleIndex;
Utils.loadScript(url, this.createFnDatabaseLoaded(url), this.createFnDatabaseError(url), databaseName);
}
}
onDirectorySelectChange() {
this.setExampleSelectOptions();
this.onExampleSelectChange();
}
onExampleSelectChange() {
const vm = this.vm, inFile = vm.vmGetInFileObject(), dataBaseName = this.model.getProperty("database" /* ModelPropID.database */), directoryName = this.view.getSelectValue("directorySelect" /* ViewID.directorySelect */);
vm.closein();
this.commonEventHandler.setPopoversHiddenExcept(); // hide all popovers, especially the gallery
inFile.open = true;
let exampleName = this.view.getSelectValue("exampleSelect" /* ViewID.exampleSelect */);
if (directoryName) {
exampleName = directoryName + "/" + exampleName;
}
const exampleEntry = this.model.getExample(exampleName);
let autorun = this.model.getProperty("autorun" /* ModelPropID.autorun */);
if (exampleEntry && exampleEntry.meta) { // TTT TODO: this is just a workaround, meta is in input now; should change command after loading!
const type = exampleEntry.meta.charAt(0);
if (type === "B" || type === "D" || type === "G") { // binary, data only, Gena Assembler?
autorun = false;
}
}
inFile.command = autorun ? "run" : "load";
if (dataBaseName !== "storage") {
exampleName = "/" + exampleName; // load absolute
}
else {
this.model.setProperty("example" /* ModelPropID.example */, exampleName);
}
inFile.name = exampleName;
inFile.start = undefined;
inFile.fnFileCallback = vm.vmGetLoadHandler();
vm.vmStop("fileLoad", 90);
this.startMainLoop();
}
exportAsBase64(storageName) {
const storage = Utils.localStorage;
let data = storage.getItem(storageName), out = "";
if (data !== null) {
const index = data.indexOf(","); // metadata separator
if (index >= 0) {
const meta = data.substring(0, index);
data = data.substring(index + 1);
data = Utils.btoa(data);
out = meta + ";base64," + data;
}
else { // hmm, no meta info
data = Utils.btoa(data);
out = "base64," + data;
}
}
Utils.console.log(out);
return out;
}
onCpcCanvasClick(event) {
this.commonEventHandler.setPopoversHiddenExcept(); // hide all popovers
this.canvas.onCanvasClick(event);
this.keyboard.setActive(true);
}
onWindowClick(event) {
this.canvas.onWindowClick(event);
this.keyboard.setActive(false);
}
fnArrayBounds() {
const arrayBounds = this.model.getProperty("arrayBounds" /* ModelPropID.arrayBounds */);
this.variables.setOptions({
arrayBounds: arrayBounds
});
this.vm.vmGoto(0); // reset current line
this.vm.vmStop("end", 0, true);
this.fnRemoveAllVariables();
}
fnImplicitLines() {
const implicitLines = this.model.getProperty("implicitLines" /* ModelPropID.implicitLines */);
this.codeGeneratorJs.setOptions({
implicitLines: implicitLines
});
if (this.codeGeneratorToken) {
this.codeGeneratorToken.setOptions({
implicitLines: implicitLines
});
}
}
fnRemoveAllVariables() {
if (Object.keys(this.variables.getAllVariables()).length) {
this.variables.removeAllVariables();
this.setVarSelectOptions("varSelect" /* ViewID.varSelect */, this.variables);
}
}
fnPrettyLowercaseVars() {
const prettyLowercaseVars = this.model.getProperty("prettyLowercaseVars" /* ModelPropID.prettyLowercaseVars */);
this.getCodeGeneratorBasic().setOptions({
lowercaseVars: prettyLowercaseVars
});
}
fnIntegerOverflow() {
const integerOverflow = this.model.getProperty("integerOverflow" /* ModelPropID.integerOverflow */);
this.codeGeneratorJs.setOptions({
integerOverflow: integerOverflow
});
}
fnTrace() {
const trace = this.model.getProperty("trace" /* ModelPropID.trace */);
this.codeGeneratorJs.setOptions({
trace: trace
});
}
fnSpeed() {
const speed = this.model.getProperty("speed" /* ModelPropID.speed */);
this.initialLoopTimeout = 1000 - speed * 10;
}
/* eslint-disable no-invalid-this */
handlers = {
timer: this.fnTimer,
waitKey: this.fnWaitKey,
waitFrame: this.fnWaitFrame,
waitSound: this.fnWaitSound,
waitInput: this.fnWaitInput,
fileCat: this.fnFileCat,
fileDir: this.fnFileDir,
fileEra: this.fnFileEra,
fileRen: this.fnFileRen,
error: Controller.fnDummy,
onError: this.fnOnError,
stop: Controller.fnDummy,
"break": Controller.fnDummy,
escape: Controller.fnDummy,
renumLines: this.fnRenumLines,
deleteLines: this.fnDeleteLines,
end: Controller.fnDummy,
editLine: this.fnEditLine,
list: this.fnList,
fileLoad: this.fnFileLoad,
fileSave: this.fnFileSave,
"new": this.fnNew,
run: this.fnRun,
parse: this.fnParse,
parseRun: this.fnParseRun,
reset: this.fnReset
};
}
/* cpcconfig.ts - configuration file for cpclocots */
const cpcconfig = {
databaseDirs: "./examples,https://benchmarko.github.io/CpcLocoApps/apps,https://benchmarko.github.io/LocoBasic/examples=locobasic,https://benchmarko.github.io/CpcLocoApps/rosetta,storage",
redirectExamples: {
"examples/art": {
database: "apps",
example: "demo/art"
},
"examples/blkedit": {
database: "apps",
example: "apps/blkedit"
}
}
};
class Model {
config;
initialConfig;
databases;
examples;
constructor(config) {
this.config = config || {}; // store only a reference
this.initialConfig = Object.assign({}, this.config); // save initial config
this.databases = {};
this.examples = {}; // loaded examples per database
}
getProperty(property) {
return this.config[property];
}
setProperty(property, value) {
this.config[property] = value;
}
getAllProperties() {
return this.config;
}
getAllInitialProperties() {
return this.initialConfig;
}
getChangedProperties() {
const current = this.config, initial = this.initialConfig, changed = {};
for (const name in current) {
if (current.hasOwnProperty(name)) {
if (current[name] !== initial[name]) {
changed[name] = current[name];
}
}
}
return changed;
}
addDatabases(db) {
for (const par in db) {
if (db.hasOwnProperty(par)) {
const entry = db[par];
this.databases[par] = entry;
this.examples[par] = {};
}
}
}
getAllDatabases() {
return this.databases;
}
getDatabase() {
const database = this.getProperty("database" /* ModelPropID.database */);
return this.databases[database];
}
getAllExamples() {
const database = this.getProperty("database" /* ModelPropID.database */);
return this.examples[database];
}
getExample(key) {
const database = this.getProperty("database" /* ModelPropID.database */);
return this.examples[database][key];
}
setExample(example) {
const database = this.getProperty("database" /* ModelPropID.database */), key = example.key;
if (!this.examples[database][key]) {
if (Utils.debug > 1) {
Utils.console.debug("setExample: creating new example:", key);
}
}
this.examples[database][key] = example;
}
removeExample(key) {
const database = this.getProperty("database" /* ModelPropID.database */);
if (!this.examples[database][key]) {
Utils.console.warn("removeExample: example does not exist: " + key);
}
delete this.examples[database][key];
}
}
class NodeAdapt {
static doAdapt() {
let https, // nodeJs
fs, module, audioContext;
const domElements = {}, myCreateElement = function (id) {
domElements[id] = {
className: "",
style: {
borderwidth: "",
borderStyle: ""
},
addEventListener: () => {
},
options: [],
getAttribute: () => {
},
setAttribute: () => {
}
};
Object.defineProperty(domElements[id], "length", {
get() {
return domElements[id].options.length;
},
set(len) {
domElements[id].options.length = len;
},
enumerable: true,
configurable: true
});
return domElements[id];
};
function fnEval(code) {
return eval(code); // eslint-disable-line no-eval
}
if (!audioContext) {
if (!audioContext) {
audioContext = () => {
throw new Error("AudioContext not supported");
};
}
}
Object.assign(window, {
console: console,
document: {
addEventListener: () => {
},
getElementById: (id) => domElements[id] || myCreateElement(id),
createElement: (type) => {
if (type === "option") {
return {};
}
Utils.console.error("createElement: unknown type", type);
return {};
}
},
AudioContext: audioContext
});
const nodeExports = eval("exports"), view = nodeExports.View, setSelectOptionsOrig = view.prototype.setSelectOptions;
view.prototype.setSelectOptions = (id, options) => {
const element = domElements[id] || myCreateElement(id);
if (!element.options.add) {
element.add = (option) => {
element.options.push(option);
if (element.options.length === 1 || option.selected) {
element.value = element.options[element.options.length - 1].value;
}
};
}
return setSelectOptionsOrig(id, options);
};
const setAreaValueOrig = view.prototype.setAreaValue;
view.prototype.setAreaValue = (id, value) => {
if (id === "resultText" /* ViewID.resultText */) {
if (value) {
Utils.console.log(value);
}
}
return setAreaValueOrig(id, value);
};
const controller = nodeExports.Controller;
controller.prototype.startWithDirectInput = function () {
this.stopUpdateCanvas();
Utils.console.log("We are ready.");
};
function isUrl(s) {
return s.startsWith("http"); // http or https
}
function nodeReadUrl(url, fnDataLoaded) {
if (!https) {
fnEval('https = require("https");'); // to trick TypeScript
}
https.get(url, (resp) => {
let data = "";
resp.on("data", (chunk) => {
data += chunk;
});
resp.on("end", () => {
fnDataLoaded(undefined, data);
});
}).on("error", (err) => {
Utils.console.log("Error: " + err.message);
fnDataLoaded(err);
});
}
let modulePath;
function nodeReadFile(name, fnDataLoaded) {
if (!fs) {
fnEval('fs = require("fs");'); // to trick TypeScript
}
if (!module) {
fnEval('module = require("module");'); // to trick TypeScript
modulePath = module.path || "";
if (!modulePath) {
Utils.console.warn("nodeReadFile: Cannot determine module path");
}
}
const name2 = modulePath ? modulePath + "/" + name : name;
fs.readFile(name2, "utf8", fnDataLoaded);
}
const utils = nodeExports.Utils;
utils.loadScript = (fileOrUrl, fnSuccess, _fnError, key) => {
const fnLoaded = (error, data) => {
if (error) {
Utils.console.error("file error: ", error);
}
if (data) {
fnEval(data); // load js (for nodeJs)
}
fnSuccess(fileOrUrl, key);
};
if (isUrl(fileOrUrl)) {
nodeReadUrl(fileOrUrl, fnLoaded);
}
else {
nodeReadFile(fileOrUrl, fnLoaded);
}
};
}
}
class CpcLoco {
static config = {
arrayBounds: false,
autorun: true,
basicVersion: "1.1", // "1.1" or "1.0"
bench: 0, // debug: number of parse bench loops
canvasType: "graphics", // "graphics", "text", "none"
databaseDirs: "examples", // example base directories (comma separated)
database: "examples", // examples, apps, saved
debug: 0,
example: "CpcLoco",
exampleIndex: "0index.js", // example index for every databaseDir
implicitLines: false, // allow implicit line numbers
input: "", // keyboard input when starting the app
integerOverflow: false, // check for integer overflow
kbdLayout: "alphanum", // alphanum, alpha, num
linesOnLoad: true, // add missing line numbers on load
dragElements: false,
palette: "color", // "color", "green", "grey"
prettyBrackets: true, // pretty print: brackets
prettyColons: true, // pretty print: colons
prettyLowercaseVars: false, // pretty print: lowercase variables
prettySpace: false, // pretty print: spaces
processFileImports: true, // open ZIP, DSK files on import
selectDataFiles: false, // select data files in example selection
showConsoleLog: false,
showCpc: true,
showDisass: false,
showExport: false,
showGallery: false,
showInput: true,
showInp2: false,
showKbd: false,
showKbdSettings: false,
showMore: false,
showOutput: false,
showPretty: false,
showRenum: false,
showResult: false,
showSettings: false,
showVariable: false,
showView: false,
sound: true,
speed: 100,
trace: false // trace code
};
static model;
static view;
static controller;
static fnHereDoc(fn) {
return String(fn).
replace(/^[^/]+\/\*\S*/, "").
replace(/\*\/[^/]+$/, "");
}
static addIndex(dir, input) {
if (typeof input === "function") {
input = {
[dir]: JSON.parse(this.fnHereDoc(input).trim())
};
}
return CpcLoco.controller.addIndex(dir, input);
}
static addItem(key, input) {
const inputString = (typeof input !== "string") ? this.fnHereDoc(input) : input;
return CpcLoco.controller.addItem(key, inputString);
}
static addRsx(key, RsxConstructor) {
return CpcLoco.controller.addRsx(key, RsxConstructor);
}
static fnParseArgs(args, config) {
for (let i = 0; i < args.length; i += 1) {
const nameValue = args[i], nameValueList = Utils.split2(nameValue, "="), name = nameValueList[0];
if (config.hasOwnProperty(name)) {
let value = nameValueList[1]; // string|number|boolean
if (value !== undefined && config.hasOwnProperty(name)) {
switch (typeof config[name]) {
case "string":
break;
case "boolean":
value = (value === "true");
break;
case "number":
value = Number(value);
break;
case "object":
break;
default:
break;
}
}
config[name] = value;
}
}
return config;
}
static fnDecodeUri(s) {
const rPlus = /\+/g; // Regex for replacing addition symbol with a space
let decoded = "";
try {
decoded = decodeURIComponent(s.replace(rPlus, " "));
}
catch (err) {
err.message += ": " + s;
Utils.console.error(err);
}
return decoded;
}
static fnParseUri(urlQuery, config) {
const rSearch = /([^&=]+)=?([^&]*)/g, args = [];
let match;
while ((match = rSearch.exec(urlQuery)) !== null) {
const name = CpcLoco.fnDecodeUri(match[1]), value = CpcLoco.fnDecodeUri(match[2]);
if (value !== null && config.hasOwnProperty(name)) {
args.push(name + "=" + value);
}
}
CpcLoco.fnParseArgs(args, config);
}
static fnMapObjectProperties(arg) {
if (typeof arg === "object") {
const res = [];
for (const key in arg) { // eslint-disable-line guard-for-in
const value = arg[key];
if (typeof value !== "object" && typeof value !== "function") {
res.push(key + ": " + value);
}
}
arg = String(arg) + "{" + res.join(", ") + "}";
}
return arg;
}
static createDebugUtilsConsole(CpcLocoLog) {
const currentConsole = Utils.console;
return {
consoleLog: {
value: CpcLocoLog || "" // already something collected?
},
console: currentConsole,
rawLog: function (fnMethod, level, args) {
if (level) {
args.unshift(level);
}
if (fnMethod) {
if (fnMethod.apply) {
fnMethod.apply(console, args);
}
}
if (this.consoleLog) {
this.consoleLog.value += args.map(CpcLoco.fnMapObjectProperties).join(" ") + ((level !== null) ? "\n" : "");
}
},
log: function () {
this.rawLog(this.console && this.console.log, "", Array.prototype.slice.call(arguments));
},
debug: function () {
this.rawLog(this.console && this.console.debug, "DEBUG:", Array.prototype.slice.call(arguments));
},
info: function () {
this.rawLog(this.console && this.console.info, "INFO:", Array.prototype.slice.call(arguments));
},
warn: function () {
this.rawLog(this.console && this.console.warn, "WARN:", Array.prototype.slice.call(arguments));
},
error: function () {
this.rawLog(this.console && this.console.error, "ERROR:", Array.prototype.slice.call(arguments));
},
changeLog: function (log) {
const oldLog = this.consoleLog;
this.consoleLog = log;
if (oldLog && oldLog.value && log) { // some log entires collected?
log.value += oldLog.value; // take collected log entries
}
}
};
}
static fnRedirectExamples(redirectExamples) {
const name = this.model.getProperty("database" /* ModelPropID.database */) + "/" + this.model.getProperty("example" /* ModelPropID.example */);
if (redirectExamples[name]) {
this.model.setProperty("database" /* ModelPropID.database */, redirectExamples[name].database);
this.model.setProperty("example" /* ModelPropID.example */, redirectExamples[name].example);
}
}
static fnDoStart() {
const startConfig = CpcLoco.config, winCpcConfig = window.cpcConfig || {};
Object.assign(startConfig, cpcconfig, winCpcConfig);
const redirectExamples = startConfig.redirectExamples;
delete startConfig.redirectExamples;
CpcLoco.model = new Model(startConfig);
const myGlobalThis = (typeof globalThis !== "undefined") ? globalThis : Function("return this")(); // for old IE
if (!myGlobalThis.process) { // browser
CpcLoco.fnParseUri(window.location.search.substring(1), startConfig);
}
else { // nodeJs
CpcLoco.fnParseArgs(myGlobalThis.process.argv.slice(2), startConfig);
}
CpcLoco.view = new View();
const debug = Number(CpcLoco.model.getProperty("debug" /* ModelPropID.debug */));
Utils.debug = debug;
let UtilsConsole = Utils.console, CpcLocoLog = "";
if (UtilsConsole.CpcLocoLog) {
CpcLocoLog = UtilsConsole.CpcLocoLog;
UtilsConsole.CpcLocoLog = undefined; // do not log any more to dummy console
}
if (Utils.debug > 0 && CpcLoco.model.getProperty("showConsoleLog" /* ModelPropID.showConsoleLog */)) { // console log window?
UtilsConsole = CpcLoco.createDebugUtilsConsole(CpcLocoLog);
Utils.console = UtilsConsole;
Utils.console.log("CpcLoco log started at", Utils.dateFormat(new Date()));
UtilsConsole.changeLog(View.getElementById1("consoleLogText" /* ViewID.consoleLogText */));
}
if (redirectExamples) {
this.fnRedirectExamples(redirectExamples);
}
CpcLoco.controller = new Controller(CpcLoco.model, CpcLoco.view);
CpcLoco.controller.onDatabaseSelectChange(); // trigger loading example
}
static fnOnLoad() {
Utils.console.log("CpcLoco started at", Utils.dateFormat(new Date()));
CpcLoco.fnDoStart();
}
}
window.CpcLoco = CpcLoco;
window.onload = () => {
CpcLoco.fnOnLoad();
};
const MyPolyfills = (typeof window !== "undefined" && window.Polyfills) ? window.Polyfills : globalThis.Polyfills;
if (MyPolyfills && MyPolyfills.isNodeAvailable) {
NodeAdapt.doAdapt();
CpcLoco.fnOnLoad();
Utils.console.debug("End of main.");
}
const api = {
"CpcLoco": CpcLoco
};
global.Cpclocots = api;
if (typeof globalThis !== 'undefined') {
globalThis.Cpclocots = api;
}
if (global.window) {
global.window.Cpclocots = api;
}
if (typeof window !== 'undefined') {
window.Cpclocots = api;
}
})(typeof window !== 'undefined' ? window : (typeof globalThis !== 'undefined' ? globalThis : this));
//# sourceMappingURL=cpclocots.min.js.map
