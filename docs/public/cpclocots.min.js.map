{"version":3,"file":"cpclocots.min.js","sources":["cpclocots.js"],"sourcesContent":["/**\n * cpclocots bundle\n * Generated on 2026-02-01T21:06:29.303Z\n */\n(function (global) {\n  'use strict';\n  // ===== dist/esm/Utils.js =====\n  // Utils.ts - Utililities for CpcLoco\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n  const Polyfills = (typeof window !== \"undefined\" && window.Polyfills) ? window.Polyfills : globalThis.Polyfills;\n  class Utils {\n      static debug = 0;\n      static console = (typeof Polyfills !== \"undefined\" && Polyfills.console) ? Polyfills.console : (typeof window !== \"undefined\" ? window.console : globalThis.console);\n      static fnLoadScriptOrStyle(script, fnSuccess, fnError) {\n          // inspired by https://github.com/requirejs/requirejs/blob/master/require.js\n          let ieTimeoutCount = 3; // IE timeout count\n          const onScriptLoad = function (event) {\n              const type = event.type, // \"load\" or \"error\"\n              node = (event.currentTarget || event.srcElement), fullUrl = node.src || node.href, // src for script, href for link\n              key = node.getAttribute(\"data-key\");\n              if (Utils.debug > 1) {\n                  Utils.console.debug(\"onScriptLoad:\", type, fullUrl, key);\n              }\n              node.removeEventListener(\"load\", onScriptLoad, false);\n              node.removeEventListener(\"error\", onScriptLoad, false);\n              if (type === \"load\") {\n                  fnSuccess(fullUrl, key);\n              }\n              else {\n                  fnError(fullUrl, key);\n              }\n          }, onScriptReadyStateChange = function (event) {\n              const node = (event ? (event.currentTarget || event.srcElement) : script), fullUrl = node.src || node.href, // src for script, href for link\n              key = node.getAttribute(\"data-key\"), node2 = node;\n              if (node2.detachEvent) {\n                  node2.detachEvent(\"onreadystatechange\", onScriptReadyStateChange);\n              }\n              if (Utils.debug > 1) {\n                  Utils.console.debug(\"onScriptReadyStateChange: \" + fullUrl);\n              }\n              // check also: https://stackoverflow.com/questions/1929742/can-script-readystate-be-trusted-to-detect-the-end-of-dynamic-script-loading\n              if (node2.readyState !== \"loaded\" && node2.readyState !== \"complete\") {\n                  if (node2.readyState === \"loading\" && ieTimeoutCount) {\n                      ieTimeoutCount -= 1;\n                      const timeout = 200; // some delay\n                      Utils.console.error(\"onScriptReadyStateChange: Still loading: \" + fullUrl + \" Waiting \" + timeout + \"ms (count=\" + ieTimeoutCount + \")\");\n                      setTimeout(function () {\n                          onScriptReadyStateChange(); // check again\n                      }, timeout);\n                  }\n                  else {\n                      // ieTimeoutCount = 3;\n                      Utils.console.error(\"onScriptReadyStateChange: Cannot load file \" + fullUrl + \" readystate=\" + node2.readyState);\n                      fnError(fullUrl, key);\n                  }\n              }\n              else {\n                  fnSuccess(fullUrl, key);\n              }\n          };\n          if (script.readyState) { // old IE8\n              ieTimeoutCount = 3;\n              script.attachEvent(\"onreadystatechange\", onScriptReadyStateChange);\n          }\n          else { // Others\n              script.addEventListener(\"load\", onScriptLoad, false);\n              script.addEventListener(\"error\", onScriptLoad, false);\n          }\n          document.getElementsByTagName(\"head\")[0].appendChild(script);\n      }\n      static loadScript(url, fnSuccess, fnError, key) {\n          const script = document.createElement(\"script\");\n          script.type = \"text/javascript\";\n          script.charset = \"utf-8\";\n          script.async = true;\n          script.src = url;\n          script.setAttribute(\"data-key\", key);\n          this.fnLoadScriptOrStyle(script, fnSuccess, fnError);\n      }\n      static hexEscape(str) {\n          return str.replace(/[\\x00-\\x1f]/g, function (char) {\n              return \"\\\\x\" + (\"00\" + char.charCodeAt(0).toString(16)).slice(-2);\n          });\n      }\n      /*\n      static hexUnescape(str: string): string {\n          return str.replace(/\\\\x([0-9A-Fa-f]{2})/g, function () {\n              return String.fromCharCode(parseInt(arguments[1], 16));\n          });\n      }\n      */\n      static dateFormat(d) {\n          return d.getFullYear() + \"/\" + (\"0\" + (d.getMonth() + 1)).slice(-2) + \"/\" + (\"0\" + d.getDate()).slice(-2) + \" \"\n              + (\"0\" + d.getHours()).slice(-2) + \":\" + (\"0\" + d.getMinutes()).slice(-2) + \":\" + (\"0\" + d.getSeconds()).slice(-2) + \".\" + (\"0\" + d.getMilliseconds()).slice(-3);\n      }\n      static stringCapitalize(str) {\n          return str.charAt(0).toUpperCase() + str.substring(1);\n      }\n      static numberWithCommas(x) {\n          // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n          const parts = String(x).split(\".\");\n          parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n          return parts.join(\".\");\n      }\n      static toRadians(deg) {\n          return deg * Math.PI / 180;\n      }\n      static toDegrees(rad) {\n          return rad * 180 / Math.PI;\n      }\n      static toPrecision9(num) {\n          const numStr = num.toPrecision(9), // some rounding, formatting\n          [decimal, exponent] = numStr.split(\"e\"), // eslint-disable-line array-element-newline\n          result = String(Number(decimal)) + (exponent !== undefined ? (\"E\" + exponent.replace(/(\\D)(\\d)$/, \"$10$2\")) : \"\");\n          // Number(): strip trailing decimal point and/or zeros (replace(/\\.?0*$/, \"\"))\n          // exponent 1 digit to 2 digits\n          return result;\n      }\n      static testIsSupported(testExpression) {\n          try {\n              Function(testExpression); // eslint-disable-line no-new-func\n          }\n          catch (e) {\n              return false;\n          }\n          return true;\n      }\n      static supportsBinaryLiterals = Utils.testIsSupported(\"0b01\"); // does the browser support binary literals?\n      static supportReservedNames = Utils.testIsSupported(\"({}).return()\"); // does the browser support reserved names (delete, new, return) in dot notation? (not old IE8; \"goto\" is ok)\n      static stringTrimEnd(str) {\n          return str.replace(/[\\s\\uFEFF\\xA0]+$/, \"\");\n      }\n      static localStorage = (typeof Polyfills !== \"undefined\" && Polyfills.localStorage) ? Polyfills.localStorage : (typeof window !== \"undefined\" ? window.localStorage : undefined);\n      static atob = function (data) {\n          return window.atob(data);\n      };\n      static btoa = function (data) {\n          return window.btoa(data);\n      };\n      static isCustomError(e) {\n          return e.pos !== undefined;\n      }\n      static split2(str, char) {\n          const index = str.indexOf(char);\n          return index >= 0 ? [str.slice(0, index), str.slice(index + 1)] : [str]; // eslint-disable-line array-element-newline\n      }\n      static string2Uint8Array(data) {\n          const buf = new ArrayBuffer(data.length), view = new Uint8Array(buf);\n          for (let i = 0; i < data.length; i += 1) {\n              view[i] = data.charCodeAt(i);\n          }\n          return view;\n      }\n      static uint8Array2string(data) {\n          const callSize = 25000; // use call window to avoid \"maximum call stack error\" for e.g. size 336461\n          let len = data.length, offset = 0, out = \"\";\n          while (len) {\n              const chunkLen = Math.min(len, callSize), chunk = data.slice ? data.slice(offset, offset + chunkLen) : data.subarray(offset, offset + chunkLen); // array.slice on Uint8Array not for IE11\n              out += String.fromCharCode.apply(null, chunk); // on Chrome this is faster than single character processing\n              offset += chunkLen;\n              len -= chunkLen;\n          }\n          return out;\n      }\n      static composeError(name, errorObject, message, value, pos, len, line, hidden) {\n          const customError = errorObject;\n          customError.name = name;\n          customError.message = message;\n          customError.value = value;\n          if (pos !== undefined) {\n              customError.pos = pos;\n          }\n          if (len !== undefined) {\n              customError.len = len;\n          }\n          // Safari: Some additional properties are already defined: line, column. Shall we use \"cause\" property now?\n          if (line !== customError.line) {\n              customError.line = line;\n          }\n          if (hidden !== undefined) {\n              customError.hidden = hidden;\n          }\n          let errorLen = customError.len;\n          if (errorLen === undefined && customError.value !== undefined) {\n              errorLen = String(customError.value).length;\n          }\n          const endPos = (customError.pos || 0) + (errorLen || 0), lineMsg = (customError.line !== undefined ? \" in \" + customError.line : \"\"), posMsg = pos !== undefined ? (\" at pos \" + (pos !== endPos ? customError.pos + \"-\" + endPos : customError.pos)) : \"\";\n          customError.shortMessage = customError.message + (lineMsg || posMsg) + \": \" + customError.value;\n          customError.message += lineMsg + posMsg + \": \" + customError.value;\n          return customError;\n      }\n      static composeVmError(name, errorObject, errCode, value) {\n          const customError = Utils.composeError(name, errorObject, String(errCode), value);\n          customError.errCode = errCode;\n          return customError;\n      }\n  }\n\n  // ===== dist/esm/BasicFormatter.js =====\n  // BasicFormatter.ts - Format BASIC source\n  // (c) Marco Vieth, 2020\n  // https://benchmarko.github.io/cpclocots/\n  //\n  //\n\n  class BasicFormatter {\n      options;\n      label = \"\"; // current label (line) for error messages\n      constructor(options) {\n          this.options = {\n              implicitLines: false\n          };\n          this.setOptions(options);\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      composeError(error, message, value, pos, len) {\n          return Utils.composeError(\"BasicFormatter\", error, message, value, pos, len, this.label);\n      }\n      // renumber\n      static fnHasLabel(label) {\n          return label !== \"\";\n      }\n      fnCreateLabelEntry(node, lastLine, implicitLines) {\n          const origLen = (node.orig || node.value).length;\n          if (!BasicFormatter.fnHasLabel(node.value) && implicitLines) {\n              node.value = String(lastLine + 1); // generate label\n          }\n          const label = node.value;\n          this.label = label; // for error messages\n          if (BasicFormatter.fnHasLabel(label)) {\n              const line = Number(label);\n              if (line < 1 || line > 65535) {\n                  throw this.composeError(Error(), \"Line number overflow\", label, node.pos, node.len);\n              }\n              if (line <= lastLine) {\n                  throw this.composeError(Error(), \"Expected increasing line number\", label, node.pos, node.len);\n              }\n          }\n          const labelEntry = {\n              value: label,\n              pos: node.pos,\n              len: origLen, // original length\n              refCount: 0\n          };\n          return labelEntry;\n      }\n      fnCreateLabelMap(nodes, implicitLines) {\n          const lines = {}; // line numbers\n          let lastLine = 0;\n          for (let i = 0; i < nodes.length; i += 1) {\n              const node = nodes[i];\n              if (node.type === \"label\") {\n                  const labelEntry = this.fnCreateLabelEntry(node, lastLine, implicitLines);\n                  lines[labelEntry.value] = labelEntry;\n                  lastLine = Number(labelEntry.value);\n              }\n          }\n          return lines;\n      }\n      fnAddSingleReference(node, lines, refs) {\n          if (node.type === \"linenumber\") {\n              if (node.value in lines) {\n                  refs.push({\n                      value: node.value,\n                      pos: node.pos,\n                      len: (node.orig || node.value).length\n                  });\n                  const linesEntry = lines[node.value];\n                  if (linesEntry.refCount === undefined) { // not needed for renum but for removing line numbers\n                      linesEntry.refCount = 1;\n                  }\n                  else {\n                      linesEntry.refCount += 1;\n                  }\n              }\n              else {\n                  throw this.composeError(Error(), \"Line does not exist\", node.value, node.pos);\n              }\n          }\n      }\n      fnAddReferencesForNode(node, lines, refs) {\n          if (node.type === \"label\") {\n              this.label = node.value;\n          }\n          else {\n              this.fnAddSingleReference(node, lines, refs);\n          }\n          if (node.left) {\n              this.fnAddSingleReference(node.left, lines, refs);\n          }\n          if (node.right) {\n              this.fnAddSingleReference(node.right, lines, refs);\n          }\n          if (node.args) {\n              if (node.type === \"onErrorGoto\" && node.args.length === 1 && node.args[0].value === \"0\") {\n                  // ignore \"on error goto 0\"\n              }\n              else {\n                  this.fnAddReferences(node.args, lines, refs); // recursive\n              }\n          }\n      }\n      fnAddReferences(nodes, lines, refs) {\n          for (let i = 0; i < nodes.length; i += 1) {\n              this.fnAddReferencesForNode(nodes[i], lines, refs);\n          }\n      }\n      fnRenumberLines(lines, refs, newLine, oldLine, step, keep) {\n          const changes = {}, keys = Object.keys(lines);\n          function fnSortbyPosition(a, b) {\n              return lines[a].pos - lines[b].pos;\n          }\n          keys.sort(fnSortbyPosition);\n          for (let i = 0; i < keys.length; i += 1) {\n              const lineEntry = lines[keys[i]], hasLabel = BasicFormatter.fnHasLabel(lineEntry.value), line = Number(lineEntry.value);\n              if (!hasLabel || (line >= oldLine && line < keep)) {\n                  if (newLine > 65535) {\n                      throw this.composeError(Error(), \"Line number overflow\", lineEntry.value, lineEntry.pos);\n                  }\n                  lineEntry.newValue = String(newLine);\n                  changes[lineEntry.pos] = lineEntry;\n                  newLine += step;\n              }\n          }\n          for (let i = 0; i < refs.length; i += 1) {\n              const ref = refs[i], lineString = ref.value, line = Number(lineString);\n              if (line >= oldLine && line < keep) {\n                  if (lineString !== lines[lineString].newValue) {\n                      ref.newValue = lines[lineString].newValue;\n                      changes[ref.pos] = ref;\n                  }\n              }\n          }\n          return changes;\n      }\n      static fnSortNumbers(a, b) {\n          return a - b;\n      }\n      static fnApplyChanges(input, changes) {\n          const keys = Object.keys(changes).map(Number);\n          keys.sort(BasicFormatter.fnSortNumbers);\n          // apply changes to input in reverse order\n          for (let i = keys.length - 1; i >= 0; i -= 1) {\n              const line = changes[keys[i]];\n              input = input.substring(0, line.pos) + line.newValue + input.substring(line.pos + line.len);\n          }\n          return input;\n      }\n      fnRenumber(input, parseTree, newLine, oldLine, step, keep) {\n          const refs = [], // references\n          lines = this.fnCreateLabelMap(parseTree, Boolean(this.options.implicitLines));\n          this.fnAddReferences(parseTree, lines, refs); // create reference list\n          const changes = this.fnRenumberLines(lines, refs, newLine, oldLine, step, keep), output = BasicFormatter.fnApplyChanges(input, changes);\n          return output;\n      }\n      renumber(input, newLine, oldLine, step, keep) {\n          const out = {\n              text: \"\"\n          };\n          this.label = \"\"; // current line (label)\n          try {\n              const tokens = this.options.lexer.lex(input), parseTree = this.options.parser.parse(tokens), output = this.fnRenumber(input, parseTree, newLine, oldLine, step, keep || 65535);\n              out.text = output;\n          }\n          catch (e) {\n              if (Utils.isCustomError(e)) {\n                  out.error = e;\n              }\n              else { // other errors\n                  out.error = e; // force set other error\n                  Utils.console.error(e);\n              }\n          }\n          return out;\n      }\n      // ---\n      fnRemoveUnusedLines(input, parseTree) {\n          const refs = [], // references\n          implicitLines = true, lines = this.fnCreateLabelMap(parseTree, implicitLines);\n          this.fnAddReferences(parseTree, lines, refs); // create reference list\n          // reference count would be enough\n          const changes = {}, keys = Object.keys(lines);\n          for (let i = 0; i < keys.length; i += 1) {\n              const lineEntry = lines[keys[i]];\n              if (lineEntry.len && !lineEntry.refCount) { // non-empty label without references?\n                  lineEntry.newValue = \"\"; // set empty line number\n                  if (input[lineEntry.pos + lineEntry.len] === \" \") { // space following line number?\n                      lineEntry.len += 1; // remove it as well\n                  }\n                  changes[lineEntry.pos] = lineEntry;\n              }\n          }\n          const output = BasicFormatter.fnApplyChanges(input, changes);\n          return output;\n      }\n      removeUnusedLines(input) {\n          const out = {\n              text: \"\"\n          };\n          this.label = \"\"; // current line (label)\n          try {\n              const tokens = this.options.lexer.lex(input), parseTree = this.options.parser.parse(tokens), output = this.fnRemoveUnusedLines(input, parseTree);\n              out.text = output;\n          }\n          catch (e) {\n              if (Utils.isCustomError(e)) {\n                  out.error = e;\n              }\n              else { // other errors\n                  out.error = e; // force set other error\n                  Utils.console.error(e);\n              }\n          }\n          return out;\n      }\n  }\n\n  // ===== dist/esm/BasicLexer.js =====\n  // BasicLexer.ts - BASIC Lexer\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n  // BASIC lexer for Locomotive BASIC 1.1 for Amstrad CPC 6128\n  //\n  // based on an idea of: https://www.codeproject.com/Articles/345888/How-to-write-a-simple-interpreter-in-JavaScript\n\n  class BasicLexer {\n      options;\n      label = \"\"; // for error messages\n      takeNumberAsLabel = true; // first number in a line is assumed to be a label (line number)\n      input = \"\"; // input to analyze\n      index = 0; // position in input\n      tokens = [];\n      whiteSpace = \"\"; // collected whitespace\n      constructor(options) {\n          this.options = {\n              keepWhiteSpace: false,\n              quiet: false\n          };\n          this.setOptions(options);\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      composeError(error, message, value, pos, len) {\n          return Utils.composeError(\"BasicLexer\", error, message, value, pos, len, this.label || undefined);\n      }\n      static isOperatorOrStreamOrAddress(c) {\n          return (/[+\\-*/^=()[\\],;:?\\\\@#]/).test(c);\n      }\n      static isComparison(c) {\n          return (/[<>]/).test(c);\n      }\n      static isComparison2(c) {\n          return (/[<>=]/).test(c);\n      }\n      static isDigit(c) {\n          return (/\\d/).test(c);\n      }\n      static isSign(c) {\n          return (/[+-]/).test(c);\n      }\n      static isBin(c) {\n          return (/[01]/).test(c);\n      }\n      static isHex(c) {\n          return (/[0-9A-Fa-f]/).test(c);\n      }\n      static isWhiteSpace(c) {\n          return (/[ \\r]/).test(c);\n      }\n      static isNotQuotes(c) {\n          return c !== \"\" && c !== '\"' && c !== \"\\n\"; // quoted string must be in one line!\n      }\n      static isIdentifierStart(c) {\n          return c !== \"\" && (/[A-Za-z]/).test(c); // cannot use complete [A-Za-z]+[\\w]*[$%!]?\n      }\n      static isIdentifierMiddle(c) {\n          return c !== \"\" && (/[A-Za-z0-9.]/).test(c);\n      }\n      static isIdentifierEnd(c) {\n          return c !== \"\" && (/[$%!]/).test(c);\n      }\n      static isNotNewLine(c) {\n          return c !== \"\" && c !== \"\\n\";\n      }\n      static isUnquotedData(c) {\n          return c !== \"\" && (/[^:,\\r\\n]/).test(c);\n      }\n      testChar(add) {\n          return this.input.charAt(this.index + add);\n      }\n      getChar() {\n          return this.input.charAt(this.index);\n      }\n      advance() {\n          this.index += 1;\n          return this.getChar();\n      }\n      advanceWhile(char, fn) {\n          let token = \"\";\n          do {\n              token += char;\n              char = this.advance();\n          } while (fn(char));\n          return token;\n      }\n      debugCheckValue(type, value, pos, orig) {\n          const origValue = orig || value, part = this.input.substring(pos, pos + origValue.length);\n          if (part !== origValue) {\n              Utils.console.debug(\"BasicLexer:debugCheckValue:\", type, part, \"<>\", origValue, \"at pos\", pos);\n          }\n      }\n      addToken(type, value, pos, orig) {\n          const node = {\n              type: type,\n              value: value,\n              pos: pos\n          };\n          if (orig !== undefined) {\n              if (orig !== value) {\n                  node.orig = orig;\n              }\n          }\n          if (this.whiteSpace !== \"\") {\n              node.ws = this.whiteSpace;\n              this.whiteSpace = \"\";\n          }\n          if (Utils.debug > 1) {\n              this.debugCheckValue(type, value, pos, node.orig); // check position of added value\n          }\n          this.tokens.push(node);\n      }\n      fnParseExponentialNumber(char) {\n          // we also try to check: [eE][+-]?\\d+; because \"E\" could be ERR, ELSE,...\n          let token = \"\", index = 1;\n          while (BasicLexer.isWhiteSpace(this.testChar(index))) { // whitespace between e and rest?\n              index += 1;\n          }\n          const char1 = this.testChar(index), char2 = this.testChar(index + 1);\n          if (BasicLexer.isDigit(char1) || (BasicLexer.isSign(char1) && BasicLexer.isDigit(char2))) { // so it is a number\n              token += char; // take \"E\"\n              char = this.advance();\n              while (BasicLexer.isWhiteSpace(char)) {\n                  token += char;\n                  char = this.advance();\n              }\n              if (BasicLexer.isSign(char)) {\n                  token += char; // take sign \"+\" or \"-\"\n                  char = this.advance();\n              }\n              if (BasicLexer.isDigit(char)) {\n                  token += this.advanceWhile(char, BasicLexer.isDigit);\n              }\n          }\n          return token;\n      }\n      fnParseNumber(char, startPos, startsWithDot) {\n          let token = \"\";\n          if (startsWithDot) {\n              token = char;\n              char = this.advance();\n          }\n          token += this.advanceWhile(char, BasicLexer.isDigit); // TODO: isDigitOrSpace: numbers may contain spaces!\n          char = this.getChar();\n          if (char === \".\" && !startsWithDot) {\n              token += char;\n              char = this.advance();\n              if (BasicLexer.isDigit(char)) { // digits after dot?\n                  token += this.advanceWhile(char, BasicLexer.isDigit);\n                  char = this.getChar();\n              }\n          }\n          let expNumberPart = \"\";\n          if (char === \"e\" || char === \"E\") { // we also try to check: [eE][+-]?\\d+; because \"E\" could be ERR, ELSE,...\n              expNumberPart = this.fnParseExponentialNumber(char);\n              token += expNumberPart;\n              if (expNumberPart[1] === \" \" && !this.options.quiet) {\n                  Utils.console.warn(this.composeError({}, \"Whitespace in exponential number\", token, startPos).message);\n                  // do we really want to allow this?\n              }\n          }\n          const orig = token;\n          token = token.replace(/ /g, \"\"); // remove spaces\n          if (!isFinite(Number(token))) { // Infnity?\n              throw this.composeError(Error(), \"Number is too large or too small\", token, startPos); // for a 64-bit double\n          }\n          const number = expNumberPart ? token : parseFloat(token);\n          this.addToken(expNumberPart ? \"expnumber\" : \"number\", String(number), startPos, orig); // store number as string\n          if (this.takeNumberAsLabel) {\n              this.takeNumberAsLabel = false;\n              this.label = String(number); // save just for error message\n          }\n      }\n      fnParseCompleteLineForRemOrApostrophe(char, startPos) {\n          if (BasicLexer.isNotNewLine(char)) {\n              let token = this.advanceWhile(char, BasicLexer.isNotNewLine), whiteSpace = \"\";\n              char = this.getChar();\n              if (token.endsWith(\"\\r\")) {\n                  token = token.substring(0, token.length - 1);\n                  whiteSpace = \"\\r\";\n                  // now token can be empty?\n              }\n              this.addToken(\"unquoted\", token, startPos);\n              if (whiteSpace && this.options.keepWhiteSpace) {\n                  this.whiteSpace = whiteSpace;\n              }\n          }\n          return char;\n      }\n      fnParseWhiteSpace(char) {\n          const token = this.advanceWhile(char, BasicLexer.isWhiteSpace);\n          if (this.options.keepWhiteSpace) {\n              this.whiteSpace = token;\n          }\n      }\n      fnParseUnquoted(char, pos) {\n          const reSpacesAtEnd = new RegExp(/\\s+$/);\n          let token = this.advanceWhile(char, BasicLexer.isUnquotedData);\n          const match = reSpacesAtEnd.exec(token), endingSpaces = (match && match[0]) || \"\";\n          token = token.trim(); // remove whitespace before and after; do we need this?\n          this.addToken(\"unquoted\", token, pos); // could be interpreted as string or number during runtime\n          if (this.options.keepWhiteSpace) {\n              this.whiteSpace = endingSpaces;\n          }\n      }\n      fnParseCompleteLineForData(char) {\n          let pos;\n          while (BasicLexer.isNotNewLine(char)) {\n              if (BasicLexer.isWhiteSpace(char)) {\n                  this.fnParseWhiteSpace(char);\n                  char = this.getChar();\n              }\n              if (char === \"\\n\") { // now newline?\n                  break;\n              }\n              pos = this.index;\n              if (char === '\"') {\n                  this.fnParseString(pos);\n                  char = this.getChar();\n              }\n              else if (char === \",\") { // empty argument?\n                  // parser can insert dummy token\n              }\n              else {\n                  this.fnParseUnquoted(char, pos);\n                  char = this.getChar();\n              }\n              if (BasicLexer.isWhiteSpace(char)) {\n                  this.fnParseWhiteSpace(char);\n                  char = this.getChar();\n              }\n              if (char !== \",\") {\n                  break;\n              }\n              pos = this.index;\n              this.addToken(char, char, pos); // \",\"\n              char = this.advance();\n              if (char === \"\\r\") { // IE8 has \"/r/n\" newlines\n                  char = this.advance();\n              }\n          }\n      }\n      fnParseIdentifier(char, startPos) {\n          let token = char;\n          char = this.advance();\n          let lcToken = (token + char).toLowerCase(); // combine first 2 letters\n          if (lcToken === \"fn\" && this.options.keywords[lcToken]) {\n              this.addToken(lcToken, token + char, startPos); // create \"fn\" token\n              this.advance();\n              return;\n          }\n          if (BasicLexer.isIdentifierMiddle(char)) {\n              token += this.advanceWhile(char, BasicLexer.isIdentifierMiddle);\n              char = this.getChar();\n          }\n          if (BasicLexer.isIdentifierEnd(char)) {\n              token += char;\n              char = this.advance();\n          }\n          lcToken = token.toLowerCase();\n          if (this.options.keywords[lcToken]) {\n              this.addToken(lcToken, token, startPos);\n              if (lcToken === \"rem\") { // special handling for line comment\n                  startPos += lcToken.length;\n                  this.fnParseCompleteLineForRemOrApostrophe(char, startPos);\n              }\n              else if (lcToken === \"data\") { // special handling because strings in data lines need not to be quoted\n                  this.fnParseCompleteLineForData(char);\n              }\n          }\n          else {\n              this.addToken(\"identifier\", token, startPos);\n          }\n      }\n      fnParseHexOrBin(char, startPos) {\n          let token = char;\n          char = this.advance();\n          if (char.toLowerCase() === \"x\") { // binary?\n              token += char;\n              char = this.advance();\n              if (BasicLexer.isBin(char)) {\n                  token += this.advanceWhile(char, BasicLexer.isBin);\n                  this.addToken(\"binnumber\", token, startPos);\n              }\n              else {\n                  throw this.composeError(Error(), \"Expected binary number\", token, startPos);\n              }\n          }\n          else { // hex\n              if (char.toLowerCase() === \"h\") { // optional h\n                  token += char;\n                  char = this.advance();\n              }\n              if (BasicLexer.isHex(char)) {\n                  token += this.advanceWhile(char, BasicLexer.isHex);\n                  this.addToken(\"hexnumber\", token, startPos);\n              }\n              else {\n                  throw this.composeError(Error(), \"Expected hex number\", token, startPos);\n              }\n          }\n      }\n      fnTryContinueString(char) {\n          let out = \"\";\n          while (char === \"\\n\") {\n              const char1 = this.testChar(1);\n              if (char1 !== \"\" && (char1 < \"0\" || char1 > \"9\")) { // heuristic: next char not a digit => continue with the (multiline) string\n                  out += this.advanceWhile(char, BasicLexer.isNotQuotes);\n                  char = this.getChar();\n              }\n              else {\n                  break;\n              }\n          }\n          return out;\n      }\n      fnParseString(startPos) {\n          let char = \"\", token = this.advanceWhile(char, BasicLexer.isNotQuotes), type = \"string\", whiteSpace = \"\";\n          char = this.getChar();\n          if (char !== '\"') {\n              const contString = this.fnTryContinueString(char); // heuristic to detect an LF in the string\n              if (contString) {\n                  if (Utils.debug) {\n                      Utils.console.debug(this.composeError({}, \"Continued string\", token, startPos + 1).message);\n                  }\n                  token += contString;\n                  char = this.getChar();\n              }\n          }\n          if (char === '\"') { // not for newline\n              this.advance();\n          }\n          else {\n              if (Utils.debug) {\n                  Utils.console.debug(this.composeError({}, \"Unterminated string\", token, startPos + 1).message);\n              }\n              type = \"ustring\"; // unterminated string\n              if (token.endsWith(\"\\r\")) {\n                  token = token.substring(0, token.length - 1);\n                  whiteSpace = \"\\r\";\n                  // now token can be empty?\n              }\n          }\n          this.addToken(type, token, startPos + 1);\n          if (whiteSpace && this.options.keepWhiteSpace) {\n              this.whiteSpace = whiteSpace;\n          }\n      }\n      fnParseRsx(char, startPos) {\n          let token = char;\n          char = this.advance();\n          if (BasicLexer.isIdentifierMiddle(char)) {\n              token += this.advanceWhile(char, BasicLexer.isIdentifierMiddle);\n          }\n          this.addToken(\"|\", token, startPos);\n      }\n      processNextCharacter(startPos) {\n          let char = this.getChar(), token;\n          if (BasicLexer.isWhiteSpace(char)) {\n              this.fnParseWhiteSpace(char);\n          }\n          else if (char === \"\\n\") {\n              this.addToken(\"(eol)\", char, startPos);\n              this.advance();\n              this.takeNumberAsLabel = true;\n          }\n          else if (char === \"'\") { // apostrophe (comment)\n              this.addToken(char, char, startPos);\n              char = this.advance();\n              this.fnParseCompleteLineForRemOrApostrophe(char, startPos + 1);\n          }\n          else if (BasicLexer.isOperatorOrStreamOrAddress(char)) {\n              this.addToken(char, char, startPos);\n              this.advance();\n          }\n          else if (BasicLexer.isDigit(char)) { // number starting with a digit?\n              this.fnParseNumber(char, startPos, false);\n          }\n          else if (char === \".\") { // number starting with a dot?\n              this.fnParseNumber(char, startPos, true);\n          }\n          else if (char === \"&\") { // isHexOrBin: bin: &X, hex: & or &H\n              this.fnParseHexOrBin(char, startPos);\n          }\n          else if (char === '\"') {\n              this.fnParseString(startPos);\n          }\n          else if (BasicLexer.isIdentifierStart(char)) {\n              this.fnParseIdentifier(char, startPos);\n          }\n          else if (char === \"|\") { // isRsx\n              this.fnParseRsx(char, startPos);\n          }\n          else if (BasicLexer.isComparison(char)) {\n              token = this.advanceWhile(char, BasicLexer.isComparison2);\n              this.addToken(token, token, startPos); // like operator\n          }\n          else {\n              throw this.composeError(Error(), \"Unrecognized token\", char, startPos);\n          }\n      }\n      lex(input) {\n          let startPos;\n          this.input = input;\n          this.index = 0;\n          this.label = \"\"; // for error messages\n          this.takeNumberAsLabel = true;\n          this.whiteSpace = \"\";\n          this.tokens.length = 0;\n          while (this.index < input.length) {\n              startPos = this.index;\n              this.processNextCharacter(startPos);\n          }\n          this.addToken(\"(end)\", \"\", this.index);\n          return this.tokens;\n      }\n  }\n\n  // ===== dist/esm/BasicParser.js =====\n  // BasicParser.ts - BASIC Parser\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n  // BASIC parser for Locomotive BASIC 1.1 for Amstrad CPC 6128\n  //\n  // [ https://www.codeproject.com/Articles/345888/How-to-write-a-simple-interpreter-in-JavaScript ; test online: http://jsfiddle.net/h3xwj/embedded/result/ ]\n  //\n  // http://crockford.com/javascript/tdop/tdop.html\n  // Top Down Operator Precedence\n  // http://crockford.com/javascript/tdop/parse.js\n  // http://crockford.com/javascript/tdop/index.html\n  //\n  // http://stevehanov.ca/blog/?id=92\n  // http://stevehanov.ca/qb.js/qbasic.js\n  //\n  // http://www.csidata.com/custserv/onlinehelp/vbsdocs/vbs232.htm  (operator precedence) ?\n  // How to write a simple interpreter in JavaScript\n  // Peter_Olson, 30 Oct 2014\n\n  class BasicParser {\n      options;\n      keywordsBasic10; // keyward list for BASIC 1.0\n      keywords = BasicParser.keywordsBasic11;\n      label = \"0\"; // for error messages\n      symbols = {};\n      // set also during parse\n      tokens = [];\n      index = 0;\n      previousToken;\n      token; // current token\n      parseTree = [];\n      statementList = []; // just to check last statement when generating error message\n      constructor(options) {\n          this.options = {\n              basicVersion: \"1.1\", // default\n              quiet: false,\n              keepBrackets: false,\n              keepColons: false,\n              keepDataComma: false,\n              keepTokens: false\n          };\n          this.setOptions(options, true);\n          this.previousToken = {}; // to avoid warnings\n          this.token = this.previousToken;\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options, force) {\n          const currentBasicVersion = this.options.basicVersion;\n          Object.assign(this.options, options);\n          if (force || (this.options.basicVersion !== currentBasicVersion)) { // changed?\n              this.applyBasicVersion();\n          }\n      }\n      getKeywords() {\n          return this.keywords;\n      }\n      applyBasicVersion() {\n          const basicVersion = this.options.basicVersion;\n          this.keywords = basicVersion === \"1.0\" ? this.getKeywords10() : BasicParser.keywordsBasic11;\n          // if basicVersion changes, we need to recreate the symbols\n          this.fnClearSymbols();\n          this.fnGenerateSymbols();\n      }\n      // for basicKeywords:\n      static parameterTypes = {\n          c: \"command\",\n          f: \"function\",\n          o: \"operator\",\n          n: \"number\",\n          s: \"string\",\n          l: \"line number\", // checked\n          q: \"line number range\",\n          v: \"variable\", // checked,\n          r: \"letter or range\",\n          a: \"any parameter\",\n          \"n0?\": \"optional parameter with default null\",\n          \"#\": \"stream\"\n      };\n      // keyword list for BASIC 1.1\n      // first letter: c=command, f=function, p=part of command, o=operator, x=misc\n      // following are arguments: n=number, s=string, l=line number (checked), v=variable (checked), q=line number range, r=letter or range, a=any, n0?=optional parameter with default null, #=stream, #0?=optional stream with default 0; suffix ?=optional (optionals must be last); last *=any number of arguments may follow\n      static keywordsBasic11 = {\n          abs: \"f n\", // ABS(<numeric expression>)\n          after: \"c\", // => afterGosub\n          afterGosub: \"c n n?\", // AFTER <timer delay>[,<timer number>] GOSUB <line number> / (special, cannot check optional first n, and line number)\n          and: \"o\", // <argument> AND <argument>\n          asc: \"f s\", // ASC(<string expression>)\n          atn: \"f n\", // ATN(<numeric expression>)\n          auto: \"c n0? n0?\", // AUTO [<line number>][,<increment>]\n          bin$: \"f n n?\", // BIN$(<unsigned integer expression>[,<integer expression>])\n          border: \"c n n?\", // BORDER <color>[,<color>]\n          \"break\": \"p\", // see: ON BREAK...\n          call: \"c n *\", // CALL <address expression>[,<list of: parameter>]\n          cat: \"c\", // CAT\n          chain: \"c s n? *\", // CHAIN <filename>[,<line number expression>][,DELETE <line number range>]  (accepts also delete syntax) or: => chainMerge\n          chainMerge: \"c s n? *\", // CHAIN MERGE <filename>[,<line number expression>][,DELETE <line number range>] / (special)\n          chr$: \"f n\", // CHR$(<integer expression>)\n          cint: \"f n\", // CINT(<numeric expression>)\n          clear: \"c\", // CLEAR  or: => clearInput\n          clearInput: \"c\", // CLEAR INPUT  (BASIC 1.1)\n          clg: \"c n?\", // CLG [<ink>]\n          closein: \"c\", // CLOSEIN\n          closeout: \"c\", // CLOSEOUT\n          cls: \"c #0?\", // CLS[#<stream expression>]\n          cont: \"c\", // CONT\n          copychr$: \"f #\", // COPYCHR$(#<stream expression>)  (BASIC 1.1)\n          cos: \"f n\", // COS(<numeric expression>)\n          creal: \"f n\", // CREAL(<numeric expression>)\n          cursor: \"c #0? n0? n?\", // CURSOR [<system switch>][,<user switch>] (either parameter can be omitted but not both)  (BASIC 1.1)\n          data: \"c n0*\", // DATA <list of: constant> (rather 0*, insert dummy null, if necessary)\n          dec$: \"f n s\", // DEC$(<numeric expression>,<format template>)  (corrected with BASIC 1.1)\n          def: \"c s *\", // DEF FN[<space>]<function name>[(<formal parameters>)]=<expression> / (not checked from this)\n          defint: \"c r r*\", // DEFINT <list of: letter range>\n          defreal: \"c r r*\", // DEFREAL <list of: letter range>\n          defstr: \"c r r*\", // DEFSTR <list of: letter range>\n          deg: \"c\", // DEG\n          \"delete\": \"c q0?\", // DELETE [<line number range>]\n          derr: \"f\", // DERR [BASIC 1.1]\n          di: \"c\", // DI\n          dim: \"c v *\", // DIM <list of: subscripted variable>\n          draw: \"c n n n0? n?\", // DRAW <x coordinate>,<y coordinate>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink mode>)\n          drawr: \"c n n n0? n?\", // DRAWR <x offset>,<y offset>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink mode>)\n          edit: \"c l\", // EDIT <line number>\n          ei: \"c\", // EI\n          \"else\": \"c\", // see: IF (else belongs to \"if\", but can also be used as command)\n          end: \"c\", // END\n          ent: \"c n *\", // ENT <envelope number>[,<envelope section][,<envelope section>]... (up to 5) / section: <number of steps>,<step size>,<pause time>  or: =<tone period>,<pause time>\n          env: \"c n *\", // ENV <envelope number>[,<envelope section][,<envelope section>]... (up to 5) / section: <number of steps>,<step size>,<pause time>  or: =<hardware envelope>,<envelope period>\n          eof: \"f\", // EOF\n          erase: \"c v *\", // ERASE <list of: variable name>  (array names without indices or dimensions)\n          erl: \"f\", // ERL\n          err: \"f\", // ERR\n          error: \"c n\", // ERROR <integer expression>\n          every: \"c\", // => everyGosub\n          everyGosub: \"c n n?\", // EVERY <timer delay>[,<timer number>] GOSUB <line number>  / (special, cannot check optional first n, and line number)\n          exp: \"f n\", // EXP(<numeric expression>)\n          fill: \"c n\", // FILL <ink>  (BASIC 1.1)\n          fix: \"f n\", // FIX(<numeric expression>)\n          fn: \"x\", // see DEF FN / (FN can also be separate from <function name>)\n          \"for\": \"c\", // FOR <simple variable>=<start> TO <end> [STEP <size>]\n          frame: \"c\", // FRAME\n          fre: \"f a\", // FRE(<numeric expression>)  or: FRE(<string expression>)\n          gosub: \"c l\", // GOSUB <line number>\n          \"goto\": \"c l\", // GOTO <line number>\n          graphics: \"c\", // => graphicsPaper or graphicsPen  (BASIC 1.1)\n          graphicsPaper: \"x n\", // GRAPHICS PAPER <ink>  / (special)  (BASIC 1.1)\n          graphicsPen: \"x n0? n?\", // GRAPHICS PEN [<ink>][,<background mode>]  / (either of the parameters may be omitted, but not both)  (BASIC 1.1)\n          hex$: \"f n n?\", // HEX$(<unsigned integer expression>[,<field width>])\n          himem: \"f\", // HIMEM\n          \"if\": \"c\", // IF <logical expression> THEN <option part> [ELSE <option part>]\n          ink: \"c n n n?\", // INK <ink>,<color>[,<color>]\n          inkey: \"f n\", // INKEY(<integer expression>)\n          inkey$: \"f\", // INKEY$\n          inp: \"f n\", // INP(<port number>)\n          input: \"c #0? *\", // INPUT[#<stream expression>,][;][<quoted string><separator>]<list of: variable>  / (special: not checked from this)\n          instr: \"f a a a?\", // INSTR([<start position>,]<searched string>,<searched for string>)  / (cannot check \"f n? s s\")\n          \"int\": \"f n\", // INT(<numeric expression>)\n          joy: \"f n\", // JOY(<integer expression>)\n          key: \"c n s\", // KEY <expansion token number>,<string expression>  / or: => keyDef\n          keyDef: \"c n n n? n? n?\", // KEY DEF <key number>,<repeat>[,<normal>[,<shifted>[,<control>]]]\n          left$: \"f s n\", // LEFT$(<string expression>,<required length>)\n          len: \"f s\", // LEN(<string expression>)\n          let: \"c\", // LET <variable>=<expression>\n          line: \"c\", // => lineInput / (not checked from this)\n          lineInput: \"c #0? *\", // INPUT INPUT[#<stream expression>,][;][<quoted string><separator>]<string variable> (not checked from this)\n          list: \"c q0? #0?\", // LIST [<line number range>][,#<stream expression>] (not checked from this, we cannot check multiple optional args; here we have stream as last parameter)\n          load: \"c s n?\", // LOAD <filename>[,<address expression>]\n          locate: \"c #0? n n\", // LOCATE [#<stream expression>,]<x coordinate>,<y coordinate>\n          log: \"f n\", // LOG(<numeric expression>)\n          log10: \"f n\", // LOG10(<numeric expression>)\n          lower$: \"f s\", // LOWER$(<string expression>)\n          mask: \"c n0? n?\", // MASK [<integer expression>][,<first point setting>]  / (either of the parameters may be omitted, but not both)  (BASIC 1.1)\n          max: \"f a *\", // MAX(<list of: numeric expression> | <one number of string>)\n          memory: \"c n\", // MEMORY <address expression>\n          merge: \"c s\", // MERGE <filename>\n          mid$: \"f s n n?\", // MID$(<string expression>,<start position>[,<sub-string length>])  / (start position=1..255, sub-string length=0..255)\n          mid$Assign: \"f s n n?\", // MID$(<string variable>,<insertion point>[,<new string length>])=<new string expression>  / (mid$ as assign)\n          min: \"f a *\", // MIN(<list of: numeric expression> | <one number of string>)\n          mod: \"o\", // <argument> MOD <argument>\n          mode: \"c n\", // MODE <integer expression>\n          move: \"c n n n0? n?\", // MOVE <x coordinate>,<y coordinate>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink>,<ink mode>)\n          mover: \"c n n n0? n?\", // MOVER <x offset>,<y offset>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink>,<ink mode>)\n          \"new\": \"c\", // NEW\n          next: \"c v*\", // NEXT [<list of: variable>]\n          not: \"o\", // NOT <argument>\n          on: \"c\", // => onBreakCont, on break gosub, on break stop, on error goto, on <ex> gosub, on <ex> goto, on sq(n) gosub\n          onBreakCont: \"c\", // ON BREAK CONT  / (special)\n          onBreakGosub: \"c l\", // ON BREAK GOSUB <line number>  / (special)\n          onBreakStop: \"c\", // ON BREAK STOP  / (special)\n          onErrorGoto: \"c l\", // ON ERROR GOTO <line number>  / (special)\n          onGosub: \"c l l*\", // ON <selector> GOSUB <list of: line number>  / (special; n not checked from this)\n          onGoto: \"c l l*\", // ON <selector> GOTO <list of: line number>  / (special; n not checked from this)\n          onSqGosub: \"c l\", // ON SQ(<channel>) GOSUB <line number>  / (special)\n          openin: \"c s\", // OPENIN <filename>\n          openout: \"c s\", // OPENOUT <filename>\n          or: \"o\", // <argument> OR <argument>\n          origin: \"c n n n? n? n? n?\", // ORIGIN <x>,<y>[,<left>,<right>,<top>,<bottom>]\n          out: \"c n n\", // OUT <port number>,<integer expression>\n          paper: \"c #0? n\", // PAPER[#<stream expression>,]<ink>\n          peek: \"f n\", // PEEK(<address expression>)\n          pen: \"c #0? n0 n?\", // PEN[#<stream expression>,][<ink>][,<background mode>]  / ink=0..15; background mode=0..1 (BASIC 1.1 with <background mode)\n          pi: \"f\", // PI\n          plot: \"c n n n0? n?\", // PLOT <x coordinate>,<y coordinate>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink mode>)\n          plotr: \"c n n n0? n?\", // PLOTR <x offset>,<y offset>[,[<ink>][,<ink mode>]]  (BASIC 1.1 with <ink mode>)\n          poke: \"c n n\", // POKE <address expression>,<integer expression>\n          pos: \"f #\", // POS(#<stream expression>)\n          print: \"c #0? *\", // PRINT[#<stream expression>,][<list of: print items>] ... [;][SPC(<integer expression>)] ... [;][TAB(<integer expression>)] ... [;][USING <format template>][<separator expression>]\n          rad: \"c\", // RAD\n          randomize: \"c n?\", // RANDOMIZE [<numeric expression>]\n          read: \"c v v*\", // READ <list of: variable>\n          release: \"c n\", // RELEASE <sound channels>  / (sound channels=1..7)\n          rem: \"c s?\", // REM <rest of line>\n          \"'\": \"c s?\", // '<rest of line> (apostrophe comment)\n          remain: \"f n\", // REMAIN(<timer number>)  / (timer number=0..3)\n          renum: \"c n0? n0? n?\", // RENUM [<new line number>][,<old line number>][,<increment>]\n          restore: \"c l?\", // RESTORE [<line number>]\n          resume: \"c l?\", // RESUME [<line number>]  or: => resumeNext\n          resumeNext: \"c\", // RESUME NEXT\n          \"return\": \"c\", // RETURN\n          right$: \"f s n\", // RIGHT$(<string expression>,<required length>)\n          rnd: \"f n?\", // RND[(<numeric expression>)]\n          round: \"f n n?\", // ROUND(<numeric expression>[,<decimals>])\n          run: \"c a?\", // RUN <string expression>  or: RUN [<line number>]  / (cannot check \"c s | l?\")\n          save: \"c s a? n? n? n?\", // SAVE <filename>[,<file type>][,<binary parameters>]  // <binary parameters>=<start address>,<file tength>[,<entry point>]\n          sgn: \"f n\", // SGN(<numeric expression>)\n          sin: \"f n\", // SIN(<numeric expression>)\n          sound: \"c n n n? n0? n0? n0? n?\", // SOUND <channel status>,<tone period>[,<duration>[,<volume>[,<valume envelope>[,<tone envelope>[,<noise period>]]]]]\n          space$: \"f n\", // SPACE$(<integer expression>)\n          spc: \"f n\", // SPC(<integer expression)  / see: PRINT SPC\n          speed: \"c\", // => speedInk, speedKey, speedWrite\n          speedInk: \"c n n\", // SPEED INK <period1>,<period2>  / (special)\n          speedKey: \"c n n\", // SPEED KEY <start delay>,<repeat period>  / (special)\n          speedWrite: \"c n\", // SPEED WRITE <integer expression>  / (integer expression=0..1)\n          sq: \"f n\", // SQ(<channel>)  / (channel=1,2 or 4)\n          sqr: \"f n\", // SQR(<numeric expression>)\n          step: \"p\", // STEP <size> / see: FOR\n          stop: \"c\", // STOP\n          str$: \"f n\", // STR$(<numeric expression>)\n          string$: \"f n a\", // STRING$(<length>,<character specificier>) / character specificier=string character or number 0..255\n          swap: \"p n n?\", // => windowSwap\n          symbol: \"c n n *\", // SYMBOL <character number>,<list of: rows>   or => symbolAfter  / character number=0..255, list of 1..8 rows=0..255\n          symbolAfter: \"c n\", // SYMBOL AFTER <integer expression>  / integer expression=0..256 (special)\n          tab: \"f n\", // TAB(<integer expression)  / see: PRINT TAB\n          tag: \"c #0?\", // TAG[#<stream expression>]\n          tagoff: \"c #0?\", // TAGOFF[#<stream expression>]\n          tan: \"f n\", // TAN(<numeric expression>)\n          test: \"f n n\", // TEST(<x coordinate>,<y coordinate>)\n          testr: \"f n n\", // TESTR(<x offset>,<y offset>)\n          then: \"p\", // THEN <option part>  / see: IF\n          time: \"f\", // TIME\n          to: \"p\", // TO <end>  / see: FOR\n          troff: \"c\", // TROFF\n          tron: \"c\", // TRON\n          unt: \"f n\", // UNT(<address expression>)\n          upper$: \"f s\", // UPPER$(<string expression>)\n          using: \"p\", // USING <format template>[<separator expression>]  / see: PRINT\n          val: \"f s\", // VAL (<string expression>)\n          vpos: \"f #\", // VPOS(#<stream expression>)\n          wait: \"c n n n?\", // WAIT <port number>,<mask>[,<inversion>]\n          wend: \"c\", // WEND\n          \"while\": \"c n\", // WHILE <logical expression>\n          width: \"c n\", // WIDTH <integer expression>\n          window: \"c #0? n n n n\", // WINDOW[#<stream expression>,]<left>,<right>,<top>,<bottom>  / or: => windowSwap\n          windowSwap: \"c n n?\", // WINDOW SWAP <stream expression>[,<stream expression>]  / (special: with numbers, not streams)\n          write: \"c #0? *\", // WRITE [#<stream expression>,][<write list>]\n          xor: \"o\", // <argument> XOR <argument>\n          xpos: \"f\", // XPOS\n          ypos: \"f\", // YPOS\n          zone: \"c n\", // ZONE <integer expression>  / integer expression=1..255\n          _rsx1: \"c a a*\", // |<rsxName>[, <argument list>] dummy with at least one parameter\n          _any1: \"x *\", // dummy: any number of args\n          _vars1: \"x v*\" // dummy: any number of variables\n      };\n      /* eslint-disable no-invalid-this */\n      specialStatements = {\n          \"|\": this.rsx, // rsx\n          after: this.afterEveryGosub,\n          chain: this.chain,\n          clear: this.clear,\n          data: this.data,\n          def: this.def,\n          \"else\": this.fnElse, // simular to a comment, normally not used\n          ent: this.entOrEnv,\n          env: this.entOrEnv,\n          every: this.afterEveryGosub,\n          \"for\": this.fnFor,\n          graphics: this.graphics,\n          \"if\": this.fnIf,\n          input: this.input,\n          key: this.key,\n          let: this.let,\n          line: this.line,\n          mid$: this.mid$Assign, // mid$Assign\n          on: this.on,\n          print: this.print,\n          \"?\": this.question, // ? is same as print\n          resume: this.resume,\n          run: this.run,\n          speed: this.speed,\n          symbol: this.symbol,\n          window: this.window,\n          write: this.write\n      };\n      /* eslint-enable no-invalid-this */\n      static closeTokensForLine = {\n          \"(eol)\": 1,\n          \"(end)\": 1\n      };\n      static closeTokensForLineAndElse = {\n          \"(eol)\": 1,\n          \"(end)\": 1,\n          \"else\": 1\n      };\n      static closeTokensForArgs = {\n          \":\": 1,\n          \"(eol)\": 1,\n          \"(end)\": 1,\n          \"else\": 1,\n          rem: 1,\n          \"'\": 1\n      };\n      static fnIsInString(string, find) {\n          return find && string.indexOf(find) >= 0;\n      }\n      getKeywords10() {\n          if (this.keywordsBasic10) {\n              return this.keywordsBasic10;\n          }\n          const keywords10 = {\n              ...BasicParser.keywordsBasic11\n          }; // clone\n          for (const key in keywords10) {\n              if (keywords10.hasOwnProperty(key)) {\n                  const keyWithSpaces = \" \" + key + \" \";\n                  // what about DEC$ ?\n                  if (BasicParser.fnIsInString(\" clearInput copychr$ cursor derr fill frame graphics graphicsPaper graphicsPen mask onBreakCont \", keyWithSpaces)) {\n                      delete keywords10[key]; // remove keywords which do not exist in BASIC 1.0\n                  }\n                  else if (BasicParser.fnIsInString(\" draw drawr move mover pen plot plotr \", keyWithSpaces)) {\n                      keywords10[key] = keywords10[key].substring(0, keywords10[key].lastIndexOf(\" \")); // remove the last parameter <ink mode>; or <background mode> for pen\n                      if (BasicParser.fnIsInString(\" move mover \", keyWithSpaces)) {\n                          keywords10[key] = keywords10[key].substring(0, keywords10[key].lastIndexOf(\" \")); // also remove parameter <ink>\n                      }\n                  }\n              }\n          }\n          this.keywordsBasic10 = keywords10;\n          return keywords10;\n      }\n      composeError(error, message, value, pos, len) {\n          len = value === \"(end)\" ? 0 : len;\n          return Utils.composeError(\"BasicParser\", error, message, value, pos, len, this.label || undefined);\n      }\n      fnLastStatementIsOnErrorGotoX() {\n          const statements = this.statementList;\n          let isOnErrorGoto = false;\n          for (let i = statements.length - 1; i >= 0; i -= 1) {\n              const lastStatement = statements[i];\n              if (lastStatement.type !== \":\") { // ignore colons (separator when keepTokens=true)\n                  if (lastStatement.type === \"onErrorGoto\" && lastStatement.args && Number(lastStatement.args[0].value) > 0) {\n                      isOnErrorGoto = true;\n                  }\n                  break;\n              }\n          }\n          return isOnErrorGoto;\n      }\n      fnMaskedError(node, message) {\n          if (!this.fnLastStatementIsOnErrorGotoX()) {\n              throw this.composeError(Error(), message, node.value, node.pos);\n          }\n          else if (!this.options.quiet) {\n              Utils.console.warn(this.composeError({}, message, node.value, node.pos).message);\n          }\n      }\n      // http://crockford.com/javascript/tdop/tdop.html (old: http://javascript.crockford.com/tdop/tdop.html)\n      // http://crockford.com/javascript/tdop/parse.js\n      // Operator precedence parsing\n      //\n      // Operator: With left binding power (lbp) and operational function.\n      // Manipulates tokens to its left (e.g: +)? => left denotative function led(), otherwise null denotative function nud()), (e.g. unary -)\n      // identifiers, numbers: also nud.\n      advance(id) {\n          let token = this.token;\n          this.previousToken = this.token;\n          if (id && id !== token.type) {\n              if (!this.fnLastStatementIsOnErrorGotoX()) {\n                  throw this.composeError(Error(), \"Expected \" + id, token.value === \"\" ? token.type : token.value, token.pos); // we cannot mask this error because advance is very generic\n              }\n              else if (!this.options.quiet) {\n                  Utils.console.warn(this.composeError({}, \"Expected \" + id, token.value === \"\" ? token.type : token.value, token.pos).message);\n              }\n          }\n          token = this.tokens[this.index]; // we get a lex token and reuse it as parseTree token\n          if (!token) { // should not occur\n              Utils.console.error(this.composeError({}, \"advance: End of file\", \"\", this.token && this.token.pos).message);\n              return this.token; // old token\n          }\n          this.index += 1;\n          const sym = this.symbols[token.type];\n          if (!sym) {\n              throw this.composeError(Error(), \"Unknown token\", token.type, token.pos);\n          }\n          this.token = token;\n          return token;\n      }\n      expression(rbp) {\n          let t = this.token, s = this.symbols[t.type];\n          if (Utils.debug > 3) {\n              Utils.console.debug(\"parse: expression rbp=\" + rbp + \" type=\" + t.type + \" t=%o\", t);\n          }\n          if (t.type === \"(end)\") {\n              throw this.composeError(Error(), \"Unexpected end of file\", \"\", t.pos);\n          }\n          this.advance();\n          if (!s.nud) {\n              throw this.composeError(Error(), \"Unexpected token\", t.value, t.pos);\n          }\n          let left = s.nud(t); // process literals, variables, and prefix operators\n          t = this.token;\n          s = this.symbols[t.type];\n          while (rbp < (s.lbp || 0)) { // as long as the right binding power is less than the left binding power of the next token...\n              this.advance();\n              if (!s.led) {\n                  throw this.composeError(Error(), \"Unexpected token\", t.type, t.pos);\n                  // TODO: How to get this error?\n              }\n              left = s.led(left); // ...the led method is invoked on the following token (infix and suffix operators), can be recursive\n              t = this.token;\n              s = this.symbols[t.type];\n          }\n          return left;\n      }\n      fnCheckExpressionType(expression, expectedType, typeFirstChar) {\n          if (expression.type !== expectedType) {\n              this.fnMaskedError(expression, \"Expected \" + BasicParser.parameterTypes[typeFirstChar]);\n          }\n      }\n      assignment() {\n          this.fnCheckExpressionType(this.token, \"identifier\", \"v\");\n          const left = this.expression(90), // take it (can also be an array) and stop\n          value = this.token;\n          this.advance(\"=\"); // equal as assignment\n          value.left = left;\n          value.right = this.expression(0);\n          value.type = \"assign\"; // replace \"=\"\n          return value;\n      }\n      statement() {\n          const t = this.token, s = this.symbols[t.type];\n          if (s.std) { // statement?\n              this.advance();\n              return s.std(this.previousToken);\n          }\n          let value;\n          if (t.type === \"identifier\") {\n              value = this.assignment();\n          }\n          else {\n              value = this.expression(0);\n          }\n          if (value.type !== \"assign\" && value.type !== \"fcall\" && value.type !== \"def\" && value.type !== \"(\" && value.type !== \"[\") {\n              this.fnMaskedError(t, \"Bad expression statement\");\n          }\n          return value;\n      }\n      statements(statementList, closeTokens) {\n          this.statementList = statementList; // fast hack to access last statement for error messages\n          let colonExpected = false;\n          while (!closeTokens[this.token.type]) {\n              if (colonExpected || this.token.type === \":\") {\n                  if (this.token.type !== \"'\" && this.token.type !== \"else\") { // no colon required for line comment or ELSE\n                      this.advance(\":\");\n                      if (this.options.keepColons) {\n                          statementList.push(this.previousToken);\n                      }\n                      else if (this.previousToken.ws) { // colon token has ws?\n                          this.token.ws = this.previousToken.ws + (this.token.ws || \"\"); // add ws to next token\n                      }\n                  }\n                  colonExpected = false;\n              }\n              else {\n                  statementList.push(this.statement());\n                  colonExpected = true;\n              }\n          }\n          return statementList;\n      }\n      static fnCreateDummyArg(type, value) {\n          return {\n              type: type, // e.g. \"null\"\n              value: value || \"\",\n              pos: 0,\n              len: 0\n          };\n      }\n      basicLine() {\n          let node;\n          if (this.token.type !== \"number\") {\n              node = BasicParser.fnCreateDummyArg(\"label\", \"\");\n              node.pos = this.token.pos;\n          }\n          else {\n              this.advance();\n              node = this.previousToken; // number token\n              node.type = \"label\"; // number => label\n          }\n          this.label = node.value; // set line number for error messages\n          node.args = this.statements([], BasicParser.closeTokensForLine);\n          if (this.token.type === \"(eol)\") {\n              if (this.options.keepTokens) { // not really a token\n                  node.args.push(this.token); // eol token with whitespace\n              }\n              this.advance();\n          }\n          else if (this.token.type === \"(end)\" && this.token.ws && this.options.keepTokens) {\n              node.args.push(this.token); // end token with whitespace\n          }\n          return node;\n      }\n      fnCombineTwoTokensNoArgs(node, token2) {\n          const name = node.type + Utils.stringCapitalize(this.token.type); // e.g .\"speedInk\"\n          node.value += (this.token.ws || \" \") + this.token.value; // combine values of both\n          this.token = this.advance(token2); // for \"speed\" e.g. \"ink\", \"key\", \"write\" (this.token.type)\n          if (this.options.keepTokens) {\n              if (!node.right) {\n                  node.right = this.previousToken; // set second token in first token\n              }\n              else { // e.g. on break...\n                  node.right.right = this.previousToken;\n              }\n          }\n          this.previousToken = node; // fast hack to get e.g. \"speed\" token\n          return name;\n      }\n      fnCombineTwoTokens(node, token2) {\n          return this.fnCreateCmdCallForType(node, this.fnCombineTwoTokensNoArgs(node, token2));\n      }\n      fnGetOptionalStream() {\n          let node;\n          if (this.token.type === \"#\") { // stream?\n              node = this.expression(0);\n          }\n          else { // create dummy\n              node = BasicParser.fnCreateDummyArg(\"#\"); // dummy stream\n              node.right = BasicParser.fnCreateDummyArg(\"null\", \"0\"); // ...with dummy parameter\n          }\n          return node;\n      }\n      fnChangeNumber2LineNumber(node) {\n          this.fnCheckExpressionType(node, \"number\", \"l\");\n          node.type = \"linenumber\"; // change type: number => linenumber\n      }\n      fnGetLineRange() {\n          let left;\n          if (this.token.type === \"number\") {\n              left = this.token;\n              this.advance();\n              this.fnChangeNumber2LineNumber(left);\n          }\n          let range;\n          if (this.token.type === \"-\") {\n              range = this.token;\n              this.advance();\n          }\n          if (range) {\n              let right;\n              if (this.token.type === \"number\") {\n                  right = this.token;\n                  this.advance();\n                  this.fnChangeNumber2LineNumber(right);\n              }\n              // accept also \"-\" as full range\n              range.type = \"linerange\"; // change \"-\" => \"linerange\"\n              range.left = left || BasicParser.fnCreateDummyArg(\"null\"); // insert dummy for left\n              range.right = right || BasicParser.fnCreateDummyArg(\"null\"); // insert dummy for right (do not skip it)\n          }\n          else if (left) {\n              range = left; // single line number\n          }\n          else {\n              throw this.composeError(Error(), \"Programming error: Undefined range\", this.token.value, this.token.pos);\n          }\n          return range;\n      }\n      static fnIsSingleLetterIdentifier(node) {\n          return node.type === \"identifier\" && !node.args && node.value.length === 1;\n      }\n      fnGetLetterRange(typeFirstChar) {\n          this.fnCheckExpressionType(this.token, \"identifier\", typeFirstChar);\n          const expression = this.expression(0); // n or n-n\n          if (BasicParser.fnIsSingleLetterIdentifier(expression)) { // ok\n              expression.type = \"letter\"; // change type: identifier -> letter\n          }\n          else if (expression.type === \"-\" && expression.left && expression.right && BasicParser.fnIsSingleLetterIdentifier(expression.left) && BasicParser.fnIsSingleLetterIdentifier(expression.right)) { // also ok\n              expression.type = \"range\"; // change type: \"-\" => range\n              expression.left.type = \"letter\"; // change type: identifier -> letter\n              expression.right.type = \"letter\"; // change type: identifier -> letter\n          }\n          else {\n              this.fnMaskedError(expression, \"Expected \" + BasicParser.parameterTypes[typeFirstChar]);\n          }\n          return expression;\n      }\n      fnCheckRemainingTypes(types) {\n          for (let i = 0; i < types.length; i += 1) { // some more parameters expected?\n              const type = types[i];\n              if (!type.endsWith(\"?\") && !type.endsWith(\"*\")) { // mandatory?\n                  const text = BasicParser.parameterTypes[type] || (\"parameter \" + type);\n                  this.fnMaskedError(this.token, \"Expected \" + text + \" for \" + this.previousToken.type);\n              }\n          }\n      }\n      fnCheckStaticTypeNotNumber(expression, typeFirstChar) {\n          const type = expression.type, isStringFunction = (this.keywords[type] || \"\").startsWith(\"f\") && type.endsWith(\"$\"), isStringIdentifier = type === \"identifier\" && expression.value.endsWith(\"$\");\n          if (type === \"string\" || type === \"ustring\" || type === \"#\" || isStringFunction || isStringIdentifier) { // got a string or a stream? (statical check)\n              this.fnMaskedError(expression, \"Expected \" + BasicParser.parameterTypes[typeFirstChar]);\n          }\n      }\n      fnCheckStaticTypeNotString(expression, typeFirstChar) {\n          const type = expression.type, isNumericFunction = (this.keywords[type] || \"\").startsWith(\"f\") && !type.endsWith(\"$\"), isNumericIdentifier = type === \"identifier\" && (expression.value.endsWith(\"%\") || expression.value.endsWith(\"!\")), isComparison = type === \"=\" || type.startsWith(\"<\") || type.startsWith(\">\"); // =, <, >, <=, >=\n          if (type === \"number\" || type === \"binnumber\" || type === \"hexnumber\" || type === \"expnumber\" || type === \"#\" || isNumericFunction || isNumericIdentifier || isComparison) { // got e.g. number or a stream? (statical check)\n              this.fnMaskedError(expression, \"Expected \" + BasicParser.parameterTypes[typeFirstChar]);\n          }\n      }\n      fnGetExpressionForType(args, type, types) {\n          const typeFirstChar = type.charAt(0), separator = \",\";\n          let expression, suppressAdvance = false;\n          switch (typeFirstChar) {\n              case \"#\": // stream expected? (for functions)\n                  if (type === \"#0?\") { // optional stream?\n                      if (this.token.type !== \"#\") { // no stream?\n                          suppressAdvance = true;\n                          type = \",\";\n                      }\n                      expression = this.fnGetOptionalStream();\n                  }\n                  else {\n                      expression = this.expression(0);\n                      this.fnCheckExpressionType(expression, \"#\", typeFirstChar); // check that it is a stream and not a number\n                  }\n                  break;\n              case \"l\":\n                  expression = this.expression(0);\n                  this.fnCheckExpressionType(expression, \"number\", typeFirstChar);\n                  this.fnChangeNumber2LineNumber(expression);\n                  break;\n              case \"v\": // variable (identifier)\n                  expression = this.expression(0);\n                  this.fnCheckExpressionType(expression, \"identifier\", typeFirstChar);\n                  break;\n              case \"r\": // letter or range of letters (defint, defreal, defstr)\n                  expression = this.fnGetLetterRange(typeFirstChar);\n                  break;\n              case \"q\": // line number range\n                  if (type !== \"q0?\") { // optional line number range\n                      throw this.composeError(Error(), \"Programming error: Unexpected line range type\", this.token.type, this.token.pos); // should not occur\n                  }\n                  if (this.token.type === \"number\" || this.token.type === \"-\") {\n                      expression = this.fnGetLineRange();\n                  }\n                  else {\n                      expression = BasicParser.fnCreateDummyArg(\"null\");\n                      if (types.length) {\n                          type = \",\"; // needMore=true, maybe take it as next parameter\n                      }\n                  }\n                  break;\n              case \"n\": // number\"\n                  if (type.substring(0, 2) === \"n0\" && this.token.type === separator) { // n0 or n0?: if parameter not specified, insert default value null?\n                      expression = BasicParser.fnCreateDummyArg(\"null\");\n                  }\n                  else {\n                      expression = this.expression(0);\n                      this.fnCheckStaticTypeNotNumber(expression, typeFirstChar);\n                  }\n                  break;\n              case \"s\": // string\n                  expression = this.expression(0);\n                  this.fnCheckStaticTypeNotString(expression, typeFirstChar);\n                  break;\n              default:\n                  expression = this.expression(0);\n                  if (expression.type === \"#\") { // got stream?\n                      this.fnMaskedError(expression, \"Unexpected stream\");\n                  }\n                  break;\n          }\n          args.push(expression);\n          if (this.token.type === separator) {\n              if (!suppressAdvance) {\n                  this.advance(separator);\n                  if (this.options.keepTokens) {\n                      args.push(this.previousToken);\n                  }\n              }\n              if (type.slice(-1) !== \"*\") {\n                  type = \"xxx\"; // initial needMore\n              }\n          }\n          else if (type !== \",\") { // !needMore\n              type = \"\"; // stop\n          }\n          return type;\n      }\n      fnGetArgs(args, keyword) {\n          const keyOpts = this.keywords[keyword], types = keyOpts.split(\" \"), closeTokens = BasicParser.closeTokensForArgs;\n          let type = \"xxx\"; // initial needMore\n          types.shift(); // remove keyword type\n          while (type && !closeTokens[this.token.type]) {\n              if (types && type.slice(-1) !== \"*\") { // \"*\"= any number of parameters\n                  type = types.shift() || \"\";\n                  if (!type) {\n                      this.fnMaskedError(this.previousToken, \"Expected end of arguments\"); // If masked, it will accept more args than expected\n                  }\n              }\n              type = this.fnGetExpressionForType(args, type, types);\n          }\n          if (types.length) { // some more parameters expected?\n              this.fnCheckRemainingTypes(types); // error if remaining mandatory args\n              type = types[0];\n              if (type === \"#0?\") { // null stream to add?\n                  const expression = BasicParser.fnCreateDummyArg(\"#\"); // dummy stream with dummy arg\n                  expression.right = BasicParser.fnCreateDummyArg(\"null\", \"0\");\n                  args.push(expression);\n              }\n          }\n          if (this.previousToken.type === \",\" && keyword !== \"delete\" && keyword !== \"list\") { // for line number range in delete, list it is ok\n              this.fnMaskedError(this.previousToken, \"Operand missing\");\n          }\n          return args;\n      }\n      fnGetArgsSepByCommaSemi(args) {\n          const closeTokens = BasicParser.closeTokensForArgs;\n          while (!closeTokens[this.token.type]) {\n              args.push(this.expression(0));\n              if (this.token.type === \",\" || this.token.type === \";\") {\n                  args.push(this.token); // keep comma or semicolon\n                  this.advance();\n              }\n              else {\n                  break;\n              }\n          }\n          return args;\n      }\n      fnGetArgsInParenthesis(args, keyword) {\n          this.advance(\"(\");\n          if (this.options.keepTokens) {\n              args.push(this.previousToken);\n          }\n          this.fnGetArgs(args, keyword || \"_any1\"); // until \")\"\n          this.advance(\")\");\n          if (this.options.keepTokens) {\n              args.push(this.previousToken);\n          }\n          return args;\n      }\n      static brackets = {\n          \"(\": \")\",\n          \"[\": \"]\"\n      };\n      fnGetArgsInParenthesesOrBrackets(args) {\n          const brackets = BasicParser.brackets;\n          this.advance(this.token.type === \"[\" ? \"[\" : \"(\");\n          const bracketOpen = this.previousToken;\n          args.push(bracketOpen);\n          this.fnGetArgs(args, \"_any1\"); // until \"]\" or \")\"\n          this.advance(this.token.type === \"]\" ? \"]\" : \")\");\n          const bracketClose = this.previousToken;\n          args.push(bracketClose);\n          if (!this.options.quiet && (brackets[bracketOpen.type] !== bracketClose.type)) {\n              Utils.console.warn(this.composeError({}, \"Inconsistent bracket style\", this.previousToken.value, this.previousToken.pos).message);\n          }\n          return args;\n      }\n      fnCreateCmdCall(node) {\n          node.args = this.fnGetArgs([], node.type);\n          return node;\n      }\n      fnCreateCmdCallForType(node, type) {\n          if (type) {\n              node.type = type; // override\n          }\n          return this.fnCreateCmdCall(node);\n      }\n      fnCreateFuncCall(node) {\n          node.args = [];\n          if (this.token.type === \"(\") { // args in parenthesis?\n              if (node.type === \"dec$\" && this.options.basicVersion === \"1.0\") {\n                  this.advance(\"(\"); // BASIC 1.0: simulate DEC$(( bug with 2 open brackets\n              }\n              this.fnGetArgsInParenthesis(node.args, node.type);\n          }\n          else { // no parenthesis?\n              // if we have a check, make sure there are no non-optional parameters left\n              const keyOpts = this.keywords[node.type];\n              if (keyOpts) {\n                  const types = keyOpts.split(\" \");\n                  types.shift(); // remove key\n                  this.fnCheckRemainingTypes(types);\n              }\n          }\n          return node;\n      }\n      // ...\n      fnIdentifier(node) {\n          if (this.token.type === \"(\" || this.token.type === \"[\") {\n              node.args = [];\n              this.fnGetArgsInParenthesesOrBrackets(node.args);\n          }\n          return node;\n      }\n      fnParenthesis(node) {\n          if (this.options.keepBrackets) {\n              node.args = [this.expression(0)];\n          }\n          else {\n              if (node.ws) { // bracket open has ws?\n                  this.token.ws = node.ws + (this.token.ws || \"\"); // add ws to next token\n              }\n              node = this.expression(0);\n          }\n          this.advance(\")\");\n          if (this.options.keepBrackets) {\n              node.args.push(this.previousToken);\n          }\n          else if (this.previousToken.ws) { // bracket close token has ws?\n              this.token.ws = this.previousToken.ws + (this.token.ws || \"\"); // add ws to next token\n          }\n          return node;\n      }\n      fnFn(node) {\n          node.args = [];\n          this.token = this.advance(\"identifier\");\n          node.right = this.previousToken;\n          if (this.token.type === \"(\") { // optional args?\n              this.fnGetArgsInParenthesis(node.args);\n          }\n          return node;\n      }\n      rsx(node) {\n          node.args = [];\n          let type = \"_any1\"; // expect any number of arguments\n          if (this.token.type === \",\") { // arguments starting with comma\n              this.advance();\n              if (this.options.keepTokens) {\n                  node.args.push(this.previousToken);\n              }\n              type = \"_rsx1\"; // dummy token: expect at least 1 argument\n          }\n          this.fnGetArgs(node.args, type); // get arguments\n          if (this.options.basicVersion === \"1.0\") { // BASIC 1.0: make sure there are no string parameters\n              for (let i = 0; i < node.args.length; i += 1) {\n                  this.fnCheckStaticTypeNotNumber(node.args[i], \"n\");\n              }\n          }\n          return node;\n      }\n      afterEveryGosub(node) {\n          const combinedNode = this.fnCreateCmdCallForType(node, node.type + \"Gosub\"); // \"afterGosub\" or \"everyGosub\", interval and optional timer\n          if (!combinedNode.args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", this.token.type, this.token.pos); // should not occur\n          }\n          if (combinedNode.args.length < 2) { // add default timer 0\n              combinedNode.args.push(BasicParser.fnCreateDummyArg(\"null\"));\n          }\n          this.advance(\"gosub\");\n          if (this.options.keepTokens) {\n              combinedNode.args.push(this.previousToken);\n          }\n          this.fnGetArgs(combinedNode.args, \"gosub\"); // line number\n          return combinedNode;\n      }\n      chain(node) {\n          if (this.token.type === \"merge\") { // chain merge?\n              const name = this.fnCombineTwoTokensNoArgs(node, this.token.type); // chainMerge\n              node.type = name;\n          }\n          node.args = [];\n          // chain, chain merge with optional DELETE\n          let node2 = this.expression(0); // filename\n          node.args.push(node2);\n          if (this.token.type === \",\") {\n              this.token = this.advance();\n              if (this.options.keepTokens) {\n                  node.args.push(this.previousToken);\n              }\n              let numberExpression = false; // line number (expression) found\n              if (this.token.type !== \",\" && this.token.type !== \"(eol)\" && this.token.type !== \"(end)\") {\n                  node2 = this.expression(0); // line number or expression\n                  node.args.push(node2);\n                  numberExpression = true;\n              }\n              if (this.token.type === \",\") {\n                  this.advance();\n                  if (this.options.keepTokens) {\n                      node.args.push(this.previousToken);\n                  }\n                  if (!numberExpression) {\n                      node2 = BasicParser.fnCreateDummyArg(\"null\"); // insert dummy arg for line\n                      node.args.push(node2);\n                  }\n                  this.advance(\"delete\");\n                  if (this.options.keepTokens) {\n                      node.args.push(this.previousToken);\n                  }\n                  this.fnGetArgs(node.args, this.previousToken.type); // args for \"delete\"\n              }\n          }\n          return node;\n      }\n      clear(node) {\n          const tokenType = this.token.type;\n          return tokenType === \"input\" && this.keywords.clearInput ? this.fnCombineTwoTokens(node, tokenType) : this.fnCreateCmdCall(node); // \"clear input\" (BASIC 1.1) or \"clear\"\n      }\n      data(node) {\n          let parameterFound = false;\n          node.args = [];\n          // data is special: it can have empty parameters, also the last parameter, and also if no parameters\n          if (this.token.type !== \",\" && this.token.type !== \"(eol)\" && this.token.type !== \"(end)\") {\n              node.args.push(this.expression(0)); // take first argument\n              parameterFound = true;\n          }\n          while (this.token.type === \",\") {\n              if (!parameterFound) {\n                  node.args.push(BasicParser.fnCreateDummyArg(\"null\")); // insert null parameter\n              }\n              this.token = this.advance();\n              if (this.options.keepDataComma) {\n                  node.args.push(this.previousToken); // \",\"\n              }\n              parameterFound = false;\n              if (this.token.type === \"(eol)\" || this.token.type === \"(end)\") {\n                  break;\n              }\n              else if (this.token.type !== \",\") {\n                  node.args.push(this.expression(0));\n                  parameterFound = true;\n              }\n          }\n          if (!parameterFound) {\n              node.args.push(BasicParser.fnCreateDummyArg(\"null\")); // insert null parameter\n          }\n          return node;\n      }\n      def(node) {\n          node.args = [];\n          this.advance(\"fn\");\n          if (this.options.keepTokens) {\n              node.right = this.previousToken;\n          }\n          this.token = this.advance(\"identifier\");\n          if (node.right) { // keepTokens\n              node.right.right = this.previousToken;\n          }\n          else {\n              node.right = this.previousToken;\n          }\n          if (this.token.type === \"(\") {\n              this.fnGetArgsInParenthesis(node.args, \"_vars1\"); // accept only variable names\n          }\n          this.advance(\"=\");\n          if (this.options.keepTokens) {\n              node.args.push(this.previousToken);\n          }\n          const expression = this.expression(0);\n          node.args.push(expression);\n          return node;\n      }\n      fnElse(node) {\n          node.args = [];\n          node.type += \"Comment\"; // else => elseComment\n          if (!this.options.quiet) {\n              Utils.console.warn(this.composeError({}, \"ELSE: Weird use of ELSE\", this.previousToken.type, this.previousToken.pos).message);\n          }\n          if (this.token.type === \"number\") { // first token number?\n              this.fnChangeNumber2LineNumber(this.token);\n          }\n          // TODO: data line as separate statement is taken\n          while (this.token.type !== \"(eol)\" && this.token.type !== \"(end)\") {\n              node.args.push(this.token); // collect tokens unchecked, may contain syntax error\n              this.advance();\n          }\n          return node;\n      }\n      entOrEnv(node) {\n          node.args = [this.expression(0)]; // should be number or variable\n          let count = 0;\n          while (this.token.type === \",\") {\n              this.token = this.advance();\n              if (this.options.keepTokens) {\n                  node.args.push(this.previousToken);\n              }\n              if (this.token.type === \"=\" && count % 3 === 0) { // special handling for parameter \"number of steps\"\n                  this.advance();\n                  if (this.options.keepTokens) {\n                      node.args.push(this.previousToken);\n                  }\n                  node.args.push(BasicParser.fnCreateDummyArg(\"null\")); // insert null parameter\n                  count += 1;\n              }\n              const expression = this.expression(0);\n              node.args.push(expression);\n              count += 1;\n          }\n          return node;\n      }\n      fnFor(node) {\n          this.fnCheckExpressionType(this.token, \"identifier\", \"v\");\n          const name = this.expression(90); // take simple identifier, nothing more\n          this.fnCheckExpressionType(name, \"identifier\", \"v\"); // expected simple\n          node.args = [name];\n          this.advance(\"=\");\n          if (this.options.keepTokens) {\n              node.args.push(this.previousToken);\n          }\n          node.args.push(this.expression(0));\n          this.token = this.advance(\"to\");\n          if (this.options.keepTokens) {\n              node.args.push(this.previousToken);\n          }\n          node.args.push(this.expression(0));\n          if (this.token.type === \"step\") {\n              this.advance();\n              if (this.options.keepTokens) {\n                  node.args.push(this.previousToken);\n              }\n              node.args.push(this.expression(0));\n          }\n          return node;\n      }\n      graphics(node) {\n          const tokenType = this.token.type;\n          if (tokenType !== \"pen\" && tokenType !== \"paper\") {\n              throw this.composeError(Error(), \"Expected PEN or PAPER\", tokenType, this.token.pos);\n          }\n          return this.fnCombineTwoTokens(node, tokenType);\n      }\n      fnCheckForUnreachableCode(args) {\n          for (let i = 0; i < args.length; i += 1) {\n              const node = args[i], tokenType = node.type;\n              if ((i === 0 && tokenType === \"linenumber\") || tokenType === \"goto\" || tokenType === \"stop\") {\n                  const index = i + 1;\n                  if (index < args.length && (args[index].type !== \"rem\") && (args[index].type !== \"'\")) {\n                      if (args[index].type === \":\" && this.options.keepColons) {\n                          // ignore\n                      }\n                      else if (!this.options.quiet) {\n                          Utils.console.warn(this.composeError({}, \"IF: Unreachable code after THEN or ELSE\", tokenType, node.pos).message);\n                      }\n                      break;\n                  }\n              }\n          }\n      }\n      fnIf(node) {\n          node.right = this.expression(0); // condition\n          node.args = [];\n          if (this.token.type !== \"goto\") { // no \"goto\", expect \"then\" token...\n              this.advance(\"then\");\n              if (this.options.keepTokens) {\n                  node.args.unshift(this.previousToken);\n              }\n              if (this.token.type === \"number\") {\n                  this.fnGetArgs(node.args, \"goto\"); // take number parameter as line number\n              }\n          }\n          this.statements(node.args, BasicParser.closeTokensForLineAndElse); // get \"then\" statements until \"else\" or eol\n          this.fnCheckForUnreachableCode(node.args);\n          if (this.token.type === \"else\") {\n              this.token = this.advance(\"else\");\n              const elseNode = this.previousToken;\n              node.args.push(elseNode);\n              elseNode.args = [];\n              if (this.token.type === \"number\") {\n                  this.fnGetArgs(elseNode.args, \"goto\"); // take number parameter as line number\n                  // only number 0?\n              }\n              if (this.token.type === \"if\") {\n                  elseNode.args.push(this.statement());\n              }\n              else {\n                  this.statements(elseNode.args, BasicParser.closeTokensForLineAndElse);\n              }\n              this.fnCheckForUnreachableCode(elseNode.args);\n          }\n          return node;\n      }\n      input(node) {\n          const stream = this.fnGetOptionalStream();\n          node.args = [stream];\n          if (stream.len !== 0) { // not an inserted stream?\n              this.advance(\",\");\n              if (this.options.keepTokens) {\n                  node.args.push(this.previousToken);\n              }\n          }\n          if (this.token.type === \";\") { // no newline after input?\n              node.args.push(this.token);\n              this.advance();\n          }\n          else {\n              node.args.push(BasicParser.fnCreateDummyArg(\"null\"));\n          }\n          if (this.token.type === \"string\" || this.token.type === \"ustring\") { // message\n              node.args.push(this.token);\n              this.token = this.advance();\n              if (this.token.type === \";\" || this.token.type === \",\") { // \";\" => need to append prompt \"? \" , \",\" = no prompt\n                  node.args.push(this.token);\n                  this.advance();\n              }\n              else {\n                  throw this.composeError(Error(), \"Expected ; or ,\", this.token.type, this.token.pos);\n              }\n          }\n          else {\n              node.args.push(BasicParser.fnCreateDummyArg(\"null\")); // dummy message\n              node.args.push(BasicParser.fnCreateDummyArg(\"null\")); // dummy prompt\n          }\n          do { // we need loop for input\n              const value2 = this.expression(90); // we expect \"identifier\", no fnxx\n              this.fnCheckExpressionType(value2, \"identifier\", \"v\");\n              node.args.push(value2);\n              if (node.type === \"lineInput\" || this.token.type !== \",\") {\n                  break; // no loop for lineInput (only one arg) or no more args\n              }\n              this.advance(\",\");\n              if (this.options.keepTokens) {\n                  node.args.push(this.previousToken);\n              }\n          } while (true); // eslint-disable-line no-constant-condition\n          return node;\n      }\n      key(node) {\n          const tokenType = this.token.type;\n          return tokenType === \"def\" ? this.fnCombineTwoTokens(node, tokenType) : this.fnCreateCmdCall(node); // \"key def\" or \"key\"\n      }\n      let(node) {\n          node.right = this.assignment();\n          return node;\n      }\n      line(node) {\n          node.type = this.fnCombineTwoTokensNoArgs(node, \"input\"); // combine \"line\" => \"lineInput\"\n          return this.input(node); // continue with input\n      }\n      mid$Assign(node) {\n          node.type = \"mid$Assign\"; // change type mid$ => mid$Assign\n          this.fnCreateFuncCall(node);\n          if (!node.args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", this.token.type, this.token.pos); // should not occur\n          }\n          // check that first argument is a variable...\n          let i = 0;\n          if (this.options.keepTokens) {\n              while (node.args[i].type === \"(\" && i < (node.args.length - 1)) {\n                  i += 1;\n              }\n          }\n          this.fnCheckExpressionType(node.args[i], \"identifier\", \"v\");\n          this.advance(\"=\"); // equal as assignment\n          if (this.options.keepTokens) {\n              node.args.push(this.previousToken);\n          }\n          const expression = this.expression(0);\n          node.args.push(expression);\n          return node;\n      }\n      on(node) {\n          node.args = [];\n          let tokenType;\n          switch (this.token.type) {\n              case \"break\":\n                  node.type = this.fnCombineTwoTokensNoArgs(node, \"break\"); // onBreak\n                  tokenType = this.token.type;\n                  if ((tokenType === \"cont\" && this.keywords.onBreakCont) || tokenType === \"gosub\" || tokenType === \"stop\") {\n                      this.fnCombineTwoTokens(node, this.token.type); // onBreakGosub, onBreakCont, onBreakStop\n                  }\n                  else {\n                      const msgContPart = this.keywords.onBreakCont ? \"CONT, \" : \"\";\n                      throw this.composeError(Error(), \"Expected \" + msgContPart + \"GOSUB or STOP\", this.token.type, this.token.pos);\n                  }\n                  break;\n              case \"error\": // on error goto\n                  node.type = this.fnCombineTwoTokensNoArgs(node, \"error\"); // onError..\n                  this.fnCombineTwoTokens(node, \"goto\"); // onErrorGoto\n                  break;\n              case \"sq\": // on sq(n) gosub\n                  node.right = this.expression(0);\n                  if (!node.right.args) {\n                      throw this.composeError(Error(), \"Programming error: Undefined args\", this.token.type, this.token.pos); // should not occur\n                  }\n                  this.advance(\"gosub\");\n                  if (this.options.keepTokens) {\n                      node.args.push(this.previousToken);\n                  }\n                  node.type = \"onSqGosub\";\n                  this.fnGetArgs(node.args, node.type);\n                  break;\n              default: // on <expr> goto|gosub\n                  node.args.push(this.expression(0));\n                  if (this.token.type === \"gosub\" || this.token.type === \"goto\") {\n                      this.advance();\n                      if (this.options.keepTokens) {\n                          node.args.push(this.previousToken); // modify\n                      }\n                      node.type = \"on\" + Utils.stringCapitalize(this.previousToken.type); // onGoto, onGosub\n                      this.fnGetArgs(node.args, node.type);\n                  }\n                  else {\n                      throw this.composeError(Error(), \"Expected GOTO or GOSUB\", this.token.type, this.token.pos);\n                  }\n                  break;\n          }\n          return node;\n      }\n      print(node) {\n          const closeTokens = BasicParser.closeTokensForArgs, stream = this.fnGetOptionalStream();\n          node.args = [stream];\n          if (stream.len !== 0) { // not an inserted stream?\n              if (!closeTokens[this.token.type]) {\n                  this.advance(\",\");\n                  if (this.options.keepTokens) {\n                      node.args.push(this.previousToken);\n                  }\n              }\n          }\n          while (!closeTokens[this.token.type]) {\n              let node2;\n              if (this.token.type === \"spc\" || this.token.type === \"tab\") {\n                  this.advance();\n                  node2 = this.fnCreateFuncCall(this.previousToken);\n              }\n              else if (this.token.type === \"using\") {\n                  node2 = this.token;\n                  node2.args = [];\n                  this.advance();\n                  node2.args.push(this.expression(0)); // format\n                  this.advance(\";\"); // after the format there must be a \";\"\n                  node2.args.push(this.previousToken); // semicolon\n                  node2.args = this.fnGetArgsSepByCommaSemi(node2.args);\n                  if (this.previousToken.type === \";\") { // using closed by \";\"?\n                      node2.args.pop(); // remove it from using\n                      node.args.push(node2);\n                      node2 = this.previousToken; // keep it for print\n                  }\n              }\n              else if (this.token.type === \";\" || this.token.type === \",\") { // separator \";\" or comma tab separator \",\"\n                  node2 = this.token;\n                  this.advance();\n              }\n              else {\n                  node2 = this.expression(0);\n              }\n              node.args.push(node2);\n          }\n          return node;\n      }\n      question(node) {\n          const node2 = this.print(node); // not really a new node\n          node2.type = \"print\";\n          return node2;\n      }\n      resume(node) {\n          const tokenType = this.token.type;\n          return tokenType === \"next\" ? this.fnCombineTwoTokens(node, tokenType) : this.fnCreateCmdCall(node); // \"resume next\" or \"resume\"\n      }\n      run(node) {\n          if (this.token.type === \"number\") {\n              node.args = this.fnGetArgs([], \"goto\"); // we get linenumber arg as for goto\n          }\n          else {\n              node = this.fnCreateCmdCall(node);\n          }\n          return node;\n      }\n      speed(node) {\n          const tokenType = this.token.type;\n          if (tokenType !== \"ink\" && tokenType !== \"key\" && tokenType !== \"write\") {\n              throw this.composeError(Error(), \"Expected INK, KEY or WRITE\", tokenType, this.token.pos);\n          }\n          return this.fnCombineTwoTokens(node, tokenType);\n      }\n      symbol(node) {\n          const tokenType = this.token.type;\n          return tokenType === \"after\" ? this.fnCombineTwoTokens(node, tokenType) : this.fnCreateCmdCall(node); // \"symbol after\" or \"symbol\"\n      }\n      window(node) {\n          const tokenType = this.token.type;\n          return tokenType === \"swap\" ? this.fnCombineTwoTokens(node, tokenType) : this.fnCreateCmdCall(node); // \"window swap\" or \"window\"\n      }\n      write(node) {\n          const closeTokens = BasicParser.closeTokensForArgs, stream = this.fnGetOptionalStream();\n          node.args = [stream];\n          if (stream.len !== 0) { // not an inserted stream?\n              if (!closeTokens[this.token.type]) {\n                  this.advance(\",\");\n                  if (this.options.keepTokens) {\n                      node.args.push(this.previousToken);\n                  }\n              }\n          }\n          const lengthBefore = node.args.length;\n          this.fnGetArgsSepByCommaSemi(node.args);\n          if ((this.previousToken.type === \",\" && node.args.length > lengthBefore) || this.previousToken.type === \";\") {\n              this.fnMaskedError(this.previousToken, \"Operand missing\");\n          }\n          return node;\n      }\n      // ---\n      fnClearSymbols() {\n          this.symbols = {};\n      }\n      static fnNode(node) {\n          return node;\n      }\n      createSymbol(id) {\n          if (!this.symbols[id]) { // some symbols are extended, e.g. symbols for both infix and prefix\n              this.symbols[id] = {}; // create symbol\n          }\n          return this.symbols[id];\n      }\n      createNudSymbol(id, nud) {\n          const symbol = this.createSymbol(id);\n          symbol.nud = nud;\n          return symbol;\n      }\n      fnInfixLed(left, rbp) {\n          const node = this.previousToken;\n          node.left = left;\n          node.right = this.expression(rbp);\n          return node;\n      }\n      createInfix(id, lbp, rbp) {\n          const symbol = this.createSymbol(id);\n          symbol.lbp = lbp;\n          symbol.led = (left) => this.fnInfixLed(left, rbp || lbp);\n      }\n      createInfixr(id, lbp) {\n          const symbol = this.createSymbol(id);\n          symbol.lbp = lbp;\n          symbol.led = (left) => this.fnInfixLed(left, lbp - 1);\n      }\n      fnPrefixNud(rbp) {\n          const node = this.previousToken;\n          node.right = this.expression(rbp);\n          return node;\n      }\n      createPrefix(id, rbp) {\n          this.createNudSymbol(id, () => this.fnPrefixNud(rbp));\n      }\n      createStatement(id, fn) {\n          const symbol = this.createSymbol(id);\n          symbol.std = () => fn.call(this, this.previousToken);\n          return symbol;\n      }\n      fnGenerateKeywordSymbols() {\n          for (const key in this.keywords) {\n              if (this.keywords.hasOwnProperty(key)) {\n                  const keywordType = this.keywords[key].charAt(0);\n                  if (keywordType === \"f\") {\n                      this.createNudSymbol(key, () => this.fnCreateFuncCall(this.previousToken));\n                  }\n                  else if (keywordType === \"c\") {\n                      this.createStatement(key, this.specialStatements[key] || this.fnCreateCmdCall);\n                  }\n                  else if (keywordType === \"p\") { // additional parts of command\n                      this.createSymbol(key);\n                  }\n              }\n          }\n      }\n      fnGenerateSymbols() {\n          this.fnGenerateKeywordSymbols();\n          // special statements ...\n          this.createStatement(\"|\", this.specialStatements[\"|\"]); // rsx\n          this.createStatement(\"mid$\", this.specialStatements.mid$); // mid$Assign (statement), combine with function\n          this.createStatement(\"?\", this.specialStatements[\"?\"]); // \"?\" is same as print\n          this.createSymbol(\":\");\n          this.createSymbol(\";\");\n          this.createSymbol(\",\");\n          this.createSymbol(\")\");\n          this.createSymbol(\"[\");\n          this.createSymbol(\"]\");\n          this.createSymbol(\"(eol)\");\n          this.createSymbol(\"(end)\");\n          this.createNudSymbol(\"number\", BasicParser.fnNode);\n          this.createNudSymbol(\"binnumber\", BasicParser.fnNode);\n          this.createNudSymbol(\"expnumber\", BasicParser.fnNode);\n          this.createNudSymbol(\"hexnumber\", BasicParser.fnNode);\n          this.createNudSymbol(\"linenumber\", BasicParser.fnNode);\n          this.createNudSymbol(\"string\", BasicParser.fnNode);\n          this.createNudSymbol(\"ustring\", BasicParser.fnNode);\n          this.createNudSymbol(\"unquoted\", BasicParser.fnNode);\n          this.createNudSymbol(\"ws\", BasicParser.fnNode); // optional whitespace\n          this.createNudSymbol(\"identifier\", () => this.fnIdentifier(this.previousToken));\n          this.createNudSymbol(\"(\", () => this.fnParenthesis(this.previousToken));\n          this.createNudSymbol(\"fn\", () => this.fnFn(this.previousToken)); // separate fn\n          this.createPrefix(\"@\", 95); // address of\n          this.createInfix(\"^\", 90, 80);\n          this.createPrefix(\"+\", 80); // + can be uses as prefix or infix\n          this.createPrefix(\"-\", 80); // - can be uses as prefix or infix\n          this.createInfix(\"*\", 70);\n          this.createInfix(\"/\", 70);\n          this.createInfix(\"\\\\\", 60); // integer division\n          this.createInfix(\"mod\", 50);\n          this.createInfix(\"+\", 40); // + can be uses as prefix or infix, so combine with prefix function\n          this.createInfix(\"-\", 40); // - can be uses as prefix or infix, so combine with prefix function\n          this.createInfix(\"=\", 30); // equal for comparison, left associative\n          this.createInfix(\"<>\", 30);\n          this.createInfix(\"<\", 30);\n          this.createInfix(\"<=\", 30);\n          this.createInfix(\">\", 30);\n          this.createInfix(\">=\", 30);\n          this.createPrefix(\"not\", 23);\n          this.createInfixr(\"and\", 22);\n          this.createInfixr(\"or\", 21);\n          this.createInfixr(\"xor\", 20);\n          this.createPrefix(\"#\", 10); // priority ok?\n      }\n      // http://crockford.com/javascript/tdop/tdop.html (old: http://javascript.crockford.com/tdop/tdop.html)\n      // http://crockford.com/javascript/tdop/parse.js\n      // Operator precedence parsing\n      //\n      // Operator: With left binding power (lbp) and operational function.\n      // Manipulates tokens to its left (e.g: +)? => left denotative function led(), otherwise null denotative function nud()), (e.g. unary -)\n      // identifiers, numbers: also nud.\n      parse(tokens) {\n          this.tokens = tokens;\n          // line\n          this.label = \"0\"; // for error messages\n          this.index = 0;\n          this.token = {};\n          this.previousToken = this.token; // just to avoid warning\n          const parseTree = this.parseTree;\n          parseTree.length = 0;\n          this.advance();\n          while (this.token.type !== \"(end)\") {\n              parseTree.push(this.basicLine());\n          }\n          return parseTree;\n      }\n  }\n\n  // ===== dist/esm/BasicTokenizer.js =====\n  // BasicTokenizer.ts - Tokenize BASIC programs\n  // (c) Marco Vieth, 2020\n  // https://benchmarko.github.io/cpclocots/\n  //\n  // decode based on lbas2ascii.pl, 28.06.2006\n  // http://cpctech.cpc-live.com/docs/bastech.html\n  // https://www.cpcwiki.eu/index.php/Technical_information_about_Locomotive_BASIC#BASIC_tokens\n  //\n\n  class BasicTokenizer {\n      pos = 0;\n      line = 0;\n      // will also be set in decode\n      lineEnd = 0;\n      input = \"\";\n      needSpace = false; // hmm\n      debug = {\n          startPos: 0,\n          line: 0,\n          info: \"\"\n      };\n      fnNum8Dec() {\n          const num = this.input.charCodeAt(this.pos);\n          this.pos += 1;\n          return num;\n      }\n      fnNum16Dec() {\n          return this.fnNum8Dec() + this.fnNum8Dec() * 256;\n      }\n      fnNum32Dec() {\n          return this.fnNum16Dec() + this.fnNum16Dec() * 65536;\n      }\n      fnNum8DecAsStr() {\n          return String(this.fnNum8Dec());\n      }\n      fnNum16DecAsStr() {\n          return String(this.fnNum16Dec());\n      }\n      // line number pointer (can occur when loading snapshots)\n      fnNum16LineAddrAsStr() {\n          const prgStart = 0x170, // assuming this as program start\n          lineAddr = this.fnNum16Dec() - prgStart, // address of (byte 0 before line)\n          addr = lineAddr + 3, // address of line number\n          line = this.input.charCodeAt(addr) + this.input.charCodeAt(addr + 1) * 256;\n          return String(line);\n      }\n      fnNum16Bin() {\n          return \"&X\" + this.fnNum16Dec().toString(2);\n      }\n      fnNum16Hex() {\n          return \"&\" + this.fnNum16Dec().toString(16).toUpperCase();\n      }\n      // floating point numbers (little endian byte order)\n      // byte 0: mantissa (bits 7-0)\n      // byte 1: mantissa (bits 15-8)\n      // byte 2: mantissa (bits 23-16)\n      // byte 3: sign, mantissa (bits 30-24)\n      // byte 4: exponent\n      //\n      //\n      // examples:\n      // 0xa2,0xda,0x0f,0x49,0x82 (PI)\n      // 0x00,0x00,0x00,0x00,0x81 (1)\n      //\n      // 0x00,0x00,0x00,0x00,0x84      ; 10 (10^1)\n      // 0x00,0x00,0x00,0x48,0x87      ; 100 (10^2)\n      // 0x00,0x00,0x00,0x7A,0x8A      ; 1000 (10^3)\n      // 0x00,0x00,0x40,0x1c,0x8e      ; 10000 (10^4) (1E+4)\n      // 0x00,0x00,0x50,0x43,0x91      ; 100000 (10^5) (1E+5)\n      // 0x00,0x00,0x24,0x74,0x94      ; 1000000 (10^6) (1E+6)\n      // 0x00,0x80,0x96,0x18,0x98      ; 10000000 (10^7) (1E+7)\n      // 0x00,0x20,0xbc,0x3e,0x9b      ; 100000000 (10^8) (1E+8)\n      // 0x00,0x28,0x6b,0x6e,0x9e      ; 1000000000 (10^9) (1E+9)\n      // 0x00,0xf9,0x02,0x15,0xa2      ; 10000000000 (10^10) (1E+10)\n      // 0x40,0xb7,0x43,0x3a,0xa5      ; 100000000000 (10^11) (1E+11)\n      // 0x10,0xa5,0xd4,0x68,0xa8      ; 1000000000000 (10^12) (1E+12)\n      // 0x2a,0xe7,0x84,0x11,0xac      ; 10000000000000 (10^13) (1E+13)\n      // Check also: https://mfukar.github.io/2015/10/29/amstrad-fp.html\n      // Example PI: b=[0xa2,0xda,0x0f,0x49,0x82]; e=b[4]-128; m=(b[3] >= 128 ? -1 : +1) * (0x80000000 + ((b[3] & 0x7f) <<24) + (b[2] << 16) + (b[1] <<8) + b[0]); z=m*Math.pow(2,e-32);console.log(m,e,z)\n      fnNumFp() {\n          const value = this.fnNum32Dec(); // signed integer\n          let exponent = this.fnNum8Dec(), out;\n          if (!exponent) { // exponent zero? => 0\n              out = \"0\";\n          }\n          else { // beware: JavaScript has no unsigned int except for \">>> 0\"\n              const mantissa = value >= 0 ? value + 0x80000000 : value;\n              exponent -= 0x81; // 2-complement: 2^-127 .. 2^128\n              const num = mantissa * Math.pow(2, exponent - 31);\n              out = Utils.toPrecision9(num);\n          }\n          return out;\n      }\n      fnGetBit7TerminatedString() {\n          const data = this.input;\n          let pos = this.pos;\n          while (data.charCodeAt(pos) <= 0x7f && pos < this.lineEnd) { // last character b7=1 (>= 0x80)\n              pos += 1;\n          }\n          const out = data.substring(this.pos, pos) + String.fromCharCode(data.charCodeAt(pos) & 0x7f); // eslint-disable-line no-bitwise\n          if (pos < this.lineEnd) { // maybe corrupted if used in DATA line\n              this.pos = pos + 1;\n          }\n          return out;\n      }\n      fnVar() {\n          this.fnNum16Dec(); // ignore offset (offset to memory location of variable)\n          return this.fnGetBit7TerminatedString();\n      }\n      fnIntVar() {\n          return this.fnVar() + \"%\";\n      }\n      fnStringVar() {\n          return this.fnVar() + \"$\";\n      }\n      fnFpVar() {\n          return this.fnVar() + \"!\";\n      }\n      fnRsx() {\n          let name = this.fnGetBit7TerminatedString();\n          name = name.substring(1); // ignore length (offset to tokens following RSX name)\n          return \"|\" + name;\n      }\n      static fnControlsToUnicode(s) {\n          return s.replace(/[\\x00-\\x1F\\x80-\\x9F]/g, function (ch) {\n              return String.fromCharCode(ch.charCodeAt(0) + 0x100);\n          });\n      }\n      fnStringUntilEol() {\n          const out = BasicTokenizer.fnControlsToUnicode(this.input.substring(this.pos, this.lineEnd - 1)); // take remaining line\n          this.pos = this.lineEnd;\n          return out;\n      }\n      fnApostrophe() {\n          return \"'\" + this.fnStringUntilEol();\n      }\n      fnRem() {\n          return \"REM\" + this.fnStringUntilEol();\n      }\n      fnQuotedString() {\n          const closingQuotes = this.input.indexOf('\"', this.pos);\n          let out = \"\";\n          if (closingQuotes < 0 || closingQuotes >= this.lineEnd) { // unclosed quoted string (quotes not found or not in this line)\n              out = BasicTokenizer.fnControlsToUnicode(this.fnStringUntilEol()); // take remaining line\n          }\n          else {\n              out = BasicTokenizer.fnControlsToUnicode(this.input.substring(this.pos, closingQuotes + 1));\n              this.pos = closingQuotes + 1; // after quotes\n          }\n          out = '\"' + out;\n          //TODO: is this still needed?\n          if (out.indexOf(\"\\r\") >= 0) {\n              Utils.console.log(\"BasicTokenizer line\", this.line, \": string contains CR, replaced by CHR$(13)\");\n              out = out.replace(/\\r/g, '\"+chr$(13)+\"');\n          }\n          if ((/\\n\\d/).test(out)) {\n              Utils.console.log(\"BasicTokenizer line\", this.line, \": string contains LF<digit>, replaced by CHR$(10)<digit>\");\n              out = out.replace(/\\n(\\d)/g, '\"+chr$(10)+\"$1');\n          }\n          return out;\n      }\n      // on sq?\n      /* eslint-disable no-invalid-this */\n      tokens = {\n          0x00: \"\", // marker for \"end of tokenised line\"\n          0x01: \":\", // \":\" statement seperator\n          0x02: this.fnIntVar, // integer variable definition (defined with \"%\" suffix)\n          0x03: this.fnStringVar, // string variable definition (defined with \"$\" suffix)\n          0x04: this.fnFpVar, // floating point variable definition (defined with \"!\" suffix)\n          0x05: \"var?\",\n          0x06: \"var?\",\n          0x07: \"var?\", // ??\n          0x08: \"var?\", // ??\n          0x09: \"var?\", // ??\n          0x0a: \"var?\", // ??\n          0x0b: this.fnVar, // integer variable definition (no suffix)\n          0x0c: this.fnVar, // string variable definition (no suffix)\n          0x0d: this.fnVar, // floating point or no type (no suffix)\n          0x0e: \"0\", // number constant \"0\"\n          0x0f: \"1\", // number constant \"1\"\n          0x10: \"2\", // number constant \"2\"\n          0x11: \"3\", // number constant \"3\"\n          0x12: \"4\", // number constant \"4\"\n          0x13: \"5\", // number constant \"5\"\n          0x14: \"6\", // number constant \"6\"\n          0x15: \"7\", // number constant \"7\"\n          0x16: \"8\", // number constant \"8\"\n          0x17: \"9\", // number constant \"9\"\n          0x18: \"10\", // number constant \"10\"\n          0x19: this.fnNum8DecAsStr, // 8-bit integer decimal value\n          0x1a: this.fnNum16DecAsStr, // 16-bit integer decimal value\n          0x1b: this.fnNum16Bin, // 16-bit integer binary value (with \"&X\" prefix)\n          0x1c: this.fnNum16Hex, // num16Hex: 16-bit integer hexadecimal value (with \"&H\" or \"&\" prefix)\n          0x1d: this.fnNum16LineAddrAsStr, // 16-bit BASIC program line memory address pointer\n          0x1e: this.fnNum16DecAsStr, // 16-bit integer BASIC line number\n          0x1f: this.fnNumFp, // floating point value\n          // 0x20-0x21 ASCII printable symbols\n          0x22: this.fnQuotedString, // '\"' quoted string value\n          // 0x23-0x7b ASCII printable symbols\n          0x7c: this.fnRsx, // \"|\" symbol; prefix for RSX commands\n          0x80: \"AFTER\",\n          0x81: \"AUTO\",\n          0x82: \"BORDER\",\n          0x83: \"CALL\",\n          0x84: \"CAT\",\n          0x85: \"CHAIN\",\n          0x86: \"CLEAR\",\n          0x87: \"CLG\",\n          0x88: \"CLOSEIN\",\n          0x89: \"CLOSEOUT\",\n          0x8a: \"CLS\",\n          0x8b: \"CONT\",\n          0x8c: \"DATA\",\n          0x8d: \"DEF\",\n          0x8e: \"DEFINT\",\n          0x8f: \"DEFREAL\",\n          0x90: \"DEFSTR\",\n          0x91: \"DEG\",\n          0x92: \"DELETE\",\n          0x93: \"DIM\",\n          0x94: \"DRAW\",\n          0x95: \"DRAWR\",\n          0x96: \"EDIT\",\n          0x97: \"ELSE\", // always with 0x01 0x97\n          0x98: \"END\",\n          0x99: \"ENT\",\n          0x9a: \"ENV\",\n          0x9b: \"ERASE\",\n          0x9c: \"ERROR\",\n          0x9d: \"EVERY\",\n          0x9e: \"FOR\",\n          0x9f: \"GOSUB\",\n          0xa0: \"GOTO\",\n          0xa1: \"IF\",\n          0xa2: \"INK\",\n          0xa3: \"INPUT\",\n          0xa4: \"KEY\",\n          0xa5: \"LET\",\n          0xa6: \"LINE\",\n          0xa7: \"LIST\",\n          0xa8: \"LOAD\",\n          0xa9: \"LOCATE\",\n          0xaa: \"MEMORY\",\n          0xab: \"MERGE\",\n          0xac: \"MID$\",\n          0xad: \"MODE\",\n          0xae: \"MOVE\",\n          0xaf: \"MOVER\",\n          0xb0: \"NEXT\",\n          0xb1: \"NEW\",\n          0xb2: \"ON\",\n          0xb3: \"ON BREAK\",\n          0xb4: \"ON ERROR GOTO 0\", // (on error goto n > 0 is decoded with separate tokens)\n          0xb5: \"ON SQ\",\n          0xb6: \"OPENIN\",\n          0xb7: \"OPENOUT\",\n          0xb8: \"ORIGIN\",\n          0xb9: \"OUT\",\n          0xba: \"PAPER\",\n          0xbb: \"PEN\",\n          0xbc: \"PLOT\",\n          0xbd: \"PLOTR\",\n          0xbe: \"POKE\",\n          0xbf: \"PRINT\",\n          0xc0: this.fnApostrophe, // \"'\" symbol (same function as REM keyword); always with 0x01 0xC0\n          0xc1: \"RAD\",\n          0xc2: \"RANDOMIZE\",\n          0xc3: \"READ\",\n          0xc4: \"RELEASE\",\n          0xc5: this.fnRem, // REM\n          0xc6: \"RENUM\",\n          0xc7: \"RESTORE\",\n          0xc8: \"RESUME\",\n          0xc9: \"RETURN\",\n          0xca: \"RUN\",\n          0xcb: \"SAVE\",\n          0xcc: \"SOUND\",\n          0xcd: \"SPEED\",\n          0xce: \"STOP\",\n          0xcf: \"SYMBOL\",\n          0xd0: \"TAG\",\n          0xd1: \"TAGOFF\",\n          0xd2: \"TROFF\",\n          0xd3: \"TRON\",\n          0xd4: \"WAIT\",\n          0xd5: \"WEND\",\n          0xd6: \"WHILE\",\n          0xd7: \"WIDTH\",\n          0xd8: \"WINDOW\",\n          0xd9: \"WRITE\",\n          0xda: \"ZONE\",\n          0xdb: \"DI\",\n          0xdc: \"EI\",\n          0xdd: \"FILL\", // (v1.1)\n          0xde: \"GRAPHICS\", // (v1.1)\n          0xdf: \"MASK\", // (v1.1)\n          0xe0: \"FRAME\", // (v1.1)\n          0xe1: \"CURSOR\", // (v1.1)\n          0xe2: \"<unused>\",\n          0xe3: \"ERL\",\n          0xe4: \"FN\",\n          0xe5: \"SPC\",\n          0xe6: \"STEP\",\n          0xe7: \"SWAP\",\n          0xe8: \"<unused>\",\n          0xe9: \"<unused>\",\n          0xea: \"TAB\",\n          0xeb: \"THEN\",\n          0xec: \"TO\",\n          0xed: \"USING\",\n          0xee: \">\", // (greater than)\n          0xef: \"=\", // (equal)\n          0xf0: \">=\", // (greater or equal)\n          0xf1: \"<\", // (less than)\n          0xf2: \"<>\", // (not equal)\n          0xf3: \"<=\", // =<, <=, < = (less than or equal)\n          0xf4: \"+\", // (addition)\n          0xf5: \"-\", // (subtraction or unary minus)\n          0xf6: \"*\", // (multiplication)\n          0xf7: \"/\", // (division)\n          0xf8: \"^\", // (x to the power of y)\n          0xf9: \"\\\\\", // (integer division)\n          0xfa: \"AND\",\n          0xfb: \"MOD\",\n          0xfc: \"OR\",\n          0xfd: \"XOR\",\n          0xfe: \"NOT\"\n          // 0xff: (prefix for additional keywords)\n      };\n      /* eslint-enable no-invalid-this */\n      tokensFF = {\n          // Functions with one argument\n          0x00: \"ABS\",\n          0x01: \"ASC\",\n          0x02: \"ATN\",\n          0x03: \"CHR$\",\n          0x04: \"CINT\",\n          0x05: \"COS\",\n          0x06: \"CREAL\",\n          0x07: \"EXP\",\n          0x08: \"FIX\",\n          0x09: \"FRE\",\n          0x0a: \"INKEY\",\n          0x0b: \"INP\",\n          0x0c: \"INT\",\n          0x0d: \"JOY\",\n          0x0e: \"LEN\",\n          0x0f: \"LOG\",\n          0x10: \"LOG10\",\n          0x11: \"LOWER$\",\n          0x12: \"PEEK\",\n          0x13: \"REMAIN\",\n          0x14: \"SGN\",\n          0x15: \"SIN\",\n          0x16: \"SPACE$\",\n          0x17: \"SQ\",\n          0x18: \"SQR\",\n          0x19: \"STR$\",\n          0x1a: \"TAN\",\n          0x1b: \"UNT\",\n          0x1c: \"UPPER$\",\n          0x1d: \"VAL\",\n          // Functions without arguments\n          0x40: \"EOF\",\n          0x41: \"ERR\",\n          0x42: \"HIMEM\",\n          0x43: \"INKEY$\",\n          0x44: \"PI\",\n          0x45: \"RND\",\n          0x46: \"TIME\",\n          0x47: \"XPOS\",\n          0x48: \"YPOS\",\n          0x49: \"DERR\", // (v1.1)\n          // Functions with more arguments\n          0x71: \"BIN$\",\n          0x72: \"DEC$\", // (v1.1)\n          0x73: \"HEX$\",\n          0x74: \"INSTR\",\n          0x75: \"LEFT$\",\n          0x76: \"MAX\",\n          0x77: \"MIN\",\n          0x78: \"POS\",\n          0x79: \"RIGHT$\",\n          0x7a: \"ROUND\",\n          0x7b: \"STRING$\",\n          0x7c: \"TEST\",\n          0x7d: \"TESTR\",\n          0x7e: \"COPYCHR$\", // (v1.1)\n          0x7f: \"VPOS\"\n      };\n      debugPrintInfo() {\n          const debug = this.debug;\n          Utils.console.debug(\"BasicTokenizer Details:\\n\", debug.info);\n          debug.line = 0;\n          debug.info = \"\";\n      }\n      debugCollectInfo(tokenLine) {\n          const debug = this.debug, hex = this.input.substring(debug.startPos, this.pos).split(\"\").map(function (s) {\n              return s.charCodeAt(0).toString(16).toUpperCase().padStart(2, \"0\");\n          }).join(\",\");\n          if (this.line !== debug.line) {\n              if (debug.info) {\n                  debug.info += \"\\n\";\n              }\n              debug.line = this.line;\n              debug.info += debug.line + \": \";\n          }\n          debug.info += \" [\" + hex + \"] \" + tokenLine;\n      }\n      fnParseNextToken(input) {\n          const oldNeedSpace = this.needSpace;\n          let token = this.fnNum8Dec();\n          if (token === 0x01) { // statement seperator \":\"?\n              if (this.pos < input.length) {\n                  const nextToken = input.charCodeAt(this.pos); // test next token\n                  if (nextToken === 0x97 || nextToken === 0xc0) { // ELSE or rem '?\n                      token = nextToken; // ignore ':'\n                      this.pos += 1;\n                  }\n              }\n          }\n          this.needSpace = ((token >= 0x05 && token <= 0x0d) || (token === 0x7c)); // variable without suffix, or RSX?\n          let tokenValue;\n          if (token === 0xff) { // extended token?\n              token = this.fnNum8Dec(); // get it\n              tokenValue = this.tokensFF[token];\n          }\n          else {\n              tokenValue = this.tokens[token];\n          }\n          let tstr;\n          if (tokenValue !== undefined) {\n              tstr = typeof tokenValue === \"function\" ? tokenValue.call(this) : tokenValue;\n              //if ((/[a-zA-Z0-9.]$/).test(tstr) && token !== 0xe4) { // last character char, number, dot? (not for token \"FN\")\n              if ((/[a-zA-Z.]$/).test(tstr) && token !== 0xe4) { // last character char, dot? (not for token \"FN\")\n                  this.needSpace = true; // maybe need space next time...\n              }\n          }\n          else { // normal ASCII\n              tstr = String.fromCharCode(token);\n          }\n          if (oldNeedSpace) {\n              //if ((/^[a-zA-Z0-9$%!]/).test(tstr) || (token >= 0x02 && token <= 0x1f)) {\n              if ((/^[a-zA-Z$%!]/).test(tstr) || (token >= 0x02 && token <= 0x1f)) {\n                  tstr = \" \" + tstr;\n              }\n          }\n          if (Utils.debug > 2) {\n              this.debugCollectInfo(tstr);\n          }\n          return tstr;\n      }\n      fnParseLineFragment() {\n          const input = this.input;\n          let out = \"\";\n          this.needSpace = false; // only needed in fnParseNextToken\n          while (this.pos < this.lineEnd) {\n              this.debug.startPos = this.pos;\n              const tstr = this.fnParseNextToken(input);\n              out += tstr;\n          }\n          return out;\n      }\n      fnParseNextLine() {\n          const lineLength = this.fnNum16Dec();\n          if (!lineLength) {\n              return undefined; // nothing more\n          }\n          this.line = this.fnNum16Dec();\n          this.lineEnd = this.pos - 4 + lineLength;\n          if (this.lineEnd > this.input.length) {\n              this.lineEnd = this.input.length;\n              Utils.console.warn(\"fnParseNextLine: pos=\" + this.pos + \": EOF met!\");\n          }\n          return this.line + \" \" + this.fnParseLineFragment();\n      }\n      fnParseProgram() {\n          let out = \"\", line;\n          while ((line = this.fnParseNextLine()) !== undefined) {\n              out += line + \"\\n\";\n              // CPC uses \"\\r\\n\" line breaks, JavaScript uses \"\\n\", textArea cannot contain \"\\r\"\n          }\n          return out;\n      }\n      decodeLineFragment(program, offset, length) {\n          this.input = program;\n          this.pos = offset;\n          this.line = 0;\n          this.lineEnd = this.pos + length;\n          const out = this.fnParseLineFragment();\n          if (Utils.debug > 2) {\n              this.debugPrintInfo();\n          }\n          return out;\n      }\n      decode(program) {\n          this.input = program;\n          this.pos = 0;\n          this.line = 0;\n          const out = this.fnParseProgram();\n          if (Utils.debug > 2) {\n              this.debugPrintInfo();\n          }\n          return out;\n      }\n  }\n\n  // ===== dist/esm/View.js =====\n  // View.ts - View Module to access HTML DOM\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n  class View {\n      static getElementById1(id) {\n          const element = window.document.getElementById(id);\n          if (!element) {\n              throw new Error(\"Unknown \" + id);\n          }\n          return element;\n      }\n      static getElementByIdAs(id) {\n          return View.getElementById1(id);\n      }\n      getHidden(id) {\n          const element = View.getElementById1(id);\n          return element.className.indexOf(\"displayNone\") >= 0;\n      }\n      setHidden(id, hidden, display) {\n          // optional display: block or flex or inherit\n          const element = View.getElementById1(id), displayVisible = \"display\" + Utils.stringCapitalize(display || \"block\");\n          if (hidden) {\n              if (element.className.indexOf(\"displayNone\") < 0) {\n                  this.toggleClass(id, \"displayNone\");\n              }\n              if (element.className.indexOf(displayVisible) >= 0) {\n                  this.toggleClass(id, displayVisible);\n              }\n          }\n          else {\n              if (element.className.indexOf(\"displayNone\") >= 0) {\n                  this.toggleClass(id, \"displayNone\");\n              }\n              if (element.className.indexOf(displayVisible) < 0) {\n                  this.toggleClass(id, displayVisible);\n              }\n          }\n          return this;\n      }\n      setDisabled(id, disabled) {\n          const element = View.getElementByIdAs(id);\n          element.disabled = disabled;\n          return this;\n      }\n      toggleClass(id, className) {\n          const element = View.getElementById1(id);\n          let classes = element.className;\n          const nameIndex = classes.indexOf(className);\n          if (nameIndex === -1) {\n              classes = classes.trim() + \" \" + className;\n          }\n          else {\n              classes = classes.substring(0, nameIndex) + classes.substring(nameIndex + className.length + 1).trim();\n          }\n          element.className = classes;\n      }\n      getAreaValue(id) {\n          const element = View.getElementByIdAs(id);\n          return element.value;\n      }\n      setAreaValue(id, value) {\n          const element = View.getElementByIdAs(id);\n          element.value = value;\n          return this;\n      }\n      getInputValue(id) {\n          const element = View.getElementByIdAs(id);\n          return element.value;\n      }\n      setInputValue(id, value) {\n          const element = View.getElementByIdAs(id);\n          element.value = value;\n          return this;\n      }\n      getInputChecked(id) {\n          const element = View.getElementByIdAs(id);\n          return element.checked;\n      }\n      setInputChecked(id, checked) {\n          const element = View.getElementByIdAs(id);\n          element.checked = checked;\n          return this;\n      }\n      setAreaInputList(id, inputs) {\n          const element = View.getElementByIdAs(id), childNodes = element.childNodes;\n          while (childNodes.length && childNodes[0].nodeType !== Node.ELEMENT_NODE) { // remove all non-element nodes\n              element.removeChild(element.firstChild);\n          }\n          for (let i = 0; i < inputs.length; i += 1) {\n              const item = inputs[i];\n              let input, label;\n              if (i * 2 >= childNodes.length) {\n                  input = window.document.createElement(\"input\");\n                  input.type = \"radio\";\n                  input.id = \"galleryItem\" + i;\n                  input.name = \"gallery\";\n                  input.value = item.value;\n                  input.checked = item.checked;\n                  label = window.document.createElement(\"label\");\n                  label.setAttribute(\"for\", \"galleryItem\" + i);\n                  label.setAttribute(\"style\", 'background: url(\"' + item.imgUrl + '\"); background-size: cover');\n                  label.setAttribute(\"title\", item.title);\n                  element.appendChild(input);\n                  element.appendChild(label);\n              }\n              else {\n                  input = childNodes[i * 2];\n                  if (input.value !== item.value) {\n                      if (Utils.debug > 3) {\n                          Utils.console.debug(\"setInputList: \" + id + \": value changed for index \" + i + \": \" + item.value);\n                      }\n                      input.value = item.value;\n                      label = childNodes[i * 2 + 1];\n                      label.setAttribute(\"style\", 'background: url(\"' + item.imgUrl + '\");');\n                      label.setAttribute(\"title\", item.title);\n                  }\n                  if (input.checked !== item.checked) {\n                      input.checked = item.checked;\n                  }\n              }\n          }\n          // remove additional items\n          while (element.childElementCount > inputs.length * 2) {\n              element.removeChild(element.lastChild);\n          }\n          return this;\n      }\n      setSelectOptions(id, options) {\n          const element = View.getElementByIdAs(id), optionList = [], existingElements = element.length;\n          // pre-create additional options\n          for (let i = existingElements; i < options.length; i += 1) {\n              const item = options[i], option = window.document.createElement(\"option\");\n              option.value = item.value;\n              option.text = item.text;\n              option.title = item.title;\n              option.selected = item.selected; // multi-select\n              optionList.push(option);\n          }\n          for (let i = 0; i < options.length; i += 1) {\n              if (i >= existingElements) {\n                  element.add(optionList[i - existingElements], null); // null needed for old FF 3.x\n              }\n              else {\n                  const item = options[i], option = element.options[i];\n                  if (option.value !== item.value) {\n                      option.value = item.value;\n                  }\n                  if (option.text !== item.text) {\n                      if (Utils.debug > 3) {\n                          Utils.console.debug(\"setSelectOptions: \" + id + \": text changed for index \" + i + \": \" + item.text);\n                      }\n                      option.text = item.text;\n                      option.title = item.title;\n                  }\n                  option.selected = item.selected; // multi-select\n              }\n          }\n          // remove additional select options\n          element.options.length = options.length;\n          return this;\n      }\n      getSelectOptions(id) {\n          const element = View.getElementByIdAs(id), elementOptions = element.options, options = [];\n          for (let i = 0; i < elementOptions.length; i += 1) {\n              const elementOption = elementOptions[i];\n              options.push({\n                  value: elementOption.value,\n                  text: elementOption.text,\n                  title: elementOption.title,\n                  selected: elementOption.selected\n              });\n          }\n          return options;\n      }\n      getSelectValue(id) {\n          const element = View.getElementByIdAs(id);\n          return element.value;\n      }\n      setSelectValue(id, value) {\n          const element = View.getElementByIdAs(id);\n          if (value) {\n              element.value = value;\n          }\n          return this;\n      }\n      setSelectTitleFromSelectedOption(id) {\n          const element = View.getElementByIdAs(id), selectedIndex = element.selectedIndex, title = (selectedIndex >= 0) ? element.options[selectedIndex].title : \"\";\n          element.title = title;\n          return this;\n      }\n      setAreaScrollTop(id, scrollTop) {\n          const element = View.getElementByIdAs(id);\n          if (scrollTop === undefined) {\n              scrollTop = element.scrollHeight;\n          }\n          element.scrollTop = scrollTop;\n          return this;\n      }\n      setSelectionRange(textarea, selectionStart, selectionEnd) {\n          // First scroll selection region to view\n          const fullText = textarea.value;\n          textarea.value = fullText.substring(0, selectionEnd);\n          // For some unknown reason, you must store the scollHeight to a variable before setting the textarea value. Otherwise it won't work for long strings\n          const scrollHeight = textarea.scrollHeight;\n          textarea.value = fullText;\n          const textareaHeight = textarea.clientHeight;\n          let scrollTop = scrollHeight;\n          if (scrollTop > textareaHeight) {\n              // scroll selection to center of textarea\n              scrollTop -= textareaHeight / 2;\n          }\n          else {\n              scrollTop = 0;\n          }\n          textarea.scrollTop = scrollTop;\n          // Continue to set selection range\n          textarea.setSelectionRange(selectionStart, selectionEnd);\n          return this;\n      }\n      setAreaSelection(id, pos, endPos) {\n          const element = View.getElementByIdAs(id);\n          if (element.selectionStart !== undefined) {\n              if (element.setSelectionRange !== undefined) {\n                  element.focus(); // not needed for scrolling but we want to see the selected text\n                  this.setSelectionRange(element, pos, endPos);\n              }\n              else {\n                  element.focus();\n                  element.selectionStart = pos;\n                  element.selectionEnd = endPos;\n              }\n          }\n          return this;\n      }\n      addEventListener(type, eventListener, element) {\n          if (element) {\n              element.addEventListener(type, eventListener, false);\n          }\n          else {\n              window.document.addEventListener(type, eventListener, false);\n          }\n          return this;\n      }\n      addEventListenerById(type, eventListener, id) {\n          if (Utils.debug) {\n              Utils.console.debug(\"addEventListenerById: type=\" + type + \", id=\" + id);\n          }\n          const element = id === \"window\" /* ViewID.window */ ? undefined : View.getElementById1(id);\n          this.addEventListener(type, eventListener, element);\n          return this;\n      }\n      removeEventListener(type, eventListener, element) {\n          if (element) {\n              element.removeEventListener(type, eventListener, false);\n          }\n          else {\n              window.document.removeEventListener(type, eventListener, false);\n          }\n          return this;\n      }\n      removeEventListenerById(type, eventListener, id) {\n          if (Utils.debug) {\n              Utils.console.debug(\"removeEventListener: type=\" + type + \", id=\" + id);\n          }\n          const element = id === \"window\" /* ViewID.window */ ? undefined : View.getElementById1(id);\n          this.removeEventListener(type, eventListener, element);\n          return this;\n      }\n      static pointerEventNames = {\n          down: \"pointerdown\",\n          move: \"pointermove\",\n          up: \"pointerup\",\n          cancel: \"pointercancel\",\n          out: \"pointerout\",\n          type: \"pointer\"\n      };\n      static touchEventNames = {\n          down: \"touchstart\",\n          move: \"touchmove\",\n          up: \"touchend\",\n          cancel: \"touchcancel\",\n          out: \"\", // n.a.\n          type: \"touch\"\n      };\n      static mouseEventNames = {\n          down: \"mousedown\",\n          move: \"mousemove\",\n          up: \"mouseup\",\n          cancel: \"\", // n.a.\n          out: \"mouseout\",\n          type: \"mouse\"\n      };\n      static getPointerEventNames() {\n          let eventNames;\n          if (window.PointerEvent) {\n              eventNames = View.pointerEventNames;\n          }\n          else if (\"ontouchstart\" in window || navigator.maxTouchPoints) {\n              eventNames = View.touchEventNames;\n          }\n          else {\n              eventNames = View.mouseEventNames;\n          }\n          return eventNames;\n      }\n      fnAttachPointerEvents(id, fnDown, fnMove, fnUp) {\n          const element = id === \"window\" /* ViewID.window */ ? undefined : View.getElementById1(id), eventNames = View.getPointerEventNames();\n          if (fnDown) {\n              this.addEventListener(eventNames.down, fnDown, element);\n          }\n          if (fnMove) {\n              this.addEventListener(eventNames.move, fnMove, element);\n          }\n          if (fnUp) {\n              this.addEventListener(eventNames.up, fnUp, element);\n              if (eventNames.cancel) {\n                  this.addEventListener(eventNames.cancel, fnUp, element); // also fnUp handler\n              }\n          }\n          return eventNames;\n      }\n      fnDetachPointerEvents(id, fnDown, fnMove, fnUp) {\n          const element = id === \"window\" /* ViewID.window */ ? undefined : View.getElementById1(id), eventNames = View.getPointerEventNames();\n          if (fnDown) {\n              this.removeEventListener(eventNames.down, fnDown, element);\n          }\n          if (fnMove) {\n              this.removeEventListener(eventNames.move, fnMove, element);\n          }\n          if (fnUp) {\n              this.removeEventListener(eventNames.up, fnUp, element);\n              if (eventNames.cancel) {\n                  this.removeEventListener(eventNames.cancel, fnUp, element); // also fnUp handler\n              }\n          }\n          return eventNames;\n      }\n      static getEventTarget(event) {\n          const target = event.target || event.srcElement; // target, not currentTarget; srcElement for IE8\n          if (!target) {\n              Utils.console.error(\"getEventTarget: Undefined event target: \" + target);\n          }\n          return target;\n      }\n      requestFullscreenForId(id) {\n          const element = View.getElementById1(id), anyEl = element, that = this, requestMethod = element.requestFullscreen || anyEl.webkitRequestFullscreen || anyEl.mozRequestFullscreen || anyEl.msRequestFullscreen, fullscreenchangedHandler = function (event) {\n              const target = View.getEventTarget(event);\n              if (document.fullscreenElement) {\n                  if (Utils.debug > 0) {\n                      Utils.console.debug(\"Entered fullscreen mode: \" + document.fullscreenElement.id);\n                  }\n              }\n              else {\n                  if (Utils.debug > 0) {\n                      Utils.console.debug(\"Leaving fullscreen mode.\");\n                  }\n                  that.removeEventListener(\"fullscreenchange\", fullscreenchangedHandler, target);\n                  // for Safari we need to do some change to make sure the window size is set (can we do better?)\n                  that.setHidden(id, true);\n                  window.setTimeout(function () {\n                      that.setHidden(id, false);\n                  }, 0);\n              }\n          };\n          if (requestMethod) {\n              const promise = requestMethod.call(element); // can we ALLOW_KEYBOARD_INPUT?\n              if (promise) {\n                  promise.then(function () {\n                      if (Utils.debug > 0) {\n                          Utils.console.debug(\"requestFullscreenForId: \" + id + \": success\");\n                      }\n                      that.addEventListenerById(\"fullscreenchange\", fullscreenchangedHandler, id);\n                  }).catch(function (err) {\n                      Utils.console.error(\"requestFullscreenForId: \" + id + \": Error attempting to enable fullscreen mode: \", err);\n                  });\n              }\n          }\n          else if (typeof window.ActiveXObject !== \"undefined\") { // older IE\n              const wscript = new window.ActiveXObject(\"WScript.Shell\");\n              if (wscript !== null) {\n                  wscript.SendKeys(\"{F11}\"); // eslint-disable-line new-cap\n              }\n          }\n          else {\n              return false;\n          }\n          return true;\n      }\n      // https://blog.logrocket.com/programmatic-file-downloads-in-the-browser-9a5186298d5c/\n      fnDownloadBlob(data, filename) {\n          if (typeof Blob === \"undefined\") {\n              Utils.console.warn(\"fnDownloadBlob: Blob undefined\");\n              return;\n          }\n          const data8 = Utils.string2Uint8Array(data), type = \"octet/stream\", blob = new Blob([data8.buffer], {\n              type: type\n          });\n          if (window.navigator && window.navigator.msSaveOrOpenBlob) { // IE11 support\n              window.navigator.msSaveOrOpenBlob(blob, filename);\n              return;\n          }\n          const url = URL.createObjectURL(blob), a = document.createElement(\"a\"), clickHandler = function () {\n              setTimeout(function () {\n                  URL.revokeObjectURL(url);\n                  a.removeEventListener(\"click\", clickHandler);\n              }, 150);\n          };\n          a.href = url;\n          a.download = filename || \"download\";\n          this.addEventListener(\"click\", clickHandler, a);\n          a.click();\n      }\n  }\n\n  // ===== dist/esm/Canvas.js =====\n  // Canvas.ts - Graphics output to HTML canvas\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n  /* globals ArrayBuffer, Uint8Array, Uint32Array */\n\n\n  class Canvas {\n      options;\n      fnUpdateCanvasHandler;\n      fnUpdateCanvas2Handler;\n      fps = 15; // FPS for canvas update\n      isRunning = false;\n      animationTimeoutId;\n      animationFrame;\n      cpcAreaBox;\n      customCharset = {};\n      gColMode = 0; // 0=normal, 1=xor, 2=and, 3=or\n      mask = 255;\n      maskBit = 128;\n      maskFirst = 1;\n      offset = 0; // screen offset\n      canvas;\n      width;\n      height;\n      borderWidth = 4;\n      dataset8;\n      needUpdate = false;\n      colorValues = [];\n      currentInks = [];\n      speedInk = [];\n      inkSet = 0;\n      pen2ColorMap = [];\n      ctx;\n      imageData;\n      fnCopy2Canvas;\n      littleEndian = true;\n      pen2Color32;\n      data32;\n      use32BitCopy = true; // determined later\n      gPen = 0;\n      gPaper = 0;\n      speedInkCount = 0; // usually 10\n      hasFocus = false; // canvas has focus\n      mode = 0;\n      modeData = Canvas.modeData[0];\n      xPos = 0;\n      yPos = 0;\n      xOrig = 0;\n      yOrig = 0;\n      xLeft = 0;\n      xRight = 639;\n      yTop = 399;\n      yBottom = 0;\n      gTransparent = false;\n      constructor(options) {\n          this.fnUpdateCanvasHandler = this.updateCanvas.bind(this);\n          this.fnUpdateCanvas2Handler = this.updateCanvas2.bind(this);\n          this.options = {};\n          this.setOptions(options, true);\n          const canvas = View.getElementByIdAs(this.options.canvasID);\n          this.canvas = canvas;\n          this.cpcAreaBox = View.getElementById1(\"cpcArea\" /* ViewID.cpcArea */);\n          // make sure canvas is not hidden (allows to get width, height, set style)\n          if (canvas.offsetParent === null) {\n              Utils.console.error(\"Error: canvas is not visible!\");\n          }\n          const width = canvas.width, height = canvas.height;\n          this.width = width;\n          this.height = height;\n          this.dataset8 = new Uint8Array(new ArrayBuffer(width * height)); // array with pen values\n          this.animationTimeoutId = undefined;\n          this.animationFrame = undefined;\n          if (this.canvas.getContext) { // not available on e.g. IE8\n              this.ctx = this.canvas.getContext(\"2d\");\n              this.imageData = this.ctx.getImageData(0, 0, width, height);\n              if (typeof Uint32Array !== \"undefined\" && this.imageData.data.buffer) { // imageData.data.buffer not available on IE10\n                  this.littleEndian = Canvas.isLittleEndian();\n                  this.pen2Color32 = new Uint32Array(new ArrayBuffer(Canvas.modeData[3].pens * 4));\n                  this.data32 = new Uint32Array(this.imageData.data.buffer);\n                  this.use32BitCopy = true;\n                  Utils.console.log(\"Canvas: using optimized copy2Canvas32bit, littleEndian:\", this.littleEndian);\n              }\n              else {\n                  this.setAlpha(255);\n                  this.use32BitCopy = false;\n                  Utils.console.log(\"Canvas: using copy2Canvas8bit\");\n              }\n              this.fnCopy2Canvas = this.getCopy2CanvasFunction(this.offset);\n          }\n          else {\n              Utils.console.warn(\"Error: canvas.getContext is not supported.\");\n              // not available on e.g. IE8, nodeJS\n              this.fnCopy2Canvas = () => {\n                  // nothing\n              };\n              this.ctx = {}; // not available\n              this.imageData = {}; // not available\n          }\n          this.reset();\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options, force) {\n          const currentPalette = this.options.palette;\n          Object.assign(this.options, options);\n          if (force || (this.options.palette !== currentPalette)) { // changed?\n              this.applyPalette();\n          }\n      }\n      // http://www.cpcwiki.eu/index.php/CPC_Palette\n      // (green and gray palette will be computed if needed)\n      static palettes = {\n          color: [\n              \"#000000\", //  0 Black\n              \"#000080\", //  1 Blue\n              \"#0000FF\", //  2 Bright Blue\n              \"#800000\", //  3 Red\n              \"#800080\", //  4 Magenta\n              \"#8000FF\", //  5 Mauve\n              \"#FF0000\", //  6 Bright Red\n              \"#FF0080\", //  7 Purple\n              \"#FF00FF\", //  8 Bright Magenta\n              \"#008000\", //  9 Green\n              \"#008080\", // 10 Cyan\n              \"#0080FF\", // 11 Sky Blue\n              \"#808000\", // 12 Yellow\n              \"#808080\", // 13 White\n              \"#8080FF\", // 14 Pastel Blue\n              \"#FF8000\", // 15 Orange\n              \"#FF8080\", // 16 Pink\n              \"#FF80FF\", // 17 Pastel Magenta\n              \"#00FF00\", // 18 Bright Green\n              \"#00FF80\", // 19 Sea Green\n              \"#00FFFF\", // 20 Bright Cyan\n              \"#80FF00\", // 21 Lime\n              \"#80FF80\", // 22 Pastel Green\n              \"#80FFFF\", // 23 Pastel Cyan\n              \"#FFFF00\", // 24 Bright Yellow\n              \"#FFFF80\", // 25 Pastel Yellow\n              \"#FFFFFF\", // 26 Bright White\n              \"#808080\", // 27 White (same as 13)\n              \"#FF00FF\", // 28 Bright Magenta (same as 8)\n              \"#FFFF80\", // 29 Pastel Yellow (same as 25)\n              \"#000080\", // 30 Blue (same as 1)\n              \"#00FF80\" //  31 Sea Green (same as 19)\n          ]\n      };\n      // mode 0: pen 0-15,16=border; inks for pen 14,15 are alternating: \"1,24\", \"16,11\"\n      static defaultInks = [\n          [1, 24, 20, 6, 26, 0, 2, 8, 10, 12, 14, 16, 18, 22, 1, 16, 1], // eslint-disable-line array-element-newline\n          [1, 24, 20, 6, 26, 0, 2, 8, 10, 12, 14, 16, 18, 22, 24, 11, 1] // eslint-disable-line array-element-newline\n      ];\n      static modeData = [\n          {\n              pens: 16, // number of pens\n              pixelWidth: 4, // pixel width\n              pixelHeight: 2 // pixel height\n          },\n          {\n              pens: 4,\n              pixelWidth: 2,\n              pixelHeight: 2\n          },\n          {\n              pens: 2,\n              pixelWidth: 1,\n              pixelHeight: 2\n          },\n          {\n              pens: 16, // mode 3 not available on a real CPC\n              pixelWidth: 1,\n              pixelHeight: 1\n          }\n      ];\n      applyBorderColor() {\n          this.canvas.style.borderColor = Canvas.palettes[this.options.palette][this.currentInks[this.inkSet][16]];\n      }\n      reset() {\n          this.changeMode(1);\n          this.inkSet = 0;\n          this.setDefaultInks();\n          this.speedInk[0] = 10;\n          this.speedInk[1] = 10;\n          this.speedInkCount = this.speedInk[this.inkSet];\n          this.applyBorderColor();\n          this.setGPen(1);\n          this.setGPaper(0);\n          this.resetCustomChars();\n          this.setMode(1);\n          this.clearGraphicsWindow();\n      }\n      resetCustomChars() {\n          this.customCharset = {}; // symbol\n      }\n      static computePalette(palette) {\n          if (palette === \"green\" || palette === \"grey\") {\n              const colorPalette = Canvas.palettes.color, colorValues = [], monoPalette = [];\n              Canvas.extractAllColorValues(colorPalette, colorValues);\n              for (let i = 0; i < colorPalette.length; i += 1) {\n                  // https://en.wikipedia.org/wiki/Luma_(video)\n                  // (0.299 * R) + (0.587 * G) + (0.114 * B);\n                  const monoValue = (0.299 * colorValues[i][0] + 0.587 * colorValues[i][1] + 0.114 * colorValues[i][2]) | 0, // eslint-disable-line no-bitwise\n                  monoHex = monoValue.toString(16).toUpperCase().padStart(2, \"0\");\n                  monoPalette[i] = palette === \"green\" ? \"#00\" + monoHex + \"00\" : \"#\" + monoHex + monoHex + monoHex;\n              }\n              Canvas.palettes[palette] = monoPalette;\n          }\n      }\n      applyPalette() {\n          const palette = this.options.palette;\n          if (!Canvas.palettes[palette]) {\n              Canvas.computePalette(palette);\n          }\n          this.setColorValues(Canvas.palettes[palette]);\n          if (this.currentInks.length) { // only if initialized (not if called from constructor)\n              this.updateColorMap();\n              this.setNeedUpdate();\n              this.applyBorderColor();\n          }\n      }\n      static isLittleEndian() {\n          // https://gist.github.com/TooTallNate/4750953\n          const b = new ArrayBuffer(4), a = new Uint32Array(b), c = new Uint8Array(b);\n          a[0] = 0xdeadbeef;\n          return (c[0] === 0xef);\n      }\n      static extractColorValues(color) {\n          return [\n              parseInt(color.substring(1, 3), 16),\n              parseInt(color.substring(3, 5), 16),\n              parseInt(color.substring(5, 7), 16)\n          ];\n      }\n      static extractAllColorValues(colors, colorValues) {\n          for (let i = 0; i < colors.length; i += 1) {\n              colorValues[i] = Canvas.extractColorValues(colors[i]);\n          }\n      }\n      setColorValues(palette) {\n          Canvas.extractAllColorValues(palette, this.colorValues);\n      }\n      setAlpha(alpha) {\n          const buf8 = this.imageData.data, length = this.dataset8.length; // or: this.width * this.height\n          for (let i = 0; i < length; i += 1) {\n              buf8[i * 4 + 3] = alpha; // alpha\n          }\n      }\n      setNeedUpdate() {\n          this.needUpdate = true;\n      }\n      updateCanvas2() {\n          if (!this.isRunning) {\n              return; // ignore remaining timeouts, if stopped\n          }\n          this.animationFrame = requestAnimationFrame(this.fnUpdateCanvasHandler);\n          if (this.needUpdate) { // could be improved: update only updateRect\n              this.needUpdate = false;\n              // we always do a full updateCanvas...\n              this.fnCopy2Canvas();\n          }\n      }\n      // http://creativejs.com/resources/requestanimationframe/ (set frame rate)\n      // https://stackoverflow.com/questions/19764018/controlling-fps-with-requestanimationframe\n      updateCanvas() {\n          this.animationTimeoutId = window.setTimeout(this.fnUpdateCanvas2Handler, 1000 / this.fps); // ts (node)\n      }\n      startUpdateCanvas() {\n          if (!this.isRunning && this.canvas.offsetParent !== null) { // animation off and canvas visible in DOM?\n              this.isRunning = true;\n              this.updateCanvas();\n          }\n      }\n      stopUpdateCanvas() {\n          if (this.isRunning) {\n              this.isRunning = false;\n              if (this.animationFrame) {\n                  cancelAnimationFrame(this.animationFrame);\n                  this.animationFrame = undefined;\n              }\n              clearTimeout(this.animationTimeoutId);\n              this.animationTimeoutId = undefined;\n          }\n      }\n      copy2Canvas8bit() {\n          const buf8 = this.imageData.data, // use Uint8ClampedArray from canvas\n          dataset8 = this.dataset8, length = dataset8.length, // or: this.width * this.height\n          pen2ColorMap = this.pen2ColorMap;\n          for (let i = 0; i < length; i += 1) {\n              const color = pen2ColorMap[dataset8[i]], j = i * 4;\n              buf8[j] = color[0]; // r\n              buf8[j + 1] = color[1]; // g\n              buf8[j + 2] = color[2]; // b\n              // alpha already set to 255\n          }\n          this.ctx.putImageData(this.imageData, 0, 0);\n      }\n      copy2Canvas32bit() {\n          const dataset8 = this.dataset8, data32 = this.data32, pen2Color32 = this.pen2Color32;\n          for (let i = 0; i < data32.length; i += 1) {\n              data32[i] = pen2Color32[dataset8[i]];\n          }\n          this.ctx.putImageData(this.imageData, 0, 0);\n      }\n      copy2Canvas32bitWithOffset() {\n          const dataset8 = this.dataset8, data32 = this.data32, pen2Color32 = this.pen2Color32, offset = this.offset;\n          for (let i = 0; i < data32.length - offset; i += 1) {\n              data32[i + offset] = pen2Color32[dataset8[i]];\n          }\n          for (let i = data32.length - offset; i < data32.length; i += 1) {\n              data32[i + offset - data32.length] = pen2Color32[dataset8[i]];\n          }\n          this.ctx.putImageData(this.imageData, 0, 0);\n      }\n      getCopy2CanvasFunction(offset) {\n          if (this.use32BitCopy) {\n              return offset ? this.copy2Canvas32bitWithOffset : this.copy2Canvas32bit;\n          }\n          return offset ? this.copy2Canvas8bit : this.copy2Canvas8bit; // TODO: for older browsers\n      }\n      setScreenOffset(offset) {\n          if (offset) {\n              // TODO\n              offset = (offset % 80) * 8 + ((offset / 80) | 0) * 80 * 16 * 8; // eslint-disable-line no-bitwise\n              offset = 640 * 400 - offset;\n          }\n          if (offset !== this.offset) {\n              this.offset = offset;\n              this.fnCopy2Canvas = this.getCopy2CanvasFunction(offset);\n              this.setNeedUpdate();\n          }\n      }\n      updateColorMap() {\n          const colorValues = this.colorValues, currentInksInSet = this.currentInks[this.inkSet], pen2ColorMap = this.pen2ColorMap, pen2Color32 = this.pen2Color32, maxPens = 16, alpha = 255;\n          for (let i = 0; i < maxPens; i += 1) {\n              pen2ColorMap[i] = colorValues[currentInksInSet[i]];\n          }\n          if (pen2Color32) {\n              for (let i = 0; i < maxPens; i += 1) {\n                  const color = pen2ColorMap[i];\n                  if (this.littleEndian) {\n                      pen2Color32[i] = color[0] + color[1] * 256 + color[2] * 65536 + alpha * 65536 * 256;\n                  }\n                  else {\n                      pen2Color32[i] = color[2] + color[1] * 256 + color[0] * 65536 + alpha * 65536 * 256; // for big endian (untested)\n                  }\n              }\n          }\n      }\n      updateColorsAndCanvasImmediately(inkList) {\n          const currentInksInSet = this.currentInks[this.inkSet], memorizedInks = currentInksInSet.slice();\n          this.currentInks[this.inkSet] = inkList; // temporary inks\n          this.updateColorMap();\n          this.fnCopy2Canvas(); // do it immediately\n          this.currentInks[this.inkSet] = memorizedInks.slice();\n          this.updateColorMap();\n          this.needUpdate = true; // we want to restore it with the next update...\n      }\n      updateSpeedInk() {\n          const pens = this.modeData.pens;\n          this.speedInkCount -= 1;\n          if (this.speedInkCount <= 0) {\n              const currentInkSet = this.inkSet, newInkSet = currentInkSet ^ 1; // eslint-disable-line no-bitwise\n              this.inkSet = newInkSet;\n              this.speedInkCount = this.speedInk[newInkSet];\n              // check for blinking inks which pens are visible in the current mode\n              for (let i = 0; i < pens; i += 1) {\n                  if (this.currentInks[newInkSet][i] !== this.currentInks[currentInkSet][i]) {\n                      this.updateColorMap(); // need ink update\n                      this.needUpdate = true; // we also need update\n                      break;\n                  }\n              }\n              // check border ink\n              if (this.currentInks[newInkSet][16] !== this.currentInks[currentInkSet][16]) {\n                  this.applyBorderColor();\n              }\n          }\n      }\n      setCustomChar(char, charData) {\n          this.customCharset[char] = charData;\n      }\n      getCharData(char) {\n          return this.customCharset[char] || this.options.charset[char];\n      }\n      setDefaultInks() {\n          this.currentInks[0] = Canvas.defaultInks[0].slice(); // copy ink set 0 array\n          this.currentInks[1] = Canvas.defaultInks[1].slice(); // copy ink set 1 array\n          this.updateColorMap();\n          this.setGPen(this.gPen);\n      }\n      setFocusOnCanvas() {\n          this.cpcAreaBox.style.background = \"#463c3c\";\n          if (this.canvas) {\n              this.canvas.focus();\n          }\n          this.hasFocus = true;\n      }\n      getMousePos(event) {\n          const anyDoc = document, isFullScreen = Boolean(document.fullscreenElement || anyDoc.mozFullScreenElement || anyDoc.webkitFullscreenElement || anyDoc.msFullscreenElement), rect = this.canvas.getBoundingClientRect();\n          if (isFullScreen) {\n              const areaX = 0, areaY = 0, rectwidth = rect.right - rect.left - (this.borderWidth + areaX) * 2, rectHeight = rect.bottom - rect.top - (this.borderWidth + areaY) * 2, ratioX = rectwidth / this.canvas.width, ratioY = rectHeight / this.canvas.height, minRatio = ratioX <= ratioY ? ratioX : ratioY, diffX = rectwidth - (this.canvas.width * minRatio), diffY = rectHeight - (this.canvas.height * minRatio);\n              return {\n                  x: (event.clientX - this.borderWidth - rect.left - diffX / 2) / ratioX * ratioX / minRatio,\n                  y: (event.clientY - this.borderWidth - rect.top - diffY / 2) / ratioY * ratioY / minRatio\n              };\n          }\n          return {\n              x: (event.clientX - this.borderWidth - rect.left) / (rect.right - rect.left - this.borderWidth * 2) * this.canvas.width,\n              y: (event.clientY - this.borderWidth - rect.top) / (rect.bottom - rect.top - this.borderWidth * 2) * this.canvas.height\n          };\n      }\n      canvasClickAction(event) {\n          const pos = this.getMousePos(event), \n          /* eslint-disable no-bitwise */\n          x = pos.x | 0, // force integer\n          y = pos.y | 0;\n          /* eslint-enable no-bitwise */\n          if (this.options.onCanvasClick) {\n              if (x >= 0 && x <= this.width - 1 && y >= 0 && y <= this.height - 1) {\n                  const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8, \n                  /* eslint-disable no-bitwise */\n                  xTxt = (x / charWidth) | 0, yTxt = (y / charHeight) | 0;\n                  /* eslint-enable no-bitwise */\n                  this.options.onCanvasClick(event, x, y, xTxt, yTxt);\n              }\n          }\n      }\n      onCanvasClick(event) {\n          if (!this.hasFocus) {\n              this.setFocusOnCanvas();\n          }\n          else {\n              this.canvasClickAction(event);\n          }\n          event.stopPropagation();\n      }\n      onWindowClick(_event) {\n          if (this.hasFocus) {\n              this.hasFocus = false;\n              this.cpcAreaBox.style.background = \"\";\n          }\n      }\n      getXpos() {\n          return this.xPos;\n      }\n      getYpos() {\n          return this.yPos;\n      }\n      fillMyRect(x, y, width, height, paper) {\n          const canvasWidth = this.width, dataset8 = this.dataset8;\n          for (let row = 0; row < height; row += 1) {\n              const idx = x + (y + row) * canvasWidth;\n              dataset8.fill(paper, idx, idx + width);\n          }\n      }\n      fillTextBox(left, top, width, height, paper) {\n          const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8;\n          paper %= this.modeData.pens; // limit papers\n          this.fillMyRect(left * charWidth, top * charHeight, width * charWidth, height * charHeight, paper);\n          this.setNeedUpdate();\n      }\n      moveMyRectUp(x, y, width, height, x2, y2) {\n          const canvasWidth = this.width, dataset8 = this.dataset8;\n          for (let row = 0; row < height; row += 1) {\n              const idx1 = x + (y + row) * canvasWidth, idx2 = x2 + (y2 + row) * canvasWidth;\n              dataset8.copyWithin(idx2, idx1, idx1 + width);\n          }\n      }\n      moveMyRectDown(x, y, width, height, x2, y2) {\n          const canvasWidth = this.width, dataset8 = this.dataset8;\n          for (let row = height - 1; row >= 0; row -= 1) {\n              const idx1 = x + (y + row) * canvasWidth, idx2 = x2 + (y2 + row) * canvasWidth;\n              dataset8.copyWithin(idx2, idx1, idx1 + width);\n          }\n      }\n      invertChar(x, y, pen, paper) {\n          const pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, penXorPaper = pen ^ paper; // eslint-disable-line no-bitwise\n          for (let row = 0; row < 8; row += 1) {\n              for (let col = 0; col < 8; col += 1) {\n                  let testPen = this.testSubPixel(x + col * pixelWidth, y + row * pixelHeight);\n                  testPen ^= penXorPaper; // eslint-disable-line no-bitwise\n                  this.setSubPixelsNormal(x + col * pixelWidth, y + row * pixelHeight, testPen);\n              }\n          }\n      }\n      setChar(char, x, y, pen, paper, transparent, gColMode, textAtGraphics) {\n          const charData = this.customCharset[char] || this.options.charset[char], pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight;\n          for (let row = 0; row < 8; row += 1) {\n              for (let col = 0; col < 8; col += 1) {\n                  const charValue = charData[row], bit = charValue & (0x80 >> col); // eslint-disable-line no-bitwise\n                  if (!(transparent && !bit)) { // do not set background pixel in transparent mode\n                      const penOrPaper = (bit) ? pen : paper;\n                      if (textAtGraphics) {\n                          this.setPixel(x + col * pixelWidth, y - row * pixelHeight, penOrPaper, gColMode);\n                      }\n                      else { // text mode\n                          this.setSubPixels(x + col * pixelWidth, y + row * pixelHeight, penOrPaper, gColMode); // colMode always 0 in text mode\n                      }\n                  }\n              }\n          }\n      }\n      readCharData(x, y, expectedPen) {\n          const charData = [], pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight;\n          for (let row = 0; row < 8; row += 1) {\n              let charValue = 0;\n              for (let col = 0; col < 8; col += 1) {\n                  const pen = this.testSubPixel(x + col * pixelWidth, y + row * pixelHeight);\n                  if (pen === expectedPen) {\n                      charValue |= (0x80 >> col); // eslint-disable-line no-bitwise\n                  }\n              }\n              charData[row] = charValue;\n          }\n          return charData;\n      }\n      // set subpixels with normal mode (gColmode=0)\n      setSubPixelsNormal(x, y, gPen) {\n          const pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, width = this.width;\n          /* eslint-disable no-bitwise */\n          x &= ~(pixelWidth - 1); // match CPC pixel\n          y &= ~(pixelHeight - 1);\n          for (let row = 0; row < pixelHeight; row += 1) {\n              const i = x + width * (y + row);\n              for (let col = 0; col < pixelWidth; col += 1) {\n                  this.dataset8[i + col] = gPen;\n              }\n          }\n          /* eslint-enable no-bitwise */\n      }\n      setSubPixels(x, y, gPen, gColMode) {\n          const pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, width = this.width;\n          /* eslint-disable no-bitwise */\n          x &= ~(pixelWidth - 1); // match CPC pixel\n          y &= ~(pixelHeight - 1);\n          for (let row = 0; row < pixelHeight; row += 1) {\n              let i = x + width * (y + row);\n              for (let col = 0; col < pixelWidth; col += 1) {\n                  switch (gColMode) {\n                      case 0: // normal\n                          this.dataset8[i] = gPen;\n                          break;\n                      case 1: // xor\n                          this.dataset8[i] ^= gPen;\n                          break;\n                      case 2: // and\n                          this.dataset8[i] &= gPen;\n                          break;\n                      case 3: // or\n                          this.dataset8[i] |= gPen;\n                          break;\n                      default:\n                          Utils.console.warn(\"setSubPixels: Unknown colMode:\", gColMode);\n                          break;\n                  }\n                  i += 1;\n              }\n          }\n          /* eslint-enable no-bitwise */\n      }\n      // some rounding needed before applying origin:\n      static roundCoordinate(cor, widthOrHeight) {\n          /* eslint-disable no-bitwise */\n          return cor >= 0 ? cor & ~(widthOrHeight - 1) : -(-cor & ~(widthOrHeight - 1));\n          /* eslint-enable no-bitwise */\n      }\n      setPixel(x, y, gPen, gColMode) {\n          // some rounding needed before applying origin:\n          x = Canvas.roundCoordinate(x, this.modeData.pixelWidth);\n          y = Canvas.roundCoordinate(y, this.modeData.pixelHeight);\n          x += this.xOrig;\n          y = this.height - 1 - (y + this.yOrig);\n          if (x < this.xLeft || x > this.xRight || y < (this.height - 1 - this.yTop) || y > (this.height - 1 - this.yBottom)) {\n              return; // not in graphics window\n          }\n          this.setSubPixels(x, y, gPen, gColMode);\n      }\n      setPixelOriginIncluded(x, y, gPen, gColMode) {\n          if (x < this.xLeft || x > this.xRight || y < (this.height - 1 - this.yTop) || y > (this.height - 1 - this.yBottom)) {\n              return; // not in graphics window\n          }\n          this.setSubPixels(x, y, gPen, gColMode);\n      }\n      testSubPixel(x, y) {\n          const i = x + this.width * y, pen = this.dataset8[i];\n          return pen;\n      }\n      testPixel(x, y) {\n          // some rounding needed before applying origin:\n          x = Canvas.roundCoordinate(x, this.modeData.pixelWidth);\n          y = Canvas.roundCoordinate(y, this.modeData.pixelHeight);\n          x += this.xOrig;\n          y = this.height - 1 - (y + this.yOrig);\n          if (x < this.xLeft || x > this.xRight || y < (this.height - 1 - this.yTop) || y > (this.height - 1 - this.yBottom)) {\n              return this.gPaper; // not in graphics window => return graphics paper\n          }\n          const i = x + this.width * y, pen = this.dataset8[i];\n          return pen;\n      }\n      getByte(addr) {\n          /* eslint-disable no-bitwise */\n          const mode = this.mode, pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, x = ((addr & 0x7ff) % 80) * 8, y = (((addr & 0x3800) / 0x800) + (((addr & 0x7ff) / 80) | 0) * 8) * pixelHeight;\n          let byte = null, // null=cannot read\n          gPen;\n          if (y < this.height) { // only if in visible range\n              if (mode === 0) {\n                  gPen = this.dataset8[x + this.width * y];\n                  byte = ((gPen >> 2) & 0x02) | ((gPen << 3) & 0x20) | ((gPen << 2) & 0x08) | ((gPen << 7) & 0x80); // b1,b5,b3,b7 (left pixel)\n                  gPen = this.dataset8[x + pixelWidth + this.width * y];\n                  byte |= ((gPen >> 3) & 0x01) | ((gPen << 2) & 0x10) | ((gPen << 1) & 0x04) | ((gPen << 6) & 0x40); // b0,b4,b2,b6 (right pixel)\n              }\n              else if (mode === 1) {\n                  byte = 0;\n                  gPen = this.dataset8[x + this.width * y];\n                  byte |= ((gPen & 0x02) << 2) | ((gPen & 0x01) << 7); // b3,b7 (left pixel 1)\n                  gPen = this.dataset8[x + pixelWidth + this.width * y];\n                  byte |= ((gPen & 0x02) << 1) | ((gPen & 0x01) << 6); // b2,b6 (pixel 2)\n                  gPen = this.dataset8[x + pixelWidth * 2 + this.width * y];\n                  byte |= ((gPen & 0x02) << 0) | ((gPen & 0x01) << 5); // b1,b5 (pixel 3)\n                  gPen = this.dataset8[x + pixelWidth * 3 + this.width * y];\n                  byte |= ((gPen & 0x02) >> 1) | ((gPen & 0x01) << 4); // b0,b4 (right pixel 4)\n              }\n              else if (mode === 2) {\n                  byte = 0;\n                  for (let i = 0; i <= 7; i += 1) {\n                      gPen = this.dataset8[x + i + this.width * y];\n                      byte |= (gPen & 0x01) << (7 - i);\n                  }\n              }\n              else { // mode === 3\n              }\n          }\n          /* eslint-enable no-bitwise */\n          return byte;\n      }\n      setByte(addr, byte) {\n          /* eslint-disable no-bitwise */\n          const mode = this.mode, pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, x = ((addr & 0x7ff) % 80) * 8, y = (((addr & 0x3800) / 0x800) + (((addr & 0x7ff) / 80) | 0) * 8) * pixelHeight;\n          let gPen;\n          if (y < this.height) { // only if in visible range\n              if (mode === 0) {\n                  gPen = ((byte << 2) & 0x08) | ((byte >> 3) & 0x04) | ((byte >> 2) & 0x02) | ((byte >> 7) & 0x01); // b1,b5,b3,b7 (left pixel)\n                  this.setSubPixelsNormal(x, y, gPen);\n                  gPen = ((byte << 3) & 0x08) | ((byte >> 2) & 0x04) | ((byte >> 1) & 0x02) | ((byte >> 6) & 0x01); // b0,b4,b2,b6 (right pixel)\n                  this.setSubPixelsNormal(x + pixelWidth, y, gPen);\n                  this.setNeedUpdate();\n              }\n              else if (mode === 1) {\n                  gPen = ((byte >> 2) & 0x02) | ((byte >> 7) & 0x01); // b3,b7 (left pixel 1)\n                  this.setSubPixelsNormal(x, y, gPen);\n                  gPen = ((byte >> 1) & 0x02) | ((byte >> 6) & 0x01); // b2,b6 (pixel 2)\n                  this.setSubPixelsNormal(x + pixelWidth, y, gPen);\n                  gPen = ((byte >> 0) & 0x02) | ((byte >> 5) & 0x01); // b1,b5 (pixel 3)\n                  this.setSubPixelsNormal(x + pixelWidth * 2, y, gPen);\n                  gPen = ((byte << 1) & 0x02) | ((byte >> 4) & 0x01); // b0,b4 (right pixel 4)\n                  this.setSubPixelsNormal(x + pixelWidth * 3, y, gPen);\n                  this.setNeedUpdate();\n              }\n              else if (mode === 2) {\n                  for (let i = 0; i <= 7; i += 1) {\n                      gPen = (byte >> (7 - i)) & 0x01;\n                      this.setSubPixelsNormal(x + i * pixelWidth, y, gPen);\n                  }\n                  this.setNeedUpdate();\n              }\n              else { // mode === 3 (not supported)\n              }\n          }\n          /* eslint-enable no-bitwise */\n      }\n      // https://de.wikipedia.org/wiki/Bresenham-Algorithmus\n      drawBresenhamLine(xstart, ystart, xend, yend) {\n          const pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, gPen = this.gPen, gPaper = this.gPaper, mask = this.mask, maskFirst = this.maskFirst, gColMode = this.gColMode, transparent = this.gTransparent;\n          let maskBit = this.maskBit;\n          xstart = Canvas.roundCoordinate(xstart, pixelWidth);\n          ystart = Canvas.roundCoordinate(ystart, pixelHeight);\n          xend = Canvas.roundCoordinate(xend, pixelWidth);\n          yend = Canvas.roundCoordinate(yend, pixelHeight);\n          // we have to add origin before modifying coordinates to match CPC pixel\n          xstart += this.xOrig;\n          ystart = this.height - 1 - (ystart + this.yOrig);\n          xend += this.xOrig;\n          yend = this.height - 1 - (yend + this.yOrig);\n          /* eslint-disable no-bitwise */\n          let dx = ((xend - xstart) / pixelWidth) | 0, dy = ((yend - ystart) / pixelHeight) | 0;\n          /* eslint-enable no-bitwise */\n          const incx = Math.sign(dx) * pixelWidth, incy = Math.sign(dy) * pixelHeight;\n          if (dx < 0) {\n              dx = -dx;\n          }\n          if (dy < 0) {\n              dy = -dy;\n          }\n          let pdx, pdy, ddx, ddy, deltaslowdirection, deltafastdirection;\n          if (dx > dy) {\n              pdx = incx;\n              pdy = 0;\n              ddx = incx;\n              ddy = incy;\n              deltaslowdirection = dy;\n              deltafastdirection = dx;\n          }\n          else {\n              pdx = 0;\n              pdy = incy;\n              ddx = incx;\n              ddy = incy;\n              deltaslowdirection = dx;\n              deltafastdirection = dy;\n          }\n          let x = xstart, y = ystart, err = deltafastdirection >> 1; // eslint-disable-line no-bitwise\n          if (maskFirst) { // draw first pixel?\n              const bit = mask & maskBit; // eslint-disable-line no-bitwise\n              if (!(transparent && !bit)) { // do not set background pixel in transparent mode\n                  this.setPixelOriginIncluded(x, y, bit ? gPen : gPaper, gColMode); // we expect integers\n              }\n              // rotate bitpos right\n              maskBit = (maskBit >> 1) | ((maskBit << 7) & 0xff); // eslint-disable-line no-bitwise\n          }\n          for (let t = 0; t < deltafastdirection; t += 1) {\n              err -= deltaslowdirection;\n              if (err < 0) {\n                  err += deltafastdirection;\n                  x += ddx;\n                  y += ddy;\n              }\n              else {\n                  x += pdx;\n                  y += pdy;\n              }\n              const bit = mask & maskBit; // eslint-disable-line no-bitwise\n              if (!(transparent && !bit)) { // do not set background pixel in transparent mode\n                  this.setPixelOriginIncluded(x, y, bit ? gPen : gPaper, gColMode); // we expect integers\n              }\n              // rotate bitpos right\n              maskBit = (maskBit >> 1) | ((maskBit << 7) & 0xff); // eslint-disable-line no-bitwise\n          }\n          this.maskBit = maskBit;\n      }\n      draw(x, y) {\n          const xStart = this.xPos, yStart = this.yPos;\n          this.move(x, y); // destination\n          this.drawBresenhamLine(xStart, yStart, x, y);\n          this.setNeedUpdate();\n      }\n      move(x, y) {\n          this.xPos = x; // must be integer\n          this.yPos = y;\n      }\n      plot(x, y) {\n          this.move(x, y);\n          this.setPixel(x, y, this.gPen, this.gColMode); // must be integer\n          this.setNeedUpdate();\n      }\n      test(x, y) {\n          this.move(x, y);\n          return this.testPixel(this.xPos, this.yPos); // use rounded values\n      }\n      setInk(pen, ink1, ink2) {\n          let needInkUpdate = false;\n          if (this.currentInks[0][pen] !== ink1) {\n              this.currentInks[0][pen] = ink1;\n              needInkUpdate = true;\n          }\n          if (this.currentInks[1][pen] !== ink2) {\n              this.currentInks[1][pen] = ink2;\n              needInkUpdate = true;\n          }\n          if (needInkUpdate) {\n              this.updateColorMap();\n              this.setNeedUpdate(); // we need to notify that an update is needed\n          }\n          return needInkUpdate;\n      }\n      setBorder(ink1, ink2) {\n          const needInkUpdate = this.setInk(16, ink1, ink2);\n          if (needInkUpdate) {\n              this.applyBorderColor();\n          }\n      }\n      setGPen(gPen) {\n          this.gPen = gPen % this.modeData.pens; // limit pens\n      }\n      setGPaper(gPaper) {\n          this.gPaper = gPaper % this.modeData.pens; // limit to pens\n      }\n      setGTransparentMode(transparent) {\n          this.gTransparent = transparent;\n      }\n      printGChar(char) {\n          const charWidth = this.modeData.pixelWidth * 8;\n          if (char >= this.options.charset.length) {\n              Utils.console.warn(\"printGChar: Ignoring char with code\", char);\n              return;\n          }\n          this.setChar(char, this.xPos, this.yPos, this.gPen, this.gPaper, this.gTransparent, this.gColMode, true);\n          this.xPos += charWidth;\n          this.setNeedUpdate();\n      }\n      printChar(char, x, y, pen, paper, transparent) {\n          const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8, pens = this.modeData.pens;\n          if (char >= this.options.charset.length) {\n              Utils.console.warn(\"printChar: Ignoring char with code\", char);\n              return;\n          }\n          pen %= pens;\n          paper %= pens; // also pens\n          this.setChar(char, x * charWidth, y * charHeight, pen, paper, transparent, 0, false);\n          this.setNeedUpdate();\n      }\n      drawCursor(x, y, pen, paper) {\n          const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8, pens = this.modeData.pens;\n          pen %= pens;\n          paper %= pens; // also pens\n          this.invertChar(x * charWidth, y * charHeight, pen, paper);\n          this.setNeedUpdate();\n      }\n      findMatchingChar(charData) {\n          const charset = this.options.charset;\n          let char = -1; // not detected\n          for (let i = 0; i < charset.length; i += 1) {\n              const charData2 = this.customCharset[i] || charset[i];\n              let match = true;\n              for (let j = 0; j < 8; j += 1) {\n                  if (charData[j] !== charData2[j]) {\n                      match = false;\n                      break;\n                  }\n              }\n              if (match) {\n                  char = i;\n                  break;\n              }\n          }\n          return char;\n      }\n      readChar(x, y, pen, paper) {\n          const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8, pens = this.modeData.pens;\n          pen %= pens;\n          paper %= pens; // also pens\n          x *= charWidth;\n          y *= charHeight;\n          let charData = this.readCharData(x, y, pen), char = this.findMatchingChar(charData);\n          if (char < 0 || char === 32) { // no match? => check inverse with paper, char=32?\n              charData = this.readCharData(x, y, paper);\n              for (let i = 0; i < charData.length; i += 1) {\n                  charData[i] ^= 0xff; // eslint-disable-line no-bitwise\n              }\n              let char2 = this.findMatchingChar(charData);\n              if (char2 >= 0) {\n                  if (char2 === 143) { // invers of space?\n                      char2 = 32; // use space\n                  }\n                  char = char2;\n              }\n          }\n          return char;\n      }\n      // fill: idea from: https://simpledevcode.wordpress.com/2015/12/29/flood-fill-algorithm-using-c-net/\n      fnIsNotInWindow(x, y) {\n          return (x < this.xLeft || x > this.xRight || y < (this.height - 1 - this.yTop) || y > (this.height - 1 - this.yBottom));\n      }\n      fill(fillPen) {\n          const gPen = this.gPen, pixelWidth = this.modeData.pixelWidth, pixelHeight = this.modeData.pixelHeight, pixels = [], fnIsStopPen = function (p) {\n              return p === fillPen || p === gPen;\n          };\n          let xPos = this.xPos, yPos = this.yPos;\n          fillPen %= this.modeData.pens; // limit pens\n          // apply origin\n          xPos += this.xOrig;\n          yPos = this.height - 1 - (yPos + this.yOrig);\n          if (this.fnIsNotInWindow(xPos, yPos)) {\n              return;\n          }\n          pixels.push({\n              x: xPos,\n              y: yPos\n          });\n          while (pixels.length) {\n              const pixel = pixels.pop();\n              let y1 = pixel.y, p1 = this.testSubPixel(pixel.x, y1);\n              while (y1 >= (this.height - 1 - this.yTop) && !fnIsStopPen(p1)) {\n                  y1 -= pixelHeight;\n                  p1 = this.testSubPixel(pixel.x, y1);\n              }\n              y1 += pixelHeight;\n              let spanLeft = false, spanRight = false;\n              p1 = this.testSubPixel(pixel.x, y1);\n              while (y1 <= (this.height - 1 - this.yBottom) && !fnIsStopPen(p1)) {\n                  this.setSubPixelsNormal(pixel.x, y1, fillPen);\n                  let x1 = pixel.x - pixelWidth;\n                  const p2 = this.testSubPixel(x1, y1);\n                  if (!spanLeft && x1 >= this.xLeft && !fnIsStopPen(p2)) {\n                      pixels.push({\n                          x: x1,\n                          y: y1\n                      });\n                      spanLeft = true;\n                  }\n                  else if (spanLeft && ((x1 < this.xLeft) || fnIsStopPen(p2))) {\n                      spanLeft = false;\n                  }\n                  x1 = pixel.x + pixelWidth;\n                  const p3 = this.testSubPixel(x1, y1);\n                  if (!spanRight && x1 <= this.xRight && !fnIsStopPen(p3)) {\n                      pixels.push({\n                          x: x1,\n                          y: y1\n                      });\n                      spanRight = true;\n                  }\n                  else if (spanRight && ((x1 > this.xRight) || fnIsStopPen(p3))) {\n                      spanRight = false;\n                  }\n                  y1 += pixelHeight;\n                  p1 = this.testSubPixel(pixel.x, y1);\n              }\n          }\n          this.setNeedUpdate();\n      }\n      static fnPutInRange(n, min, max) {\n          if (n < min) {\n              n = min;\n          }\n          else if (n > max) {\n              n = max;\n          }\n          return n;\n      }\n      setOrigin(xOrig, yOrig) {\n          const pixelWidth = this.modeData.pixelWidth;\n          xOrig &= ~(pixelWidth - 1); // eslint-disable-line no-bitwise\n          this.xOrig = xOrig; // must be integer\n          this.yOrig = yOrig;\n          this.move(0, 0);\n      }\n      getXOrigin() {\n          return this.xOrig;\n      }\n      getYOrigin() {\n          return this.yOrig;\n      }\n      setGWindow(xLeft, xRight, yTop, yBottom) {\n          const pixelWidth = 8, // force byte boundaries: always 8 x/byte\n          pixelHeight = this.modeData.pixelHeight; // usually 2, anly for mode 3 we have 1\n          xLeft = Canvas.fnPutInRange(xLeft, 0, this.width - 1);\n          xRight = Canvas.fnPutInRange(xRight, 0, this.width - 1);\n          yTop = Canvas.fnPutInRange(yTop, 0, this.height - 1);\n          yBottom = Canvas.fnPutInRange(yBottom, 0, this.height - 1);\n          // exchange coordinates, if needed (left>right or top<bottom)\n          if (xRight < xLeft) {\n              const tmp = xRight;\n              xRight = xLeft;\n              xLeft = tmp;\n          }\n          if (yTop < yBottom) {\n              const tmp = yTop;\n              yTop = yBottom;\n              yBottom = tmp;\n          }\n          // On the CPC this is set to byte positions (CPC Systembuch, p. 346)\n          // ORIGIN 0,0,13,563,399,0 gets origin 0,0,8,567,399 mod2+1,mod2\n          /* eslint-disable no-bitwise */\n          xLeft &= ~(pixelWidth - 1);\n          xRight |= (pixelWidth - 1);\n          yTop |= (pixelHeight - 1); // we know: top is larger than bottom\n          yBottom &= ~(pixelHeight - 1);\n          /* eslint-enable no-bitwise */\n          this.xLeft = xLeft;\n          this.xRight = xRight;\n          this.yTop = yTop;\n          this.yBottom = yBottom;\n      }\n      setGColMode(gColMode) {\n          if (gColMode !== this.gColMode) {\n              this.gColMode = gColMode;\n          }\n      }\n      clearTextWindow(left, right, top, bottom, paper) {\n          const width = right + 1 - left, height = bottom + 1 - top;\n          this.fillTextBox(left, top, width, height, paper);\n      }\n      clearGraphicsWindow() {\n          this.fillMyRect(this.xLeft, this.height - 1 - this.yTop, this.xRight + 1 - this.xLeft, this.yTop + 1 - this.yBottom, this.gPaper); // +1 or not?\n          this.move(0, 0);\n          this.setNeedUpdate();\n      }\n      clearFullWindow() {\n          const paper = 0;\n          this.fillMyRect(0, 0, this.width, this.height, paper);\n          this.setNeedUpdate();\n      }\n      windowScrollUp(left, right, top, bottom, paper) {\n          const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8, width = right + 1 - left, height = bottom + 1 - top;\n          if (height > 1) { // scroll part\n              this.moveMyRectUp(left * charWidth, (top + 1) * charHeight, width * charWidth, (height - 1) * charHeight, left * charWidth, top * charHeight);\n          }\n          this.fillTextBox(left, bottom, width, 1, paper);\n          this.setNeedUpdate();\n      }\n      windowScrollDown(left, right, top, bottom, paper) {\n          const charWidth = this.modeData.pixelWidth * 8, charHeight = this.modeData.pixelHeight * 8, width = right + 1 - left, height = bottom + 1 - top;\n          if (height > 1) { // scroll part\n              this.moveMyRectDown(left * charWidth, top * charHeight, width * charWidth, (height - 1) * charHeight, left * charWidth, (top + 1) * charHeight);\n          }\n          this.fillTextBox(left, top, width, 1, paper);\n          this.setNeedUpdate();\n      }\n      setSpeedInk(time1, time2) {\n          this.speedInk[0] = time1;\n          this.speedInk[1] = time2;\n      }\n      setMask(mask) {\n          this.mask = mask;\n          this.maskBit = 128;\n      }\n      setMaskFirst(maskFirst) {\n          this.maskFirst = maskFirst;\n      }\n      getMode() {\n          return this.mode;\n      }\n      changeMode(mode) {\n          const modeData = Canvas.modeData[mode];\n          this.mode = mode;\n          this.modeData = modeData;\n      }\n      setMode(mode) {\n          this.setScreenOffset(0);\n          this.changeMode(mode);\n          this.setOrigin(0, 0);\n          this.setGWindow(0, this.width - 1, this.height - 1, 0);\n          this.setGColMode(0);\n          this.setMask(255);\n          this.setMaskFirst(1);\n          this.setGPen(this.gPen); // keep, but maybe different for other mode\n          this.setGPaper(this.gPaper); // keep, maybe different for other mode\n          this.setGTransparentMode(false);\n      }\n      takeScreenShot() {\n          if (this.canvas.toDataURL) {\n              return this.canvas.toDataURL(\"image/png\").replace(\"image/png\", \"image/octet-stream\"); // here is the most important part because if you do not replace you will get a DOM 18 exception.\n          }\n          Utils.console.warn(\"Screenshot not available\");\n          return \"\";\n      }\n  }\n\n  // ===== dist/esm/CodeGeneratorBasic.js =====\n  // CodeGeneratorBasic.ts - Code Generator for BASIC (for testing, pretty print?)\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n  //\n\n  class CodeGeneratorBasic {\n      options;\n      // set in every generate:\n      keywords;\n      hasColons = false;\n      keepWhiteSpace = false;\n      line = 0; // current line (label)\n      constructor(options) {\n          this.options = {\n              quiet: false\n          };\n          this.setOptions(options);\n          this.keywords = options.parser.getKeywords();\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      static combinedKeywords = {\n          chainMerge: \"CHAIN\", // \"CHAIN MERGE\"\n          clearInput: \"CLEAR\", // \"CLEAR INPUT\"\n          graphicsPaper: \"GRAPHICS\", // \"GRAPHICS PAPER\"\n          graphicsPen: \"GRAPHICS\", // \"GRAPHICS PEN\"\n          keyDef: \"KEY\", // \"KEY DEF\"\n          lineInput: \"LINE\", // \"LINE INPUT\"\n          mid$Assign: \"MID$\",\n          onBreakCont: \"ON\", // \"\"ON BREAK CONT\"\n          onBreakGosub: \"ON\", // \"\"ON BREAK GOSUB\"\n          onBreakStop: \"ON\", // \"\"ON BREAK STOP\"\n          onErrorGoto: \"ON\", // \"ON ERROR GOTO\"\n          resumeNext: \"RESUME\", // \"RESUME NEXT\"\n          speedInk: \"SPEED\", // \"SPEED INK\"\n          speedKey: \"SPEED\", // \"SPEED KEY\"\n          speedWrite: \"SPEED\", // \"SPEED WRITE\"\n          symbolAfter: \"SYMBOL\", // \"SYMBOL AFTER\"\n          windowSwap: \"WINDOW\" // \"WINDOW SWAP\"\n      };\n      static operators = {\n          \"+\": \"+\",\n          \"-\": \"-\",\n          \"*\": \"*\",\n          \"/\": \"/\",\n          \"\\\\\": \"\\\\\",\n          \"^\": \"^\",\n          and: \"AND\",\n          or: \"OR\",\n          xor: \"XOR\",\n          not: \"NOT\",\n          mod: \"MOD\",\n          \">\": \">\",\n          \"<\": \"<\",\n          \">=\": \">=\",\n          \"<=\": \"<=\",\n          \"=\": \"=\",\n          \"<>\": \"<>\",\n          \"@\": \"@\",\n          \"#\": \"#\"\n      };\n      static operatorPrecedence = {\n          \"@\": 95, // prefix\n          \"^\": 90,\n          \"p-\": 80, // prefix - (fast hack)\n          \"p+\": 80, // prefix + (fast hack)\n          \"*\": 70,\n          \"/\": 70,\n          \"\\\\\": 60,\n          mod: 50,\n          \"+\": 40,\n          \"-\": 40,\n          \"=\": 30,\n          \"<>\": 30,\n          \"<\": 30,\n          \"<=\": 30,\n          \">\": 30,\n          \">=\": 30,\n          not: 23, // prefix\n          and: 22,\n          or: 21,\n          xor: 20,\n          \"#\": 10 // priority?\n      };\n      static operatorAssociativity = {\n          \"^\": \"right\", // right-associative\n          \"*\": \"left\", // left-associative (commutative, so parens not needed for equal precedence)\n          \"+\": \"left\", // left-associative (commutative, so parens not needed for equal precedence)\n          \"/\": \"left\", // left-associative (non-commutative, so parens ARE needed for equal precedence)\n          \"\\\\\": \"left\", // left-associative (non-commutative, so parens ARE needed)\n          mod: \"left\", // left-associative (non-commutative)\n          \"-\": \"left\", // left-associative (non-commutative, so parens ARE needed for equal precedence)\n          \"=\": \"none\", // comparison operators are non-associative\n          \"<>\": \"none\",\n          \"<\": \"none\",\n          \"<=\": \"none\",\n          \">\": \"none\",\n          \">=\": \"none\",\n          and: \"left\",\n          or: \"left\",\n          xor: \"left\"\n      };\n      composeError(error, message, value, pos) {\n          return Utils.composeError(\"CodeGeneratorBasic\", error, message, value, pos, undefined, this.line);\n      }\n      static fnWs(node) {\n          return node.ws || \"\";\n      }\n      static fnSpace1(value) {\n          return (!value.length || value.startsWith(\" \") ? \"\" : \" \") + value;\n      }\n      static getUcKeyword(node) {\n          const type = node.type;\n          return CodeGeneratorBasic.combinedKeywords[type] || type.toUpperCase();\n      }\n      fnParseArgs(args) {\n          const nodeArgs = []; // do not modify node.args here (could be a parameter of defined function)\n          if (!args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", \"\", -1); // should not occur\n          }\n          for (let i = 0; i < args.length; i += 1) {\n              let value = this.parseNode(args[i]);\n              if (args[i].type === \"'\" || args[i].type === \"else\" || args[i].type === \"elseComment\") { // fast hack to put a space before \"'\", \"else\" or \"elseComment\", if there is no space previously\n                  if (i > 0 && !nodeArgs[i - 1].endsWith(\" \") && !nodeArgs[i - 1].endsWith(\":\")) {\n                      value = CodeGeneratorBasic.fnSpace1(value);\n                  }\n              }\n              nodeArgs.push(value);\n          }\n          return nodeArgs;\n      }\n      combineArgsWithColon(args) {\n          if (!this.hasColons) {\n              for (let i = 1; i < args.length; i += 1) { // start with 1\n                  const arg = args[i].trim();\n                  if (!arg.startsWith(\"ELSE\") && !arg.startsWith(\"'\") && arg !== \"\") {\n                      args[i] = \":\" + args[i];\n                  }\n              }\n          }\n          return args.join(\"\");\n      }\n      fnParenthesisOpen(node) {\n          return CodeGeneratorBasic.fnWs(node) + node.value + (node.args ? this.fnParseArgs(node.args).join(\"\") : \"\");\n      }\n      static string(node) {\n          return CodeGeneratorBasic.fnWs(node) + '\"' + node.value + '\"';\n      }\n      static ustring(node) {\n          return CodeGeneratorBasic.fnWs(node) + '\"' + node.value;\n      }\n      assign(node) {\n          // see also \"let\"\n          if (node.left.type !== \"identifier\") {\n              throw this.composeError(Error(), \"Unexpected assign type\", node.type, node.pos); // should not occur\n          }\n          // no spaces needed around \"=\"\n          return this.parseNode(node.left) + CodeGeneratorBasic.fnWs(node) + node.value + this.parseNode(node.right);\n      }\n      static expnumber(node) {\n          return CodeGeneratorBasic.fnWs(node) + Number(node.value).toExponential().toUpperCase().replace(/(\\d+)$/, function (x) {\n              return x.length >= 2 ? x : x.padStart(2, \"0\"); // format with 2 exponential digits\n          });\n      }\n      static binHexNumber(node) {\n          return CodeGeneratorBasic.fnWs(node) + node.value.toUpperCase(); // binnumber: maybe \"&x\", hexnumber: mayby \"&h\"\n      }\n      label(node) {\n          this.line = Number(node.value); // set line before parsing args\n          const value = this.combineArgsWithColon(this.fnParseArgs(node.args));\n          return CodeGeneratorBasic.fnWs(node) + node.value + (node.value !== \"\" ? CodeGeneratorBasic.fnSpace1(value) : value);\n      }\n      // special keyword functions\n      vertical(node) {\n          return CodeGeneratorBasic.fnWs(node) + node.value.toUpperCase() + this.fnParseArgs(node.args).join(\"\");\n      }\n      afterEveryGosub(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          nodeArgs[0] = CodeGeneratorBasic.fnSpace1(nodeArgs[0]); // first argument\n          nodeArgs[nodeArgs.length - 2] = CodeGeneratorBasic.fnSpace1(nodeArgs[nodeArgs.length - 2]); // \"gosub\"\n          nodeArgs[nodeArgs.length - 1] = CodeGeneratorBasic.fnSpace1(nodeArgs[nodeArgs.length - 1]); // line number\n          return CodeGeneratorBasic.fnWs(node) + node.value.toUpperCase() + nodeArgs.join(\"\");\n      }\n      chainOrChainMerge(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          if (nodeArgs.length > 2) { // with delete?\n              if (nodeArgs[nodeArgs.length - 2] === \"DELETE\") {\n                  nodeArgs[nodeArgs.length - 1] = CodeGeneratorBasic.fnSpace1(nodeArgs[nodeArgs.length - 1]);\n              }\n          }\n          return CodeGeneratorBasic.fnWs(node) + CodeGeneratorBasic.getUcKeyword(node) + (node.right ? CodeGeneratorBasic.fnSpace1(this.parseNode(node.right)) : \"\") + CodeGeneratorBasic.fnSpace1(nodeArgs.join(\"\"));\n      }\n      data(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              const value2 = nodeArgs[i];\n              nodeArgs[i] = value2;\n          }\n          let args = nodeArgs.join(\"\");\n          if (!this.keepWhiteSpace) {\n              args = Utils.stringTrimEnd(args); // remove trailing spaces\n          }\n          return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + CodeGeneratorBasic.fnSpace1(args);\n      }\n      def(node) {\n          return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + (node.right ? CodeGeneratorBasic.fnSpace1(this.parseNode(node.right)) + this.fnParseArgs(node.args).join(\"\") : \"\");\n      }\n      elseComment(node) {\n          if (!node.args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", \"\", -1); // should not occur\n          }\n          const args = node.args;\n          let value = \"\";\n          for (let i = 0; i < args.length; i += 1) {\n              const token = args[i];\n              if (token.value) {\n                  if (this.keepWhiteSpace) {\n                      value += CodeGeneratorBasic.fnWs(token) + token.value;\n                  }\n                  else {\n                      value += CodeGeneratorBasic.fnSpace1(CodeGeneratorBasic.fnWs(token) + token.value);\n                  }\n              }\n          }\n          return CodeGeneratorBasic.fnWs(node) + \"else\".toUpperCase() + value;\n      }\n      fn(node) {\n          if (!node.right) {\n              return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase(); // only fn\n          }\n          const nodeArgs = node.args ? this.fnParseArgs(node.args) : [];\n          let right = this.parseNode(node.right);\n          if ((node.right.pos - node.pos) > 2) { // space between fn and identifier?\n              right = CodeGeneratorBasic.fnSpace1(right); // keep it\n          }\n          return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + right + nodeArgs.join(\"\");\n      }\n      fnFor(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              if (i !== 1 && i !== 2) { // not for \"=\" and startValue\n                  nodeArgs[i] = CodeGeneratorBasic.fnSpace1(nodeArgs[i]); // set minimal spaces in case we do not keep whitespace\n              }\n          }\n          return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + nodeArgs.join(\"\");\n      }\n      fnElse(node) {\n          return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + CodeGeneratorBasic.fnSpace1(this.combineArgsWithColon(this.fnParseArgs(node.args)));\n      }\n      fnIf(node) {\n          const nodeArgs = this.fnParseArgs(node.args), partName = nodeArgs.shift(); // \"then\"/\"goto\"\n          return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + CodeGeneratorBasic.fnSpace1(this.parseNode(node.right))\n              + CodeGeneratorBasic.fnSpace1(partName) + CodeGeneratorBasic.fnSpace1(this.combineArgsWithColon(nodeArgs));\n      }\n      inputLineInput(node) {\n          const nodeArgs = node.args ? this.fnParseArgs(node.args) : [], // also for clear input, which has no args\n          name = node.right ? this.parseNode(node.right) : \"\"; // line input?\n          return CodeGeneratorBasic.fnWs(node) + CodeGeneratorBasic.getUcKeyword(node) + CodeGeneratorBasic.fnSpace1(name) + CodeGeneratorBasic.fnSpace1(nodeArgs.join(\"\"));\n      }\n      list(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          if (nodeArgs.length && nodeArgs[0] === \"\") { // empty range?\n              nodeArgs.shift(); // remove\n          }\n          if (nodeArgs.length && nodeArgs[nodeArgs.length - 1] === \"#\") { // dummy stream?\n              nodeArgs.pop(); // remove\n          }\n          return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + CodeGeneratorBasic.fnSpace1(nodeArgs.join(\"\"));\n      }\n      mid$Assign(node) {\n          return CodeGeneratorBasic.fnWs(node) + CodeGeneratorBasic.getUcKeyword(node) + this.fnParseArgs(node.args).join(\"\");\n      }\n      onBreakOrError(node) {\n          return CodeGeneratorBasic.fnWs(node) + \"ON\" + CodeGeneratorBasic.fnSpace1(this.parseNode(node.right)) + CodeGeneratorBasic.fnSpace1(this.fnParseArgs(node.args).join(\"\"));\n      }\n      onGotoGosub(node) {\n          const nodeArgs = this.fnParseArgs(node.args), expression = nodeArgs.shift(), instruction = nodeArgs.shift(); // \"goto\" or \"gosub\"\n          return CodeGeneratorBasic.fnWs(node) + \"ON\" + CodeGeneratorBasic.fnSpace1(expression) + CodeGeneratorBasic.fnSpace1(instruction) + CodeGeneratorBasic.fnSpace1(nodeArgs.join(\"\"));\n      }\n      onSqGosub(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          nodeArgs[nodeArgs.length - 2] = CodeGeneratorBasic.fnSpace1(nodeArgs[nodeArgs.length - 2]); // \"gosub\" with space (optional)\n          nodeArgs[nodeArgs.length - 1] = CodeGeneratorBasic.fnSpace1(nodeArgs[nodeArgs.length - 1]); // line number with space\n          return CodeGeneratorBasic.fnWs(node) + \"ON\" + CodeGeneratorBasic.fnSpace1(this.parseNode(node.right)) + nodeArgs.join(\"\");\n      }\n      print(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          let value = \"\";\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              value += nodeArgs[i];\n          }\n          if (node.value !== \"?\") { // for \"print\"\n              value = CodeGeneratorBasic.fnSpace1(value);\n          }\n          return CodeGeneratorBasic.fnWs(node) + node.value.toUpperCase() + value; // we use value to get PRINT or ?\n      }\n      rem(node) {\n          return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + this.fnParseArgs(node.args).join(\"\");\n      }\n      using(node) {\n          const nodeArgs = this.fnParseArgs(node.args), template = nodeArgs.length ? nodeArgs.shift() || \"\" : \"\";\n          return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + CodeGeneratorBasic.fnSpace1(template) + nodeArgs.join(\"\");\n      }\n      write(node) {\n          return CodeGeneratorBasic.fnWs(node) + node.type.toUpperCase() + (node.args ? CodeGeneratorBasic.fnSpace1(this.fnParseArgs(node.args).join(\"\")) : \"\"); // separators already there\n      }\n      /* eslint-disable no-invalid-this */\n      parseFunctions = {\n          \"(\": this.fnParenthesisOpen,\n          string: CodeGeneratorBasic.string,\n          ustring: CodeGeneratorBasic.ustring,\n          assign: this.assign,\n          expnumber: CodeGeneratorBasic.expnumber,\n          binnumber: CodeGeneratorBasic.binHexNumber,\n          hexnumber: CodeGeneratorBasic.binHexNumber,\n          label: this.label,\n          \"|\": this.vertical,\n          afterGosub: this.afterEveryGosub,\n          chain: this.chainOrChainMerge,\n          chainMerge: this.chainOrChainMerge,\n          data: this.data,\n          def: this.def,\n          \"else\": this.fnElse,\n          elseComment: this.elseComment,\n          everyGosub: this.afterEveryGosub,\n          fn: this.fn,\n          \"for\": this.fnFor,\n          \"if\": this.fnIf,\n          input: this.inputLineInput,\n          lineInput: this.inputLineInput,\n          list: this.list,\n          mid$Assign: this.mid$Assign,\n          onBreakCont: this.onBreakOrError, // 3 parts\n          onBreakGosub: this.onBreakOrError,\n          onBreakStop: this.onBreakOrError,\n          onErrorGoto: this.onBreakOrError,\n          onGosub: this.onGotoGosub,\n          onGoto: this.onGotoGosub,\n          onSqGosub: this.onSqGosub,\n          print: this.print,\n          rem: this.rem,\n          using: this.using,\n          write: this.write\n      };\n      /* eslint-enable no-invalid-this */\n      fnParseOther(node) {\n          const type = node.type;\n          let value = \"\"; // CodeGeneratorBasic.fnGetWs(node);\n          if (node.left) {\n              value += this.parseNode(node.left);\n          }\n          value += CodeGeneratorBasic.fnWs(node);\n          const keyType = this.keywords[type];\n          if (keyType) {\n              value += CodeGeneratorBasic.getUcKeyword(node);\n          }\n          else if (node.value) { // e.g. string,...\n              value += node.value;\n          }\n          let right = \"\";\n          if (node.right) {\n              right = this.parseNode(node.right);\n              const needSpace1 = this.keywords[right.toLowerCase()] || keyType;\n              value += needSpace1 ? CodeGeneratorBasic.fnSpace1(right) : right;\n          }\n          if (node.args) {\n              const nodeArgs = this.fnParseArgs(node.args).join(\"\"), needSpace2 = keyType && keyType.charAt(0) !== \"f\" && node.type !== \"'\";\n              // special handling for combined keywords with 2 tokens (for 3 tokens, we need a specific function)\n              value += needSpace2 ? CodeGeneratorBasic.fnSpace1(nodeArgs) : nodeArgs;\n          }\n          return value;\n      }\n      static getLeftOrRightOperatorPrecedence(node) {\n          const precedence = CodeGeneratorBasic.operatorPrecedence, operators = CodeGeneratorBasic.operators;\n          let pr;\n          if (operators[node.type] && (node.left || node.right)) { // binary operator (or unary operator, e.g. not)\n              if (node.left) { // right is binary\n                  pr = precedence[node.type] || 0;\n              }\n              else {\n                  pr = precedence[\"p\" + node.type] || precedence[node.type] || 0;\n              }\n          }\n          return pr;\n      }\n      parseOperator(node) {\n          const precedence = CodeGeneratorBasic.operatorPrecedence, operators = CodeGeneratorBasic.operators;\n          let value;\n          if (node.left) {\n              value = this.parseNode(node.left);\n              const p = precedence[node.type], pl = CodeGeneratorBasic.getLeftOrRightOperatorPrecedence(node.left);\n              if (pl !== undefined && pl < p) {\n                  value = \"(\" + value + \")\";\n              }\n              const right = node.right;\n              let value2 = this.parseNode(right);\n              const pr = CodeGeneratorBasic.getLeftOrRightOperatorPrecedence(right);\n              if (pr !== undefined) {\n                  if (pr < p) {\n                      // Lower precedence on right: always needs parentheses\n                      value2 = \"(\" + value2 + \")\";\n                  }\n                  else if (pr === p) {\n                      // Equal precedence: check associativity\n                      const assoc = CodeGeneratorBasic.operatorAssociativity[node.type];\n                      if (assoc === \"right\") {\n                          // Right-associative: no parentheses needed for equal precedence\n                          // e.g., 2^3^4 = 2^(3^4)\n                      }\n                      else if (assoc === \"left\") {\n                          // Left-associative: parentheses needed for non-commutative operators\n                          // Commutative operators: + and * (associativity handles it)\n                          // Non-commutative: - / \\ mod (must preserve grouping)\n                          // eslint-disable-next-line max-depth\n                          if ((/(^|-|\\/|\\\\|mod|=|<>|<|<=|>|>=)$/).test(node.type)) {\n                              value2 = \"(\" + value2 + \")\";\n                          }\n                      }\n                      else {\n                          // \"none\" (comparison operators): always keep parentheses\n                          value2 = \"(\" + value2 + \")\";\n                      }\n                  }\n              }\n              const operator = CodeGeneratorBasic.fnWs(node) + operators[node.type].toUpperCase();\n              if ((/^(and|or|xor|mod)$/).test(node.type)) {\n                  value += CodeGeneratorBasic.fnSpace1(operator) + CodeGeneratorBasic.fnSpace1(value2);\n              }\n              else {\n                  value += operator + value2;\n              }\n          }\n          else if (node.right) { // unary operator, e.g. not, '#'\n              if (node.len === 0) {\n                  value = \"\"; // ignore dummy token, e.g. '#'\n              }\n              else {\n                  const right = node.right;\n                  value = this.parseNode(right);\n                  let pr;\n                  if (right.left) { // was binary op?\n                      pr = precedence[right.type] || 0; // no special prio\n                  }\n                  else {\n                      pr = precedence[\"p\" + right.type] || precedence[right.type] || 0; // check unary operator first\n                  }\n                  const p = precedence[\"p\" + node.type] || precedence[node.type] || 0; // check unary operator first\n                  if (p && pr && (pr < p)) {\n                      value = \"(\" + value + \")\";\n                  }\n                  value = CodeGeneratorBasic.fnWs(node) + operators[node.type].toUpperCase() + (node.type === \"not\" ? CodeGeneratorBasic.fnSpace1(value) : value);\n              }\n          }\n          else { // no operator, e.g. \"=\" in \"for\"\n              value = this.fnParseOther(node);\n          }\n          return value;\n      }\n      parseNode(node) {\n          const type = node.type;\n          if (Utils.debug > 3) {\n              Utils.console.debug(\"evaluate: parseNode node=%o type=\" + type + \" value=\" + node.value + \" left=%o right=%o args=%o\", node, node.left, node.right, node.args);\n          }\n          let value;\n          if (CodeGeneratorBasic.operators[type]) {\n              value = this.parseOperator(node);\n          }\n          else if (this.parseFunctions[type]) { // function with special handling?\n              value = this.parseFunctions[type].call(this, node);\n          }\n          else { // for other functions, generate code directly\n              if ((type === \"identifier\" || type === \"letter\") && this.options.lowercaseVars) {\n                  node.value = node.value.toLowerCase();\n              }\n              value = this.fnParseOther(node);\n          }\n          return value;\n      }\n      evaluate(parseTree) {\n          let output = \"\";\n          for (let i = 0; i < parseTree.length; i += 1) {\n              if (Utils.debug > 2) {\n                  Utils.console.debug(\"evaluate: parseTree i=%d, node=%o\", i, parseTree[i]);\n              }\n              const line = this.parseNode(parseTree[i]);\n              if ((line !== undefined) && (line !== \"\")) {\n                  if (line !== null) {\n                      if (output.length === 0) {\n                          output = line;\n                      }\n                      else {\n                          output += line;\n                      }\n                  }\n                  else {\n                      output = \"\"; // cls (clear output when node is set to null)\n                  }\n              }\n          }\n          return output;\n      }\n      generate(input) {\n          const out = {\n              text: \"\"\n          };\n          this.hasColons = Boolean(this.options.parser.getOptions().keepColons);\n          this.keepWhiteSpace = Boolean(this.options.lexer.getOptions().keepWhiteSpace);\n          this.keywords = this.options.parser.getKeywords();\n          this.line = 0;\n          try {\n              const tokens = this.options.lexer.lex(input), parseTree = this.options.parser.parse(tokens), output = this.evaluate(parseTree);\n              out.text = output;\n          }\n          catch (e) {\n              if (Utils.isCustomError(e)) {\n                  out.error = e;\n                  if (!this.options.quiet) {\n                      Utils.console.warn(e); // show our customError as warning\n                  }\n              }\n              else { // other errors\n                  out.error = e; // force set other error\n                  Utils.console.error(e);\n              }\n          }\n          return out;\n      }\n  }\n\n  // ===== dist/esm/CodeGeneratorJs.js =====\n  // CodeGeneratorJs.ts - Code Generator for JavaScript\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n  //\n\n  class CodeGeneratorJs {\n      options;\n      line = \"0\"; // current line (label)\n      reJsKeywords;\n      stack = {\n          forLabel: [],\n          forVarName: [],\n          whileLabel: []\n      };\n      gosubCount = 0;\n      ifCount = 0;\n      stopCount = 0;\n      forCount = 0; // stack needed\n      whileCount = 0; // stack needed\n      referencedLabelsCount = {};\n      dataList = []; // collected data from data lines\n      labelList = []; // all labels\n      sourceMap = {};\n      countMap = {};\n      // for evaluate:\n      variables = {}; // will be set later\n      defScopeArgs;\n      defintDefstrTypes = {};\n      constructor(options) {\n          this.options = {\n              quiet: false\n          };\n          this.setOptions(options); // optional options\n          this.reJsKeywords = CodeGeneratorJs.createJsKeywordRegex();\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      // ECMA 3 JS Keywords which must be avoided in dot notation for properties when using IE8\n      static jsKeywords = [\n          \"do\",\n          \"if\",\n          \"in\",\n          \"for\",\n          \"int\",\n          \"new\",\n          \"try\",\n          \"var\",\n          \"byte\",\n          \"case\",\n          \"char\",\n          \"else\",\n          \"enum\",\n          \"goto\",\n          \"long\",\n          \"null\",\n          \"this\",\n          \"true\",\n          \"void\",\n          \"with\",\n          \"break\",\n          \"catch\",\n          \"class\",\n          \"const\",\n          \"false\",\n          \"final\",\n          \"float\",\n          \"short\",\n          \"super\",\n          \"throw\",\n          \"while\",\n          \"delete\",\n          \"double\",\n          \"export\",\n          \"import\",\n          \"native\",\n          \"public\",\n          \"return\",\n          \"static\",\n          \"switch\",\n          \"throws\",\n          \"typeof\",\n          \"boolean\",\n          \"default\",\n          \"extends\",\n          \"finally\",\n          \"package\",\n          \"private\",\n          \"abstract\",\n          \"continue\",\n          \"debugger\",\n          \"function\",\n          \"volatile\",\n          \"interface\",\n          \"protected\",\n          \"transient\",\n          \"implements\",\n          \"instanceof\",\n          \"synchronized\"\n      ];\n      reset() {\n          const stack = this.stack;\n          stack.forLabel.length = 0;\n          stack.forVarName.length = 0;\n          stack.whileLabel.length = 0;\n          this.line = \"0\"; // current line (label)\n          this.resetCountsPerLine();\n          this.labelList.length = 0;\n          this.dataList.length = 0;\n          this.sourceMap = {};\n          this.referencedLabelsCount = {}; // labels or line numbers\n          this.countMap = {};\n      }\n      resetCountsPerLine() {\n          this.gosubCount = 0;\n          this.ifCount = 0;\n          this.stopCount = 0;\n          this.forCount = 0; // stack needed\n          this.whileCount = 0; // stack needed\n      }\n      composeError(error, message, value, pos) {\n          return Utils.composeError(\"CodeGeneratorJs\", error, message, value, pos, undefined, this.line);\n      }\n      static createJsKeywordRegex() {\n          return new RegExp(\"^(\" + CodeGeneratorJs.jsKeywords.join(\"|\") + \")$\");\n      }\n      fnDeclareVariable(name) {\n          if (!this.variables.variableExist(name)) { // variable not yet defined?\n              this.variables.initVariable(name);\n          }\n      }\n      static varTypeMap = {\n          \"!\": \"R\",\n          \"%\": \"I\",\n          $: \"$\" // or \"S\"?\n      };\n      fnAdaptVariableName(node, name, arrayIndices) {\n          const defScopeArgs = this.defScopeArgs;\n          name = name.toLowerCase().replace(/\\./g, \"_\");\n          const firstChar = name.charAt(0);\n          if ((defScopeArgs && !defScopeArgs.suppressEscape) || !Utils.supportReservedNames) { // avoid keywords as def fn parameters (keep for ERASE); and for IE8 avoid keywords in dot notation\n              if (this.reJsKeywords.test(name)) { // IE8: avoid keywords in dot notation\n                  name = \"_\" + name; // prepend underscore\n              }\n          }\n          const mappedTypeChar = CodeGeneratorJs.varTypeMap[name.charAt(name.length - 1)] || \"\"; // map last char\n          if (mappedTypeChar) {\n              name = name.slice(0, -1); // remove type char\n              node.pt = name.charAt(name.length - 1); // set also type; TODO currently not used\n          }\n          if (arrayIndices) {\n              name += \"A\".repeat(arrayIndices);\n          }\n          name += mappedTypeChar; // put type at the end\n          let needDeclare = false;\n          if (defScopeArgs) {\n              if (!defScopeArgs.suppressEscape) { // do not escape variable names for ERASE\n                  if (name === \"o\" || name === \"t\" || name === \"v\") { // we must not use formal parameter \"o\", \"t\", \"v\", since we use them already\n                      name = \"N\" + name; // change variable name to something we cannot set in BASIC\n                  }\n              }\n              if (!defScopeArgs.collectDone) { // in collection mode?\n                  defScopeArgs[name] = true; // declare DEF scope variable\n              }\n              else if (!(name in defScopeArgs)) {\n                  needDeclare = true;\n              }\n          }\n          else {\n              needDeclare = true;\n          }\n          if (needDeclare) {\n              if (mappedTypeChar) { // we have an explicit type\n                  this.fnDeclareVariable(name);\n                  name = \"v.\" + name; // access with \"v.\"\n              }\n              else if (!this.defintDefstrTypes[firstChar]) {\n                  // the first char of the variable name is not defined via DEFINT or DEFSTR in the program\n                  name += \"R\"; // then we know that the type is real\n                  this.fnDeclareVariable(name);\n                  name = \"v.\" + name; // access with \"v.\"\n              }\n              else {\n                  // we do not know which type we will need, so declare for all types\n                  this.fnDeclareVariable(name + \"I\");\n                  this.fnDeclareVariable(name + \"R\");\n                  this.fnDeclareVariable(name + \"$\");\n                  name = 'v[\"' + name + '\" + t.' + name.charAt(0) + \"]\";\n              }\n          }\n          return name;\n      }\n      fnParseOneArg(arg) {\n          this.parseNode(arg); // eslint-disable-line no-use-before-define\n          return arg.pv;\n      }\n      fnParseArgRange(args, start, stop) {\n          const nodeArgs = []; // do not modify node.args here (could be a parameter of defined function)\n          for (let i = start; i <= stop; i += 1) {\n              nodeArgs.push(this.fnParseOneArg(args[i]));\n          }\n          return nodeArgs;\n      }\n      fnParseArgs(args) {\n          if (!args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", \"\", -1); // should not occur\n          }\n          return this.fnParseArgRange(args, 0, args.length - 1);\n      }\n      fnParseArgsIgnoringCommaSemi(args) {\n          const nodeArgs = [];\n          for (let i = 0; i < args.length; i += 1) {\n              if (args[i].type !== \",\" && args[i].type !== \";\") { // ignore separators\n                  nodeArgs.push(this.fnParseOneArg(args[i]));\n              }\n          }\n          return nodeArgs;\n      }\n      fnDetermineStaticVarType(name) {\n          return this.variables.determineStaticVarType(name);\n      }\n      static fnExtractVarName(name) {\n          if (name.indexOf(\"v.\") === 0) { // variable object?\n              name = name.substring(2); // remove preceding \"v.\"\n              const bracketIndex = name.indexOf(\"[\");\n              if (bracketIndex >= 0) {\n                  name = name.substring(0, bracketIndex);\n              }\n          }\n          if (name.indexOf('v[\"') === 0) { // variable object in brackets?\n              name = name.substring(3); // remove preceding 'v[\"'\n              const quotesIndex = name.indexOf('\"');\n              name = name.substring(0, quotesIndex);\n          }\n          return name;\n      }\n      static fnGetNameTypeExpression(name) {\n          if (name.indexOf(\"v.\") === 0) { // variable object with dot?\n              name = name.substring(2); // remove preceding \"v.\"\n              const bracketIndex = name.indexOf(\"[\");\n              if (bracketIndex >= 0) {\n                  name = name.substring(0, bracketIndex);\n              }\n              name = '\"' + name + '\"';\n          }\n          if (name.indexOf(\"v[\") === 0) { // variable object with brackets?\n              name = name.substring(2); // remove preceding \"v[\"\n              const closeBracketIndex = name.indexOf(\"]\");\n              name = name.substring(0, closeBracketIndex);\n          }\n          return name;\n      }\n      static fnIsIntConst(a) {\n          const reIntConst = /^[+-]?(\\d+|0x[0-9a-f]+|0b[0-1]+)$/; // regex for integer, hex, binary constant\n          return reIntConst.test(a);\n      }\n      fnGetRoundString(node, err) {\n          if (node.pt !== \"I\") { // no rounding needed for integer, hex, binary constants, integer variables, functions returning integer (optimization)\n              node.pv = \"o.vmRound(\" + node.pv + \")\";\n          }\n          return this.options.integerOverflow ? \"o.vmInRange16(\" + node.pv + ', \"' + err + '\")' : node.pv;\n      }\n      static fnIsInString(string, find) {\n          return find && string.indexOf(find) >= 0;\n      }\n      fnPropagateStaticTypes(node, left, right, types) {\n          if (left.pt && right.pt) {\n              if (CodeGeneratorJs.fnIsInString(types, left.pt + right.pt)) {\n                  node.pt = left.pt === right.pt ? left.pt : \"R\";\n              }\n              else {\n                  throw this.composeError(Error(), \"Type error\", node.value, node.pos);\n              }\n          }\n          else if (left.pt && !CodeGeneratorJs.fnIsInString(types, left.pt) || right.pt && !CodeGeneratorJs.fnIsInString(types, right.pt)) {\n              throw this.composeError(Error(), \"Type error\", node.value, node.pos);\n          }\n      }\n      // operators\n      plus(node, left, right) {\n          if (left === undefined) { // unary plus? => skip it\n              node.pv = right.pv;\n              const type = right.pt;\n              if (CodeGeneratorJs.fnIsInString(\"IR$\", type)) { // I, R or $?\n                  node.pt = type;\n              }\n              else if (type) {\n                  throw this.composeError(Error(), \"Type error\", node.value, node.pos);\n              }\n          }\n          else {\n              node.pv = left.pv + \" + \" + right.pv;\n              this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI $$\");\n          }\n      }\n      minus(node, left, right) {\n          if (left === undefined) { // unary minus?\n              const value = right.pv, type = right.pt;\n              // when optimizing, beware of \"--\" operator in JavaScript!\n              if (CodeGeneratorJs.fnIsIntConst(value) || right.type === \"number\") { // int const or number const (also fp)\n                  if (value.charAt(0) === \"-\") { // starting already with \"-\"?\n                      node.pv = value.substring(1); // remove \"-\"\n                  }\n                  else {\n                      node.pv = \"-\" + value;\n                  }\n              }\n              else {\n                  node.pv = \"-(\" + value + \")\"; // can be an expression\n              }\n              if (CodeGeneratorJs.fnIsInString(\"IR\", type)) { // I or R?\n                  node.pt = type;\n              }\n              else if (type) {\n                  throw this.composeError(Error(), \"Type error\", node.value, node.pos);\n              }\n          }\n          else {\n              node.pv = left.pv + \" - \" + right.pv;\n              this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI\");\n          }\n      }\n      mult(node, left, right) {\n          node.pv = left.pv + \" * \" + right.pv;\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI\");\n      }\n      div(node, left, right) {\n          node.pv = left.pv + \" / \" + right.pv;\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI\");\n          node.pt = \"R\"; // event II can get a fraction\n      }\n      intDiv(node, left, right) {\n          node.pv = \"(\" + this.fnGetRoundString(left, \"IDIV\") + \" / \" + this.fnGetRoundString(right, \"IDIV\") + \") | 0\"; // integer division\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI\");\n          node.pt = \"I\";\n      }\n      exponent(node, left, right) {\n          node.pv = \"Math.pow(\" + left.pv + \", \" + right.pv + \")\";\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI\");\n      }\n      and(node, left, right) {\n          node.pv = this.fnGetRoundString(left, \"AND\") + \" & \" + this.fnGetRoundString(right, \"AND\");\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI\");\n          node.pt = \"I\";\n      }\n      or(node, left, right) {\n          node.pv = this.fnGetRoundString(left, \"OR\") + \" | \" + this.fnGetRoundString(right, \"OR\");\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI\");\n          node.pt = \"I\";\n      }\n      xor(node, left, right) {\n          node.pv = this.fnGetRoundString(left, \"XOR\") + \" ^ \" + this.fnGetRoundString(right, \"XOR\");\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI\");\n          node.pt = \"I\";\n      }\n      not(node, _oLeft, right) {\n          node.pv = \"~(\" + this.fnGetRoundString(right, \"NOT\") + \")\"; // a can be an expression\n          node.pt = \"I\";\n      }\n      mod(node, left, right) {\n          node.pv = this.fnGetRoundString(left, \"MOD\") + \" % \" + this.fnGetRoundString(right, \"MOD\");\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI\");\n          node.pt = \"I\";\n      }\n      greater(node, left, right) {\n          node.pv = left.pv + \" > \" + right.pv + \" ? -1 : 0\";\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI $$\");\n          node.pt = \"I\";\n      }\n      less(node, left, right) {\n          node.pv = left.pv + \" < \" + right.pv + \" ? -1 : 0\";\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI $$\");\n          node.pt = \"I\";\n      }\n      greaterEqual(node, left, right) {\n          node.pv = left.pv + \" >= \" + right.pv + \" ? -1 : 0\";\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI $$\");\n          node.pt = \"I\";\n      }\n      lessEqual(node, left, right) {\n          node.pv = left.pv + \" <= \" + right.pv + \" ? -1 : 0\";\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI $$\");\n          node.pt = \"I\";\n      }\n      equal(node, left, right) {\n          node.pv = left.pv + \" === \" + right.pv + \" ? -1 : 0\";\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI $$\");\n          node.pt = \"I\";\n      }\n      notEqual(node, left, right) {\n          node.pv = left.pv + \" !== \" + right.pv + \" ? -1 : 0\";\n          this.fnPropagateStaticTypes(node, left, right, \"II RR IR RI $$\");\n          node.pt = \"I\";\n      }\n      addressOf(node, _oLeft, right) {\n          if (right.type !== \"identifier\") {\n              throw this.composeError(Error(), \"Expected variable\", node.value, node.pos);\n          }\n          // we want a name, for arrays with \"A\"'s but without array indices\n          const name = CodeGeneratorJs.fnGetNameTypeExpression(right.pv);\n          node.pv = \"o.addressOf(\" + name + \")\"; // address of\n          node.pt = \"I\";\n      }\n      static stream(node, _oLeft, right) {\n          // \"#\" stream as prefix operator\n          node.pv = right.pv;\n          node.pt = \"I\";\n      }\n      /* eslint-disable no-invalid-this */\n      allOperators = {\n          \"+\": this.plus,\n          \"-\": this.minus,\n          \"*\": this.mult,\n          \"/\": this.div,\n          \"\\\\\": this.intDiv,\n          \"^\": this.exponent,\n          and: this.and,\n          or: this.or,\n          xor: this.xor,\n          not: this.not,\n          mod: this.mod,\n          \">\": this.greater,\n          \"<\": this.less,\n          \">=\": this.greaterEqual,\n          \"<=\": this.lessEqual,\n          \"=\": this.equal,\n          \"<>\": this.notEqual,\n          \"@\": this.addressOf,\n          \"#\": CodeGeneratorJs.stream\n      };\n      unaryOperators = {\n          \"+\": this.plus,\n          \"-\": this.minus,\n          not: this.not,\n          \"@\": this.addressOf,\n          \"#\": CodeGeneratorJs.stream\n      };\n      /* eslint-enable no-invalid-this */\n      fnParseDefIntRealStr(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              const arg = nodeArgs[i];\n              nodeArgs[i] = \"o.\" + node.type + '(\"' + arg + '\")';\n          }\n          node.pv = nodeArgs.join(\"; \");\n      }\n      fnAddReferenceLabel(label, node) {\n          if (label in this.referencedLabelsCount) {\n              this.referencedLabelsCount[label] += 1;\n          }\n          else {\n              if (Utils.debug > 1) {\n                  Utils.console.debug(\"fnAddReferenceLabel: line does not (yet) exist:\", label);\n              }\n              if (!this.countMap.merge && !this.countMap.chainMerge) {\n                  throw this.composeError(Error(), \"Line does not exist\", label, node.pos);\n              }\n          }\n      }\n      fnGetForLabel() {\n          const label = this.line + \"f\" + this.forCount;\n          this.forCount += 1;\n          return label;\n      }\n      fnGetGosubLabel() {\n          const label = this.line + \"g\" + this.gosubCount;\n          this.gosubCount += 1;\n          return label;\n      }\n      fnGetIfLabel() {\n          const label = this.line + \"i\" + this.ifCount;\n          this.ifCount += 1;\n          return label;\n      }\n      fnGetStopLabel() {\n          const label = this.line + \"s\" + this.stopCount;\n          this.stopCount += 1;\n          return label;\n      }\n      fnGetWhileLabel() {\n          const label = this.line + \"w\" + this.whileCount;\n          this.whileCount += 1;\n          return label;\n      }\n      fnCommandWithGoto(node, nodeArgs) {\n          nodeArgs = nodeArgs || this.fnParseArgs(node.args);\n          const label = this.fnGetStopLabel();\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \"); o.vmGoto(\\\"\" + label + \"\\\"); break;\\ncase \\\"\" + label + \"\\\":\";\n          return node.pv;\n      }\n      static commaOrSemicolon(node) {\n          node.pv = node.type;\n      }\n      vertical(node) {\n          const rsxName = node.value.substring(1).toLowerCase(), nodeArgs = this.fnParseArgs(node.args), label = this.fnGetStopLabel();\n          nodeArgs.unshift('\"' + rsxName + '\"'); // put as first arg\n          node.pv = \"o.callRsx(\" + nodeArgs.join(\", \") + \"); o.vmGoto(\\\"\" + label + \"\\\"); break;\\ncase \\\"\" + label + \"\\\":\"; // most RSX commands need goto (era, ren,...)\n      }\n      static number(node) {\n          node.pt = (/^\\d+$/).test(node.value) ? \"I\" : \"R\";\n          node.pv = node.value;\n      }\n      static expnumber(node) {\n          node.pt = \"R\";\n          node.pv = node.value;\n      }\n      static binnumber(node) {\n          let value = node.value.slice(2); // remove &x\n          if (Utils.supportsBinaryLiterals) {\n              value = \"0b\" + ((value.length) ? value : \"0\"); // &x->0b; 0b is ES6\n          }\n          else {\n              value = \"0x\" + ((value.length) ? parseInt(value, 2).toString(16) : \"0\"); // we convert it to hex\n          }\n          node.pt = \"I\";\n          node.pv = value;\n      }\n      static hexnumber(node) {\n          let value = node.value.slice(1); // remove &\n          if (value.charAt(0).toLowerCase() === \"h\") { // optional h\n              value = value.slice(1); // remove\n          }\n          value ||= \"0\";\n          let n = parseInt(value, 16);\n          if (n > 32767) { //\ttwo's complement\n              n = 65536 - n;\n              value = \"-0x\" + n.toString(16);\n          }\n          else {\n              value = \"0x\" + value;\n          }\n          node.pt = \"I\";\n          node.pv = value;\n      }\n      identifier(node) {\n          const nodeArgs = node.args ? this.fnParseArgRange(node.args, 1, node.args.length - 2) : [], // array: we skip open and close bracket\n          name = this.fnAdaptVariableName(node, node.value, nodeArgs.length); // here we use node.value;\n          let indices = \"\";\n          for (let i = 0; i < nodeArgs.length; i += 1) { // array indices\n              const arg = node.args[i + 1], // +1 because of opening braket\n              index = arg.pt !== \"I\" ? (\"o.vmRound(\" + nodeArgs[i] + \")\") : nodeArgs[i];\n              // can we use fnGetRoundString()?\n              indices += \"[\" + index + \"]\";\n          }\n          const varType = this.fnDetermineStaticVarType(name);\n          if (varType.length > 1) {\n              node.pt = varType.charAt(1);\n          }\n          node.pv = name + indices;\n      }\n      static letter(node) {\n          node.pv = node.value.toLowerCase();\n      }\n      static linenumber(node) {\n          node.pv = node.value;\n      }\n      range(node) {\n          if (!node.left || !node.right) {\n              throw this.composeError(Error(), \"Programming error: Undefined left or right\", node.type, node.pos); // should not occur\n          }\n          const left = this.fnParseOneArg(node.left).toLowerCase(), right = this.fnParseOneArg(node.right).toLowerCase();\n          if (left > right) {\n              throw this.composeError(Error(), \"Decreasing range\", node.value, node.pos);\n          }\n          node.pv = left + '\", \"' + right;\n      }\n      linerange(node) {\n          if (!node.left || !node.right) {\n              throw this.composeError(Error(), \"Programming error: Undefined left or right\", node.type, node.pos); // should not occur\n          }\n          const left = this.fnParseOneArg(node.left), right = this.fnParseOneArg(node.right), leftNumber = Number(left), // \"undefined\" gets NaN (should we check node.left.type for null?)\n          rightNumber = Number(right);\n          if (leftNumber > rightNumber) { // comparison with NaN and number is always false\n              throw this.composeError(Error(), \"Decreasing line range\", node.value, node.pos);\n          }\n          const rightSpecified = (right === \"undefined\") ? \"65535\" : right; // make sure we set a missing right range parameter\n          node.pv = !right ? left : left + \", \" + rightSpecified;\n      }\n      static string(node) {\n          let value = node.value;\n          value = value.replace(/\\\\/g, \"\\\\\\\\\"); // escape backslashes\n          value = Utils.hexEscape(value);\n          node.pt = \"$\";\n          node.pv = '\"' + value + '\"';\n      }\n      static unquoted(node) {\n          node.pt = \"$\";\n          node.pv = node.value;\n      }\n      static fnNull(node) {\n          node.pv = node.value || \"undefined\"; // use explicit value or \"undefined\"\n      }\n      assign(node) {\n          // see also \"let\"\n          if (!node.left || !node.right) {\n              throw this.composeError(Error(), \"Programming error: Undefined left or right\", node.type, node.pos); // should not occur\n          }\n          if (node.left.type !== \"identifier\") {\n              throw this.composeError(Error(), \"Unexpected assign type\", node.type, node.pos); // should not occur\n          }\n          const name = this.fnParseOneArg(node.left), assignValue = this.fnParseOneArg(node.right);\n          this.fnPropagateStaticTypes(node, node.left, node.right, \"II RR IR RI $$\");\n          const varType = this.fnDetermineStaticVarType(name);\n          let value;\n          if (node.pt) {\n              if (node.left.pt === \"I\" && node.right.pt === \"R\") { // special handing for IR: rounding needed\n                  value = \"o.vmRound(\" + assignValue + \")\";\n                  node.pt = \"I\"; // \"R\" => \"I\"\n              }\n              else {\n                  value = assignValue;\n              }\n          }\n          else {\n              value = \"o.vmAssign(\\\"\" + varType + \"\\\", \" + assignValue + \")\";\n          }\n          node.pv = name + \" = \" + value;\n      }\n      generateTraceLabel(node, tracePrefix, i) {\n          const traceLabel = tracePrefix + ((i > 0) ? \"t\" + i : \"\"), pos = node.pos, len = node.len || node.value.length || 0;\n          this.sourceMap[traceLabel] = [\n              pos,\n              len\n          ];\n          return traceLabel;\n      }\n      label(node) {\n          const isTraceActive = this.options.trace || Boolean(this.countMap.tron), isResumeNext = Boolean(this.countMap.resumeNext), isResumeNoArgs = Boolean(this.countMap.resumeNoArgsCount);\n          let label = node.value;\n          this.line = label; // set line before parsing args\n          if (this.countMap.resumeNext) {\n              this.labelList.push(label); // only needed to support resume next\n          }\n          this.resetCountsPerLine(); // we want to have \"stable\" counts, even if other lines change, e.g. direct\n          const isDirect = label === \"direct\";\n          let value = \"\";\n          if (isDirect) { // special handling for direct\n              value = \"o.vmGoto(\\\"directEnd\\\"); break;\\n\";\n              label = '\"direct\"';\n          }\n          if (!this.options.noCodeFrame) {\n              value += \"case \" + label + \":\";\n              value += \" o.line = \" + label + \";\";\n              if (isTraceActive) {\n                  value += \" o.vmTrace();\";\n              }\n          }\n          else {\n              value = \"\";\n          }\n          const nodeArgs = this.fnParseArgs(node.args);\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              let value2 = nodeArgs[i];\n              if (value2 !== \"\") {\n                  if (isTraceActive || isResumeNext || isResumeNoArgs) {\n                      const traceLabel = this.generateTraceLabel(node.args[i], this.line, i); // side effect: put position in source map\n                      if (i > 0) { // only if not first statement in the line\n                          if (isResumeNext || isResumeNoArgs) { // eslint-disable-line max-depth\n                              value += '\\ncase \"' + traceLabel + '\":';\n                          }\n                          value += ' o.line = \"' + traceLabel + '\";';\n                          if (isResumeNext) { // eslint-disable-line max-depth\n                              this.labelList.push('\"' + traceLabel + '\"'); // only needed to support resume next\n                          }\n                      }\n                  }\n                  if (!(/[}:;\\n]$/).test(value2)) { // does not end with } : ; \\n\n                      value2 += \";\";\n                  }\n                  else if (value2.substring(value2.length - 1) === \"\\n\") {\n                      value2 = value2.substring(0, value2.length - 1);\n                  }\n                  value += \" \" + value2;\n              }\n          }\n          if (isDirect && !this.options.noCodeFrame) {\n              value += \"\\n o.vmGoto(\\\"end\\\"); break;\\ncase \\\"directEnd\\\":\"; // put in next line because of possible \"rem\"\n          }\n          node.pv = value;\n      }\n      // special keyword functions\n      afterEveryGosub(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          if (!node.args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", node.type, node.pos); // should not occur\n          }\n          this.fnAddReferenceLabel(nodeArgs[2], node.args[2]); // argument 2 = line number\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \")\";\n      }\n      static cont(node) {\n          node.pv = \"o.\" + node.type + \"(); break;\"; // append break\n      }\n      data(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          for (let i = 0; i < node.args.length; i += 1) {\n              if (node.args[i].type === \"unquoted\") {\n                  nodeArgs[i] = '\"' + nodeArgs[i].replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + '\"'; // escape backslashes and quotes, put in quotes\n              }\n          }\n          let lineString = String(this.line); // TODO: already string?\n          if (lineString === \"direct\") {\n              lineString = '\"' + lineString + '\"';\n          }\n          nodeArgs.unshift(lineString); // prepend line number\n          this.dataList.push(\"o.data(\" + nodeArgs.join(\", \") + \")\"); // will be set at the beginning of the script\n          node.pv = \"/* data */\";\n      }\n      def(node) {\n          if (!node.right) {\n              throw this.composeError(Error(), \"Programming error: Undefined right\", node.type, node.pos); // should not occur\n          }\n          const savedValue = node.right.value;\n          node.right.value = \"fn\" + savedValue; // prefix with \"fn\"\n          const name = this.fnParseOneArg(node.right);\n          node.right.value = savedValue; // restore\n          const expressionArg = node.args.pop();\n          this.defScopeArgs = {}; // collect DEF scope args\n          const nodeArgs = this.fnParseArgs(node.args);\n          this.defScopeArgs.collectDone = true; // collection done => now use them\n          const expression = this.fnParseOneArg(expressionArg);\n          this.defScopeArgs = undefined;\n          this.fnPropagateStaticTypes(node, node.right, expressionArg, \"II RR IR RI $$\");\n          let value;\n          if (node.pt) {\n              if (node.right.pt === \"I\" && expressionArg.pt === \"R\") { // special handing for IR: rounding needed\n                  value = \"o.vmRound(\" + expression + \")\";\n                  node.pt = \"I\"; // \"R\" => \"I\"\n              }\n              else {\n                  value = expression;\n              }\n          }\n          else {\n              const varType = this.fnDetermineStaticVarType(name);\n              value = \"o.vmAssign(\\\"\" + varType + \"\\\", \" + expression + \")\";\n          }\n          value = name + \" = function (\" + nodeArgs.join(\", \") + \") { return \" + value + \"; };\";\n          node.pv = value;\n      }\n      dim(node) {\n          const args = [];\n          if (!node.args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", node.type, node.pos); // should not occur\n          }\n          for (let i = 0; i < node.args.length; i += 1) {\n              const nodeArg = node.args[i];\n              if (nodeArg.type !== \"identifier\") {\n                  throw this.composeError(Error(), \"Expected variable in DIM\", node.type, node.pos);\n              }\n              if (!nodeArg.args) {\n                  throw this.composeError(Error(), \"Programming error: Undefined args\", nodeArg.type, nodeArg.pos); // should not occur\n              }\n              const nodeArgs = this.fnParseArgRange(nodeArg.args, 1, nodeArg.args.length - 2), // we skip open and close bracket\n              fullExpression = this.fnParseOneArg(nodeArg), name = CodeGeneratorJs.fnGetNameTypeExpression(fullExpression);\n              nodeArgs.unshift(name); // put as first arg\n              args.push(\"/* \" + fullExpression + \" = */ o.dim(\" + nodeArgs.join(\", \") + \")\");\n          }\n          node.pv = args.join(\"; \");\n      }\n      fnDelete(node) {\n          const nodeArgs = this.fnParseArgs(node.args), name = Utils.supportReservedNames ? (\"o.\" + node.type) : 'o[\"' + node.type + '\"]';\n          if (!nodeArgs.length) { // no arguments? => complete range\n              nodeArgs.push(\"1\");\n              nodeArgs.push(\"65535\");\n          }\n          node.pv = name + \"(\" + nodeArgs.join(\", \") + \"); break;\";\n      }\n      edit(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \"); break;\";\n      }\n      elseComment(node) {\n          if (!node.args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", \"\", -1); // should not occur\n          }\n          let value = \"else\"; // not: node.type;\n          for (let i = 0; i < node.args.length; i += 1) {\n              const token = node.args[i];\n              if (token.value) {\n                  value += \" \" + token.value;\n              }\n          }\n          node.pv = \"// \" + value + \"\\n\";\n      }\n      erase(node) {\n          this.defScopeArgs = {}; // collect DEF scope args\n          this.defScopeArgs.suppressEscape = true; // suppress escape with prefix \"N\"\n          const nodeArgs = this.fnParseArgs(node.args);\n          this.defScopeArgs = undefined;\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              nodeArgs[i] = '\"' + nodeArgs[i] + '\"'; // put in quotes\n          }\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \")\";\n      }\n      error(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \"); break\";\n      }\n      fn(node) {\n          if (!node.right) {\n              throw this.composeError(Error(), \"Programming error: Undefined right\", node.type, node.pos); // should not occur\n          }\n          const nodeArgs = this.fnParseArgs(node.args), savedValue = node.right.value;\n          node.right.value = \"fn\" + savedValue; // prefix with \"fn\"\n          const name = this.fnParseOneArg(node.right);\n          node.right.value = savedValue; // restore\n          if (node.right.pt) {\n              node.pt = node.right.pt;\n          }\n          node.pv = name + \"(\" + nodeArgs.join(\", \") + \")\";\n      }\n      static parseIntNumber(numString) {\n          // Number() cannot parse negative bin or hex numbers so detect a sign first\n          const hasSign = numString[0] === \"-\", value = hasSign ? -Number(numString.substring(1)) : Number(numString);\n          return value;\n      }\n      // eslint-disable-next-line complexity\n      fnFor(node) {\n          const nodeArgs = this.fnParseArgs(node.args), varName = nodeArgs[0], label = this.fnGetForLabel();\n          this.stack.forLabel.push(label);\n          this.stack.forVarName.push(varName);\n          if (!node.args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", node.type, node.pos); // should not occur\n          }\n          const startNode = node.args[1], endNode = node.args[2], stepNode = node.args[3]; // optional\n          let startValue = nodeArgs[1], endValue = nodeArgs[2], stepValue = stepNode ? nodeArgs[3] : \"1\"; // default step\n          // optimization for integer constants (check value and not type, because we also want to accept e.g. -<number>):\n          const startIsIntConst = CodeGeneratorJs.fnIsIntConst(startValue), endIsIntConst = CodeGeneratorJs.fnIsIntConst(endValue), stepIsIntConst = CodeGeneratorJs.fnIsIntConst(stepValue), varType = this.fnDetermineStaticVarType(varName), type = (varType.length > 1) ? varType.charAt(1) : \"\";\n          if (type === \"$\") {\n              throw this.composeError(Error(), \"Type error\", node.args[0].value, node.args[0].pos);\n          }\n          if (!startIsIntConst) {\n              if (startNode.pt !== \"I\") {\n                  startValue = \"o.vmAssign(\\\"\" + varType + \"\\\", \" + startValue + \")\"; // assign checks and rounds, if needed\n              }\n          }\n          let endName;\n          if (!endIsIntConst) {\n              if (endNode.pt !== \"I\") {\n                  endValue = \"o.vmAssign(\\\"\" + varType + \"\\\", \" + endValue + \")\";\n              }\n              endName = CodeGeneratorJs.fnExtractVarName(varName) + \"End\";\n              this.fnDeclareVariable(endName); // declare also end variable\n              endName = \"v.\" + endName;\n          }\n          if (varName.indexOf(\"v[\") === 0) { // untyped?\n              // TODO\n          }\n          let stepName;\n          if (!stepIsIntConst) {\n              if (stepNode && stepNode.pt !== \"I\") {\n                  stepValue = \"o.vmAssign(\\\"\" + varType + \"\\\", \" + stepValue + \")\";\n              }\n              stepName = CodeGeneratorJs.fnExtractVarName(varName) + \"Step\";\n              this.fnDeclareVariable(stepName); // declare also step variable\n              stepName = \"v.\" + stepName;\n          }\n          let value = \"/* for() */\";\n          if (type !== \"I\" && type !== \"R\") {\n              value += \" o.vmAssertNumberType(\\\"\" + varType + \"\\\");\"; // do a type check: assert number type\n          }\n          value += \" \" + varName + \" = \" + startValue + \";\";\n          if (!endIsIntConst) {\n              value += \" \" + endName + \" = \" + endValue + \";\";\n          }\n          if (!stepIsIntConst) {\n              value += \" \" + stepName + \" = \" + stepValue + \";\";\n          }\n          value += \" o.vmGoto(\\\"\" + label + \"b\\\"); break;\";\n          value += \"\\ncase \\\"\" + label + \"\\\": \";\n          value += varName + \" += \" + (stepIsIntConst ? stepValue : stepName) + \";\";\n          value += \"\\ncase \\\"\" + label + \"b\\\": \";\n          const endNameOrValue = endIsIntConst ? endValue : endName;\n          if (stepIsIntConst) {\n              const stepValueAsNum = CodeGeneratorJs.parseIntNumber(stepValue); // can also be a negative binary or hexadecimal string\n              if (stepValueAsNum > 0) {\n                  value += \"if (\" + varName + \" > \" + endNameOrValue + \") { o.vmGoto(\\\"\" + label + \"e\\\"); break; }\";\n              }\n              else if (stepValueAsNum < 0) {\n                  value += \"if (\" + varName + \" < \" + endNameOrValue + \") { o.vmGoto(\\\"\" + label + \"e\\\"); break; }\";\n              }\n              else { // stepValue === 0 => endless loop, if starting with variable !== end\n                  value += \"if (\" + varName + \" === \" + endNameOrValue + \") { o.vmGoto(\\\"\" + label + \"e\\\"); break; }\";\n              }\n          }\n          else {\n              value += \"if (\" + stepName + \" > 0 && \" + varName + \" > \" + endNameOrValue + \" || \" + stepName + \" < 0 && \" + varName + \" < \" + endNameOrValue + \" || !\" + stepName + \" && \" + varName + \" === \" + endNameOrValue + \") { o.vmGoto(\\\"\" + label + \"e\\\"); break; }\";\n          }\n          node.pv = value;\n      }\n      gosub(node) {\n          const nodeArgs = this.fnParseArgs(node.args), label = this.fnGetGosubLabel();\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);\n          }\n          node.pv = \"o.\" + node.type + '(\"' + label + '\", ' + nodeArgs.join(\", \") + '); break;\\ncase \"' + label + '\":';\n      }\n      gotoOrResume(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);\n          }\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \"); break\"; // with break\n      }\n      fnThenOrElsePart(args, tracePrefix) {\n          const isTraceActive = this.options.trace, isResumeNext = Boolean(this.countMap.resumeNext), isResumeNoArgs = Boolean(this.countMap.resumeNoArgsCount), nodeArgs = this.fnParseArgs(args);\n          if (args.length && args[0].type === \"linenumber\") {\n              const line = nodeArgs[0];\n              this.fnAddReferenceLabel(line, args[0]);\n              nodeArgs[0] = \"o.goto(\" + line + \"); break\"; // convert to \"goto\"\n          }\n          if (isTraceActive || isResumeNext || isResumeNoArgs) {\n              for (let i = 0; i < nodeArgs.length; i += 1) {\n                  const traceLabel = this.generateTraceLabel(args[i], tracePrefix, i);\n                  let value = \"\";\n                  if (isResumeNext || isResumeNoArgs) {\n                      value += '\\ncase \"' + traceLabel + '\":';\n                  }\n                  if (isResumeNext) {\n                      this.labelList.push('\"' + traceLabel + '\"'); // only needed to support resume next\n                  }\n                  value += ' o.line = \"' + traceLabel + '\";';\n                  nodeArgs[i] = value + \" \" + nodeArgs[i];\n              }\n          }\n          return nodeArgs.join(\"; \");\n      }\n      static fnIsSimplePart(part) {\n          const partNoTrailingBreak = part.replace(/; break$/, \"\"), simplePart = !(/case|break/).test(partNoTrailingBreak);\n          return simplePart;\n      }\n      fnIf(node) {\n          if (!node.right) {\n              throw this.composeError(Error(), \"Programming error: Undefined left\", node.type, node.pos); // should not occur\n          }\n          let expression = this.fnParseOneArg(node.right);\n          if (expression.endsWith(\" ? -1 : 0\")) { // optimize simple expression\n              expression = expression.replace(/ \\? -1 : 0$/, \"\");\n          }\n          const label = this.fnGetIfLabel(), // need it also for tracing nested if\n          elseArgs = node.args.length && node.args[node.args.length - 1].type === \"else\" ? node.args.pop().args : undefined, elsePart = elseArgs ? this.fnThenOrElsePart(elseArgs, label + \"E\") : \"\", thenPart = this.fnThenOrElsePart(node.args, label + \"T\"), // \"then\"/\"goto\" statements\n          simpleThen = CodeGeneratorJs.fnIsSimplePart(thenPart), simpleElse = elsePart ? CodeGeneratorJs.fnIsSimplePart(elsePart) : true;\n          let value = \"if (\" + expression + \") { \";\n          if (simpleThen && simpleElse) {\n              value += thenPart + \"; }\";\n              if (elsePart) {\n                  value += \" else { \" + elsePart + \"; }\";\n              }\n          }\n          else {\n              value += 'o.vmGoto(\"' + label + '\"); break; } ';\n              if (elsePart !== \"\") { // \"else\" statements?\n                  value += \"/* else */ \" + elsePart + \"; \";\n              }\n              value += 'o.vmGoto(\"' + label + 'e\"); break;\\ncase \"' + label + '\": ' + thenPart + ';\\ncase \"' + label + 'e\": ';\n          }\n          node.pv = value;\n      }\n      inputOrlineInput(node) {\n          const nodeArgs = this.fnParseArgs(node.args), varTypes = [], label = this.fnGetStopLabel();\n          if (nodeArgs.length < 4) {\n              throw this.composeError(Error(), \"Programming error: Not enough parameters\", node.type, node.pos); // should not occur\n          }\n          const stream = nodeArgs[0];\n          let noCRLF = nodeArgs[1];\n          if (noCRLF === \";\") { // ; or null\n              noCRLF = '\"' + noCRLF + '\"';\n          }\n          let msg = nodeArgs[2];\n          if (!node.args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", node.type, node.pos); // should not occur\n          }\n          if (node.args[2].type === \"null\") { // message type\n              msg = '\"\"';\n          }\n          const prompt = nodeArgs[3];\n          if (prompt === \";\" || node.args[3].type === \"null\") { // \";\" => insert prompt \"? \" in quoted string\n              msg = msg.substring(0, msg.length - 1) + \"? \" + msg.substr(-1, 1);\n          }\n          for (let i = 4; i < nodeArgs.length; i += 1) {\n              varTypes[i - 4] = this.fnDetermineStaticVarType(nodeArgs[i]);\n          }\n          let value = \"o.vmGoto(\\\"\" + label + \"\\\"); break;\\ncase \\\"\" + label + \"\\\":\"; // also before input\n          const label2 = this.fnGetStopLabel();\n          value += \"o.\" + node.type + \"(\" + stream + \", \" + noCRLF + \", \" + msg + \", \\\"\" + varTypes.join('\", \"') + \"\\\"); o.vmGoto(\\\"\" + label2 + \"\\\"); break;\\ncase \\\"\" + label2 + \"\\\":\";\n          for (let i = 4; i < nodeArgs.length; i += 1) {\n              value += \"; \" + nodeArgs[i] + \" = o.vmGetNextInput()\";\n          }\n          node.pv = value;\n      }\n      let(node) {\n          if (!node.right) {\n              throw this.composeError(Error(), \"Programming error: Undefined right\", node.type, node.pos); // should not occur\n          }\n          this.assign(node.right);\n          node.pv = node.right.pv;\n          node.pt = node.right.pt; // TODO: Do we need this?\n      }\n      list(node) {\n          const nodeArgs = this.fnParseArgs(node.args); // or: fnCommandWithGoto\n          if (!node.args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", node.type, node.pos); // should not occur\n          }\n          if (!node.args.length || node.args[node.args.length - 1].type === \"#\") { // last parameter stream? or no parameters?\n              const stream = nodeArgs.pop() || \"0\";\n              nodeArgs.unshift(stream); // put it first\n          }\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \"); break;\";\n      }\n      mid$Assign(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          if (nodeArgs.length < 4) {\n              nodeArgs.splice(2, 0, \"undefined\"); // set empty length\n          }\n          const name = nodeArgs[0], varType = this.fnDetermineStaticVarType(name);\n          node.pv = name + \" = o.vmAssign(\\\"\" + varType + \"\\\", o.mid$Assign(\" + nodeArgs.join(\", \") + \"))\";\n      }\n      static fnNew(node) {\n          const name = Utils.supportReservedNames ? (\"o.\" + node.type) : 'o[\"' + node.type + '\"]';\n          node.pv = name + \"();\";\n      }\n      next(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          if (!nodeArgs.length) {\n              nodeArgs.push(\"\"); // we have no variable, so use empty argument\n          }\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              const label = this.stack.forLabel.pop(), varName = this.stack.forVarName.pop();\n              let errorNode;\n              if (label === undefined) {\n                  if (nodeArgs[i] === \"\") { // inserted node?\n                      errorNode = node;\n                  }\n                  else { // identifier arg\n                      errorNode = node.args[i];\n                  }\n                  throw this.composeError(Error(), \"Unexpected NEXT\", errorNode.type, errorNode.pos);\n              }\n              if (nodeArgs[i] !== \"\" && nodeArgs[i] !== varName) {\n                  errorNode = node.args[i];\n                  throw this.composeError(Error(), \"Unexpected NEXT variable\", errorNode.value, errorNode.pos);\n              }\n              nodeArgs[i] = \"/* \" + node.type + \"(\\\"\" + nodeArgs[i] + \"\\\") */ o.vmGoto(\\\"\" + label + \"\\\"); break;\\ncase \\\"\" + label + \"e\\\":\";\n          }\n          node.pv = nodeArgs.join(\"; \");\n      }\n      onBreakGosubOrRestore(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);\n          }\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \")\";\n      }\n      onErrorGoto(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              if (Number(nodeArgs[i])) { // only for lines > 0\n                  this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);\n              }\n          }\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \")\";\n      }\n      onGosubOnGoto(node) {\n          const nodeArgs = this.fnParseArgs(node.args), label = node.type === \"onGosub\" ? this.fnGetGosubLabel() : this.fnGetStopLabel();\n          for (let i = 1; i < nodeArgs.length; i += 1) { // starting with 1\n              this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);\n          }\n          nodeArgs.unshift('\"' + label + '\"');\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + '); break;\\ncase \"' + label + '\":';\n      }\n      onSqGosub(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              this.fnAddReferenceLabel(nodeArgs[i], node.args[i]);\n          }\n          if (!node.right) {\n              throw this.composeError(Error(), \"Programming error: Undefined right\", \"\", -1); // should not occur\n          }\n          const sqArgs = this.fnParseArgs(node.right.args);\n          nodeArgs.unshift(sqArgs[0]);\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \")\";\n      }\n      print(node) {\n          const args = node.args, nodeArgs = [];\n          let newLine = true;\n          for (let i = 0; i < args.length; i += 1) {\n              const arg = args[i];\n              let argString = this.fnParseOneArg(arg);\n              if (i === args.length - 1) {\n                  if (arg.type === \";\" || arg.type === \",\" || arg.type === \"spc\" || arg.type === \"tab\") {\n                      newLine = false;\n                  }\n              }\n              if (arg.type === \",\") { // comma tab\n                  argString = \"{type: \\\"commaTab\\\", args: []}\"; // we must delay the commaTab() call until print() is called\n                  nodeArgs.push(argString);\n              }\n              else if (arg.type !== \";\") { // ignore \";\" separators\n                  nodeArgs.push(argString);\n              }\n          }\n          if (newLine) {\n              const arg2 = '\"\\\\r\\\\n\"';\n              nodeArgs.push(arg2);\n          }\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \")\";\n      }\n      randomize(node) {\n          let value;\n          if (node.args.length) {\n              const nodeArgs = this.fnParseArgs(node.args);\n              value = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \")\";\n          }\n          else {\n              const label = this.fnGetStopLabel();\n              value = \"o.vmGoto(\\\"\" + label + \"\\\"); break;\\ncase \\\"\" + label + \"\\\":\"; // also before input\n              value += this.fnCommandWithGoto(node) + \" o.randomize(o.vmGetNextInput())\";\n          }\n          node.pv = value;\n      }\n      read(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          for (let i = 0; i < nodeArgs.length; i += 1) {\n              const name = nodeArgs[i], varType = this.fnDetermineStaticVarType(name);\n              nodeArgs[i] = name + \" = o.\" + node.type + \"(\\\"\" + varType + \"\\\")\";\n          }\n          node.pv = nodeArgs.join(\"; \");\n      }\n      rem(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          node.pv = \"//\" + nodeArgs.join(\"\") + \"\\n\";\n      }\n      apostrophe(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          if (nodeArgs.length && !nodeArgs[0].startsWith(\" \")) {\n              nodeArgs[0] = \" \" + nodeArgs[0]; // add extra space\n          }\n          node.pv = \"//\" + nodeArgs.join(\"\") + \"\\n\";\n      }\n      static fnReturn(node) {\n          const name = Utils.supportReservedNames ? (\"o.\" + node.type) : 'o[\"' + node.type + '\"]';\n          node.pv = name + \"(); break;\";\n      }\n      run(node) {\n          if (node.args.length) {\n              if (node.args[0].type === \"linenumber\" || node.args[0].type === \"number\") { // optional line number, should be linenumber only\n                  this.fnAddReferenceLabel(this.fnParseOneArg(node.args[0]), node.args[0]); // parse only one arg, args are parsed later\n              }\n          }\n          node.pv = this.fnCommandWithGoto(node);\n      }\n      save(node) {\n          let nodeArgs = [];\n          if (node.args.length) {\n              const fileName = this.fnParseOneArg(node.args[0]);\n              nodeArgs.push(fileName);\n              if (node.args.length > 1) {\n                  this.defScopeArgs = {}; // collect DEF scope args\n                  const type = '\"' + this.fnParseOneArg(node.args[1]) + '\"';\n                  this.defScopeArgs = undefined;\n                  nodeArgs.push(type);\n                  const nodeArgs2 = node.args.slice(2), // get remaining args\n                  nodeArgs3 = this.fnParseArgs(nodeArgs2);\n                  nodeArgs = nodeArgs.concat(nodeArgs3);\n              }\n          }\n          node.pv = this.fnCommandWithGoto(node, nodeArgs);\n      }\n      spc(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          node.pv = \"{type: \\\"spc\\\", args: [\" + nodeArgs.join(\", \") + \"]}\"; // we must delay the spc() call until print() is called because we need stream\n      }\n      stopOrEnd(node) {\n          const label = this.fnGetStopLabel();\n          node.pv = \"o.\" + node.type + \"(\\\"\" + label + \"\\\"); break;\\ncase \\\"\" + label + \"\\\":\";\n      }\n      tab(node) {\n          const nodeArgs = this.fnParseArgs(node.args);\n          node.pv = \"{type: \\\"tab\\\", args: [\" + nodeArgs.join(\", \") + \"]}\"; // we must delay the tab() call until print() is called\n      }\n      usingOrWrite(node) {\n          const nodeArgs = this.fnParseArgsIgnoringCommaSemi(node.args);\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \")\";\n      }\n      wend(node) {\n          const label = this.stack.whileLabel.pop();\n          if (label === undefined) {\n              throw this.composeError(Error(), \"Unexpected WEND\", node.type, node.pos);\n          }\n          node.pv = \"/* o.\" + node.type + \"() */ o.vmGoto(\\\"\" + label + \"\\\"); break;\\ncase \\\"\" + label + \"e\\\":\";\n      }\n      fnWhile(node) {\n          const nodeArgs = this.fnParseArgs(node.args), label = this.fnGetWhileLabel();\n          this.stack.whileLabel.push(label);\n          node.pv = \"\\ncase \\\"\" + label + \"\\\": if (!(\" + nodeArgs + \")) { o.vmGoto(\\\"\" + label + \"e\\\"); break; }\";\n      }\n      /* eslint-disable no-invalid-this */\n      parseFunctions = {\n          \";\": CodeGeneratorJs.commaOrSemicolon, // \";\" for input, line input\n          \",\": CodeGeneratorJs.commaOrSemicolon, // \",\" for input, line input\n          \"|\": this.vertical,\n          number: CodeGeneratorJs.number,\n          expnumber: CodeGeneratorJs.expnumber,\n          binnumber: CodeGeneratorJs.binnumber,\n          hexnumber: CodeGeneratorJs.hexnumber,\n          linenumber: CodeGeneratorJs.linenumber,\n          identifier: this.identifier,\n          letter: CodeGeneratorJs.letter, // for defint, defreal, defstr\n          range: this.range,\n          linerange: this.linerange,\n          string: CodeGeneratorJs.string,\n          ustring: CodeGeneratorJs.string, // unterminated string the same as string\n          unquoted: CodeGeneratorJs.unquoted,\n          \"null\": CodeGeneratorJs.fnNull,\n          assign: this.assign,\n          label: this.label,\n          // special keyword functions\n          afterGosub: this.afterEveryGosub,\n          call: this.fnCommandWithGoto,\n          chain: this.fnCommandWithGoto,\n          chainMerge: this.fnCommandWithGoto,\n          clear: this.fnCommandWithGoto, // will also do e.g. closeout\n          closeout: this.fnCommandWithGoto,\n          cont: CodeGeneratorJs.cont,\n          data: this.data,\n          def: this.def,\n          defint: this.fnParseDefIntRealStr,\n          defreal: this.fnParseDefIntRealStr,\n          defstr: this.fnParseDefIntRealStr,\n          dim: this.dim,\n          \"delete\": this.fnDelete,\n          edit: this.edit,\n          elseComment: this.elseComment,\n          end: this.stopOrEnd,\n          erase: this.erase,\n          error: this.error,\n          everyGosub: this.afterEveryGosub,\n          fn: this.fn,\n          \"for\": this.fnFor,\n          frame: this.fnCommandWithGoto,\n          gosub: this.gosub,\n          \"goto\": this.gotoOrResume,\n          \"if\": this.fnIf,\n          input: this.inputOrlineInput,\n          let: this.let,\n          lineInput: this.inputOrlineInput,\n          list: this.list,\n          load: this.fnCommandWithGoto,\n          merge: this.fnCommandWithGoto,\n          mid$Assign: this.mid$Assign,\n          \"new\": CodeGeneratorJs.fnNew,\n          next: this.next,\n          onBreakGosub: this.onBreakGosubOrRestore,\n          onErrorGoto: this.onErrorGoto,\n          onGosub: this.onGosubOnGoto,\n          onGoto: this.onGosubOnGoto,\n          onSqGosub: this.onSqGosub,\n          openin: this.fnCommandWithGoto,\n          print: this.print,\n          randomize: this.randomize,\n          read: this.read,\n          rem: this.rem,\n          \"'\": this.apostrophe, // apostrophe comment\n          renum: this.fnCommandWithGoto,\n          restore: this.onBreakGosubOrRestore,\n          resume: this.gotoOrResume,\n          resumeNext: this.gotoOrResume,\n          \"return\": CodeGeneratorJs.fnReturn,\n          run: this.run,\n          save: this.save,\n          sound: this.fnCommandWithGoto, // maybe queue is full, so insert break\n          spc: this.spc,\n          stop: this.stopOrEnd,\n          tab: this.tab,\n          tron: this.fnCommandWithGoto, // not really needed with goto, but...\n          using: this.usingOrWrite,\n          wend: this.wend,\n          \"while\": this.fnWhile,\n          write: this.usingOrWrite\n      };\n      /* eslint-enable no-invalid-this */\n      fnParseOther(node) {\n          const nodeArgs = this.fnParseArgs(node.args), typeWithSpaces = \" \" + node.type + \" \";\n          node.pv = \"o.\" + node.type + \"(\" + nodeArgs.join(\", \") + \")\";\n          if (CodeGeneratorJs.fnIsInString(\" asc cint derr eof erl err fix fre inkey inp instr int joy len memory peek pos remain sgn sq test testr unt vpos xpos ypos \", typeWithSpaces)) {\n              node.pt = \"I\";\n          }\n          else if (CodeGeneratorJs.fnIsInString(\" abs atn cos creal exp log log10 pi rnd round sin sqr tan time val \", typeWithSpaces)) {\n              node.pt = \"R\";\n          }\n          else if (CodeGeneratorJs.fnIsInString(\" bin$ chr$ copychr$ dec$ hex$ inkey$ left$ lower$ mid$ right$ space$ str$ string$ upper$ \", typeWithSpaces)) {\n              node.pt = \"$\";\n          }\n          // Note: min and max usually return a number, but for a single string argument also the string!\n          if (node.type === \"min\" || node.type === \"max\") {\n              if (node.args.length === 1) {\n                  if (node.args[0].type === \"$\") {\n                      node.pt = \"$\";\n                  }\n              }\n              else if (node.args.length > 1) {\n                  node.pt = \"R\";\n              }\n          }\n      }\n      parseOperator(node) {\n          const operators = this.allOperators;\n          if (node.left) {\n              this.parseNode(node.left);\n              if (operators[node.left.type] && node.left.left) { // binary operator?\n                  node.left.pv = \"(\" + node.left.pv + \")\";\n              }\n              if (!node.right) {\n                  throw this.composeError(Error(), \"Programming error: Undefined right\", \"\", -1); // should not occur\n              }\n              this.parseNode(node.right);\n              if (operators[node.right.type] && node.right.left) { // binary operator?\n                  node.right.pv = \"(\" + node.right.pv + \")\";\n              }\n              operators[node.type].call(this, node, node.left, node.right);\n          }\n          else {\n              if (!node.right) {\n                  throw this.composeError(Error(), \"Programming error: Undefined right\", \"\", -1); // should not occur\n              }\n              this.parseNode(node.right);\n              this.unaryOperators[node.type].call(this, node, undefined, node.right); // unary operator: we just use node.right\n          }\n      }\n      parseNode(node) {\n          if (Utils.debug > 3) {\n              Utils.console.debug(\"evaluate: parseNode node=%o type=\" + node.type + \" value=\" + node.value + \" left=%o right=%o args=%o\", node, node.left, node.right, node.args);\n          }\n          if (this.allOperators[node.type]) {\n              this.parseOperator(node);\n          }\n          else if (this.parseFunctions[node.type]) { // function with special handling?\n              this.parseFunctions[node.type].call(this, node);\n          }\n          else { // for other functions, generate code directly\n              this.fnParseOther(node);\n          }\n      }\n      static fnCommentUnusedCases(output, labels) {\n          return output.replace(/^case (\\d+):/gm, function (all, line) {\n              return (labels[line]) ? all : \"/* \" + all + \" */\";\n          });\n      }\n      fnCheckLabel(node, lastLine) {\n          let label = node.value;\n          if (label === \"\") {\n              if (this.options.implicitLines) {\n                  label = String(lastLine + 1); // no line => we just increase the last line by 1\n                  node.value = label; // we also modify the parse tree\n              }\n              else {\n                  throw this.composeError(Error(), \"Direct command found\", label, node.pos);\n              }\n          }\n          const lineNumber = Number(label);\n          if ((lineNumber | 0) !== lineNumber) { // eslint-disable-line no-bitwise\n              throw this.composeError(Error(), \"Expected integer line number\", label, node.pos);\n          }\n          if (lineNumber < 1 || lineNumber > 65535) {\n              throw this.composeError(Error(), \"Line number overflow\", label, node.pos);\n          }\n          if (lineNumber <= lastLine) {\n              throw this.composeError(Error(), \"Expected increasing line number\", label, node.pos);\n          }\n          return label;\n      }\n      fnCreateLabelMap(nodes, labels) {\n          let lastLine = 0;\n          for (let i = 0; i < nodes.length; i += 1) {\n              const node = nodes[i];\n              if (node.type === \"label\" && node.value !== \"direct\") {\n                  const label = this.fnCheckLabel(node, lastLine);\n                  if (label) {\n                      labels[label] = 0; // init call count\n                      lastLine = Number(label);\n                  }\n              }\n          }\n      }\n      removeAllDefVarTypes() {\n          const varTypes = this.defintDefstrTypes;\n          for (const name in varTypes) { // eslint-disable-line guard-for-in\n              delete varTypes[name];\n          }\n      }\n      fnSetDefVarTypeRange(type, first, last) {\n          const firstNum = first.charCodeAt(0), lastNum = last.charCodeAt(0);\n          for (let i = firstNum; i <= lastNum; i += 1) {\n              const varChar = String.fromCharCode(i);\n              this.defintDefstrTypes[varChar] = type;\n          }\n      }\n      fnPrecheckDefintDefstr(node) {\n          if (node.args) {\n              const type = node.type === \"defint\" ? \"I\" : \"$\";\n              for (let i = 0; i < node.args.length; i += 1) {\n                  const arg = node.args[i];\n                  if (arg.type === \"letter\") {\n                      this.defintDefstrTypes[arg.value.toLowerCase()] = type;\n                  }\n                  else if (arg.type === \"range\") {\n                      if (!arg.left || !arg.right) {\n                          throw this.composeError(Error(), \"Programming error: Undefined left or right\", node.type, node.pos); // should not occur\n                      }\n                      this.fnSetDefVarTypeRange(type, arg.left.value.toLowerCase(), arg.right.value.toLowerCase());\n                  }\n              }\n          }\n      }\n      fnPrecheckTree(nodes, countMap) {\n          for (let i = 0; i < nodes.length; i += 1) {\n              const node = nodes[i];\n              countMap[node.type] = (countMap[node.type] || 0) + 1;\n              if (node.type === \"defint\" || node.type === \"defstr\") {\n                  if (node.args) {\n                      this.fnPrecheckDefintDefstr(node);\n                  }\n              }\n              if (node.type === \"resume\" && !(node.args && node.args.length)) {\n                  const resumeNoArgs = \"resumeNoArgsCount\";\n                  countMap[resumeNoArgs] = (countMap[resumeNoArgs] || 0) + 1;\n              }\n              if (node.args) {\n                  this.fnPrecheckTree(node.args, countMap); // recursive\n              }\n          }\n      }\n      //\n      // evaluate\n      //\n      evaluate(parseTree, variables) {\n          this.variables = variables;\n          this.defScopeArgs = undefined;\n          // create labels map\n          this.fnCreateLabelMap(parseTree, this.referencedLabelsCount);\n          this.removeAllDefVarTypes();\n          this.fnPrecheckTree(parseTree, this.countMap); // also sets \"resumeNoArgsCount\" for resume without args\n          let output = \"\";\n          for (let i = 0; i < parseTree.length; i += 1) {\n              if (Utils.debug > 2) {\n                  Utils.console.debug(\"evaluate: parseTree i=%d, node=%o\", i, parseTree[i]);\n              }\n              const line = this.fnParseOneArg(parseTree[i]);\n              if ((line !== undefined) && (line !== \"\")) {\n                  if (line !== null) {\n                      if (output.length === 0) {\n                          output = line;\n                      }\n                      else {\n                          output += \"\\n\" + line;\n                      }\n                  }\n                  else {\n                      output = \"\"; // cls (clear output when node is set to null)\n                  }\n              }\n          }\n          // optimize: comment lines which are not referenced\n          if (!this.countMap.merge && !this.countMap.chainMerge && !this.countMap.resumeNext && !this.countMap.resumeNoArgsCount) {\n              output = CodeGeneratorJs.fnCommentUnusedCases(output, this.referencedLabelsCount);\n          }\n          return output;\n      }\n      static combineData(data) {\n          return data.length ? data.join(\";\\n\") + \";\\n\" : \"\";\n      }\n      static combineLabels(data) {\n          return data.length ? \"o.vmSetLabels([\" + data.join(\",\") + \"]);\\n\" : \"\";\n      }\n      getSourceMap() {\n          return this.sourceMap;\n      }\n      debugGetLabelsCount() {\n          return Object.keys(this.referencedLabelsCount).length;\n      }\n      generate(input, variables, allowDirect) {\n          const out = {\n              text: \"\"\n          };\n          this.reset();\n          try {\n              const tokens = this.options.lexer.lex(input), parseTree = this.options.parser.parse(tokens);\n              if (allowDirect && parseTree.length) {\n                  const lastLine = parseTree[parseTree.length - 1];\n                  if (lastLine.type === \"label\" && lastLine.value === \"\") {\n                      lastLine.value = \"direct\";\n                  }\n              }\n              let output = this.evaluate(parseTree, variables);\n              const combinedData = CodeGeneratorJs.combineData(this.dataList), combinedLabels = CodeGeneratorJs.combineLabels(this.labelList);\n              if (!this.options.noCodeFrame) {\n                  output = '\"use strict\"\\n'\n                      + \"var v=o.vmGetAllVariables();\\n\"\n                      + \"var t=o.vmGetAllVarTypes();\\n\"\n                      + \"while (o.vmLoopCondition()) {\\nswitch (o.line) {\\ncase 0:\\n\"\n                      + combinedData\n                      + combinedLabels\n                      + \" o.vmGoto(o.startLine ? o.startLine : \\\"start\\\"); break;\\ncase \\\"start\\\":\\n\"\n                      + output\n                      + \"\\ncase \\\"end\\\": o.line=\\\"end\\\"; o.vmStop(\\\"end\\\", 90); break;\\ndefault: o.error(8); o.vmGoto(\\\"end\\\"); break;\\n}}\\n\";\n              }\n              else {\n                  output = combinedData + output;\n              }\n              out.text = output;\n          }\n          catch (e) {\n              if (Utils.isCustomError(e)) {\n                  out.error = e;\n                  if (!this.options.quiet) {\n                      Utils.console.warn(e); // show our customError as warning\n                  }\n              }\n              else { // other errors\n                  out.error = e; // force set other error\n                  Utils.console.error(e);\n              }\n          }\n          return out;\n      }\n  }\n\n  // ===== dist/esm/CodeGeneratorToken.js =====\n  // CodeGeneratorToken.ts - Code Generator for BASIC (for testing, pretty print?)\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n  //\n\n  class CodeGeneratorToken {\n      options;\n      label = \"0\"; // current line (label)\n      constructor(options) {\n          this.options = {\n              allowLineFragments: false, // only for testing\n              implicitLines: false,\n              quiet: false\n          };\n          this.setOptions(options);\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      static tokens = {\n          _eol: 0x00, // marker for \"end of tokenised line\"\n          \":\": 0x01, // \":\" statement seperator\n          _intVar: 0x02, // integer variable definition (defined with \"%\" suffix)  \"(A-Z)+%\"\n          _stringVar: 0x03, // string variable definition (defined with \"$\" suffix)  \"(A-Z)+\\$\"\n          _floatVar: 0x04, // floating point variable definition (defined with \"!\" suffix) \"(A-Z)+!\"\n          // \"\": 0x05, // \"var?\"\n          // \"\": 0x06, // \"var?\"\n          // \"\": 0x07, // \"var?\"\n          // \"\": 0x08, // \"var?\"\n          // \"\": 0x09, // \"var?\"\n          // \"\": 0x0a, // \"var?\"\n          // \"\": 0x0b, // integer variable definition (no suffix)\n          // \"\": 0x0c, // string variable definition (no suffix)\n          _anyVar: 0x0d, // floating point or no type (no suffix)\n          0: 0x0e, // number constant \"0\"\n          1: 0x0f, // number constant \"1\"\n          2: 0x10, // number constant \"2\"\n          3: 0x11, // number constant \"3\"\n          4: 0x12, // number constant \"4\"\n          5: 0x13, // number constant \"5\"\n          6: 0x14, // number constant \"6\"\n          7: 0x15, // number constant \"7\"\n          8: 0x16, // number constant \"8\"\n          9: 0x17, // number constant \"9\"\n          10: 0x18, // number constant \"10\" (not sure when this is used)\n          _dec8: 0x19, // 8-bit integer decimal value\n          _dec16: 0x1a, // 16-bit integer decimal value\n          _bin16: 0x1b, // 16-bit integer binary value (with \"&X\" prefix)\n          _hex16: 0x1c, // num16Hex: 16-bit integer hexadecimal value (with \"&H\" or \"&\" prefix)\n          // \"\": 0x1d, // 16-bit BASIC program line memory address pointer (should not occur)\n          _line16: 0x1e, // 16-bit integer BASIC line number\n          _float: 0x1f, // floating point value\n          // 0x20-0x21 ASCII printable symbols (space, \"!\")\n          // \"\": 0x22, // '\"' quoted string value\n          // 0x23-0x7b ASCII printable symbols\n          \"#\": 0x23, // \"#\" character (stream)\n          \"(\": 0x28, // \"(\" character\n          \")\": 0x29, // \")\" character\n          \",\": 0x2c, // \",\" character\n          \"?\": 0x3f, // \"?\" character (print)\n          \"@\": 0x40, // \"@\" character (address of)\n          \"[\": 0x5b, // \"[\" character\n          \"]\": 0x5d, // \"]\" character\n          \"|\": 0x7c, // \"|\" symbol; prefix for RSX commands\n          after: 0x80,\n          afterGosub: 0x80,\n          auto: 0x81,\n          border: 0x82,\n          call: 0x83,\n          cat: 0x84,\n          chain: 0x85,\n          chainMerge: 0x85, // 0xab85\n          clear: 0x86,\n          clearInput: 0x86, // 0xa386\n          clg: 0x87,\n          closein: 0x88,\n          closeout: 0x89,\n          cls: 0x8a,\n          cont: 0x8b,\n          data: 0x8c,\n          def: 0x8d,\n          defint: 0x8e,\n          defreal: 0x8f,\n          defstr: 0x90,\n          deg: 0x91,\n          \"delete\": 0x92,\n          dim: 0x93,\n          draw: 0x94,\n          drawr: 0x95,\n          edit: 0x96,\n          \"else\": 0x97,\n          end: 0x98,\n          ent: 0x99,\n          env: 0x9a,\n          erase: 0x9b,\n          error: 0x9c,\n          every: 0x9d,\n          everyGosub: 0x9d,\n          \"for\": 0x9e,\n          gosub: 0x9f,\n          \"goto\": 0xa0,\n          \"if\": 0xa1,\n          ink: 0xa2,\n          input: 0xa3,\n          key: 0xa4,\n          keyDef: 0xa4, // 0x8da4\n          let: 0xa5,\n          line: 0xa6,\n          lineInput: 0xa6, // 0xa3a6\n          list: 0xa7,\n          load: 0xa8,\n          locate: 0xa9,\n          memory: 0xaa,\n          merge: 0xab,\n          mid$: 0xac,\n          mid$Assign: 0xac,\n          mode: 0xad,\n          move: 0xae,\n          mover: 0xaf,\n          next: 0xb0,\n          \"new\": 0xb1,\n          on: 0xb2,\n          _onBreak: 0xb3, // onBreakCont, onBreakGosub, onBreakStop\n          _onErrorGoto0: 0xb4, // \"on error goto 0\" (on error goto n > 0 is decoded with separate tokens)\n          onGosub: 0xb2,\n          onGoto: 0xb2,\n          _onSq: 0xb5, // \"on sq\" (onSqGosub)\n          openin: 0xb6,\n          openout: 0xb7,\n          origin: 0xb8,\n          out: 0xb9,\n          paper: 0xba,\n          pen: 0xbb,\n          plot: 0xbc,\n          plotr: 0xbd,\n          poke: 0xbe,\n          print: 0xbf,\n          \"'\": 0xc0, // apostrophe \"'\" symbol (same function as REM keyword)\n          rad: 0xc1,\n          randomize: 0xc2,\n          read: 0xc3,\n          release: 0xc4,\n          rem: 0xc5, // rem\n          renum: 0xc6,\n          restore: 0xc7,\n          resume: 0xc8,\n          resumeNext: 0xc8, // 0xb0c8\n          \"return\": 0xc9,\n          run: 0xca,\n          save: 0xcb,\n          sound: 0xcc,\n          speedInk: 0xcd, // 0xa2cd\n          speedKey: 0xcd, // 0xa4cd,\n          speedWrite: 0xcd, // 0xd9cd\n          stop: 0xce,\n          swap: 0xe7,\n          symbol: 0xcf,\n          symbolAfter: 0xcf, // 0x80cf\n          tag: 0xd0,\n          tagoff: 0xd1,\n          troff: 0xd2,\n          tron: 0xd3,\n          wait: 0xd4,\n          wend: 0xd5,\n          \"while\": 0xd6,\n          width: 0xd7,\n          window: 0xd8,\n          windowSwap: 0xd8, // 0xe7d8\n          write: 0xd9,\n          zone: 0xda,\n          di: 0xdb,\n          ei: 0xdc,\n          fill: 0xdd, // (v1.1)\n          graphics: 0xde, // (v1.1)\n          graphicsPaper: 0xde, // 0xbade\n          graphicsPen: 0xde, // 0xbbde\n          mask: 0xdf, // (v1.1)\n          frame: 0xe0, // (v1.1)\n          cursor: 0xe1, // (v1.1)\n          // \"<unused>\":         0xe2,\n          erl: 0xe3,\n          fn: 0xe4,\n          spc: 0xe5,\n          step: 0xe6,\n          // swap: 0xe7, only: windowSwap...\n          // \"<unused>\":         0xe8,\n          // \"<unused>\":         0xe9,\n          tab: 0xea,\n          then: 0xeb,\n          to: 0xec,\n          using: 0xed,\n          \">\": 0xee, // (greater than)\n          \"=\": 0xef, // (equal)\n          assign: 0xef, // equal as assign\n          \">=\": 0xf0, // (greater or equal)\n          \"<\": 0xf1, // (less than)\n          \"<>\": 0xf2, // (not equal)\n          \"<=\": 0xf3, // =<, <=, < = (less than or equal)\n          \"+\": 0xf4, // (addition)\n          \"-\": 0xf5, // (subtraction or unary minus)\n          \"*\": 0xf6, // (multiplication)\n          \"/\": 0xf7, // (division)\n          \"^\": 0xf8, // (x to the power of y)\n          \"\\\\\": 0xf9, // (integer division)\n          and: 0xfa,\n          mod: 0xfb,\n          or: 0xfc,\n          xor: 0xfd,\n          not: 0xfe\n          // 0xff: (prefix for additional keywords)\n      };\n      static tokensFF = {\n          // Functions with one argument\n          abs: 0x00,\n          asc: 0x01,\n          atn: 0x02,\n          chr$: 0x03,\n          cint: 0x04,\n          cos: 0x05,\n          creal: 0x06,\n          exp: 0x07,\n          fix: 0x08,\n          fre: 0x09,\n          inkey: 0x0a,\n          inp: 0x0b,\n          \"int\": 0x0c,\n          joy: 0x0d,\n          len: 0x0e,\n          log: 0x0f,\n          log10: 0x10,\n          lower$: 0x11,\n          peek: 0x12,\n          remain: 0x13,\n          sgn: 0x14,\n          sin: 0x15,\n          space$: 0x16,\n          sq: 0x17,\n          sqr: 0x18,\n          str$: 0x19,\n          tan: 0x1a,\n          unt: 0x1b,\n          upper$: 0x1c,\n          val: 0x1d,\n          // Functions without arguments\n          eof: 0x40,\n          err: 0x41,\n          himem: 0x42,\n          inkey$: 0x43,\n          pi: 0x44,\n          rnd: 0x45,\n          time: 0x46,\n          xpos: 0x47,\n          ypos: 0x48,\n          derr: 0x49, // (v1.1)\n          // Functions with more arguments\n          bin$: 0x71,\n          dec$: 0x72, // (v1.1)\n          hex$: 0x73,\n          instr: 0x74,\n          left$: 0x75,\n          max: 0x76,\n          min: 0x77,\n          pos: 0x78,\n          right$: 0x79,\n          round: 0x7a,\n          string$: 0x7b,\n          test: 0x7c,\n          testr: 0x7d,\n          copychr$: 0x7e, // (v1.1)\n          vpos: 0x7f\n      };\n      composeError(error, message, value, pos) {\n          return Utils.composeError(\"CodeGeneratorToken\", error, message, value, pos, undefined, this.label);\n      }\n      static convUInt8ToString(n) {\n          return String.fromCharCode(n);\n      }\n      static convUInt16ToString(n) {\n          return String.fromCharCode(n & 0xff) + String.fromCharCode(n >> 8); // eslint-disable-line no-bitwise\n      }\n      static convInt32ToString(n) {\n          return CodeGeneratorToken.convUInt16ToString(n & 0xffff) + CodeGeneratorToken.convUInt16ToString((n >> 16) & 0xffff); // eslint-disable-line no-bitwise\n      }\n      static token2String(name) {\n          let token = CodeGeneratorToken.tokens[name], result = \"\";\n          if (token === undefined) {\n              token = CodeGeneratorToken.tokensFF[name];\n              if (token === undefined) {\n                  Utils.console.error(\"token2String: Not a token: \" + name);\n                  return name; // return something\n              }\n              result = CodeGeneratorToken.convUInt8ToString(0xff); // prefix for special tokens\n          }\n          return result + CodeGeneratorToken.convUInt8ToString(token);\n      }\n      static getBit7TerminatedString(s) {\n          return s.substring(0, s.length - 1) + String.fromCharCode(s.charCodeAt(s.length - 1) | 0x80); // eslint-disable-line no-bitwise\n      }\n      static fnGetWs(node) {\n          return node.ws || \"\";\n      }\n      fnParseArgs(args) {\n          const nodeArgs = []; // do not modify node.args here (could be a parameter of defined function)\n          if (!args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", \"\", -1); // should not occur\n          }\n          for (let i = 0; i < args.length; i += 1) {\n              nodeArgs.push(this.parseNode(args[i]));\n          }\n          return nodeArgs;\n      }\n      fnArgs(node) {\n          return this.fnParseArgs(node.args).join(node.value);\n      }\n      range(node) {\n          return this.parseNode(node.left) + CodeGeneratorToken.fnGetWs(node) + node.value + this.parseNode(node.right);\n      }\n      linerange(node) {\n          return this.parseNode(node.left) + CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(node.value) + this.parseNode(node.right);\n      }\n      static string(node) {\n          return CodeGeneratorToken.fnGetWs(node) + '\"' + node.value + '\"';\n      }\n      static ustring(node) {\n          return CodeGeneratorToken.fnGetWs(node) + '\"' + node.value; // unterminated string\n      }\n      static fnEol() {\n          return \"\";\n      }\n      static floatToByteString(number) {\n          let mantissa = 0, exponent = 0, sign = 0;\n          if (number !== 0) {\n              if (number < 0) {\n                  sign = 0x80000000;\n                  number = -number;\n              }\n              exponent = Math.ceil(Math.log(number) / Math.log(2));\n              mantissa = Math.round(number / Math.pow(2, exponent - 32)) & ~0x80000000; // eslint-disable-line no-bitwise\n              if (mantissa === 0) {\n                  exponent += 1;\n              }\n              exponent += 0x80;\n          }\n          return CodeGeneratorToken.convInt32ToString(sign + mantissa) + CodeGeneratorToken.convUInt8ToString(exponent);\n      }\n      static number(node) {\n          const numberString = node.value.toUpperCase(), // maybe \"e\" inside\n          number = Number(numberString);\n          let result = \"\";\n          if (number === Math.floor(number)) { // integer?\n              if (number >= 0 && number <= 9) { // integer number constant 0-9? (not sure when 10 is used)\n                  result = CodeGeneratorToken.token2String(numberString);\n              }\n              else if (number >= 10 && number <= 0xff) {\n                  result = CodeGeneratorToken.token2String(\"_dec8\") + CodeGeneratorToken.convUInt8ToString(number);\n              }\n              else if (number >= -0x7fff && number <= 0x7fff) {\n                  result = (number < 0 ? CodeGeneratorToken.token2String(\"-\") : \"\") + CodeGeneratorToken.token2String(\"_dec16\") + CodeGeneratorToken.convUInt16ToString(number);\n              }\n          }\n          if (result === \"\") { // no integer number yet, use float...\n              result = CodeGeneratorToken.token2String(\"_float\") + CodeGeneratorToken.floatToByteString(number);\n          }\n          return CodeGeneratorToken.fnGetWs(node) + result;\n      }\n      static binnumber(node) {\n          const valueString = node.value.slice(2), // remove &x\n          value = (valueString.length) ? parseInt(valueString, 2) : 0; // we convert it to dec\n          return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(\"_bin16\") + CodeGeneratorToken.convUInt16ToString(value);\n      }\n      static hexnumber(node) {\n          let valueString = node.value.slice(1); // remove &\n          if (valueString.charAt(0).toLowerCase() === \"h\") { // optional h\n              valueString = valueString.slice(1); // remove\n          }\n          const value = (valueString.length) ? parseInt(valueString, 16) : 0; // we convert it to dec\n          return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(\"_hex16\") + CodeGeneratorToken.convUInt16ToString(value);\n      }\n      static varTypeMap = {\n          \"!\": \"_floatVar\",\n          \"%\": \"_intVar\",\n          $: \"_stringVar\"\n      };\n      identifier(node) {\n          let name = node.value, // keep case, maybe mixed\n          mappedTypeName = CodeGeneratorToken.varTypeMap[name.charAt(name.length - 1)] || \"\"; // map last char\n          if (mappedTypeName) {\n              name = name.slice(0, -1); // remove type char\n          }\n          else {\n              mappedTypeName = \"_anyVar\";\n          }\n          const offset = 0; // (offset to memory location of variable; not used here)\n          return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(mappedTypeName) + CodeGeneratorToken.convUInt16ToString(offset) + CodeGeneratorToken.getBit7TerminatedString(name) + (node.args ? this.fnParseArgs(node.args).join(\"\") : \"\");\n      }\n      static linenumber(node) {\n          return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(\"_line16\") + CodeGeneratorToken.convUInt16ToString(Number(node.value));\n      }\n      fnLabel(node) {\n          if (node.value === \"\") { // direct\n              if (this.options.implicitLines) {\n                  node.value = String(Number(this.label) + 1); // no line => we just increase the last line by 1\n              }\n              else if (!this.options.allowLineFragments) {\n                  throw this.composeError(Error(), \"Direct command found\", node.value, node.pos);\n              }\n              // only for allowLineFragments we allow to use an empty label\n          }\n          this.label = node.value; // set line before parsing args\n          const line = Number(this.label), nodeArgs = this.fnParseArgs(node.args);\n          let value = nodeArgs.join(\"\");\n          if (node.value !== \"\") { // not direct\n              if (value.charAt(0) === \" \") { // remove one space (implicit space after label)\n                  value = value.substring(1);\n              }\n              value = CodeGeneratorToken.convUInt16ToString(line) + value + CodeGeneratorToken.token2String(\"_eol\"); // no ws\n              value = CodeGeneratorToken.convUInt16ToString(value.length + 2) + value;\n          }\n          return value;\n      }\n      // special keyword functions\n      vertical(node) {\n          const rsxName = node.value.substring(1).toUpperCase(), nodeArgs = this.fnParseArgs(node.args), offset = 0; // offset to tokens following RSX name\n          // if rsxname.length=0 we take 0x80 from empty getBit7TerminatedString\n          return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(node.type) + (rsxName.length ? CodeGeneratorToken.convUInt8ToString(offset) : \"\") + CodeGeneratorToken.getBit7TerminatedString(rsxName) + nodeArgs.join(\"\");\n      }\n      fnElseOrApostrophe(node) {\n          // prefix token with \":\"\n          return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(\":\") + CodeGeneratorToken.token2String(node.type) + this.fnParseArgs(node.args).join(\"\");\n      }\n      elseComment(node) {\n          if (!node.args) {\n              throw this.composeError(Error(), \"Programming error: Undefined args\", \"\", -1); // should not occur\n          }\n          const type = \"else\"; // not \"elseComment\"\n          let value = CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(\":\") + CodeGeneratorToken.token2String(type); // always prefix with \":\"\n          const args = node.args;\n          // we do not have a parse tree here but a simple list\n          for (let i = 0; i < args.length; i += 1) {\n              const token = args[i];\n              let value2 = token.value;\n              if (value2) {\n                  if (token.type === \"linenumber\") {\n                      value2 = CodeGeneratorToken.linenumber(token);\n                  }\n                  value += value2;\n              }\n          }\n          return value;\n      }\n      onBreakContOrGosubOrStop(node) {\n          return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(\"_onBreak\") + (node.right && node.right.right ? this.parseNode(node.right.right) : \"\") + this.fnParseArgs(node.args).join(\"\");\n      }\n      onErrorGoto(node) {\n          if (node.args && node.args.length && node.args[0].value === \"0\") { // on error goto 0?\n              return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(\"_onErrorGoto0\");\n          }\n          return CodeGeneratorToken.fnGetWs(node) + CodeGeneratorToken.token2String(\"on\") + this.parseNode(node.right) + this.fnParseArgs(node.args).join(\"\");\n      }\n      onSqGosub(node) {\n          return CodeGeneratorToken.token2String(\"_onSq\") + this.fnParseArgs(node.right.args).join(\"\") + this.fnParseArgs(node.args).join(\"\");\n      }\n      /* eslint-disable no-invalid-this */\n      parseFunctions = {\n          args: this.fnArgs,\n          range: this.range,\n          linerange: this.linerange,\n          string: CodeGeneratorToken.string,\n          ustring: CodeGeneratorToken.ustring,\n          \"(eol)\": CodeGeneratorToken.fnEol, // ignore newline \"\\n\"\n          number: CodeGeneratorToken.number,\n          expnumber: CodeGeneratorToken.number, // same handling as for number\n          binnumber: CodeGeneratorToken.binnumber,\n          hexnumber: CodeGeneratorToken.hexnumber,\n          identifier: this.identifier,\n          linenumber: CodeGeneratorToken.linenumber,\n          label: this.fnLabel,\n          \"|\": this.vertical,\n          \"else\": this.fnElseOrApostrophe,\n          elseComment: this.elseComment,\n          onBreakCont: this.onBreakContOrGosubOrStop,\n          onBreakGosub: this.onBreakContOrGosubOrStop,\n          onBreakStop: this.onBreakContOrGosubOrStop,\n          onErrorGoto: this.onErrorGoto,\n          onSqGosub: this.onSqGosub,\n          \"'\": this.fnElseOrApostrophe\n      };\n      /* eslint-enable no-invalid-this */\n      fnParseOther(node) {\n          const type = node.type, isToken = CodeGeneratorToken.tokens[type] !== undefined || CodeGeneratorToken.tokensFF[type] !== undefined;\n          let value = \"\"; // CodeGeneratorToken.fnGetWs(node);\n          if (node.left) {\n              value += this.parseNode(node.left);\n          }\n          value += CodeGeneratorToken.fnGetWs(node);\n          if (isToken) {\n              value += CodeGeneratorToken.token2String(type);\n          }\n          else if (node.value) { // e.g. string,...\n              value += node.value;\n          }\n          if (node.right) {\n              value += this.parseNode(node.right);\n          }\n          if (node.args) {\n              value += this.fnParseArgs(node.args).join(\"\");\n          }\n          return value;\n      }\n      parseNode(node) {\n          if (Utils.debug > 3) {\n              Utils.console.debug(\"evaluate: parseNode node=%o type=\" + node.type + \" value=\" + node.value + \" left=%o right=%o args=%o\", node, node.left, node.right, node.args);\n          }\n          const type = node.type;\n          let value;\n          if (node.len === 0 && type !== \"label\") { // ignore dummy token, e.g. '#' (but not label)\n              value = \"\";\n          }\n          else {\n              value = this.parseFunctions[type] ? this.parseFunctions[type].call(this, node) : this.fnParseOther(node);\n              // function with special handling or other type\n          }\n          if (Utils.debug > 2) {\n              Utils.console.debug(\"parseNode: type='\" + type + \"', value='\" + node.value + \"', ws='\" + node.ws + \"', resultValue='\" + value + \"'\");\n          }\n          return value;\n      }\n      evaluate(parseTree) {\n          let output = \"\";\n          for (let i = 0; i < parseTree.length; i += 1) {\n              if (Utils.debug > 2) {\n                  Utils.console.debug(\"evaluate: parseTree i=%d, node=%o\", i, parseTree[i]);\n              }\n              const node = this.parseNode(parseTree[i]);\n              if ((node !== undefined) && (node !== \"\")) {\n                  if (node !== null) {\n                      output += node;\n                  }\n                  else {\n                      output = \"\"; // cls (clear output when node is set to null)\n                  }\n              }\n          }\n          if (this.label) {\n              output += CodeGeneratorToken.token2String(\"_eol\") + CodeGeneratorToken.token2String(\"_eol\"); // 2 times eol is eof\n          }\n          return output;\n      }\n      generate(input) {\n          const out = {\n              text: \"\"\n          };\n          this.label = \"0\";\n          try {\n              const tokens = this.options.lexer.lex(input), parseTree = this.options.parser.parse(tokens), output = this.evaluate(parseTree);\n              out.text = output;\n          }\n          catch (e) {\n              if (Utils.isCustomError(e)) {\n                  out.error = e;\n                  if (!this.options.quiet) {\n                      Utils.console.warn(e); // show our customError as warning\n                  }\n              }\n              else { // other errors\n                  out.error = e; // force set other error\n                  Utils.console.error(e);\n              }\n          }\n          return out;\n      }\n  }\n\n  // ===== dist/esm/CommonEventHandler.js =====\n  // CommonEventHandler.ts - Common event handler for browser events\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n\n\n  class CommonEventHandler {\n      options;\n      model;\n      view;\n      controller;\n      eventDefInternalMap = {};\n      fnUserAction = undefined;\n      constructor(options) {\n          this.options = {};\n          this.setOptions(options);\n          // copy for easy access:\n          this.model = this.options.model;\n          this.view = this.options.view;\n          this.controller = this.options.controller;\n          this.createEventDefMap();\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      fnSetUserAction(fnAction) {\n          this.fnUserAction = fnAction;\n      }\n      initOneToggle(_type, id, eventDef) {\n          if (eventDef.property) {\n              if (eventDef.toggleId) {\n                  const isEnabled = this.model.getProperty(eventDef.property);\n                  this.view.setHidden(eventDef.toggleId, !isEnabled, eventDef.display);\n                  if (Utils.debug > 3) {\n                      Utils.console.debug(\"initToggles: setHidden: togglId:\", eventDef.toggleId, \", property:\", eventDef.property, \", hidden:\", !isEnabled, \", display:\", eventDef.display);\n                  }\n              }\n              if (eventDef.viewType === \"checked\") {\n                  const isEnabled2 = this.model.getProperty(eventDef.property);\n                  this.view.setInputChecked(id, isEnabled2);\n                  if (Utils.debug > 3) {\n                      Utils.console.debug(\"initToggles: checked: id:\", id, \", property:\", eventDef.property, \", checked:\", isEnabled2);\n                  }\n              }\n              else if (eventDef.viewType === \"select\") {\n                  const value = this.model.getProperty(eventDef.property);\n                  this.view.setSelectValue(id, value);\n                  if (Utils.debug > 3) {\n                      Utils.console.debug(\"initToggles: select: id:\", id, \", property:\", eventDef.property, \", value:\", value);\n                  }\n              }\n              else if (eventDef.viewType === \"numberInput\") {\n                  const value = this.model.getProperty(eventDef.property);\n                  this.view.setInputValue(id, String(value));\n                  if (Utils.debug > 3) {\n                      Utils.console.debug(\"initToggles: numberInput: id:\", id, \", property:\", eventDef.property, \", value:\", value);\n                  }\n              }\n          }\n      }\n      initToggles() {\n          const eventDefInternalMap = this.eventDefInternalMap;\n          for (const type in eventDefInternalMap) {\n              if (eventDefInternalMap.hasOwnProperty(type)) {\n                  const eventDefMap4Type = eventDefInternalMap[type];\n                  for (const id in eventDefMap4Type) {\n                      if (eventDefMap4Type.hasOwnProperty(id)) {\n                          const eventDef = eventDefMap4Type[id];\n                          this.initOneToggle(type, id, eventDef);\n                      }\n                  }\n              }\n          }\n      }\n      static getToggleId(eventDef) {\n          if (!eventDef.toggleId) {\n              Utils.console.error(\"getToggleId: id=\" + eventDef.id + \": toggleId missing!\");\n              return \"\"; //TTT\n          }\n          return eventDef.toggleId;\n      }\n      static getproperty(eventDef) {\n          if (!eventDef.property) {\n              Utils.console.error(\"setPopoversHiddenExcept: id=\" + eventDef.id + \": property missing!\");\n              return \"\"; //TTT\n          }\n          return eventDef.property;\n      }\n      setPopoversHiddenExcept(exceptId) {\n          const eventDefInternalMap = this.eventDefInternalMap, eventDefMapClick = eventDefInternalMap.click;\n          for (const id in eventDefMapClick) {\n              if (eventDefMapClick.hasOwnProperty(id)) {\n                  const eventDef = eventDefMapClick[id];\n                  if (eventDef.isPopover && (eventDef.toggleId !== exceptId)) {\n                      const toggleId = CommonEventHandler.getToggleId(eventDef), property = CommonEventHandler.getproperty(eventDef);\n                      if (!this.view.getHidden(toggleId)) {\n                          // we cannot use toggleAreaHidden because it would be recursive\n                          this.model.setProperty(property, false);\n                          this.view.setHidden(toggleId, true, eventDef.display);\n                      }\n                  }\n              }\n          }\n      }\n      toggleAreaHidden(eventDef) {\n          const toggleId = CommonEventHandler.getToggleId(eventDef), property = CommonEventHandler.getproperty(eventDef), visible = !this.model.getProperty(property);\n          this.model.setProperty(property, visible);\n          this.view.setHidden(toggleId, !visible, eventDef.display);\n          // on old browsers display \"flex\" is not available, so set default \"\" (=\"block\"), if still hidden\n          if (visible && eventDef.display === \"flex\" && this.view.getHidden(toggleId)) {\n              this.view.setHidden(toggleId, !visible);\n          }\n          if (visible && eventDef.isPopover) {\n              this.setPopoversHiddenExcept(toggleId);\n          }\n          return visible;\n      }\n      // maybe we can avoid this...\n      getEventDefById(type, id) {\n          const eventDefForType = this.eventDefInternalMap[type], eventDef = eventDefForType[id];\n          if (!eventDef) {\n              Utils.console.error(\"getEventDefById: type=\" + type + \", id=\" + id + \": No eventDef!\");\n          }\n          return eventDef;\n      }\n      toggleAreaHiddenById(type, id) {\n          const eventDef = this.getEventDefById(type, id);\n          return this.toggleAreaHidden(eventDef);\n      }\n      onCheckedChange(eventDef) {\n          const id = eventDef.id, property = CommonEventHandler.getproperty(eventDef), checked = this.view.getInputChecked(id);\n          this.model.setProperty(property, checked);\n          return checked;\n      }\n      onNumberInputChange(eventDef) {\n          const id = eventDef.id, property = CommonEventHandler.getproperty(eventDef), valueAsString = this.view.getInputValue(id), value = Number(valueAsString);\n          this.model.setProperty(property, value);\n          return value;\n      }\n      onSelectChange(eventDef) {\n          const id = eventDef.id, property = CommonEventHandler.getproperty(eventDef), value = this.view.getSelectValue(id);\n          this.model.setProperty(property, value);\n          this.view.setSelectTitleFromSelectedOption(id);\n          return value;\n      }\n      onExportButtonClick(eventDef) {\n          if (this.toggleAreaHidden(eventDef)) {\n              this.controller.setExportSelectOptions(\"exportFileSelect\" /* ViewID.exportFileSelect */);\n          }\n      }\n      onGalleryButtonClick(eventDef) {\n          if (this.toggleAreaHidden(eventDef)) {\n              this.controller.setGalleryAreaInputs();\n          }\n      }\n      fnUpdateAreaText(input) {\n          this.controller.setInputText(input, true);\n          this.view.setAreaValue(\"outputText\" /* ViewID.outputText */, \"\");\n      }\n      onUndoButtonClick() {\n          const input = this.controller.undoStackElement();\n          this.fnUpdateAreaText(input);\n      }\n      onRedoButtonClick() {\n          const input = this.controller.redoStackElement();\n          this.fnUpdateAreaText(input);\n      }\n      onContinueButtonClick(eventDef, event) {\n          this.controller.startContinue();\n          this.onCpcCanvasClick(eventDef, event);\n      }\n      onParseRunButtonClick(eventDef, event) {\n          this.controller.startParseRun();\n          this.onCpcCanvasClick(eventDef, event);\n      }\n      static onHelpButtonClick() {\n          window.open(\"https://github.com/benchmarko/cpclocots/#readme\");\n      }\n      onGalleryItemClick(_eventDef, event) {\n          const target = View.getEventTarget(event), value = target.value;\n          this.view.setSelectValue(\"exampleSelect\" /* ViewID.exampleSelect */, value);\n          this.setPopoversHiddenExcept(); // close\n          this.controller.onExampleSelectChange();\n      }\n      // eslint-disable-next-line class-methods-use-this\n      onCopyTextButtonClick() {\n          const textText = View.getElementByIdAs(\"textText\" /* ViewID.textText */);\n          textText.select();\n          this.view.setAreaSelection(\"textText\" /* ViewID.textText */, 0, 99999); // for mobile devices\n          if (window.navigator && window.navigator.clipboard) {\n              window.navigator.clipboard.writeText(textText.value);\n          }\n          else {\n              Utils.console.warn(\"Copy to clipboard not available\");\n          }\n      }\n      static encodeUriParam(params) {\n          const parts = [];\n          for (const key in params) {\n              if (params.hasOwnProperty(key)) {\n                  const value = params[key];\n                  parts[parts.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value === null ? \"\" : value);\n              }\n          }\n          return parts.join(\"&\");\n      }\n      onReloadButtonClick() {\n          this.setPopoversHiddenExcept(); // hide all popovers,\n          const changed = this.model.getChangedProperties();\n          let paras = CommonEventHandler.encodeUriParam(changed);\n          paras = paras.replace(/%2[Ff]/g, \"/\"); // unescape %2F -> /\n          window.location.search = \"?\" + paras;\n      }\n      onVarSelectChange() {\n          const par = this.view.getSelectValue(\"varSelect\" /* ViewID.varSelect */), value = this.controller.getVariable(par), valueString = (value !== undefined) ? String(value) : \"\";\n          this.view.setAreaValue(\"varText\" /* ViewID.varText */, valueString);\n      }\n      onKbdLayoutSelectChange(eventDef) {\n          const value = this.onSelectChange(eventDef);\n          this.view.setHidden(\"kbdAlpha\" /* ViewID.kbdAlpha */, value === \"num\");\n          this.view.setHidden(\"kbdNum\" /* ViewID.kbdNum */, value === \"alpha\");\n      }\n      onBasicVersionSelectChange(eventDef) {\n          const value = this.onSelectChange(eventDef);\n          this.controller.setBasicVersion(value);\n      }\n      onPaletteSelectChange(eventDef) {\n          const value = this.onSelectChange(eventDef);\n          this.controller.setPalette(value);\n      }\n      onCanvasTypeSelectChange(eventDef) {\n          const value = this.onSelectChange(eventDef);\n          this.controller.setCanvasType(value);\n      }\n      onDebugInputChange(eventDef) {\n          const value = this.onNumberInputChange(eventDef);\n          Utils.debug = value;\n      }\n      onDragElementsInputChange(eventDef) {\n          const checked = this.onCheckedChange(eventDef);\n          this.controller.fnDragElementsActive(checked);\n      }\n      onShowCpcInputChange(eventDef) {\n          if (this.toggleAreaHidden(eventDef)) {\n              this.controller.startUpdateCanvas();\n          }\n          else {\n              this.controller.stopUpdateCanvas();\n          }\n      }\n      onShowKbdInputChange(eventDef) {\n          if (this.toggleAreaHidden(eventDef)) {\n              this.controller.getVirtualKeyboard(); // maybe draw it\n          }\n      }\n      onDisassInputChange() {\n          const addressStr = this.view.getInputValue(\"disassInput\" /* ViewID.disassInput */), addrList = addressStr.split(\"-\"), // maybe range\n          addr = parseInt(addrList[0], 16), // parse as hex\n          endAddr = addrList[1] ? parseInt(addrList[1], 16) : undefined; // parse as hex\n          this.controller.setDisassAddr(addr, endAddr);\n      }\n      onSoundInputChange(eventDef) {\n          this.onCheckedChange(eventDef);\n          this.controller.setSoundActive();\n      }\n      onScreenshotButtonClick() {\n          var example = this.view.getSelectValue(\"exampleSelect\" /* ViewID.exampleSelect */), image = this.controller.startScreenshot(), link = View.getElementById1(\"screenshotLink\" /* ViewID.screenshotLink */), name = example + \".png\";\n          if (image) {\n              link.setAttribute(\"download\", name);\n              link.setAttribute(\"href\", image);\n              link.click();\n          }\n      }\n      onClearInputButtonClick() {\n          this.view.setAreaValue(\"inp2Text\" /* ViewID.inp2Text */, \"\"); // delete input\n      }\n      onFullscreenButtonClick() {\n          let id;\n          if (!this.view.getHidden(\"cpcCanvas\" /* ViewID.cpcCanvas */)) {\n              id = \"cpcCanvas\" /* ViewID.cpcCanvas */;\n          }\n          else if (!this.view.getHidden(\"textText\" /* ViewID.textText */)) {\n              // for ViewID.textText (textArea), we use the surrounding div...\n              id = \"textCanvasDiv\" /* ViewID.textCanvasDiv */;\n          }\n          else {\n              Utils.console.warn(\"Fullscreen only possible for graphics or text canvas\");\n              return;\n          }\n          const switched = this.view.requestFullscreenForId(id); // make sure to use an element with tabindex set to get keyboard events\n          if (!switched) {\n              Utils.console.warn(\"Switch to fullscreen not available\");\n          }\n      }\n      onCpcCanvasClick(_eventDef, event) {\n          this.setPopoversHiddenExcept(); // hide all popovers\n          this.controller.onCpcCanvasClick(event);\n      }\n      createEventDefMap() {\n          const eventDefInternalMap = this.eventDefInternalMap, eventDefs = {\n              click: [\n                  {\n                      id: \"clearInputButton\" /* ViewID.clearInputButton */,\n                      func: this.onClearInputButtonClick\n                  },\n                  {\n                      id: \"continueButton\" /* ViewID.continueButton */,\n                      func: this.onContinueButtonClick\n                  },\n                  {\n                      id: \"cpcCanvas\" /* ViewID.cpcCanvas */,\n                      func: this.onCpcCanvasClick\n                  },\n                  {\n                      id: \"copyTextButton\" /* ViewID.copyTextButton */,\n                      func: this.onCopyTextButtonClick\n                  },\n                  {\n                      id: \"downloadButton\" /* ViewID.downloadButton */,\n                      controllerFunc: this.controller.fnDownload\n                  },\n                  {\n                      id: \"enterButton\" /* ViewID.enterButton */,\n                      controllerFunc: this.controller.startEnter\n                  },\n                  {\n                      id: \"exportButton\" /* ViewID.exportButton */,\n                      toggleId: \"exportArea\" /* ViewID.exportArea */,\n                      property: \"showExport\" /* ModelPropID.showExport */,\n                      display: \"flex\",\n                      isPopover: true,\n                      func: this.onExportButtonClick\n                  },\n                  {\n                      id: \"fullscreenButton\" /* ViewID.fullscreenButton */,\n                      func: this.onFullscreenButtonClick\n                  },\n                  {\n                      id: \"galleryButton\" /* ViewID.galleryButton */,\n                      toggleId: \"galleryArea\" /* ViewID.galleryArea */,\n                      property: \"showGallery\" /* ModelPropID.showGallery */,\n                      display: \"flex\",\n                      isPopover: true,\n                      func: this.onGalleryButtonClick\n                  },\n                  {\n                      id: \"galleryItem\" /* ViewID.galleryItem */,\n                      func: this.onGalleryItemClick\n                  },\n                  {\n                      id: \"helpButton\" /* ViewID.helpButton */,\n                      func: CommonEventHandler.onHelpButtonClick\n                  },\n                  {\n                      id: \"lineNumberAddButton\" /* ViewID.lineNumberAddButton */,\n                      controllerFunc: this.controller.fnAddLines\n                  },\n                  {\n                      id: \"lineNumberRemoveButton\" /* ViewID.lineNumberRemoveButton */,\n                      controllerFunc: this.controller.fnRemoveLines\n                  },\n                  {\n                      id: \"moreButton\" /* ViewID.moreButton */,\n                      toggleId: \"moreArea\" /* ViewID.moreArea */,\n                      property: \"showMore\" /* ModelPropID.showMore */,\n                      display: \"flex\",\n                      isPopover: true,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"parseButton\" /* ViewID.parseButton */,\n                      controllerFunc: this.controller.startParse\n                  },\n                  {\n                      id: \"parseRunButton\" /* ViewID.parseRunButton */,\n                      func: this.onParseRunButtonClick\n                  },\n                  {\n                      id: \"prettyButton\" /* ViewID.prettyButton */,\n                      controllerFunc: this.controller.fnPretty\n                  },\n                  {\n                      id: \"prettyPopoverButton\" /* ViewID.prettyPopoverButton */,\n                      toggleId: \"prettyArea\" /* ViewID.prettyArea */,\n                      property: \"showPretty\" /* ModelPropID.showPretty */,\n                      display: \"flex\",\n                      isPopover: true,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"redoButton\" /* ViewID.redoButton */,\n                      func: this.onRedoButtonClick\n                  },\n                  {\n                      id: \"redoButton2\" /* ViewID.redoButton2 */,\n                      func: this.onRedoButtonClick // same redo\n                  },\n                  {\n                      id: \"reloadButton\" /* ViewID.reloadButton */,\n                      func: this.onReloadButtonClick\n                  },\n                  {\n                      id: \"reload2Button\" /* ViewID.reload2Button */,\n                      func: this.onReloadButtonClick // same as relaodButton\n                  },\n                  {\n                      id: \"renumButton\" /* ViewID.renumButton */,\n                      controllerFunc: this.controller.startRenum\n                  },\n                  {\n                      id: \"renumPopoverButton\" /* ViewID.renumPopoverButton */,\n                      toggleId: \"renumArea\" /* ViewID.renumArea */,\n                      property: \"showRenum\" /* ModelPropID.showRenum */,\n                      display: \"flex\",\n                      isPopover: true,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"resetButton\" /* ViewID.resetButton */,\n                      controllerFunc: this.controller.startReset\n                  },\n                  {\n                      id: \"runButton\" /* ViewID.runButton */,\n                      controllerFunc: this.controller.startRun\n                  },\n                  {\n                      id: \"screenshotButton\" /* ViewID.screenshotButton */,\n                      func: this.onScreenshotButtonClick\n                  },\n                  {\n                      id: \"screenshotLink\" /* ViewID.screenshotLink */ // nothing\n                  },\n                  {\n                      id: \"settingsButton\" /* ViewID.settingsButton */,\n                      toggleId: \"settingsArea\" /* ViewID.settingsArea */,\n                      property: \"showSettings\" /* ModelPropID.showSettings */,\n                      display: \"flex\",\n                      isPopover: true,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"stopButton\" /* ViewID.stopButton */,\n                      controllerFunc: this.controller.startBreak\n                  },\n                  {\n                      id: \"textText\" /* ViewID.textText */,\n                      func: this.onCpcCanvasClick // same as for cpcCanvas\n                  },\n                  {\n                      id: \"undoButton\" /* ViewID.undoButton */,\n                      func: this.onUndoButtonClick\n                  },\n                  {\n                      id: \"undoButton2\" /* ViewID.undoButton2 */,\n                      func: this.onUndoButtonClick // same undo\n                  },\n                  {\n                      id: \"viewButton\" /* ViewID.viewButton */,\n                      toggleId: \"viewArea\" /* ViewID.viewArea */,\n                      property: \"showView\" /* ModelPropID.showView */,\n                      display: \"flex\",\n                      isPopover: true,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"window\" /* ViewID.window */, //TTT do we need this?\n                      controllerFunc: this.controller.onWindowClick\n                  }\n              ],\n              change: [\n                  {\n                      id: \"arrayBoundsInput\" /* ViewID.arrayBoundsInput */,\n                      viewType: \"checked\",\n                      property: \"arrayBounds\" /* ModelPropID.arrayBounds */,\n                      func: this.onCheckedChange,\n                      controllerFunc: this.controller.fnArrayBounds\n                  },\n                  {\n                      id: \"autorunInput\" /* ViewID.autorunInput */,\n                      viewType: \"checked\",\n                      property: \"autorun\" /* ModelPropID.autorun */,\n                      func: this.onCheckedChange\n                  },\n                  {\n                      id: \"basicVersionSelect\" /* ViewID.basicVersionSelect */,\n                      viewType: \"select\",\n                      property: \"basicVersion\" /* ModelPropID.basicVersion */,\n                      func: this.onBasicVersionSelectChange\n                  },\n                  {\n                      id: \"canvasTypeSelect\" /* ViewID.canvasTypeSelect */,\n                      viewType: \"select\",\n                      property: \"canvasType\" /* ModelPropID.canvasType */,\n                      func: this.onCanvasTypeSelectChange\n                  },\n                  {\n                      id: \"databaseSelect\" /* ViewID.databaseSelect */,\n                      controllerFunc: this.controller.onDatabaseSelectChange\n                  },\n                  {\n                      id: \"debugInput\" /* ViewID.debugInput */,\n                      viewType: \"numberInput\",\n                      property: \"debug\" /* ModelPropID.debug */,\n                      func: this.onDebugInputChange\n                  },\n                  {\n                      id: \"directorySelect\" /* ViewID.directorySelect */,\n                      controllerFunc: this.controller.onDirectorySelectChange\n                  },\n                  {\n                      id: \"disassInput\" /* ViewID.disassInput */,\n                      func: this.onDisassInputChange\n                  },\n                  {\n                      id: \"exampleSelect\" /* ViewID.exampleSelect */,\n                      controllerFunc: this.controller.onExampleSelectChange\n                  },\n                  {\n                      id: \"implicitLinesInput\" /* ViewID.implicitLinesInput */,\n                      viewType: \"checked\",\n                      property: \"implicitLines\" /* ModelPropID.implicitLines */,\n                      func: this.onCheckedChange,\n                      controllerFunc: this.controller.fnImplicitLines\n                  },\n                  {\n                      id: \"integerOverflowInput\" /* ViewID.integerOverflowInput */,\n                      viewType: \"checked\",\n                      property: \"integerOverflow\" /* ModelPropID.integerOverflow */,\n                      func: this.onCheckedChange,\n                      controllerFunc: this.controller.fnIntegerOverflow\n                  },\n                  {\n                      id: \"kbdLayoutSelect\" /* ViewID.kbdLayoutSelect */,\n                      viewType: \"select\",\n                      property: \"kbdLayout\" /* ModelPropID.kbdLayout */,\n                      func: this.onKbdLayoutSelectChange\n                  },\n                  {\n                      id: \"linesOnLoadInput\" /* ViewID.linesOnLoadInput */,\n                      viewType: \"checked\",\n                      property: \"linesOnLoad\" /* ModelPropID.linesOnLoad */,\n                      func: this.onCheckedChange\n                  },\n                  {\n                      id: \"dragElementsInput\" /* ViewID.dragElementsInput */,\n                      viewType: \"checked\",\n                      property: \"dragElements\" /* ModelPropID.dragElements */,\n                      func: this.onDragElementsInputChange\n                  },\n                  {\n                      id: \"outputText\" /* ViewID.outputText */,\n                      controllerFunc: this.controller.invalidateScript\n                  },\n                  {\n                      id: \"paletteSelect\" /* ViewID.paletteSelect */,\n                      viewType: \"select\",\n                      property: \"palette\" /* ModelPropID.palette */,\n                      func: this.onPaletteSelectChange\n                  },\n                  {\n                      id: \"prettyBracketsInput\" /* ViewID.prettyBracketsInput */,\n                      viewType: \"checked\",\n                      property: \"prettyBrackets\" /* ModelPropID.prettyBrackets */,\n                      func: this.onCheckedChange\n                  },\n                  {\n                      id: \"prettyColonsInput\" /* ViewID.prettyColonsInput */,\n                      viewType: \"checked\",\n                      property: \"prettyColons\" /* ModelPropID.prettyColons */,\n                      func: this.onCheckedChange\n                  },\n                  {\n                      id: \"prettyLowercaseVarsInput\" /* ViewID.prettyLowercaseVarsInput */,\n                      viewType: \"checked\",\n                      property: \"prettyLowercaseVars\" /* ModelPropID.prettyLowercaseVars */,\n                      func: this.onCheckedChange,\n                      controllerFunc: this.controller.fnPrettyLowercaseVars\n                  },\n                  {\n                      id: \"prettySpaceInput\" /* ViewID.prettySpaceInput */,\n                      viewType: \"checked\",\n                      property: \"prettySpace\" /* ModelPropID.prettySpace */,\n                      func: this.onCheckedChange\n                  },\n                  {\n                      id: \"selectDataFilesInput\" /* ViewID.selectDataFilesInput */,\n                      viewType: \"checked\",\n                      property: \"selectDataFiles\" /* ModelPropID.selectDataFiles */,\n                      func: this.onCheckedChange\n                  },\n                  {\n                      id: \"showConsoleLogInput\" /* ViewID.showConsoleLogInput */,\n                      viewType: \"checked\",\n                      toggleId: \"consoleLogArea\" /* ViewID.consoleLogArea */,\n                      property: \"showConsoleLog\" /* ModelPropID.showConsoleLog */,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"showCpcInput\" /* ViewID.showCpcInput */,\n                      viewType: \"checked\",\n                      toggleId: \"cpcArea\" /* ViewID.cpcArea */,\n                      property: \"showCpc\" /* ModelPropID.showCpc */,\n                      func: this.onShowCpcInputChange\n                  },\n                  {\n                      id: \"showDisassInput\" /* ViewID.showDisassInput */,\n                      viewType: \"checked\",\n                      toggleId: \"disassArea\" /* ViewID.disassArea */,\n                      property: \"showDisass\" /* ModelPropID.showDisass */,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"showInp2Input\" /* ViewID.showInp2Input */,\n                      viewType: \"checked\",\n                      toggleId: \"inp2Area\" /* ViewID.inp2Area */,\n                      property: \"showInp2\" /* ModelPropID.showInp2 */,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"showInputInput\" /* ViewID.showInputInput */,\n                      viewType: \"checked\",\n                      toggleId: \"inputArea\" /* ViewID.inputArea */,\n                      property: \"showInput\" /* ModelPropID.showInput */,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"showKbdInput\" /* ViewID.showKbdInput */,\n                      viewType: \"checked\",\n                      toggleId: \"kbdArea\" /* ViewID.kbdArea */,\n                      property: \"showKbd\" /* ModelPropID.showKbd */,\n                      func: this.onShowKbdInputChange\n                  },\n                  {\n                      id: \"showOutputInput\" /* ViewID.showOutputInput */,\n                      viewType: \"checked\",\n                      toggleId: \"outputArea\" /* ViewID.outputArea */,\n                      property: \"showOutput\" /* ModelPropID.showOutput */,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"showResultInput\" /* ViewID.showResultInput */,\n                      viewType: \"checked\",\n                      toggleId: \"resultArea\" /* ViewID.resultArea */,\n                      property: \"showResult\" /* ModelPropID.showResult */,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"showVariableInput\" /* ViewID.showVariableInput */,\n                      viewType: \"checked\",\n                      toggleId: \"variableArea\" /* ViewID.variableArea */,\n                      property: \"showVariable\" /* ModelPropID.showVariable */,\n                      func: this.toggleAreaHidden\n                  },\n                  {\n                      id: \"soundInput\" /* ViewID.soundInput */,\n                      viewType: \"checked\",\n                      property: \"sound\" /* ModelPropID.sound */,\n                      func: this.onSoundInputChange\n                  },\n                  {\n                      id: \"speedInput\" /* ViewID.speedInput */,\n                      viewType: \"numberInput\",\n                      property: \"speed\" /* ModelPropID.speed */,\n                      func: this.onNumberInputChange,\n                      controllerFunc: this.controller.fnSpeed\n                  },\n                  {\n                      id: \"traceInput\" /* ViewID.traceInput */,\n                      viewType: \"checked\",\n                      property: \"trace\" /* ModelPropID.trace */,\n                      func: this.onCheckedChange,\n                      controllerFunc: this.controller.fnTrace\n                  },\n                  {\n                      id: \"varSelect\" /* ViewID.varSelect */,\n                      func: this.onVarSelectChange\n                  },\n                  {\n                      id: \"varText\" /* ViewID.varText */,\n                      controllerFunc: this.controller.changeVariable\n                  }\n              ]\n          };\n          for (const type in eventDefs) {\n              if (eventDefs.hasOwnProperty(type)) {\n                  eventDefInternalMap[type] = {};\n                  const eventDefList = eventDefs[type], itemForType = eventDefInternalMap[type];\n                  for (let i = 0; i < eventDefList.length; i += 1) {\n                      itemForType[eventDefList[i].id] = eventDefList[i];\n                  }\n              }\n          }\n      }\n      handleEvent(event) {\n          const target = View.getEventTarget(event), type = event.type; // click or change\n          let id = (target) ? target.getAttribute(\"id\") : String(target);\n          if (this.fnUserAction) {\n              this.fnUserAction(event, id);\n          }\n          if (id) {\n              if (target.disabled) { // check needed for IE which also fires for disabled buttons\n                  return; // ignore\n              }\n              if (id.startsWith(\"galleryItem\")) {\n                  id = \"galleryItem\"; // replace galleryitem<num> by galleryitem\n              }\n              if (this.eventDefInternalMap[type] && this.eventDefInternalMap[type][id]) {\n                  const eventDef = this.eventDefInternalMap[type][id];\n                  if (Utils.debug) {\n                      Utils.console.debug(\"handleEvent: \" + type + \", \" + id + \":\", eventDef);\n                  }\n                  if (eventDef.func) {\n                      eventDef.func.call(this, eventDef, event);\n                  }\n                  if (eventDef.controllerFunc) {\n                      eventDef.controllerFunc.call(this.controller, eventDef, event);\n                  }\n              }\n              else if (!id.endsWith(\"Select\") && !id.endsWith(\"Input\")) { // do not print all messages; these are usually handled by change\n                  Utils.console.log(\"handleEvent: \" + type + \", \" + id + \": No handler\");\n              }\n          }\n          else if (Utils.debug) {\n              Utils.console.log(\"handleEvent: \" + type + \": unknown target:\", target.tagName, target.id);\n          }\n          if (type === \"click\") { // special\n              if (id !== \"cpcCanvas\" /* ViewID.cpcCanvas */ && id !== \"textText\" /* ViewID.textText */) {\n                  this.controller.onWindowClick(event);\n              }\n          }\n      }\n  }\n\n  // ===== dist/esm/cpcCharset.js =====\n  // cpcCharset.ts\n  //\n  /* eslint-disable array-element-newline */\n  const cpcCharset = [\n      [0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff], // 0x00\n      [0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0], // 0x01\n      [0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff], // 0x02\n      [0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0xff], // 0x03\n      [0x0c, 0x18, 0x30, 0x7e, 0x0c, 0x18, 0x30, 0x00], // 0x04\n      [0xff, 0xc3, 0xe7, 0xdb, 0xdb, 0xe7, 0xc3, 0xff], // 0x05\n      [0x00, 0x01, 0x03, 0x06, 0xcc, 0x78, 0x30, 0x00], // 0x06\n      [0x3c, 0x66, 0xc3, 0xc3, 0xff, 0x24, 0xe7, 0x00], // 0x07\n      [0x00, 0x00, 0x30, 0x60, 0xff, 0x60, 0x30, 0x00], // 0x08\n      [0x00, 0x00, 0x0c, 0x06, 0xff, 0x06, 0x0c, 0x00], // 0x09\n      [0x18, 0x18, 0x18, 0x18, 0xdb, 0x7e, 0x3c, 0x18], // 0x0a\n      [0x18, 0x3c, 0x7e, 0xdb, 0x18, 0x18, 0x18, 0x18], // 0x0b\n      [0x18, 0x5a, 0x3c, 0x99, 0xdb, 0x7e, 0x3c, 0x18], // 0x0c\n      [0x00, 0x03, 0x33, 0x63, 0xfe, 0x60, 0x30, 0x00], // 0x0d\n      [0x3c, 0x66, 0xff, 0xdb, 0xdb, 0xff, 0x66, 0x3c], // 0x0e\n      [0x3c, 0x66, 0xc3, 0xdb, 0xdb, 0xc3, 0x66, 0x3c], // 0x0f\n      [0xff, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xff], // 0x10\n      [0x3c, 0x7e, 0xdb, 0xdb, 0xdf, 0xc3, 0x66, 0x3c], // 0x11\n      [0x3c, 0x66, 0xc3, 0xdf, 0xdb, 0xdb, 0x7e, 0x3c], // 0x12\n      [0x3c, 0x66, 0xc3, 0xfb, 0xdb, 0xdb, 0x7e, 0x3c], // 0x13\n      [0x3c, 0x7e, 0xdb, 0xdb, 0xfb, 0xc3, 0x66, 0x3c], // 0x14\n      [0x00, 0x01, 0x33, 0x1e, 0xce, 0x7b, 0x31, 0x00], // 0x15\n      [0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xe7], // 0x16\n      [0x03, 0x03, 0x03, 0xff, 0x03, 0x03, 0x03, 0x00], // 0x17\n      [0xff, 0x66, 0x3c, 0x18, 0x18, 0x3c, 0x66, 0xff], // 0x18\n      [0x18, 0x18, 0x3c, 0x3c, 0x3c, 0x3c, 0x18, 0x18], // 0x19\n      [0x3c, 0x66, 0x66, 0x30, 0x18, 0x00, 0x18, 0x00], // 0x1a\n      [0x3c, 0x66, 0xc3, 0xff, 0xc3, 0xc3, 0x66, 0x3c], // 0x1b\n      [0xff, 0xdb, 0xdb, 0xdb, 0xfb, 0xc3, 0xc3, 0xff], // 0x1c\n      [0xff, 0xc3, 0xc3, 0xfb, 0xdb, 0xdb, 0xdb, 0xff], // 0x1d\n      [0xff, 0xc3, 0xc3, 0xdf, 0xdb, 0xdb, 0xdb, 0xff], // 0x1e\n      [0xff, 0xdb, 0xdb, 0xdb, 0xdf, 0xc3, 0xc3, 0xff], // 0x1f\n      [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x20\n      [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00], // 0x21\n      [0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x22\n      [0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00], // 0x23\n      [0x18, 0x3e, 0x58, 0x3c, 0x1a, 0x7c, 0x18, 0x00], // 0x24\n      [0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00], // 0x25\n      [0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00], // 0x26\n      [0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x27\n      [0x0c, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00], // 0x28\n      [0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00], // 0x29\n      [0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00], // 0x2a\n      [0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00], // 0x2b\n      [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30], // 0x2c\n      [0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00], // 0x2d\n      [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00], // 0x2e\n      [0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00], // 0x2f\n      [0x7c, 0xc6, 0xce, 0xd6, 0xe6, 0xc6, 0x7c, 0x00], // 0x30\n      [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00], // 0x31\n      [0x3c, 0x66, 0x06, 0x3c, 0x60, 0x66, 0x7e, 0x00], // 0x32\n      [0x3c, 0x66, 0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00], // 0x33\n      [0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00], // 0x34\n      [0x7e, 0x62, 0x60, 0x7c, 0x06, 0x66, 0x3c, 0x00], // 0x35\n      [0x3c, 0x66, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00], // 0x36\n      [0x7e, 0x66, 0x06, 0x0c, 0x18, 0x18, 0x18, 0x00], // 0x37\n      [0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00], // 0x38\n      [0x3c, 0x66, 0x66, 0x3e, 0x06, 0x66, 0x3c, 0x00], // 0x39\n      [0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00], // 0x3a\n      [0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30], // 0x3b\n      [0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x00], // 0x3c\n      [0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00], // 0x3d\n      [0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00], // 0x3e\n      [0x3c, 0x66, 0x66, 0x0c, 0x18, 0x00, 0x18, 0x00], // 0x3f\n      [0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x7c, 0x00], // 0x40\n      [0x18, 0x3c, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x00], // 0x41\n      [0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00], // 0x42\n      [0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00], // 0x43\n      [0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00], // 0x44\n      [0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00], // 0x45\n      [0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00], // 0x46\n      [0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00], // 0x47\n      [0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00], // 0x48\n      [0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00], // 0x49\n      [0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00], // 0x4a\n      [0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00], // 0x4b\n      [0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00], // 0x4c\n      [0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00], // 0x4d\n      [0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00], // 0x4e\n      [0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00], // 0x4f\n      [0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00], // 0x50\n      [0x38, 0x6c, 0xc6, 0xc6, 0xda, 0xcc, 0x76, 0x00], // 0x51\n      [0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00], // 0x52\n      [0x3c, 0x66, 0x60, 0x3c, 0x06, 0x66, 0x3c, 0x00], // 0x53\n      [0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00], // 0x54\n      [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00], // 0x55\n      [0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00], // 0x56\n      [0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00], // 0x57\n      [0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0xc6, 0x00], // 0x58\n      [0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x3c, 0x00], // 0x59\n      [0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00], // 0x5a\n      [0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00], // 0x5b\n      [0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00], // 0x5c\n      [0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00], // 0x5d\n      [0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00], // 0x5e\n      [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff], // 0x5f\n      [0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x60\n      [0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00], // 0x61\n      [0xe0, 0x60, 0x7c, 0x66, 0x66, 0x66, 0xdc, 0x00], // 0x62\n      [0x00, 0x00, 0x3c, 0x66, 0x60, 0x66, 0x3c, 0x00], // 0x63\n      [0x1c, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00], // 0x64\n      [0x00, 0x00, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00], // 0x65\n      [0x1c, 0x36, 0x30, 0x78, 0x30, 0x30, 0x78, 0x00], // 0x66\n      [0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x7c], // 0x67\n      [0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00], // 0x68\n      [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00], // 0x69\n      [0x06, 0x00, 0x0e, 0x06, 0x06, 0x66, 0x66, 0x3c], // 0x6a\n      [0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00], // 0x6b\n      [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00], // 0x6c\n      [0x00, 0x00, 0x6c, 0xfe, 0xd6, 0xd6, 0xc6, 0x00], // 0x6d\n      [0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x00], // 0x6e\n      [0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00], // 0x6f\n      [0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0], // 0x70\n      [0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e], // 0x71\n      [0x00, 0x00, 0xdc, 0x76, 0x60, 0x60, 0xf0, 0x00], // 0x72\n      [0x00, 0x00, 0x3c, 0x60, 0x3c, 0x06, 0x7c, 0x00], // 0x73\n      [0x30, 0x30, 0x7c, 0x30, 0x30, 0x36, 0x1c, 0x00], // 0x74\n      [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00], // 0x75\n      [0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00], // 0x76\n      [0x00, 0x00, 0xc6, 0xd6, 0xd6, 0xfe, 0x6c, 0x00], // 0x77\n      [0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00], // 0x78\n      [0x00, 0x00, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x7c], // 0x79\n      [0x00, 0x00, 0x7e, 0x4c, 0x18, 0x32, 0x7e, 0x00], // 0x7a\n      [0x0e, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0e, 0x00], // 0x7b\n      [0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // 0x7c\n      [0x70, 0x18, 0x18, 0x0e, 0x18, 0x18, 0x70, 0x00], // 0x7d\n      [0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x7e\n      [0xcc, 0x33, 0xcc, 0x33, 0xcc, 0x33, 0xcc, 0x33], // 0x7f\n      [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0x80\n      [0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00], // 0x81\n      [0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00], // 0x82\n      [0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00], // 0x83\n      [0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0], // 0x84\n      [0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0], // 0x85\n      [0x0f, 0x0f, 0x0f, 0x0f, 0xf0, 0xf0, 0xf0, 0xf0], // 0x86\n      [0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0], // 0x87\n      [0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f], // 0x88\n      [0xf0, 0xf0, 0xf0, 0xf0, 0x0f, 0x0f, 0x0f, 0x0f], // 0x89\n      [0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f], // 0x8a\n      [0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f], // 0x8b\n      [0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff], // 0x8c\n      [0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff], // 0x8d\n      [0x0f, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff], // 0x8e\n      [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff], // 0x8f\n      [0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00], // 0x90\n      [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00], // 0x91\n      [0x00, 0x00, 0x00, 0x1f, 0x1f, 0x00, 0x00, 0x00], // 0x92\n      [0x18, 0x18, 0x18, 0x1f, 0x0f, 0x00, 0x00, 0x00], // 0x93\n      [0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18], // 0x94\n      [0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18], // 0x95\n      [0x00, 0x00, 0x00, 0x0f, 0x1f, 0x18, 0x18, 0x18], // 0x96\n      [0x18, 0x18, 0x18, 0x1f, 0x1f, 0x18, 0x18, 0x18], // 0x97\n      [0x00, 0x00, 0x00, 0xf8, 0xf8, 0x00, 0x00, 0x00], // 0x98\n      [0x18, 0x18, 0x18, 0xf8, 0xf0, 0x00, 0x00, 0x00], // 0x99\n      [0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00], // 0x9a\n      [0x18, 0x18, 0x18, 0xff, 0xff, 0x00, 0x00, 0x00], // 0x9b\n      [0x00, 0x00, 0x00, 0xf0, 0xf8, 0x18, 0x18, 0x18], // 0x9c\n      [0x18, 0x18, 0x18, 0xf8, 0xf8, 0x18, 0x18, 0x18], // 0x9d\n      [0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x18, 0x18], // 0x9e\n      [0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18], // 0x9f\n      [0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00], // 0xa0\n      [0x0c, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00], // 0xa1\n      [0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0xa2\n      [0x3c, 0x66, 0x60, 0xf8, 0x60, 0x66, 0xfe, 0x00], // 0xa3\n      [0x38, 0x44, 0xba, 0xa2, 0xba, 0x44, 0x38, 0x00], // 0xa4\n      [0x7e, 0xf4, 0xf4, 0x74, 0x34, 0x34, 0x34, 0x00], // 0xa5\n      [0x1e, 0x30, 0x38, 0x6c, 0x38, 0x18, 0xf0, 0x00], // 0xa6\n      [0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00], // 0xa7\n      [0x40, 0xc0, 0x44, 0x4c, 0x54, 0x1e, 0x04, 0x00], // 0xa8\n      [0x40, 0xc0, 0x4c, 0x52, 0x44, 0x08, 0x1e, 0x00], // 0xa9\n      [0xe0, 0x10, 0x62, 0x16, 0xea, 0x0f, 0x02, 0x00], // 0xaa\n      [0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x7e, 0x00], // 0xab\n      [0x18, 0x18, 0x00, 0x7e, 0x00, 0x18, 0x18, 0x00], // 0xac\n      [0x00, 0x00, 0x00, 0x7e, 0x06, 0x06, 0x00, 0x00], // 0xad\n      [0x18, 0x00, 0x18, 0x30, 0x66, 0x66, 0x3c, 0x00], // 0xae\n      [0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // 0xaf\n      [0x00, 0x00, 0x73, 0xde, 0xcc, 0xde, 0x73, 0x00], // 0xb0\n      [0x7c, 0xc6, 0xc6, 0xfc, 0xc6, 0xc6, 0xf8, 0xc0], // 0xb1\n      [0x00, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00], // 0xb2\n      [0x3c, 0x60, 0x60, 0x3c, 0x66, 0x66, 0x3c, 0x00], // 0xb3\n      [0x00, 0x00, 0x1e, 0x30, 0x7c, 0x30, 0x1e, 0x00], // 0xb4\n      [0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0x6c, 0x38, 0x00], // 0xb5\n      [0x00, 0xc0, 0x60, 0x30, 0x38, 0x6c, 0xc6, 0x00], // 0xb6\n      [0x00, 0x00, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60], // 0xb7\n      [0x00, 0x00, 0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x00], // 0xb8\n      [0x00, 0x00, 0x00, 0x7e, 0xd8, 0xd8, 0x70, 0x00], // 0xb9\n      [0x03, 0x06, 0x0c, 0x3c, 0x66, 0x3c, 0x60, 0xc0], // 0xba\n      [0x03, 0x06, 0x0c, 0x66, 0x66, 0x3c, 0x60, 0xc0], // 0xbb\n      [0x00, 0xe6, 0x3c, 0x18, 0x38, 0x6c, 0xc7, 0x00], // 0xbc\n      [0x00, 0x00, 0x66, 0xc3, 0xdb, 0xdb, 0x7e, 0x00], // 0xbd\n      [0xfe, 0xc6, 0x60, 0x30, 0x60, 0xc6, 0xfe, 0x00], // 0xbe\n      [0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x6c, 0xee, 0x00], // 0xbf\n      [0x18, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x00], // 0xc0\n      [0x18, 0x0c, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00], // 0xc1\n      [0x00, 0x00, 0x00, 0x01, 0x03, 0x06, 0x0c, 0x18], // 0xc2\n      [0x00, 0x00, 0x00, 0x80, 0xc0, 0x60, 0x30, 0x18], // 0xc3\n      [0x18, 0x3c, 0x66, 0xc3, 0x81, 0x00, 0x00, 0x00], // 0xc4\n      [0x18, 0x0c, 0x06, 0x03, 0x03, 0x06, 0x0c, 0x18], // 0xc5\n      [0x00, 0x00, 0x00, 0x81, 0xc3, 0x66, 0x3c, 0x18], // 0xc6\n      [0x18, 0x30, 0x60, 0xc0, 0xc0, 0x60, 0x30, 0x18], // 0xc7\n      [0x18, 0x30, 0x60, 0xc1, 0x83, 0x06, 0x0c, 0x18], // 0xc8\n      [0x18, 0x0c, 0x06, 0x83, 0xc1, 0x60, 0x30, 0x18], // 0xc9\n      [0x18, 0x3c, 0x66, 0xc3, 0xc3, 0x66, 0x3c, 0x18], // 0xca\n      [0xc3, 0xe7, 0x7e, 0x3c, 0x3c, 0x7e, 0xe7, 0xc3], // 0xcb\n      [0x03, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xc0], // 0xcc\n      [0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x07, 0x03], // 0xcd\n      [0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0x33, 0x33], // 0xce\n      [0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55], // 0xcf\n      [0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0xd0\n      [0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03], // 0xd1\n      [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff], // 0xd2\n      [0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0], // 0xd3\n      [0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80], // 0xd4\n      [0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01], // 0xd5\n      [0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff], // 0xd6\n      [0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff], // 0xd7\n      [0xaa, 0x55, 0xaa, 0x55, 0x00, 0x00, 0x00, 0x00], // 0xd8\n      [0x0a, 0x05, 0x0a, 0x05, 0x0a, 0x05, 0x0a, 0x05], // 0xd9\n      [0x00, 0x00, 0x00, 0x00, 0xaa, 0x55, 0xaa, 0x55], // 0xda\n      [0xa0, 0x50, 0xa0, 0x50, 0xa0, 0x50, 0xa0, 0x50], // 0xdb\n      [0xaa, 0x54, 0xa8, 0x50, 0xa0, 0x40, 0x80, 0x00], // 0xdc\n      [0xaa, 0x55, 0x2a, 0x15, 0x0a, 0x05, 0x02, 0x01], // 0xdd\n      [0x01, 0x02, 0x05, 0x0a, 0x15, 0x2a, 0x55, 0xaa], // 0xde\n      [0x00, 0x80, 0x40, 0xa0, 0x50, 0xa8, 0x54, 0xaa], // 0xdf\n      [0x7e, 0xff, 0x99, 0xff, 0xbd, 0xc3, 0xff, 0x7e], // 0xe0\n      [0x7e, 0xff, 0x99, 0xff, 0xc3, 0xbd, 0xff, 0x7e], // 0xe1\n      [0x38, 0x38, 0xfe, 0xfe, 0xfe, 0x10, 0x38, 0x00], // 0xe2\n      [0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00], // 0xe3\n      [0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00], // 0xe4\n      [0x10, 0x38, 0x7c, 0xfe, 0xfe, 0x10, 0x38, 0x00], // 0xe5\n      [0x00, 0x3c, 0x66, 0xc3, 0xc3, 0x66, 0x3c, 0x00], // 0xe6\n      [0x00, 0x3c, 0x7e, 0xff, 0xff, 0x7e, 0x3c, 0x00], // 0xe7\n      [0x00, 0x7e, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00], // 0xe8\n      [0x00, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x00], // 0xe9\n      [0x0f, 0x07, 0x0d, 0x78, 0xcc, 0xcc, 0xcc, 0x78], // 0xea\n      [0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18], // 0xeb\n      [0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x7c, 0x38], // 0xec\n      [0x18, 0x1c, 0x1e, 0x1b, 0x18, 0x78, 0xf8, 0x70], // 0xed\n      [0x99, 0x5a, 0x24, 0xc3, 0xc3, 0x24, 0x5a, 0x99], // 0xee\n      [0x10, 0x38, 0x38, 0x38, 0x38, 0x38, 0x7c, 0xd6], // 0xef\n      [0x18, 0x3c, 0x7e, 0xff, 0x18, 0x18, 0x18, 0x18], // 0xf0\n      [0x18, 0x18, 0x18, 0x18, 0xff, 0x7e, 0x3c, 0x18], // 0xf1\n      [0x10, 0x30, 0x70, 0xff, 0xff, 0x70, 0x30, 0x10], // 0xf2\n      [0x08, 0x0c, 0x0e, 0xff, 0xff, 0x0e, 0x0c, 0x08], // 0xf3\n      [0x00, 0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00], // 0xf4\n      [0x00, 0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00], // 0xf5\n      [0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00], // 0xf6\n      [0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00], // 0xf7\n      [0x38, 0x38, 0x92, 0x7c, 0x10, 0x28, 0x28, 0x28], // 0xf8\n      [0x38, 0x38, 0x10, 0xfe, 0x10, 0x28, 0x44, 0x82], // 0xf9\n      [0x38, 0x38, 0x12, 0x7c, 0x90, 0x28, 0x24, 0x22], // 0xfa\n      [0x38, 0x38, 0x90, 0x7c, 0x12, 0x28, 0x48, 0x88], // 0xfb\n      [0x00, 0x3c, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x00], // 0xfc\n      [0x3c, 0xff, 0xff, 0x18, 0x0c, 0x18, 0x30, 0x18], // 0xfd\n      [0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18], // 0xfe\n      [0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00] //  0xff\n  ];\n  /* eslint-enable array-element-newline */\n\n  // ===== dist/esm/Random.js =====\n  // Random.ts - Random Number Generator\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n  // Random number generator taken from:\n  // Raj Jain: The Art of Computer Systems Performance Analysis, John Wiley & Sons, 1991, page 442-444\n  //\n  class Random {\n      x;\n      constructor(seed) {\n          this.init(seed);\n      }\n      init(seed) {\n          this.x = seed || 1; // do not use 0\n      }\n      random() {\n          const m = 2147483647, // prime number 2^31-1; modulus, do not change!\n          a = 16807, // 7^5, one primitive root; multiplier\n          q = 127773, // m div a\n          r = 2836; // m mod a\n          let x = this.x; // last random value\n          x = a * (x % q) - r * ((x / q) | 0); // eslint-disable-line no-bitwise\n          // we use \"| 0\" to get an integer div result\n          if (x <= 0) {\n              x += m; // x is new random number\n          }\n          this.x = x;\n          return x / m;\n      }\n  }\n\n  // ===== dist/esm/CpcVmRsx.js =====\n  // CpcVmRsx.ts - CPC Virtual Machine: RSX (Resident System Extension)\n  // (c) Marco Vieth, 2020\n  // https://benchmarko.github.io/cpclocots/\n  //\n  class CpcVmRsx {\n      rsxPermanent = {};\n      rsxTemporary = {};\n      callRsx(vm, name, ...args) {\n          const fn = this.rsxTemporary[name] || this.rsxPermanent[name];\n          if (fn) {\n              fn.apply(vm, args);\n          }\n          return Boolean(fn);\n      }\n      registerRsx(rsxModule, permanent) {\n          const rsxRegister = permanent ? this.rsxPermanent : this.rsxTemporary, rsxCommands = rsxModule.getRsxCommands();\n          for (const command in rsxCommands) {\n              if (rsxCommands.hasOwnProperty(command)) {\n                  rsxRegister[command] = rsxCommands[command];\n              }\n          }\n      }\n      resetRsx() {\n          this.rsxTemporary = {};\n      }\n  }\n\n  // ===== dist/esm/CpcVm.js =====\n  // CpcVm.ts - CPC Virtual Machine\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n\n\n  class CpcVm {\n      options;\n      quiet = false;\n      onClickKey;\n      fnOpeninHandler; // = undefined;\n      fnCloseinHandler;\n      fnCloseoutHandler;\n      fnLoadHandler;\n      fnRunHandler;\n      fnOnCanvasClickHandler;\n      fnInputCallbackHandler;\n      fnLineInputCallbackHandler;\n      fnRandomizeCallbackHandler;\n      canvas;\n      keyboard;\n      soundClass;\n      variables;\n      random;\n      stopEntry;\n      inputValues; // values to input into script\n      inFile; // file handling\n      outFile; // file handling\n      inkeyTimeMs = 0; // next time of frame fly (if >0, next time when inkey$ can be checked without inserting \"waitFrame\")\n      gosubStack = []; // stack of line numbers for gosub/return\n      maxGosubStackLength = 83; // maximum nesting of GOSUB on a real CPC\n      mem; // for peek, poke\n      dataList; // array for BASIC data lines (continuous)\n      dataIndex = 0; // current index\n      dataLineIndex = {\n          0: 0 // for line 0: index 0\n      };\n      labelList; // for resume next\n      sourceMap = {};\n      windowDataList; // window data for window 0..7,8,9\n      timerList; // BASIC timer 0..3 (3 has highest priority)\n      sqTimer; // Sound queue timer 0..2\n      soundData;\n      crtcData;\n      crtcReg = 0;\n      printControlBuf = \"\";\n      startTime = 0;\n      lastRnd = 0; // last random number\n      nextFrameTime = 0;\n      initialStop = 5;\n      stopCount = 0;\n      line = 0;\n      startLine = 0;\n      errorGotoLine = 0;\n      errorResumeLine = 0;\n      breakGosubLine = 0;\n      breakResumeLine = 0;\n      outBuffer = \"\";\n      errorCode = 0; // last error code (Err)\n      errorLine = 0; // line of last error (Erl)\n      degFlag = false; // degree or radians\n      tronFlag1 = false; // trace flag\n      ramSelect = 0;\n      screenPage = 3; // 16K screen page, 3=0xc000..0xffff\n      minCharHimem = CpcVm.maxHimem;\n      maxCharHimem = CpcVm.maxHimem;\n      himemValue = CpcVm.maxHimem;\n      minCustomChar = 256;\n      timerPriority = -1; // priority of running task: -1=low (min priority to start new timers)\n      zoneValue = 13; // print tab zone value\n      modeValue = -1;\n      progEnd = CpcVm.progStart + 3; // initially 370\n      rsx = new CpcVmRsx();\n      static frameTimeMs = 1000 / 50; // 50 Hz => 20 ms\n      static timerCount = 4; // number of timers\n      static sqTimerCount = 3; // sound queue timers\n      static streamCount = 10; // 0..7 window, 8 printer, 9 cassette\n      static progStart = 367;\n      static maxHimem = 42747; // high memory limit (42747 after symbol after 256)\n      static emptyParas = {};\n      static modeData = [\n          {\n              pens: 16 // number of pens (see also Canvas: modeData)\n          },\n          {\n              pens: 4\n          },\n          {\n              pens: 2\n          },\n          {\n              pens: 16\n          }\n      ];\n      static winData = [\n          {\n              left: 0,\n              right: 19,\n              top: 0,\n              bottom: 24\n          },\n          {\n              left: 0,\n              right: 39,\n              top: 0,\n              bottom: 24\n          },\n          {\n              left: 0,\n              right: 79,\n              top: 0,\n              bottom: 24\n          },\n          {\n              left: 0, // mode 3 not available on CPC\n              right: 79,\n              top: 0,\n              bottom: 49\n          }\n      ];\n      static utf8ToCpc = {\n          8364: 128,\n          8218: 130,\n          402: 131,\n          8222: 132,\n          8230: 133,\n          8224: 134,\n          8225: 135,\n          710: 136,\n          8240: 137,\n          352: 138,\n          8249: 139,\n          338: 140,\n          381: 142,\n          8216: 145,\n          8217: 146,\n          8220: 147,\n          8221: 148,\n          8226: 149,\n          8211: 150,\n          8212: 151,\n          732: 152,\n          8482: 153,\n          353: 154,\n          8250: 155,\n          339: 156,\n          382: 158,\n          376: 159\n      };\n      static controlCodeParameterCount = [\n          0, // 0x00\n          1, // 0x01\n          0, // 0x02\n          0, // 0x03\n          1, // 0x04\n          1, // 0x05\n          0, // 0x06\n          0, // 0x07\n          0, // 0x08\n          0, // 0x09\n          0, // 0x0a\n          0, // 0x0b\n          0, // 0x0c\n          0, // 0x0d\n          1, // 0x0e\n          1, // 0x0f\n          0, // 0x10\n          0, // 0x11\n          0, // 0x12\n          0, // 0x13\n          0, // 0x14\n          0, // 0x15\n          1, // 0x16\n          1, // 0x17\n          0, // 0x18\n          9, // 0x19\n          4, // 0x1a\n          0, // 0x1b\n          3, // 0x1c\n          2, // 0x1d\n          0, // 0x1e\n          2 //  0x1f\n      ];\n      static errors = [\n          \"Improper argument\", // 0\n          \"Unexpected NEXT\", // 1\n          \"Syntax Error\", // 2\n          \"Unexpected RETURN\", // 3\n          \"DATA exhausted\", // 4\n          \"Improper argument\", // 5\n          \"Overflow\", // 6\n          \"Memory full\", // 7\n          \"Line does not exist\", // 8\n          \"Subscript out of range\", // 9\n          \"Array already dimensioned\", // 10\n          \"Division by zero\", // 11\n          \"Invalid direct command\", // 12\n          \"Type mismatch\", // 13\n          \"String space full\", // 14\n          \"String too long\", // 15\n          \"String expression too complex\", // 16\n          \"Cannot CONTinue\", // 17\n          \"Unknown user function\", // 18\n          \"RESUME missing\", // 19\n          \"Unexpected RESUME\", // 20\n          \"Direct command found\", // 21\n          \"Operand missing\", // 22\n          \"Line too long\", // 23\n          \"EOF met\", // 24\n          \"File type error\", // 25\n          \"NEXT missing\", // 26\n          \"File already open\", // 27\n          \"Unknown command\", // 28\n          \"WEND missing\", // 29\n          \"Unexpected WEND\", // 30\n          \"File not open\", // 31,\n          \"Broken\", // 32 \"Broken in\" (derr=146: xxx not found)\n          \"Unknown error\" // 33...\n      ];\n      static stopPriority = {\n          \"\": 0, // nothing\n          direct: 0, // direct input mode\n          timer: 20, // timer expired\n          waitFrame: 40, // FRAME command: wait for frame fly\n          waitKey: 41, // wait for key (higher priority that waitFrame)\n          waitSound: 43, // wait for sound queue\n          waitInput: 45, // wait for input: INPUT, LINE INPUT, RANDOMIZE without parameter\n          fileCat: 45, // CAT\n          fileDir: 45, // |DIR\n          fileEra: 45, // |ERA\n          fileRen: 45, // |REN\n          error: 50, // BASIC error, ERROR command\n          onError: 50, // ON ERROR GOTO active, hide error\n          stop: 60, // STOP or END command\n          \"break\": 80, // break pressed\n          escape: 85, // escape key, set in controller\n          renumLines: 85, // RENUMber program\n          deleteLines: 85, // delete lines\n          editLine: 85, // edit line\n          end: 90, // end of program\n          list: 90, // LIST program\n          fileLoad: 90, // CHAIN, CHAIN MERGE, LOAD, MERGE, OPENIN, RUN\n          fileSave: 90, // OPENOUT, SAVE\n          \"new\": 90, // NEW, remove program, variables\n          run: 95,\n          parse: 95, // set in controller\n          parseRun: 95, // parse and run, used in controller\n          reset: 99 // reset system\n      };\n      constructor(options) {\n          this.fnOpeninHandler = this.vmOpeninCallback.bind(this);\n          this.fnCloseinHandler = this.vmCloseinCallback.bind(this);\n          this.fnCloseoutHandler = this.vmCloseoutCallback.bind(this);\n          this.fnLoadHandler = this.vmLoadCallback.bind(this);\n          this.fnRunHandler = this.vmRunCallback.bind(this);\n          this.fnOnCanvasClickHandler = this.onCanvasClickCallback.bind(this);\n          this.fnInputCallbackHandler = this.vmInputCallback.bind(this);\n          this.fnLineInputCallbackHandler = this.vmLineInputCallback.bind(this);\n          this.fnRandomizeCallbackHandler = this.vmRandomizeCallback.bind(this);\n          this.options = {};\n          this.setOptions(options);\n          this.canvas = this.setCanvas(options.canvas);\n          this.keyboard = options.keyboard;\n          this.soundClass = options.sound;\n          this.variables = options.variables;\n          this.quiet = Boolean(options.quiet);\n          this.onClickKey = options.onClickKey;\n          this.random = new Random();\n          this.stopCount = this.initialStop;\n          this.stopEntry = {\n              reason: \"\", // stop reason\n              priority: 0, // stop priority (higher number means higher priority which can overwrite lower priority)\n              paras: {}\n          };\n          this.inputValues = []; // values to input into script\n          this.inFile = {\n              open: false,\n              command: \"\",\n              name: \"\",\n              line: 0,\n              start: undefined,\n              fileData: [],\n              fnFileCallback: undefined,\n              first: 0,\n              last: 0,\n              memorizedExample: \"\"\n          };\n          this.outFile = {\n              open: false,\n              command: \"\",\n              name: \"\",\n              line: 0,\n              start: 0,\n              fileData: [],\n              fnFileCallback: undefined,\n              stream: 0,\n              typeString: \"\",\n              length: 0,\n              entry: 0\n          }; // file handling\n          // \"open\": File open flag\n          // \"command\": Command that started the file open (in: chain, chainMerge, load, merge, openin, run; out: save, openput)\n          // \"name\": File name\n          // \"type\": File type: A, B, P, T\n          // \"start\": start address of data\n          // \"length\": length of data\n          // \"entry\": entry address (save)\n          // \"line\": ?\n          // \"fileData\": File contents for (LINE) INPUT #9; PRINT #9, WRITE #9\n          // \"fnFileCallback\": Callback for stop reason \"fileLoad\", \"fileSave\"\n          // \"line\": run line (CHAIN, CHAIN MERGE)\n          // \"first\": first line to delete (CHAIN MERGE)\n          // \"last\": last line to delete (CHAIN MERGE)\n          this.gosubStack = []; // stack of line numbers for gosub/return\n          this.mem = []; // for peek, poke\n          this.dataList = []; // array for BASIC data lines (continuous)\n          this.labelList = [];\n          this.windowDataList = []; // window data for window 0..7,8,9\n          for (let i = 0; i < CpcVm.streamCount; i += 1) {\n              this.windowDataList[i] = {};\n          }\n          this.timerList = []; // BASIC timer 0..3 (3 has highest priority)\n          for (let i = 0; i < CpcVm.timerCount; i += 1) {\n              this.timerList[i] = {};\n          }\n          this.soundData = [];\n          this.sqTimer = []; // Sound queue timer 0..2\n          for (let i = 0; i < CpcVm.sqTimerCount; i += 1) {\n              this.sqTimer[i] = {};\n          }\n          this.crtcData = [];\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      vmReset() {\n          this.startTime = Date.now();\n          this.vmResetRandom();\n          this.nextFrameTime = Date.now() + CpcVm.frameTimeMs; // next time of frame fly\n          this.stopCount = this.initialStop;\n          this.line = 0; // current line number (or label)\n          this.startLine = 0; // line to start\n          this.errorGotoLine = 0;\n          this.errorResumeLine = 0;\n          this.breakGosubLine = 0;\n          this.breakResumeLine = 0;\n          this.inputValues.length = 0;\n          this.vmResetInFileHandling();\n          this.vmResetControlBuffer();\n          this.outBuffer = \"\"; // console output\n          this.vmStop(\"\", 0, true);\n          this.vmResetData();\n          this.errorCode = 0; // last error code\n          this.errorLine = 0; // line of last error\n          this.gosubStack.length = 0;\n          this.degFlag = false; // degree or radians\n          this.tronFlag1 = false;\n          this.screenPage = 3; // 16K screen page, 3=0xc000..0xffff\n          this.crtcReg = 0;\n          this.crtcData.length = 0;\n          this.vmResetMemory();\n          this.symbolAfter(240); // set also minCustomChar\n          this.vmResetTimers();\n          this.timerPriority = -1; // priority of running task: -1=low (min priority to start new timers)\n          this.zoneValue = 13; // print tab zone value\n          this.defreal(\"a\", \"z\"); // init vartypes\n          this.vmResetPenPaperWindowData();\n          this.mode(1); // including vmResetWindowData() without pen and paper\n          this.canvas.reset();\n          this.keyboard.reset();\n          this.soundClass.reset();\n          this.soundData.length = 0;\n          this.inkeyTimeMs = 0; // if >0, next time when inkey$ can be checked without inserting \"waitFrame\"\n          this.rsx.resetRsx(); // remove temporary rsx\n      }\n      vmResetMemory() {\n          this.mem.length = 0; // clear memory (for PEEK, POKE)\n          this.ramSelect = 0; // for banking with 16K banks in the range 0x4000-0x7fff (0=default; 1...=additional)\n          this.minCharHimem = CpcVm.maxHimem;\n          this.maxCharHimem = CpcVm.maxHimem;\n          this.himemValue = CpcVm.maxHimem;\n          this.minCustomChar = 256;\n          this.progEnd = CpcVm.progStart + 3;\n      }\n      vmResetRandom() {\n          this.random.init();\n          this.lastRnd = 0;\n      }\n      vmResetTimers() {\n          const data = {\n              line: 0, // gosub line when timer expires\n              repeat: false, // flag if timer is repeating (every) or one time (after)\n              intervalMs: 0, // interval or timeout\n              active: false, // flag if timer is active\n              nextTimeMs: 0, // next expiration time\n              handlerRunning: false, // flag if handler (subroutine) is running\n              stackIndexReturn: 0, // index in gosub stack with return, if handler is running\n              savedPriority: 0 // priority befora calling the handler\n          }, timer = this.timerList, sqTimer = this.sqTimer;\n          for (let i = 0; i < CpcVm.timerCount; i += 1) {\n              Object.assign(timer[i], data);\n          }\n          // sound queue timer\n          for (let i = 0; i < CpcVm.sqTimerCount; i += 1) {\n              Object.assign(sqTimer[i], data);\n          }\n      }\n      vmResetPenPaperWindowData() {\n          const penPaperData = {\n              pen: 1,\n              paper: 0\n          }, windowDataList = this.windowDataList;\n          for (let i = 0; i < windowDataList.length - 2; i += 1) { // for window streams\n              Object.assign(windowDataList[i], penPaperData);\n          }\n      }\n      vmResetWindowData(resetPenPaper) {\n          if (resetPenPaper) {\n              this.vmResetPenPaperWindowData();\n          }\n          const data = {\n              pos: 0, // current text position in line\n              vpos: 0,\n              textEnabled: true, // text enabled\n              tag: false, // tag=text at graphics\n              transparent: false, // transparent mode\n              cursorOn: false, // system switch\n              cursorEnabled: true // user switch\n          }, printData = {\n              pos: 0,\n              vpos: 0,\n              right: 132 // override\n          }, cassetteData = {\n              pos: 0,\n              vpos: 0,\n              right: 255 // override\n          }, winData = CpcVm.winData[this.modeValue], windowDataList = this.windowDataList, modeDataPens = CpcVm.modeData[this.modeValue].pens;\n          for (let i = 0; i < windowDataList.length - 2; i += 1) { // for window streams\n              const modeWinData = Object.assign(windowDataList[i], winData, data);\n              modeWinData.pen %= modeDataPens;\n              modeWinData.paper %= modeDataPens; // limit also paper to number of pens\n          }\n          Object.assign(windowDataList[8], winData, printData); // printer\n          Object.assign(windowDataList[9], winData, cassetteData); // cassette\n      }\n      vmResetControlBuffer() {\n          this.printControlBuf = \"\"; // collected control characters for PRINT\n      }\n      static vmResetFileHandling(file) {\n          file.open = false;\n          file.command = \"\"; // to be sure\n          file.name = \"\";\n          file.line = 0;\n          file.start = undefined; // to be sure\n          file.fileData.length = 0;\n      }\n      vmResetInFileHandling() {\n          const inFile = this.inFile;\n          CpcVm.vmResetFileHandling(inFile);\n          inFile.first = 0;\n          inFile.last = 0;\n      }\n      vmResetOutFileHandling() {\n          const outFile = this.outFile;\n          CpcVm.vmResetFileHandling(outFile);\n          outFile.stream = 0;\n          outFile.typeString = \"\";\n          outFile.length = 0;\n          outFile.entry = 0;\n      }\n      vmResetData() {\n          this.dataList.length = 0; // array for BASIC data lines (continuous)\n          this.dataIndex = 0; // current index\n          this.dataLineIndex = {\n              0: 0 // for line 0: index 0\n          };\n      }\n      vmResetInks() {\n          this.canvas.setDefaultInks();\n          this.canvas.setSpeedInk(10, 10);\n      }\n      vmReset4Run() {\n          const stream = 0;\n          this.clearInput();\n          this.closein();\n          this.closeout();\n          this.cursor(stream, 0);\n          this.labelList.length = 0;\n          this.gosubStack.length = 0;\n          this.restore(); // restore data line index\n          this.errorGotoLine = 0;\n          this.errorResumeLine = 0;\n          this.soundClass.resetQueue();\n          this.soundData.length = 0;\n      }\n      vmPutProgramInMem(tokens) {\n          const addr = CpcVm.progStart + 1, // 368=0x170\n          tokensLen = addr + tokens.length > 0xffff ? 0xffff - addr : tokens.length; // prevent overflow\n          this.progEnd = addr + tokensLen;\n          for (let i = 0; i < tokensLen; i += 1) {\n              const code = CpcVm.vmGetCharCodeAt(tokens, i);\n              this.poke(addr + i, code);\n          }\n          if (tokensLen < tokens.length) {\n              if (!this.quiet) {\n                  Utils.console.warn(\"vmPutProgramInMem: program too large (\" + tokens.length + \"), truncated by\", tokens.length - tokensLen, \"to fit in memory\");\n              }\n          }\n          return tokensLen;\n      }\n      setCanvas(canvas) {\n          this.canvas = canvas;\n          if (this.canvas) {\n              this.canvas.setOptions({\n                  onCanvasClick: this.fnOnCanvasClickHandler\n              });\n          }\n          return canvas;\n      }\n      vmGetLoadHandler() {\n          return this.fnLoadHandler;\n      }\n      vmGetMem() {\n          return this.mem;\n      }\n      onCanvasClickCallback(event, x, y, xTxt, yTxt) {\n          // for graphics coordinates, adapt origin\n          const height = 400;\n          let char = -1;\n          x -= this.canvas.getXOrigin();\n          y = height - 1 - (y + this.canvas.getYOrigin());\n          if (this.canvas.getXpos() === 1000 && this.canvas.getYpos() === 1000) { // only activate move if pos is 1000, 1000\n              this.canvas.move(x, y);\n          }\n          if (this.onClickKey) {\n              for (let stream = 0; stream < CpcVm.streamCount - 2; stream += 1) { // check all window streams\n                  const win = this.windowDataList[stream];\n                  char = this.canvas.readChar(xTxt, yTxt, win.pen, win.paper);\n                  if (char > 0 && char !== 32) {\n                      break; // found some char\n                  }\n              }\n              if ((char < 0 || char === 32 || char === 143) && event.detail === 2) { // no (useful) char but mouse double click?\n                  char = 13; // use CR\n              }\n              if (char >= 0) { // call click handler (put char in keyboard input buffer)\n                  this.onClickKey(String.fromCharCode(char));\n              }\n          }\n          if (Utils.debug > 0) {\n              Utils.console.debug(\"onCanvasClickCallback: x\", x, \"y\", y, \"xTxt\", xTxt, \"yTxt\", yTxt, \"char\", char);\n          }\n      }\n      vmRegisterRsx(rsxModule, permanent) {\n          this.rsx.registerRsx(rsxModule, permanent);\n      }\n      vmGetAllVariables() {\n          return this.variables.getAllVariables();\n      }\n      vmGetAllVarTypes() {\n          return this.variables.getAllVarTypes();\n      }\n      vmGetVariableByIndex(index) {\n          return this.variables.getVariableByIndex(index);\n      }\n      vmSetStartLine(line) {\n          this.startLine = line;\n      }\n      vmSetLabels(labels) {\n          this.labelList.length = 0;\n          Object.assign(this.labelList, labels);\n      }\n      vmOnBreakContSet() {\n          return this.breakGosubLine < 0; // on break cont\n      }\n      vmOnBreakHandlerActive() {\n          return Boolean(this.breakResumeLine);\n      }\n      vmEscape() {\n          let stop = true;\n          if (this.breakGosubLine > 0) { // on break gosub n\n              if (!this.breakResumeLine) { // do not nest break gosub\n                  this.breakResumeLine = Number(this.line);\n                  this.vmGosub(this.line, this.breakGosubLine);\n              }\n              stop = false;\n          }\n          else if (this.breakGosubLine < 0) { // on break cont\n              stop = false;\n          } // else: on break stop\n          return stop;\n      }\n      vmAssertNumber(n, err) {\n          if (typeof n !== \"number\") {\n              throw this.vmComposeError(Error(), 13, err + \" \" + n); // Type mismatch\n          }\n      }\n      vmAssertString(s, err) {\n          if (typeof s !== \"string\") {\n              throw this.vmComposeError(Error(), 13, err + \" \" + s); // Type mismatch\n          }\n      }\n      vmAssertInRange(n, min, max, err) {\n          this.vmAssertNumber(n, err);\n          if (n < min || n > max) {\n              if (!this.quiet) {\n                  Utils.console.warn(\"vmAssertInRange: number not in range:\", min + \"<=\" + n + \"<=\" + max);\n              }\n              throw this.vmComposeError(Error(), 5, err + \" \" + n); // 5=Improper argument\n          }\n          return n;\n      }\n      // round number (-2^31..2^31) to integer; throw error if no number\n      vmRound(n, err) {\n          this.vmAssertNumber(n, err || \"?\");\n          return (n >= 0) ? (n + 0.5) | 0 : (n - 0.5) | 0; // eslint-disable-line no-bitwise\n      }\n      vmInRangeRound(n, min, max, err) {\n          n = this.vmRound(n, err);\n          if (n < min || n > max) {\n              if (!this.quiet) {\n                  Utils.console.warn(\"vmInRangeRound: number not in range:\", min + \"<=\" + n + \"<=\" + max);\n              }\n              throw this.vmComposeError(Error(), n < -32768 || n > 32767 ? 6 : 5, err + \" \" + n); // 6=Overflow, 5=Improper argument\n          }\n          return n;\n      }\n      vmInRange16(n, err) {\n          const min = -32768, max = 32767;\n          if (n < min || n > max) {\n              if (!this.quiet) {\n                  Utils.console.warn(\"vmInRange16: number not in range:\", min + \"<=\" + n + \"<=\" + max);\n              }\n              throw this.vmComposeError(Error(), n < min || n > max ? 6 : 5, err + \" \" + n); // 6=Overflow, 5=Improper argument\n          }\n          return n;\n      }\n      vmLineInRange(n, err) {\n          const min = 1, max = 65535, num2 = this.vmRound(n, err);\n          if (n !== num2) { // fractional number? => integer expected\n              throw this.vmComposeError(Error(), 23, err + \" \" + n); // Line too long\n          }\n          if (n < min || n > max) {\n              if (!this.quiet) {\n                  Utils.console.warn(\"vmLineInRange: number not in range:\", min + \"<=\" + n + \"<=\" + max);\n              }\n              throw this.vmComposeError(Error(), 5, err + \" \" + n); // 5=Improper argument\n          }\n          return n;\n      }\n      vmRound2Complement(n, err) {\n          n = this.vmInRangeRound(n, -32768, 65535, err);\n          if (n < 0) { // undo two's complement\n              n += 65536;\n          }\n          return n;\n      }\n      vmGetLetterCode(s, err) {\n          this.vmAssertString(s, err);\n          s = s.toLowerCase();\n          if (s.length !== 1 || s < \"a\" || s > \"z\") { // single letter?\n              throw this.vmComposeError(Error(), 2, err + \" \" + s); // Syntax Error\n          }\n          return s.charCodeAt(0);\n      }\n      vmDetermineVarType(varType) {\n          return (varType.length > 1) ? varType.charAt(1) : this.variables.getVarType(varType.charAt(0));\n      }\n      vmAssertNumberType(varType) {\n          const type = this.vmDetermineVarType(varType);\n          if (type !== \"I\" && type !== \"R\") { // not integer or real?\n              throw this.vmComposeError(Error(), 13, \"type \" + type); // \"Type mismatch\"\n          }\n      }\n      // format a value for assignment to a variable with type determined from varType\n      vmAssign(varType, value) {\n          const type = this.vmDetermineVarType(varType);\n          if (type === \"R\") { // real\n              this.vmAssertNumber(value, \"=\");\n          }\n          else if (type === \"I\") { // integer\n              value = this.vmRound(value, \"=\"); // round number to integer\n          }\n          else if (type === \"$\") { // string\n              if (typeof value !== \"string\") {\n                  if (!this.quiet) {\n                      Utils.console.warn(\"vmAssign: expected string but got:\", value);\n                  }\n                  throw this.vmComposeError(Error(), 13, \"type \" + type + \"=\" + value); // \"Type mismatch\"\n              }\n          }\n          return value;\n      }\n      vmGoto(line, _msg) {\n          this.line = line;\n      }\n      fnCheckSqTimer() {\n          let timerExpired = false;\n          if (this.timerPriority < 2) {\n              for (let i = 0; i < CpcVm.sqTimerCount; i += 1) {\n                  const timer = this.sqTimer[i];\n                  // use sound.sq(i) and not this.sq(i) since that would reset onSq timer\n                  if (timer.active && !timer.handlerRunning && (this.soundClass.sq(i) & 0x07)) { // eslint-disable-line no-bitwise\n                      this.vmGosub(this.line, timer.line);\n                      timer.handlerRunning = true;\n                      timer.stackIndexReturn = this.gosubStack.length;\n                      timer.repeat = false; // one shot\n                      timerExpired = true;\n                      break; // found expired timer\n                  }\n              }\n          }\n          return timerExpired;\n      }\n      vmCheckTimer(time) {\n          let timerExpired = false;\n          for (let i = CpcVm.timerCount - 1; i > this.timerPriority; i -= 1) { // check timers starting with highest priority first\n              const timer = this.timerList[i];\n              if (timer.active && !timer.handlerRunning && time > timer.nextTimeMs) { // timer expired?\n                  this.vmGosub(this.line, timer.line);\n                  timer.handlerRunning = true;\n                  timer.stackIndexReturn = this.gosubStack.length;\n                  timer.savedPriority = this.timerPriority;\n                  this.timerPriority = i;\n                  if (!timer.repeat) { // not repeating\n                      timer.active = false;\n                  }\n                  else {\n                      const delta = time - timer.nextTimeMs;\n                      timer.nextTimeMs += timer.intervalMs * Math.ceil(delta / timer.intervalMs);\n                  }\n                  timerExpired = true;\n                  break; // found expired timer\n              }\n              else if (i === 2) { // for priority 2 we check the sq timers which also have priority 2\n                  if (this.fnCheckSqTimer()) {\n                      break; // found expired timer\n                  }\n              }\n          }\n          return timerExpired;\n      }\n      vmCheckTimerHandlers() {\n          for (let i = CpcVm.timerCount - 1; i >= 0; i -= 1) {\n              const timer = this.timerList[i];\n              if (timer.handlerRunning) {\n                  if (timer.stackIndexReturn > this.gosubStack.length) {\n                      timer.handlerRunning = false;\n                      this.timerPriority = timer.savedPriority; // restore priority\n                      timer.stackIndexReturn = 0;\n                  }\n              }\n          }\n      }\n      vmCheckSqTimerHandlers() {\n          let timerReloaded = false;\n          for (let i = CpcVm.sqTimerCount - 1; i >= 0; i -= 1) {\n              const timer = this.sqTimer[i];\n              if (timer.handlerRunning) {\n                  if (timer.stackIndexReturn > this.gosubStack.length) {\n                      timer.handlerRunning = false;\n                      this.timerPriority = timer.savedPriority; // restore priority\n                      timer.stackIndexReturn = 0;\n                      if (!timer.repeat) { // not reloaded\n                          timer.active = false;\n                      }\n                      else {\n                          timerReloaded = true;\n                      }\n                  }\n              }\n          }\n          return timerReloaded;\n      }\n      vmCheckNextFrame(time) {\n          if (time >= this.nextFrameTime) { // next time of frame fly\n              const delta = time - this.nextFrameTime;\n              if (delta > CpcVm.frameTimeMs) {\n                  this.nextFrameTime += CpcVm.frameTimeMs * Math.ceil(delta / CpcVm.frameTimeMs);\n              }\n              else {\n                  this.nextFrameTime += CpcVm.frameTimeMs;\n              }\n              this.canvas.updateSpeedInk();\n              this.vmCheckTimer(time); // check BASIC timers and sound queue\n              this.soundClass.scheduler(); // on a real CPC it is 100 Hz, we use 50 Hz\n          }\n      }\n      vmGetTimeUntilFrame(time) {\n          time = time || Date.now();\n          return this.nextFrameTime - time;\n      }\n      vmLoopCondition() {\n          const time = Date.now();\n          if (time >= this.nextFrameTime) {\n              this.vmCheckNextFrame(time);\n              this.stopCount -= 1;\n              if (this.stopCount <= 0) { // do not stop too often because of just timer reason because setTimeout is expensive\n                  this.stopCount = this.initialStop;\n                  this.vmStop(\"timer\", 20);\n              }\n          }\n          return this.stopEntry.reason === \"\";\n      }\n      vmDefineVarTypes(type, err, first, last) {\n          const firstNum = this.vmGetLetterCode(first, err), lastNum = last ? this.vmGetLetterCode(last, err) : firstNum;\n          for (let i = firstNum; i <= lastNum; i += 1) {\n              const varChar = String.fromCharCode(i);\n              this.variables.setVarType(varChar, type);\n          }\n      }\n      vmStop(reason, priority, force, paras) {\n          const defaultPriority = CpcVm.stopPriority[reason];\n          if (defaultPriority === undefined) {\n              Utils.console.warn(\"Programming error: vmStop: Unknown reason:\", reason);\n          }\n          priority = priority || 0;\n          if (priority !== 0) {\n              priority = defaultPriority;\n          }\n          if (force || priority >= this.stopEntry.priority) {\n              this.stopEntry.priority = priority;\n              this.stopEntry.reason = reason;\n              this.stopEntry.paras = paras || CpcVm.emptyParas;\n          }\n      }\n      vmNotImplemented(name) {\n          if (Utils.debug > 0) {\n              Utils.console.debug(\"Not implemented:\", name);\n          }\n      }\n      vmUsingStringFormat(format, arg) {\n          const padChar = \" \", re1 = /^\\\\ *\\\\$/;\n          let str;\n          if (format === \"&\") {\n              str = arg;\n          }\n          else if (format === \"!\") {\n              str = arg.charAt(0);\n          }\n          else if (re1.test(format)) { // \"\\...\\\"\n              const padLen = format.length - arg.length, pad = (padLen > 0) ? padChar.repeat(padLen) : \"\";\n              str = arg + pad; // string left aligned\n          }\n          else { // no string format\n              throw this.vmComposeError(Error(), 13, \"USING format \" + format); // \"Type mismatch\"\n          }\n          return str;\n      }\n      // not fully implemented\n      vmUsingNumberFormat(format, arg) {\n          const padChar = \" \", re1 = /^\\\\ *\\\\$/;\n          let str;\n          if (format === \"&\" || format === \"!\" || re1.test(format)) { // string format for number?\n              throw this.vmComposeError(Error(), 13, \"USING format \" + format); // \"Type mismatch\"\n          }\n          if (format.indexOf(\".\") < 0) { // no decimal point?\n              str = arg.toFixed(0);\n          }\n          else { // assume ###.##\n              const formatParts = format.split(\".\", 2), decimals = formatParts[1].length;\n              // To avoid rounding errors: https://www.jacklmoore.com/notes/rounding-in-javascript\n              arg = Number(Math.round(Number(arg + \"e\" + decimals)) + \"e-\" + decimals);\n              str = arg.toFixed(decimals);\n          }\n          if (format.indexOf(\",\") >= 0) { // contains comma => insert thousands separator\n              str = Utils.numberWithCommas(str);\n          }\n          const padLen = format.length - str.length, pad = (padLen > 0) ? padChar.repeat(padLen) : \"\";\n          str = pad + str;\n          if (str.length > format.length) {\n              str = \"%\" + str; // mark too long\n          }\n          return str;\n      }\n      vmUsingFormat(format, arg) {\n          return typeof arg === \"string\" ? this.vmUsingStringFormat(format, arg) : this.vmUsingNumberFormat(format, arg);\n      }\n      vmGetStopObject() {\n          return this.stopEntry;\n      }\n      vmGetInFileObject() {\n          return this.inFile;\n      }\n      vmGetKeyboard() {\n          return this.keyboard;\n      }\n      vmGetOutFileObject() {\n          return this.outFile;\n      }\n      vmAdaptFilename(name, err) {\n          this.vmAssertString(name, err);\n          name = name.replace(/ /g, \"\"); // remove spaces\n          if (name[0] === \"!\") {\n              name = name.substring(1); // remove preceding \"!\"\n          }\n          const index = name.indexOf(\":\");\n          if (index >= 0) {\n              name = name.substring(index + 1); // remove user and drive letter including \":\"\n          }\n          if (name.endsWith(\".\")) {\n              name = name.substring(0, name.length - 1); // remove training \".\"\n          }\n          name = name.toLowerCase();\n          if (!name) {\n              throw this.vmComposeError(Error(), 32, \"Bad filename: \" + name);\n          }\n          return name;\n      }\n      vmGetSoundData() {\n          return this.soundData;\n      }\n      vmSetSourceMap(sourceMap) {\n          this.sourceMap = sourceMap;\n      }\n      vmTrace() {\n          if (this.tronFlag1) {\n              const stream = 0;\n              this.print(stream, \"[\" + String(this.line) + \"]\");\n          }\n      }\n      vmGetOutBuffer() {\n          return this.outBuffer;\n      }\n      vmPrint2OutBuffer(s) {\n          this.outBuffer += CpcVm.vmWithControlCodes(s);\n      }\n      vmDrawMovePlot(type, gPen, gColMode) {\n          if (gPen !== undefined) {\n              gPen = this.vmInRangeRound(gPen, 0, 15, type);\n              this.canvas.setGPen(gPen);\n          }\n          if (gColMode !== undefined) {\n              gColMode = this.vmInRangeRound(gColMode, 0, 3, type);\n              this.canvas.setGColMode(gColMode);\n          }\n      }\n      vmAfterEveryGosub(type, interval, timer, line) {\n          interval = this.vmInRangeRound(interval, 0, 32767, type); // more would be overflow\n          timer = this.vmInRangeRound(timer || 0, 0, 3, type);\n          line = this.vmLineInRange(line, type + \" GOSUB\");\n          const timerEntry = this.timerList[timer];\n          if (interval) {\n              const intervalMs = interval * CpcVm.frameTimeMs; // convert to ms\n              timerEntry.intervalMs = intervalMs;\n              timerEntry.line = line;\n              timerEntry.repeat = type === \"EVERY\";\n              timerEntry.active = true;\n              timerEntry.nextTimeMs = Date.now() + intervalMs;\n          }\n          else { // interval 0 => switch running timer off\n              timerEntry.active = false;\n          }\n      }\n      vmCopyFromScreen(source, dest) {\n          for (let i = 0; i < 0x4000; i += 1) {\n              let byte = this.canvas.getByte(source + i); // get byte from screen memory\n              if (byte === null) { // byte not visible on screen?\n                  byte = this.mem[source + i] || 0; // get it from our memory\n              }\n              this.mem[dest + i] = byte;\n          }\n      }\n      vmCopyToScreen(source, dest) {\n          for (let i = 0; i < 0x4000; i += 1) {\n              const byte = this.mem[source + i] || 0; // get it from our memory\n              this.canvas.setByte(dest + i, byte);\n          }\n      }\n      vmSetScreenBase(byte) {\n          byte = this.vmInRangeRound(byte, 0, 255, \"screenBase\");\n          const page = byte >> 6, // eslint-disable-line no-bitwise\n          oldPage = this.screenPage;\n          if (page !== oldPage) {\n              let addr = oldPage << 14; // eslint-disable-line no-bitwise\n              this.vmCopyFromScreen(addr, addr);\n              this.screenPage = page;\n              addr = page << 14; // eslint-disable-line no-bitwise\n              this.vmCopyToScreen(addr, addr);\n          }\n      }\n      vmSetScreenOffset(offset) {\n          this.canvas.setScreenOffset(offset);\n      }\n      // could be also set vmSetScreenViewBase? thisiScreenViewPage?  We always draw on visible canvas?\n      vmSetTransparentMode(stream, transparent) {\n          this.windowDataList[stream].transparent = Boolean(transparent);\n      }\n      // --\n      abs(n) {\n          this.vmAssertNumber(n, \"ABS\");\n          return Math.abs(n);\n      }\n      addressOf(variable) {\n          // not really implemented\n          this.vmAssertString(variable, \"@\");\n          const varIndex = this.variables.getVariableIndex(variable);\n          if (varIndex < 0) {\n              throw this.vmComposeError(Error(), 5, \"@\" + variable); // Improper argument\n          }\n          return varIndex;\n      }\n      afterGosub(interval, timer, line) {\n          this.vmAfterEveryGosub(\"AFTER\", interval, timer, line);\n      }\n      static vmGetCharCodeAt(s, i) {\n          const code = s.charCodeAt(i);\n          if (code < 0x100 || code >= 0x200) {\n              return code;\n          }\n          return code & 0xFF; // eslint-disable-line no-bitwise\n      }\n      static vmWithControlCodes(s) {\n          let out = \"\";\n          for (let i = 0; i < s.length; i += 1) {\n              out += String.fromCharCode(CpcVm.vmGetCharCodeAt(s, i));\n          }\n          return out;\n      }\n      /*\n      private static vmGetCpcCharCode(code: number): number {\n          return code & 0xFF; // eslint-disable-line no-bitwise\n      }\n      */\n      static vmGetCpcCharCode(code) {\n          if (code > 0xff) { // map some UTF-8 character codes\n              if (CpcVm.utf8ToCpc[code]) {\n                  code = CpcVm.utf8ToCpc[code];\n              }\n              else if (code <= 0x1FF) {\n                  code &= 0xFF; // eslint-disable-line no-bitwise\n              }\n          }\n          return code;\n      }\n      // and\n      asc(s) {\n          this.vmAssertString(s, \"ASC\");\n          if (!s.length) {\n              throw this.vmComposeError(Error(), 5, \"ASC\"); // Improper argument\n          }\n          return CpcVm.vmGetCpcCharCode(s.charCodeAt(0));\n      }\n      atn(n) {\n          this.vmAssertNumber(n, \"ATN\");\n          n = Math.atan(n);\n          return this.degFlag ? Utils.toDegrees(n) : n;\n      }\n      auto(line, increment) {\n          line = line === undefined ? 10 : this.vmLineInRange(line, \"AUTO\");\n          increment = increment === undefined ? 10 : this.vmLineInRange(increment, \"AUTO\");\n          this.vmNotImplemented(\"AUTO \" + line + \",\" + increment);\n      }\n      bin$(n, pad) {\n          n = this.vmRound2Complement(n, \"BIN$\");\n          pad = this.vmInRangeRound(pad || 0, 0, 16, \"BIN$\");\n          return n.toString(2).padStart(pad, \"0\");\n      }\n      border(ink1, ink2) {\n          ink1 = this.vmInRangeRound(ink1, 0, 31, \"BORDER\");\n          if (ink2 === undefined) {\n              ink2 = ink1;\n          }\n          else {\n              ink2 = this.vmInRangeRound(ink2, 0, 31, \"BORDER\");\n          }\n          this.canvas.setBorder(ink1, ink2);\n      }\n      // break\n      vmMcSetMode(mode) {\n          mode = this.vmInRangeRound(mode, 0, 3, \"MCSetMode\");\n          const canvasMode = this.canvas.getMode();\n          if (mode !== canvasMode) {\n              const addr = this.screenPage << 14; // eslint-disable-line no-bitwise\n              // keep screen bytes, just interpret in other mode\n              this.vmCopyFromScreen(addr, addr); // read bytes from screen memory into memory\n              this.canvas.changeMode(mode); // change mode and interpretation of bytes\n              this.vmCopyToScreen(addr, addr); // write bytes back to screen memory\n              this.canvas.changeMode(canvasMode); // keep mode\n              // TODO: new content should still be written in old mode but interpreted in new mode\n          }\n      }\n      vmTxtInverse(stream) {\n          const win = this.windowDataList[stream], tmpPen = win.pen;\n          this.pen(stream, win.paper);\n          this.paper(stream, tmpPen);\n      }\n      // special function to set all inks temporarily; experimental and expensive\n      updateColorsImmediately(addr) {\n          const inkList = [];\n          for (let i = 0; i < 17; i += 1) {\n              /* eslint-disable no-bitwise */\n              const byte = this.peek((addr + i) & 0xffff), color = byte & 0x1f;\n              /* eslint-enable no-bitwise */\n              inkList[i] = color;\n          }\n          this.canvas.updateColorsAndCanvasImmediately(inkList);\n      }\n      call(addr, ...args) {\n          // varargs (adr + parameters)\n          addr = this.vmRound2Complement(addr, \"CALL\");\n          if (args.length > 32) { // more that 32 arguments?\n              throw this.vmComposeError(Error(), 2, \"CALL \"); // Syntax Error\n          }\n          for (let i = 0; i < args.length; i += 1) {\n              if (typeof args[i] === \"number\") {\n                  args[i] = this.vmRound2Complement(args[i], \"CALL\"); // even if the args itself are not used here\n              }\n          }\n          switch (addr) {\n              case 0xbb00: // KM Initialize (ROM &19E0)\n                  this.keyboard.resetCpcKeysExpansions();\n                  this.call(0xbb03); // KM Reset\n                  break;\n              case 0xbb03: // KM Reset (ROM &1AE1)\n                  this.clearInput();\n                  this.keyboard.resetExpansionTokens();\n                  // TODO: reset also speed key\n                  break;\n              case 0xbb0c: // KM Char Return (ROM &1A77), depending on number of args\n                  this.keyboard.putKeyInBuffer(String.fromCharCode(args.length), true); // with trigger onkeydown\n                  break;\n              case 0xbb06: // KM Wait Char (ROM &1A3C); since we do not return a character, we do the same as call &bb18\n              case 0xbb18: // KM Wait Key (ROM &1B56)\n                  if (this.inkey$() === \"\") { // no key?\n                      this.vmStop(\"waitKey\", 30); // wait for key\n                  }\n                  break;\n              case 0xbb4e: // TXT Initialize (ROM &1078)\n                  this.canvas.resetCustomChars();\n                  this.vmResetPenPaperWindowData(); // reset pen and paper\n                  this.vmResetWindowData(); // reset windows\n                  // and TXT Reset...\n                  this.vmResetControlBuffer();\n                  break;\n              case 0xbb51: // TXT Reset (ROM &11088)\n                  this.vmResetControlBuffer();\n                  break;\n              case 0xbb5a: // TXT Output (ROM &1400), depending on number of args\n                  this.print(0, String.fromCharCode(args.length));\n                  break;\n              case 0xbb5d: // TXT WR Char (ROM &1334), depending on number of args\n                  this.vmDrawUndrawCursor(0);\n                  this.vmPrintChars(0, String.fromCharCode(args.length));\n                  this.vmDrawUndrawCursor(0);\n                  break;\n              case 0xbb6c: // TXT Clear Window (ROM &1540)\n                  this.cls(0);\n                  break;\n              case 0xbb7b: // TXT Cursor Enable (ROM &1289); user switch (cursor enabled)\n                  this.cursor(0, undefined, 1);\n                  break;\n              case 0xbb7e: // TXT Cursor Disable (ROM &129A); user switch\n                  this.cursor(0, undefined, 0);\n                  break;\n              case 0xbb81: // TXT Cursor On (ROM &1279); system switch (cursor on)\n                  this.cursor(0, 1);\n                  break;\n              case 0xbb84: // TXT Cursor Off (ROM &1281); system switch\n                  this.cursor(0, 0);\n                  break;\n              case 0xbb8a: // TXT Place Cursor (ROM &1268)\n              case 0xbb8d: // TXT Remove Cursor (ROM &1268); same as place cursor\n                  this.vmPlaceRemoveCursor(0); // 0=stream\n                  break;\n              case 0xbb90: // TXT Set Pen (ROM &12A9), depending on number of args\n                  this.pen(0, args.length % 16);\n                  break;\n              case 0xbb96: // TXT Set Paper (ROM &12AE); depending on number of args\n                  this.paper(0, args.length % 16);\n                  break;\n              case 0xbb9c: // TXT Inverse (ROM &12C9), same as print chr$(24);\n                  this.vmTxtInverse(0);\n                  break;\n              case 0xbb9f: // TXT Set Back (ROM &137A), depending on number of args\n                  this.vmSetTransparentMode(0, args.length);\n                  break;\n              case 0xbbdb: // GRA Clear Window (ROM &17C5)\n                  this.canvas.clearGraphicsWindow();\n                  break;\n              case 0xbbde: // GRA Set Pen (ROM &17F6), depending on number of args\n                  // we can only set graphics pen depending on number of args (pen 0=no arg, pen 1=one arg)\n                  this.graphicsPen(args.length % 16);\n                  break;\n              case 0xbbe4: // GRA Set Paper (ROM &17FD), depending on number of args\n                  this.graphicsPaper(args.length % 16);\n                  break;\n              case 0xbbfc: // GRA WR Char (ROM &1945), depending on number of args\n                  this.canvas.printGChar(args.length);\n                  break;\n              case 0xbbff: // SCR Initialize (ROM &0AA0)\n                  this.vmSetScreenBase(0xc0);\n                  this.modeValue = 1;\n                  this.canvas.setMode(this.modeValue); // does not clear canvas\n                  this.canvas.clearFullWindow(); // (SCR Mode Clear)\n                  // and SCR Reset:\n                  this.vmResetInks();\n                  break;\n              case 0xbc02: // SCR Reset (ROM &0AB1)\n                  this.vmResetInks();\n                  break;\n              case 0xbc06: // SCR SET BASE (&BC08, ROM &0B45); We use &BC06 to load reg A from reg E (not for CPC 664!)\n              case 0xbc07: // Works on all CPC 464/664/6128\n                  this.vmSetScreenBase(args[0]);\n                  break;\n              case 0xbc0e: // SCR SET MODE (ROM &0ACE), depending on number of args\n                  this.mode(args.length % 4); // 3 is valid also on CPC\n                  break;\n              case 0xbca7: // SOUND Reset (ROM &1E68)\n                  this.soundClass.reset();\n                  break;\n              case 0xbcb6: // SOUND Hold (ROM &1ECB)\n                  this.vmNotImplemented(\"CALL &BCBC\");\n                  break;\n              case 0xbcb9: // SOUND Continue (ROM &1EE6)\n                  this.vmNotImplemented(\"CALL &BCB9\");\n                  break;\n              case 0xbd19: // MC Wait Flyback (ROM &07BA)\n                  this.frame();\n                  break;\n              case 0xbd1c: // MC Set Mode (ROM &0776) just set mode, depending on number of args\n                  this.vmMcSetMode(args.length % 4);\n                  break;\n              /*\n              // would be a temporary functionality, will be undo with next interrupt\n              case 0xbd22: // MC Clear Inks (ROM &0786), ink table address in DE (last parameter)\n                  break;\n              */\n              case 0xbd25: // MC Set Inks (ROM &0799), ink table address in DE (last parameter), experimental\n                  this.updateColorsImmediately(args[0]);\n                  break;\n              case 0xbd3d: // KM Flush (ROM ?; CPC 664/6128)\n                  this.clearInput();\n                  break;\n              case 0xbd49: // GRA Set First (ROM ?; CPC 664/6128), depending on number of args\n                  this.canvas.setMaskFirst(args.length % 2);\n                  break;\n              case 0xbd4c: // GRA Set Mask (ROM ?; CPC 664/6128), depending on number of args\n                  this.canvas.setMask(args.length);\n                  break;\n              case 0xbd52: // GRA Fill (ROM ?; CPC 664/6128), depending on number of args\n                  this.fill(args.length % 16);\n                  break;\n              case 0xbd5b: // KL RAM SELECT (CPC 6128 only)\n                  // we can only set RAM bank depending on number of args\n                  this.vmSetRamSelect(args.length);\n                  break;\n              default:\n                  if (!this.rsx.callRsx(this, \"&\" + addr.toString(16).toLowerCase().padStart(4, \"0\"), ...args)) { // maybe user defined addr\n                      if (Utils.debug > 0) {\n                          Utils.console.debug(\"Ignored: CALL\", addr, args);\n                      }\n                  }\n                  break;\n          }\n      }\n      callRsx(name, ...args) {\n          // RSX name can contain letters, digits and \".\" (in basic it is uppercase but here we get lowercase characters)\n          if (args.length > 32) { // more that 32 arguments?\n              throw this.vmComposeError(Error(), 2, \"RSX \"); // Syntax Error\n          }\n          for (let i = 0; i < args.length; i += 1) {\n              if (typeof args[i] === \"number\") {\n                  args[i] = this.vmRound2Complement(args[i], \"RSX\"); // even if the args itself are not used here\n              }\n          }\n          if (!this.rsx.callRsx(this, name, ...args)) {\n              throw this.vmComposeError(Error(), 28, \"|\" + name); // Unknown command\n          }\n      }\n      cat() {\n          const stream = 0, fileParas = {\n              command: \"cat\",\n              stream: stream,\n              fileMask: \"\",\n              line: this.line // unused\n          };\n          this.vmStop(\"fileCat\", 45, false, fileParas);\n      }\n      chain(name, line, first, last) {\n          const inFile = this.inFile;\n          name = this.vmAdaptFilename(name, \"CHAIN\");\n          this.closein();\n          inFile.line = line === undefined ? 0 : this.vmInRangeRound(line, 0, 65535, \"CHAIN\"); // here we do rounding of line number\n          inFile.first = first === undefined ? 0 : this.vmAssertInRange(first, 1, 65535, \"CHAIN\"); // first and last are not needed\n          inFile.last = last === undefined ? 0 : this.vmAssertInRange(last, 1, 65535, \"CHAIN\");\n          inFile.open = true;\n          inFile.command = \"chain\";\n          inFile.name = name;\n          inFile.fnFileCallback = this.fnCloseinHandler;\n          this.vmStop(\"fileLoad\", 90);\n      }\n      chainMerge(name, line, first, last) {\n          const inFile = this.inFile;\n          name = this.vmAdaptFilename(name, \"CHAIN MERGE\");\n          this.closein();\n          inFile.line = line === undefined ? 0 : this.vmInRangeRound(line, 0, 65535, \"CHAIN MERGE\"); // here we do rounding of line number;\n          inFile.first = first === undefined ? 0 : this.vmAssertInRange(first, 1, 65535, \"CHAIN MERGE\");\n          inFile.last = last === undefined ? 0 : this.vmAssertInRange(last, 1, 65535, \"CHAIN MERGE\");\n          inFile.open = true;\n          inFile.command = \"chainMerge\";\n          inFile.name = name;\n          inFile.fnFileCallback = this.fnCloseinHandler;\n          this.vmStop(\"fileLoad\", 90);\n      }\n      chr$(n) {\n          n = this.vmInRangeRound(n, 0, 255, \"CHR$\");\n          return String.fromCharCode(n);\n      }\n      cint(n) {\n          return this.vmInRangeRound(n, -32768, 32767, \"CINT\");\n      }\n      clear() {\n          this.vmResetTimers();\n          this.ei();\n          this.vmSetStartLine(0);\n          this.breakGosubLine = 0;\n          this.breakResumeLine = 0;\n          this.errorGotoLine = 0;\n          this.errorResumeLine = 0;\n          this.gosubStack.length = 0;\n          this.variables.initAllVariables();\n          this.defreal(\"a\", \"z\");\n          this.restore(); // restore data line index\n          this.rad();\n          this.soundClass.resetQueue();\n          this.soundData.length = 0;\n          this.vmResetInFileHandling();\n          this.vmResetOutFileHandling();\n      }\n      clearInput() {\n          this.keyboard.clearInput();\n      }\n      clg(gPaper) {\n          if (gPaper !== undefined) {\n              gPaper = this.vmInRangeRound(gPaper, 0, 15, \"CLG\");\n              this.canvas.setGPaper(gPaper);\n          }\n          this.canvas.clearGraphicsWindow();\n      }\n      vmCloseinCallback() {\n          const inFile = this.inFile;\n          CpcVm.vmResetFileHandling(inFile);\n      }\n      closein() {\n          if (this.inFile.open) {\n              this.vmCloseinCallback(); // close directly\n          }\n      }\n      vmCloseoutCallback() {\n          const outFile = this.outFile;\n          CpcVm.vmResetFileHandling(outFile);\n      }\n      closeout() {\n          const outFile = this.outFile;\n          if (outFile.open) {\n              if (outFile.command !== \"openout\") {\n                  if (!this.quiet) {\n                      Utils.console.warn(\"closeout: command=\", outFile.command); // should not occur\n                  }\n              }\n              if (!outFile.fileData.length) { // openout without data?\n                  this.vmCloseoutCallback(); // close directly\n              }\n              else { // data to save\n                  outFile.command = \"closeout\";\n                  outFile.start = 0;\n                  outFile.length = 0; // will be set during fileSave\n                  outFile.fnFileCallback = this.fnCloseoutHandler;\n                  this.vmStop(\"fileSave\", 90); // must stop directly after closeout\n              }\n          }\n      }\n      // also called for chr$(12), call &bb6c\n      cls(stream) {\n          stream = this.vmInRangeRound(stream, 0, 7, \"CLS\");\n          const win = this.windowDataList[stream];\n          this.vmDrawUndrawCursor(stream); // why, if we clear anyway?\n          this.canvas.clearTextWindow(win.left, win.right, win.top, win.bottom, win.paper); // cls window\n          win.pos = 0;\n          win.vpos = 0;\n          if (!stream) {\n              this.outBuffer = \"\"; // clear also console, if stream===0\n          }\n      }\n      commaTab(stream) {\n          stream = this.vmInRangeRound(stream, 0, 9, \"commaTab\");\n          this.vmMoveCursor2AllowedPos(stream);\n          const zone = this.zoneValue, win = this.windowDataList[stream];\n          let count = zone - (win.pos % zone);\n          if (win.pos) { // <>0: not begin of line\n              if (win.pos + count + zone > (win.right + 1 - win.left)) {\n                  win.pos += count + zone;\n                  this.vmMoveCursor2AllowedPos(stream);\n                  count = 0;\n              }\n          }\n          return \" \".repeat(count);\n      }\n      cont() {\n          if (!this.startLine) {\n              throw this.vmComposeError(Error(), 17, \"CONT\"); // cannot continue\n          }\n          this.vmGoto(this.startLine, \"CONT\");\n          this.startLine = 0;\n      }\n      copychr$(stream) {\n          stream = this.vmInRangeRound(stream, 0, 7, \"COPYCHR$\");\n          this.vmMoveCursor2AllowedPos(stream);\n          this.vmDrawUndrawCursor(stream); // undraw\n          const win = this.windowDataList[stream], charCode = this.canvas.readChar(win.pos + win.left, win.vpos + win.top, win.pen, win.paper), char = (charCode >= 0) ? String.fromCharCode(charCode) : \" \"; // if not detected (-1), use space\n          this.vmDrawUndrawCursor(stream); // draw\n          return char;\n      }\n      cos(n) {\n          this.vmAssertNumber(n, \"COS\");\n          return Math.cos((this.degFlag) ? Utils.toRadians(n) : n);\n      }\n      creal(n) {\n          this.vmAssertNumber(n, \"CREAL\");\n          return n;\n      }\n      vmPlaceRemoveCursor(stream) {\n          const win = this.windowDataList[stream];\n          this.vmMoveCursor2AllowedPos(stream);\n          this.canvas.drawCursor(win.pos + win.left, win.vpos + win.top, win.pen, win.paper);\n      }\n      vmDrawUndrawCursor(stream) {\n          const win = this.windowDataList[stream];\n          if (win.cursorOn && win.cursorEnabled) {\n              this.vmPlaceRemoveCursor(stream);\n          }\n      }\n      cursor(stream, cursorOn, cursorEnabled) {\n          stream = this.vmInRangeRound(stream, 0, 7, \"CURSOR\");\n          const win = this.windowDataList[stream];\n          if (cursorOn !== undefined) { // system\n              cursorOn = this.vmInRangeRound(cursorOn, 0, 1, \"CURSOR\");\n              this.vmDrawUndrawCursor(stream); // undraw\n              win.cursorOn = Boolean(cursorOn);\n              this.vmDrawUndrawCursor(stream); // draw\n          }\n          if (cursorEnabled !== undefined) { // user\n              cursorEnabled = this.vmInRangeRound(cursorEnabled, 0, 1, \"CURSOR\");\n              this.vmDrawUndrawCursor(stream); // undraw\n              win.cursorEnabled = Boolean(cursorEnabled);\n              this.vmDrawUndrawCursor(stream); // draw\n          }\n      }\n      data(line, ...args) {\n          this.vmLineInRange(line, \"DATA\");\n          if (!this.dataLineIndex[line]) {\n              this.dataLineIndex[line] = this.dataList.length; // set current index for the line\n          }\n          // append data\n          for (let i = 0; i < args.length; i += 1) {\n              this.dataList.push(args[i]);\n          }\n      }\n      dec$(n, frmt) {\n          const formatRegExp = /^[+\\-$*#,.^]*$/;\n          this.vmAssertNumber(n, \"DEC$\");\n          this.vmAssertString(frmt, \"DEC$\");\n          if (!formatRegExp.test(frmt)) { // only allowed characters: + - $  * # , . ^\n              throw this.vmComposeError(Error(), 5, \"DEC$ \" + frmt); // Improper argument\n          }\n          return this.vmUsingNumberFormat(frmt, n);\n      }\n      // def fn\n      defint(first, last) {\n          this.vmDefineVarTypes(\"I\", \"DEFINT\", first, last);\n      }\n      defreal(first, last) {\n          this.vmDefineVarTypes(\"R\", \"DEFREAL\", first, last);\n      }\n      defstr(first, last) {\n          this.vmDefineVarTypes(\"$\", \"DEFSTR\", first, last);\n      }\n      deg() {\n          this.degFlag = true;\n      }\n      \"delete\"(first, last) {\n          if (first === undefined) {\n              first = 1;\n              last = last === undefined ? 65535 : this.vmInRangeRound(last, 1, 65535, \"DELETE\");\n          }\n          else {\n              first = this.vmInRangeRound(first, 1, 65535, \"DELETE\");\n              if (last === undefined) { // just one parameter?\n                  last = first;\n              }\n              else { // range\n                  last = this.vmInRangeRound(last, 1, 65535, \"DELETE\");\n              }\n          }\n          this.vmStop(\"deleteLines\", 85, false, {\n              command: \"DELETE\",\n              stream: 0, // unused\n              first: first,\n              last: last,\n              line: this.line // unused\n          });\n      }\n      derr() {\n          return 0; // \"[Not implemented yet: derr]\"\n      }\n      di() {\n          this.timerPriority = 3; // increase priority\n      }\n      dim(varName, ...args) {\n          const dimensions = [];\n          this.vmAssertString(varName, \"DIM\");\n          for (let i = 0; i < args.length; i += 1) {\n              const size = this.vmInRangeRound(args[i], 0, 32767, \"DIM\") + 1; // for basic we have sizes +1\n              dimensions.push(size);\n          }\n          this.variables.dimVariable(varName, dimensions);\n      }\n      draw(x, y, gPen, gColMode) {\n          x = this.vmInRangeRound(x, -32768, 32767, \"DRAW\");\n          y = this.vmInRangeRound(y, -32768, 32767, \"DRAW\");\n          this.vmDrawMovePlot(\"DRAW\", gPen, gColMode);\n          this.canvas.draw(x, y);\n      }\n      drawr(x, y, gPen, gColMode) {\n          x = this.vmInRangeRound(x, -32768, 32767, \"DRAWR\") + this.canvas.getXpos();\n          y = this.vmInRangeRound(y, -32768, 32767, \"DRAWR\") + this.canvas.getYpos();\n          this.vmDrawMovePlot(\"DRAWR\", gPen, gColMode);\n          this.canvas.draw(x, y);\n      }\n      edit(line) {\n          const lineParas = {\n              command: \"edit\",\n              stream: 0, // unused\n              first: line,\n              last: 0, // unused,\n              line: this.line // unused\n          };\n          this.vmStop(\"editLine\", 85, false, lineParas);\n      }\n      ei() {\n          this.timerPriority = -1; // decrease priority\n      }\n      end(label) {\n          this.stop(label);\n      }\n      ent(toneEnv, ...args) {\n          toneEnv = this.vmInRangeRound(toneEnv, -15, 15, \"ENT\");\n          const envData = [];\n          let arg, repeat = false;\n          if (toneEnv < 0) {\n              toneEnv = -toneEnv;\n              repeat = true;\n          }\n          if (toneEnv) { // not 0\n              for (let i = 0; i < args.length; i += 3) { // starting with 1: 3 parameters per section\n                  if (args[i] !== undefined) {\n                      arg = {\n                          steps: this.vmInRangeRound(args[i], 0, 239, \"ENT\"), // number of steps: 0..239\n                          diff: this.vmInRangeRound(args[i + 1], -128, 127, \"ENT\"), // size (period change) of steps: -128..+127\n                          time: this.vmInRangeRound(args[i + 2], 0, 255, \"ENT\"), // time per step: 0..255 (0=256)\n                          repeat: repeat\n                      }; // as ToneEnvData1\n                  }\n                  else { // special handling\n                      arg = {\n                          period: this.vmInRangeRound(args[i + 1], 0, 4095, \"ENT\"), // absolute period\n                          time: this.vmInRangeRound(args[i + 2], 0, 255, \"ENT\") // time: 0..255 (0=256)\n                      }; // as ToneEnvData2\n                  }\n                  envData.push(arg);\n              }\n              this.soundClass.setToneEnv(toneEnv, envData);\n          }\n          else { // 0\n              if (!this.quiet) {\n                  Utils.console.warn(\"ENT: toneEnv\", toneEnv);\n              }\n              throw this.vmComposeError(Error(), 5, \"ENT \" + toneEnv); // Improper argument\n          }\n      }\n      env(volEnv, ...args) {\n          volEnv = this.vmInRangeRound(volEnv, 1, 15, \"ENV\");\n          const envData = [];\n          let arg;\n          for (let i = 0; i < args.length; i += 3) { // starting with 1: 3 parameters per section\n              if (args[i] !== undefined) {\n                  arg = {\n                      steps: this.vmInRangeRound(args[i], 0, 127, \"ENV\"), // number of steps: 0..127\n                      /* eslint-disable no-bitwise */\n                      diff: this.vmInRangeRound(args[i + 1], -128, 127, \"ENV\") & 0x0f, // size (volume) of steps: moved to range 0..15\n                      /* eslint-enable no-bitwise */\n                      time: this.vmInRangeRound(args[i + 2], 0, 255, \"ENV\") // time per step: 0..255 (0=256)\n                  }; // as VolEnvData1\n                  if (!arg.time) { // (0=256)\n                      arg.time = 256;\n                  }\n              }\n              else { // special handling for register parameters\n                  arg = {\n                      register: this.vmInRangeRound(args[i + 1], 0, 15, \"ENV\"), // register: 0..15\n                      period: this.vmInRangeRound(args[i + 2], -32768, 65535, \"ENV\")\n                  }; // as VolEnvData2\n              }\n              envData.push(arg);\n          }\n          this.soundClass.setVolEnv(volEnv, envData);\n      }\n      eof() {\n          const inFile = this.inFile;\n          let eof = -1;\n          if (inFile.open && inFile.fileData.length) {\n              eof = 0;\n          }\n          return eof;\n      }\n      // find array variable matching <name>(A+)(typeChar?)\n      vmFindArrayVariable(name) {\n          let typeChar = name.charAt(name.length - 1); // last character\n          if (typeChar === \"I\" || typeChar === \"R\" || typeChar === \"$\") { // explicit type specified?\n              name = name.slice(0, -1); // remove type char\n          }\n          else {\n              typeChar = this.vmDetermineVarType(name.charAt(0)); // determine type char\n          }\n          name += \"A\";\n          // find array variable(s) of same type, including multi-dim\n          const fnArrayVarFilter = function (variable) {\n              return (variable.indexOf(name) === 0 && (variable.charAt(variable.length - 1) === typeChar)) ? variable : null; // find array var(A)*<typeChar>\n          };\n          let names = this.variables.getAllVariableNames();\n          names = names.filter(fnArrayVarFilter);\n          return names;\n      }\n      erase(...args) {\n          if (!args.length) {\n              throw this.vmComposeError(Error(), 2, \"ERASE\"); // Syntax Error\n          }\n          for (let i = 0; i < args.length; i += 1) {\n              this.vmAssertString(args[i], \"ERASE\");\n              const names = this.vmFindArrayVariable(args[i]);\n              if (names.length) {\n                  for (let j = 0; j < names.length; j += 1) {\n                      const name = names[j];\n                      this.variables.initVariable(name);\n                  }\n              }\n              else {\n                  if (!this.quiet) {\n                      Utils.console.warn(\"erase: Array variable not found:\", args[i]);\n                  }\n                  throw this.vmComposeError(Error(), 5, \"ERASE \" + args[i]); // Improper argument\n              }\n          }\n      }\n      erl() {\n          const errorLine = parseInt(String(this.errorLine), 10); // in CpcLoco we have an error label here, so return number only\n          return errorLine || 0;\n      }\n      err() {\n          return this.errorCode;\n      }\n      vmComposeError(error, err, errInfo) {\n          const errors = CpcVm.errors, errorString = errors[err] || errors[errors.length - 1]; // maybe Unknown error\n          this.errorCode = err;\n          this.errorLine = this.line;\n          const errorWithInfo = errorString + \" in \" + this.errorLine + (errInfo ? (\": \" + errInfo) : \"\");\n          let hidden = false; // hide errors wich are catched\n          if (this.errorGotoLine && !this.errorResumeLine) {\n              this.errorResumeLine = this.errorLine;\n              this.vmGoto(this.errorGotoLine, \"onError\");\n              this.vmStop(\"onError\", 50);\n              hidden = true;\n          }\n          else {\n              this.vmStop(\"error\", 50);\n          }\n          if (!this.quiet) {\n              Utils.console.log(\"BASIC error(\" + err + \"):\", errorWithInfo + (hidden ? \" (hidden: \" + hidden + \")\" : \"\"));\n          }\n          const traceLine = this.line, sourceMapEntry = this.sourceMap[traceLine], pos = sourceMapEntry && sourceMapEntry[0], len = sourceMapEntry && sourceMapEntry[1];\n          return Utils.composeError(\"CpcVm\", error, errorString, errInfo, pos, len, this.line, hidden);\n      }\n      error(err, errInfo) {\n          err = this.vmInRangeRound(err, 0, 255, \"ERROR\"); // could trigger another error\n          throw this.vmComposeError(Error(), err, errInfo);\n      }\n      everyGosub(interval, timer, line) {\n          this.vmAfterEveryGosub(\"EVERY\", interval, timer, line);\n      }\n      exp(n) {\n          this.vmAssertNumber(n, \"EXP\");\n          return Math.exp(n);\n      }\n      fill(gPen) {\n          gPen = this.vmInRangeRound(gPen, 0, 15, \"FILL\");\n          this.canvas.fill(gPen);\n      }\n      fix(n) {\n          this.vmAssertNumber(n, \"FIX\");\n          return Math.trunc(n); // (ES6: Math.trunc)\n      }\n      frame() {\n          this.vmStop(\"waitFrame\", 40);\n      }\n      fre(arg) {\n          if (typeof arg !== \"number\" && typeof arg !== \"string\") {\n              throw this.vmComposeError(Error(), 2, \"FRE\"); // Syntax Error\n          }\n          // on a CPC it is start of strings - end of arrays, here we use himem - end of program\n          return this.himemValue - this.progEnd;\n      }\n      vmGosub(retLabel, n) {\n          this.vmGoto(n, \"gosub (ret=\" + retLabel + \")\");\n          this.gosubStack.push(retLabel);\n      }\n      gosub(retLabel, n) {\n          this.vmLineInRange(n, \"GOSUB\");\n          if (this.gosubStack.length >= this.maxGosubStackLength) { // limit stack size (not necessary in JS, but...)\n              throw this.vmComposeError(Error(), 7, \"GOSUB \" + n); // Memory full\n          }\n          this.vmGosub(retLabel, n);\n      }\n      \"goto\"(line) {\n          this.vmLineInRange(line, \"GOTO\");\n          this.vmGoto(line, \"goto\");\n      }\n      graphicsPaper(gPaper) {\n          gPaper = this.vmInRangeRound(gPaper, 0, 15, \"GRAPHICS PAPER\");\n          this.canvas.setGPaper(gPaper);\n      }\n      graphicsPen(gPen, transparentMode) {\n          if (gPen === undefined && transparentMode === undefined) {\n              throw this.vmComposeError(Error(), 22, \"GRAPHICS PEN\"); // Operand missing\n          }\n          if (gPen !== undefined) {\n              gPen = this.vmInRangeRound(gPen, 0, 15, \"GRAPHICS PEN\");\n              this.canvas.setGPen(gPen);\n          }\n          if (transparentMode !== undefined) {\n              transparentMode = this.vmInRangeRound(transparentMode, 0, 1, \"GRAPHICS PEN\");\n              this.canvas.setGTransparentMode(Boolean(transparentMode));\n          }\n      }\n      hex$(n, pad) {\n          n = this.vmRound2Complement(n, \"HEX$\");\n          pad = this.vmInRangeRound(pad || 0, 0, 16, \"HEX$\");\n          return n.toString(16).toUpperCase().padStart(pad, \"0\");\n      }\n      himem() {\n          return this.himemValue;\n      }\n      ink(pen, ink1, ink2) {\n          pen = this.vmInRangeRound(pen, 0, 15, \"INK\");\n          ink1 = this.vmInRangeRound(ink1, 0, 31, \"INK\");\n          if (ink2 === undefined) {\n              ink2 = ink1;\n          }\n          else {\n              ink2 = this.vmInRangeRound(ink2, 0, 31, \"INK\");\n          }\n          this.canvas.setInk(pen, ink1, ink2);\n      }\n      inkey(key) {\n          key = this.vmInRangeRound(key, 0, 79, \"INKEY\");\n          return this.keyboard.getKeyState(key);\n      }\n      inkey$() {\n          const key = this.keyboard.getKeyFromBuffer();\n          // do some slowdown, if checked too early again without key press\n          if (key !== \"\") { // some key pressed?\n              this.inkeyTimeMs = 0;\n          }\n          else { // no key\n              const now = Date.now();\n              if (this.inkeyTimeMs && now < this.inkeyTimeMs) { // last inkey without key was in range of frame fly?\n                  this.frame(); // then insert a frame fly\n              }\n              this.inkeyTimeMs = now + CpcVm.frameTimeMs; // next time of frame fly\n          }\n          return key;\n      }\n      inp(port) {\n          port = this.vmRound2Complement(port, \"INP\"); // two's complement of 16 bit address\n          // eslint-disable-next-line no-bitwise\n          let byte = (port & 0xff);\n          // eslint-disable-next-line no-bitwise\n          byte |= 0xff; // we return always the same 0xff\n          return byte;\n      }\n      vmSetInputValues(inputValues) {\n          this.inputValues = inputValues;\n      }\n      vmGetNextInput() {\n          const inputValues = this.inputValues, value = inputValues.shift();\n          return value;\n      }\n      vmInputCallback() {\n          const inputParas = this.vmGetStopObject().paras, stream = inputParas.stream, input = inputParas.input, inputValues = input.split(\",\"), convertedInputValues = [], types = inputParas.types;\n          let inputOk = true;\n          if (Utils.debug > 0) {\n              Utils.console.debug(\"vmInputCallback:\", input);\n          }\n          if (types && (inputValues.length === types.length)) {\n              for (let i = 0; i < types.length; i += 1) {\n                  const varType = types[i], type = this.vmDetermineVarType(varType), value = inputValues[i];\n                  if (type !== \"$\") { // not a string?\n                      const valueNumber = this.vmVal(value); // convert to number (also binary, hex), empty string gets 0\n                      if (isNaN(valueNumber)) {\n                          inputOk = false;\n                      }\n                      convertedInputValues.push(valueNumber);\n                  }\n                  else {\n                      convertedInputValues.push(value);\n                  }\n              }\n          }\n          else {\n              inputOk = false;\n          }\n          this.cursor(stream, 0);\n          if (!inputOk) {\n              this.print(stream, \"?Redo from start\\r\\n\");\n              inputParas.input = \"\";\n              this.print(stream, inputParas.message);\n              this.cursor(stream, 1);\n          }\n          else {\n              this.vmSetInputValues(convertedInputValues);\n          }\n          return inputOk;\n      }\n      fnFileInputGetString(fileData) {\n          let line = fileData[0].replace(/^\\s+/, \"\"), // remove preceding whitespace\n          value;\n          if (line.charAt(0) === '\"') { // quoted string?\n              const index = line.indexOf('\"', 1); // closing quotes in this line?\n              if (index >= 0) {\n                  value = line.substring(1, index + 1 - 1); // take string without quotes\n                  line = line.substring(index + 1);\n                  line = line.replace(/^\\s*,/, \"\"); // multiple args => remove next comma\n              }\n              else if (fileData.length > 1) { // no closing quotes in this line => try to combine with next line\n                  fileData.shift(); // remove line\n                  line += \"\\n\" + fileData[0]; // combine lines\n              }\n              else {\n                  throw this.vmComposeError(Error(), 13, \"INPUT #9: no closing quotes: \" + line);\n              }\n          }\n          else { // unquoted string\n              const index = line.indexOf(\",\"); // multiple args?\n              if (index >= 0) {\n                  value = line.substring(0, index); // take arg\n                  line = line.substring(index + 1);\n              }\n              else {\n                  value = line; // take line\n                  line = \"\";\n              }\n          }\n          fileData[0] = line;\n          return value;\n      }\n      fnFileInputGetNumber(fileData) {\n          let line = fileData[0].replace(/^\\s+/, \"\"), // remove preceding whitespace\n          index = line.indexOf(\",\"), // multiple args?\n          value;\n          if (index >= 0) {\n              value = line.substring(0, index); // take arg\n              line = line.substring(index + 1);\n          }\n          else {\n              index = line.indexOf(\" \"); // space?\n              if (index >= 0) {\n                  value = line.substring(0, index); // take item until space\n                  line = line.substring(index);\n                  line = line.replace(/^\\s*/, \"\"); // remove spaces after number\n              }\n              else {\n                  value = line; // take line\n                  line = \"\";\n              }\n          }\n          const nValue = this.vmVal(value); // convert to number (also binary, hex)\n          if (isNaN(nValue)) { // eslint-disable-line max-depth\n              throw this.vmComposeError(Error(), 13, \"INPUT #9 \" + nValue + \": \" + value); // Type mismatch\n          }\n          fileData[0] = line;\n          return nValue;\n      }\n      vmInputNextFileItem(type) {\n          const fileData = this.inFile.fileData;\n          let value;\n          while (fileData.length && value === undefined) {\n              if (type === \"$\") {\n                  value = this.fnFileInputGetString(fileData);\n              }\n              else { // number type\n                  value = this.fnFileInputGetNumber(fileData);\n              }\n              if (!fileData[0].length) {\n                  fileData.shift(); // remove empty line\n              }\n          }\n          return value;\n      }\n      vmInputFromFile(types) {\n          const inputValues = [];\n          for (let i = 0; i < types.length; i += 1) {\n              const varType = types[i], type = this.vmDetermineVarType(varType), value = this.vmInputNextFileItem(type);\n              inputValues[i] = this.vmAssign(varType, value);\n          }\n          this.vmSetInputValues(inputValues);\n      }\n      input(stream, noCRLF, msg, ...args) {\n          stream = this.vmInRangeRound(stream, 0, 9, \"INPUT\");\n          if (stream < 8) {\n              this.print(stream, msg);\n              this.vmStop(\"waitInput\", 45, false, {\n                  command: \"input\",\n                  stream: stream,\n                  message: msg,\n                  noCRLF: noCRLF,\n                  fnInputCallback: this.fnInputCallbackHandler,\n                  types: args,\n                  input: \"\",\n                  line: this.line // to repeat in case of break\n              });\n              this.cursor(stream, 1);\n          }\n          else if (stream === 8) {\n              this.vmSetInputValues([\"I am the printer!\"]);\n          }\n          else if (stream === 9) {\n              if (!this.inFile.open) {\n                  throw this.vmComposeError(Error(), 31, \"INPUT #\" + stream); // File not open\n              }\n              else if (this.eof()) {\n                  throw this.vmComposeError(Error(), 24, \"INPUT #\" + stream); // EOF met\n              }\n              this.vmInputFromFile(args); // remaining arguments\n          }\n      }\n      instr(p1, p2, p3) {\n          const startPos = typeof p1 === \"number\" ? this.vmInRangeRound(p1, 1, 255, \"INSTR\") - 1 : 0, // p1=startpos\n          str = typeof p1 === \"number\" ? p2 : p1, search = typeof p1 === \"number\" ? p3 : p2;\n          this.vmAssertString(str, \"INSTR\");\n          this.vmAssertString(search, \"INSTR\");\n          if (startPos >= str.length) {\n              return 0; // not found\n          }\n          if (!search.length) {\n              return startPos + 1;\n          }\n          return CpcVm.vmWithControlCodes(str).indexOf(CpcVm.vmWithControlCodes(search), startPos) + 1;\n      }\n      \"int\"(n) {\n          this.vmAssertNumber(n, \"INT\");\n          return Math.floor(n);\n      }\n      joy(joy) {\n          joy = this.vmInRangeRound(joy, 0, 1, \"JOY\");\n          return this.keyboard.getJoyState(joy);\n      }\n      key(token, s) {\n          token = this.vmRound(token, \"KEY\");\n          if (token >= 128 && token <= 159) {\n              token -= 128;\n          }\n          token = this.vmInRangeRound(token, 0, 31, \"KEY\"); // round again, but we want the check\n          this.vmAssertString(s, \"KEY\");\n          this.keyboard.setExpansionToken(token, s);\n      }\n      keyDef(cpcKey, repeat, normal, shift, ctrl) {\n          const options = {\n              cpcKey: this.vmInRangeRound(cpcKey, 0, 79, \"KEY DEF\"),\n              repeat: this.vmInRangeRound(repeat, 0, 1, \"KEY DEF\"),\n              normal: (normal !== undefined) ? this.vmInRangeRound(normal, 0, 255, \"KEY DEF\") : undefined,\n              shift: (shift !== undefined) ? this.vmInRangeRound(shift, 0, 255, \"KEY DEF\") : undefined,\n              ctrl: (ctrl !== undefined) ? this.vmInRangeRound(ctrl, 0, 255, \"KEY DEF\") : undefined\n          };\n          this.keyboard.setCpcKeyExpansion(options);\n      }\n      left$(s, len) {\n          this.vmAssertString(s, \"LEFT$\");\n          len = this.vmInRangeRound(len, 0, 255, \"LEFT$\");\n          return s.substring(0, len);\n      }\n      len(s) {\n          this.vmAssertString(s, \"LEN\");\n          return s.length;\n      }\n      // let\n      vmLineInputCallback() {\n          const inputParas = this.vmGetStopObject().paras, input = inputParas.input;\n          if (Utils.debug > 0) {\n              Utils.console.debug(\"vmLineInputCallback:\", input);\n          }\n          this.vmSetInputValues([input]);\n          this.cursor(inputParas.stream, 0);\n          return true;\n      }\n      lineInput(stream, noCRLF, msg, varType) {\n          stream = this.vmInRangeRound(stream, 0, 9, \"LINE INPUT\");\n          if (stream < 8) {\n              this.vmAssertString(varType, \"LINE INPUT\");\n              this.print(stream, msg);\n              const type = this.vmDetermineVarType(varType);\n              if (type !== \"$\") { // not string?\n                  this.print(stream, \"\\r\\n\");\n                  throw this.vmComposeError(Error(), 13, \"LINE INPUT \" + type); // Type mismatch\n              }\n              this.cursor(stream, 1);\n              this.vmStop(\"waitInput\", 45, false, {\n                  command: \"lineinput\",\n                  stream: stream,\n                  message: msg,\n                  noCRLF: noCRLF,\n                  fnInputCallback: this.fnLineInputCallbackHandler,\n                  input: \"\",\n                  line: this.line // to repeat in case of break\n              });\n          }\n          else if (stream === 8) {\n              this.vmSetInputValues([\"I am the printer!\"]);\n          }\n          else if (stream === 9) {\n              if (!this.inFile.open) {\n                  throw this.vmComposeError(Error(), 31, \"LINE INPUT #\" + stream); // File not open\n              }\n              else if (this.eof()) {\n                  throw this.vmComposeError(Error(), 24, \"LINE INPUT #\" + stream); // EOF met\n              }\n              this.vmSetInputValues(this.inFile.fileData.splice(0, arguments.length - 3)); // always 1 element\n          }\n      }\n      list(stream, first, last) {\n          stream = this.vmInRangeRound(stream, 0, 9, \"LIST\");\n          if (first === undefined) {\n              first = 1;\n              if (last === undefined) { // no first and last parameter?\n                  last = 65535;\n              }\n          }\n          else {\n              first = this.vmInRangeRound(first, 1, 65535, \"LIST\");\n              if (last === undefined) { // just one parameter?\n                  last = first;\n              }\n              else { // range\n                  last = this.vmInRangeRound(last, 1, 65535, \"LIST\");\n              }\n          }\n          if (stream === 9) {\n              if (!this.outFile.open) { // catch here\n                  throw this.vmComposeError(Error(), 31, \"LIST #\" + stream); // File not open\n              }\n          }\n          this.vmStop(\"list\", 90, false, {\n              command: \"list\",\n              stream: stream,\n              first: first,\n              last: last,\n              line: this.line // unused\n          });\n      }\n      vmLoadCallback(input, meta) {\n          const inFile = this.inFile;\n          let putInMemory = false;\n          if (input !== null && meta) {\n              if (meta.typeString === \"B\" || meta.typeString === \"S\" || inFile.start !== undefined) { // only for binary files or when a load address is specified (feature)\n                  const start = inFile.start !== undefined ? inFile.start : Number(meta.start);\n                  let length = Number(meta.length); // we do not really need the length from metadata\n                  if (isNaN(length)) {\n                      length = input.length; // only valid after atob()\n                  }\n                  if (Utils.debug > 1) {\n                      Utils.console.debug(\"vmLoadCallback:\", inFile.name + \": putting data in memory\", start, \"-\", start + length);\n                  }\n                  if (meta.typeString === \"S\") {\n                      for (let i = 0; i < length; i += 1) {\n                          this.vmSetMem(start + i, input.charCodeAt(i)); // set snapshot data directly without memory mapping\n                      }\n                      const addr = this.screenPage << 14; // eslint-disable-line no-bitwise\n                      this.vmCopyToScreen(addr, addr);\n                  }\n                  else {\n                      for (let i = 0; i < length; i += 1) {\n                          this.poke((start + i) & 0xffff, input.charCodeAt(i)); // eslint-disable-line no-bitwise\n                      }\n                  }\n                  putInMemory = true;\n              }\n          }\n          this.closein();\n          return putInMemory;\n      }\n      load(name, start) {\n          const inFile = this.inFile;\n          name = this.vmAdaptFilename(name, \"LOAD\");\n          if (start !== undefined) {\n              start = this.vmRound2Complement(start, \"LOAD\");\n          }\n          this.closein();\n          inFile.open = true;\n          inFile.command = \"load\";\n          inFile.name = name;\n          inFile.start = start;\n          inFile.fnFileCallback = this.fnLoadHandler;\n          this.vmStop(\"fileLoad\", 90);\n      }\n      vmLocate(stream, pos, vpos) {\n          const win = this.windowDataList[stream];\n          win.pos = pos - 1;\n          win.vpos = vpos - 1;\n      }\n      locate(stream, pos, vpos) {\n          stream = this.vmInRangeRound(stream, 0, 7, \"LOCATE\");\n          pos = this.vmInRangeRound(pos, 1, 255, \"LOCATE\");\n          vpos = this.vmInRangeRound(vpos, 1, 255, \"LOCATE\");\n          this.vmDrawUndrawCursor(stream); // undraw\n          this.vmLocate(stream, pos, vpos);\n          this.vmDrawUndrawCursor(stream); // draw\n      }\n      log(n) {\n          this.vmAssertNumber(n, \"LOG\");\n          if (n <= 0) {\n              throw this.vmComposeError(Error(), 6, \"LOG \" + n);\n          }\n          return Math.log(n);\n      }\n      log10(n) {\n          this.vmAssertNumber(n, \"LOG10\");\n          if (n <= 0) {\n              throw this.vmComposeError(Error(), 6, \"LOG10 \" + n);\n          }\n          return Math.log10(n);\n      }\n      static fnLowerCase(match) {\n          return match.toLowerCase();\n      }\n      lower$(s) {\n          this.vmAssertString(s, \"LOWER$\");\n          s = s.replace(/[A-Z]/g, CpcVm.fnLowerCase); // replace only characters A-Z\n          return s;\n      }\n      mask(mask, first) {\n          if (mask === undefined && first === undefined) {\n              throw this.vmComposeError(Error(), 22, \"MASK\"); // Operand missing\n          }\n          if (mask !== undefined) {\n              mask = this.vmInRangeRound(mask, 0, 255, \"MASK\");\n              this.canvas.setMask(mask);\n          }\n          if (first !== undefined) {\n              first = this.vmInRangeRound(first, 0, 1, \"MASK\");\n              this.canvas.setMaskFirst(first);\n          }\n      }\n      max(...args) {\n          if (!args.length) {\n              throw this.vmComposeError(Error(), 22, \"MAX\"); // Operand missing\n          }\n          else if (args.length === 1) { // if just one argument, return it, even if it is a string\n              if (typeof args[0] !== \"number\" && !this.quiet) {\n                  Utils.console.warn(\"MAX: Not a number:\", args[0]);\n              }\n              return args[0];\n          }\n          for (let i = 0; i < args.length; i += 1) {\n              this.vmAssertNumber(args[i], \"MAX\");\n          }\n          return Math.max.apply(null, args);\n      }\n      memory(n) {\n          n = this.vmRound2Complement(n, \"MEMORY\");\n          if (n < this.progEnd || n > this.minCharHimem) {\n              throw this.vmComposeError(Error(), 7, \"MEMORY \" + n); // Memory full\n          }\n          this.himemValue = n;\n      }\n      merge(name) {\n          const inFile = this.inFile;\n          name = this.vmAdaptFilename(name, \"MERGE\");\n          this.closein();\n          inFile.open = true;\n          inFile.command = \"merge\";\n          inFile.name = name;\n          inFile.fnFileCallback = this.fnCloseinHandler;\n          this.vmStop(\"fileLoad\", 90);\n      }\n      mid$(s, start, len) {\n          this.vmAssertString(s, \"MID$\");\n          start = this.vmInRangeRound(start, 1, 255, \"MID$\");\n          if (len !== undefined) {\n              len = this.vmInRangeRound(len, 0, 255, \"MID$\");\n          }\n          return s.substr(start - 1, len); // or: s.substring(start - 1, len === undefined ? len : start - 1 + len);\n      }\n      mid$Assign(s, start, len, newString) {\n          this.vmAssertString(s, \"MID$\");\n          this.vmAssertString(newString, \"MID$\");\n          start = this.vmInRangeRound(start, 1, 255, \"MID$\") - 1;\n          len = (len !== undefined) ? this.vmInRangeRound(len, 0, 255, \"MID$\") : newString.length;\n          if (len > newString.length) {\n              len = newString.length;\n          }\n          if (len > s.length - start) {\n              len = s.length - start;\n          }\n          s = s.substring(0, start) + newString.substring(0, len) + s.substring(start + len);\n          return s;\n      }\n      min(...args) {\n          if (!args.length) {\n              throw this.vmComposeError(Error(), 22, \"MIN\"); // Operand missing\n          }\n          else if (args.length === 1) { // if just one argument, return it, even if it is a string\n              if (typeof args[0] !== \"number\" && !this.quiet) {\n                  Utils.console.warn(\"MIN: Not a number:\", args[0]);\n              }\n              return args[0];\n          }\n          for (let i = 0; i < args.length; i += 1) {\n              this.vmAssertNumber(args[i], \"MIN\");\n          }\n          return Math.min.apply(null, args);\n      }\n      // mod\n      // changing the mode without clearing the screen (called by rsx |MODE)\n      vmChangeMode(mode) {\n          this.modeValue = mode;\n          const winData = CpcVm.winData[this.modeValue];\n          for (let i = 0; i < CpcVm.streamCount - 2; i += 1) { // for window streams\n              const win = this.windowDataList[i];\n              Object.assign(win, winData);\n          }\n          this.canvas.changeMode(mode);\n      }\n      mode(mode) {\n          mode = this.vmInRangeRound(mode, 0, 3, \"MODE\");\n          this.modeValue = mode;\n          this.vmResetWindowData(); // do not reset pen and paper but limit them to the mode\n          this.outBuffer = \"\"; // clear console\n          this.canvas.setMode(mode); // does not clear canvas\n          this.canvas.clearFullWindow(); // always with paper 0 (SCR MODE CLEAR)\n      }\n      move(x, y, gPen, gColMode) {\n          x = this.vmInRangeRound(x, -32768, 32767, \"MOVE\");\n          y = this.vmInRangeRound(y, -32768, 32767, \"MOVE\");\n          this.vmDrawMovePlot(\"MOVE\", gPen, gColMode);\n          this.canvas.move(x, y);\n      }\n      mover(x, y, gPen, gColMode) {\n          x = this.vmInRangeRound(x, -32768, 32767, \"MOVER\") + this.canvas.getXpos();\n          y = this.vmInRangeRound(y, -32768, 32767, \"MOVER\") + this.canvas.getYpos();\n          this.vmDrawMovePlot(\"MOVER\", gPen, gColMode);\n          this.canvas.move(x, y);\n      }\n      \"new\"() {\n          this.progEnd = CpcVm.progStart + 3;\n          this.clear();\n          const lineParas = {\n              command: \"new\",\n              stream: 0, // unused\n              first: 0, // unused\n              last: 0, // unused\n              line: this.line // unused\n          };\n          this.vmStop(\"new\", 90, false, lineParas);\n      }\n      onBreakCont() {\n          this.breakGosubLine = -1;\n          this.breakResumeLine = 0;\n      }\n      onBreakGosub(line) {\n          this.breakGosubLine = this.vmLineInRange(line, \"ON BREAK GOSUB\");\n          this.breakResumeLine = 0;\n      }\n      onBreakStop() {\n          this.breakGosubLine = 0;\n          this.breakResumeLine = 0;\n      }\n      onErrorGoto(line) {\n          this.errorGotoLine = (line !== 0) ? this.vmLineInRange(line, \"ON ERROR GOTO\") : 0;\n          if (!line && this.errorResumeLine) { // line=0 but an error to resume?\n              throw this.vmComposeError(Error(), this.errorCode, \"ON ERROR GOTO without RESUME from \" + this.errorLine);\n          }\n      }\n      onGosub(retLabel, n, ...args) {\n          n = this.vmInRangeRound(n, 0, 255, \"ON GOSUB\");\n          let line;\n          if (!n || n > args.length) { // out of range? => continue with line after onGosub\n              if (Utils.debug > 1) {\n                  Utils.console.debug(\"onGosub: out of range: n=\" + n + \" in \" + this.line);\n              }\n              line = retLabel;\n          }\n          else {\n              line = this.vmLineInRange(args[n - 1], \"ON GOSUB\"); // n=1...\n              if (this.gosubStack.length >= this.maxGosubStackLength) { // limit stack size (not necessary in JS, but...)\n                  throw this.vmComposeError(Error(), 7, \"ON GOSUB \" + n); // Memory full\n              }\n              this.gosubStack.push(retLabel);\n          }\n          this.vmGoto(line, \"onGosub (n=\" + n + \", ret=\" + retLabel + \", line=\" + line + \")\");\n      }\n      onGoto(retLabel, n, ...args) {\n          n = this.vmInRangeRound(n, 0, 255, \"ON GOTO\");\n          let line;\n          if (!n || n > args.length) { // out of range? => continue with line after onGoto\n              if (Utils.debug > 1) {\n                  Utils.console.debug(\"onGoto: out of range: n=\" + n + \" in \" + this.line);\n              }\n              line = retLabel;\n          }\n          else {\n              line = this.vmLineInRange(args[n - 1], \"ON GOTO\");\n          }\n          this.vmGoto(line, \"onGoto (n=\" + n + \", ret=\" + retLabel + \", line=\" + line + \")\");\n      }\n      static fnChannel2ChannelIndex(channel) {\n          if (channel === 4) {\n              channel = 2;\n          }\n          else {\n              channel -= 1;\n          }\n          return channel;\n      }\n      onSqGosub(channel, line) {\n          channel = this.vmInRangeRound(channel, 1, 4, \"ON SQ GOSUB\");\n          if (channel === 3) {\n              throw this.vmComposeError(Error(), 5, \"ON SQ GOSUB \" + channel); // Improper argument\n          }\n          channel = CpcVm.fnChannel2ChannelIndex(channel);\n          const sqTimer = this.sqTimer[channel];\n          sqTimer.line = this.vmLineInRange(line, \"ON SQ GOSUB\");\n          sqTimer.active = true;\n          sqTimer.repeat = true; // means reloaded for sq\n      }\n      vmOpeninCallback(input) {\n          if (input !== null) {\n              const inFile = this.inFile, eolStr = input.indexOf(\"\\r\\n\") > 0 ? \"\\r\\n\" : \"\\n\"; // heuristic: if CRLF found, use it as split\n              if (input.endsWith(eolStr)) {\n                  input = input.substring(0, input.length - eolStr.length); // remove last eol marker (also for data files)\n              }\n              inFile.fileData = input.split(eolStr);\n          }\n          else {\n              this.closein();\n          }\n      }\n      openin(name) {\n          name = this.vmAdaptFilename(name, \"OPENIN\");\n          const inFile = this.inFile;\n          if (!inFile.open) {\n              if (name) {\n                  inFile.open = true;\n                  inFile.command = \"openin\";\n                  inFile.name = name;\n                  inFile.fnFileCallback = this.fnOpeninHandler;\n                  this.vmStop(\"fileLoad\", 90);\n              }\n          }\n          else {\n              throw this.vmComposeError(Error(), 27, \"OPENIN \" + inFile.name); // file already open\n          }\n      }\n      openout(name) {\n          const outFile = this.outFile;\n          if (outFile.open) {\n              throw this.vmComposeError(Error(), 27, \"OPENOUT \" + outFile.name); // file already open\n          }\n          name = this.vmAdaptFilename(name, \"OPENOUT\");\n          outFile.open = true;\n          outFile.command = \"openout\";\n          outFile.name = name;\n          outFile.fileData.length = 0; // no data yet\n          outFile.typeString = \"A\"; // ASCII\n      }\n      // or\n      origin(xOff, yOff, xLeft, xRight, yTop, yBottom) {\n          xOff = this.vmInRangeRound(xOff, -32768, 32767, \"ORIGIN\");\n          yOff = this.vmInRangeRound(yOff, -32768, 32767, \"ORIGIN\");\n          this.canvas.setOrigin(xOff, yOff);\n          if (xLeft !== undefined) {\n              xLeft = this.vmInRangeRound(xLeft, -32768, 32767, \"ORIGIN\");\n              xRight = this.vmInRangeRound(xRight, -32768, 32767, \"ORIGIN\");\n              yTop = this.vmInRangeRound(yTop, -32768, 32767, \"ORIGIN\");\n              yBottom = this.vmInRangeRound(yBottom, -32768, 32767, \"ORIGIN\");\n              this.canvas.setGWindow(xLeft, xRight, yTop, yBottom);\n          }\n      }\n      vmSetRamSelect(bank) {\n          // we support RAM select for banks 0,4... (so not for 1 to 3)\n          if (!bank) {\n              this.ramSelect = 0;\n          }\n          else if (bank >= 4) {\n              this.ramSelect = bank - 3; // bank 4 gets position 1\n          }\n      }\n      vmSetCrtcData(crtcReg, byte) {\n          const crtcData = this.crtcData;\n          crtcData[crtcReg] = byte;\n          if (crtcReg === 12 || crtcReg === 13) { // screen offset changed\n              const offset = (((crtcData[12] || 0) & 0x03) << 9) | ((crtcData[13] || 0) << 1); // eslint-disable-line no-bitwise\n              this.vmSetScreenOffset(offset);\n              if (crtcReg === 12) { // scren base?\n                  // do we want to set it here?\n                  // 0x30 => 0xc0\n                  this.vmSetScreenBase((byte << 2) & 0xc0); // eslint-disable-line no-bitwise\n              }\n          }\n      }\n      out(port, byte) {\n          port = this.vmRound2Complement(port, \"OUT\");\n          byte = this.vmInRangeRound(byte, 0, 255, \"OUT\");\n          const portHigh = port >> 8; // eslint-disable-line no-bitwise\n          if (portHigh === 0x7f) { // 7Fxx = RAM select\n              this.vmSetRamSelect(byte - 0xc0);\n          }\n          else if (portHigh === 0xbc) { // limited support for CRTC 12, 13\n              this.crtcReg = byte % 14;\n          }\n          else if (portHigh === 0xbd) {\n              this.vmSetCrtcData(this.crtcReg, byte);\n          }\n          else if (Utils.debug > 0) {\n              Utils.console.debug(\"OUT\", Number(port).toString(16), byte, \": unknown port\");\n          }\n      }\n      paper(stream, paper) {\n          stream = this.vmInRangeRound(stream, 0, 7, \"PAPER\");\n          paper = this.vmInRangeRound(paper, 0, 15, \"PAPER\");\n          const win = this.windowDataList[stream], modeData = CpcVm.modeData[this.modeValue];\n          win.paper = paper % modeData.pens; // limit to available pens\n      }\n      vmGetCharDataByte(addr) {\n          const dataPos = (addr - 1 - this.minCharHimem) % 8, char = this.minCustomChar + (addr - 1 - dataPos - this.minCharHimem) / 8, charData = this.canvas.getCharData(char);\n          return charData[dataPos];\n      }\n      vmSetCharDataByte(addr, byte) {\n          const dataPos = (addr - 1 - this.minCharHimem) % 8, char = this.minCustomChar + (addr - 1 - dataPos - this.minCharHimem) / 8, charData = this.canvas.getCharData(char), charDataCopy = charData.slice(); // we need a copy to not modify original data\n          charDataCopy[dataPos] = byte; // change one byte\n          this.canvas.setCustomChar(char, charDataCopy);\n      }\n      peek(addr) {\n          addr = this.vmRound2Complement(addr, \"PEEK\");\n          // check two higher bits of 16 bit address to get 16K page\n          const page = addr >> 14; // eslint-disable-line no-bitwise\n          let byte;\n          if (page === this.screenPage) { // screen memory page?\n              byte = this.canvas.getByte(addr); // get byte from screen memory\n              if (byte === null) { // byte not visible on screen?\n                  byte = this.mem[addr] || 0; // get it from our memory\n              }\n          }\n          else if (page === 1 && this.ramSelect) { // memory mapped RAM with page 1=0x4000..0x7fff?\n              addr = (this.ramSelect - 1) * 0x4000 + 0x10000 + addr;\n              byte = this.mem[addr] || 0;\n          }\n          else if (addr > this.minCharHimem && addr <= this.maxCharHimem) { // character map; TODO: can also be in memory mapped area\n              byte = this.vmGetCharDataByte(addr);\n          }\n          else {\n              byte = this.mem[addr] || 0;\n          }\n          return byte;\n      }\n      pen(stream, pen, transparent) {\n          stream = this.vmInRangeRound(stream, 0, 7, \"PEN\");\n          if (pen !== undefined) {\n              const win = this.windowDataList[stream], modeData = CpcVm.modeData[this.modeValue];\n              pen = this.vmInRangeRound(pen, 0, 15, \"PEN\");\n              win.pen = pen % modeData.pens; // limit to available pens\n          }\n          if (transparent !== undefined) {\n              transparent = this.vmInRangeRound(transparent, 0, 1, \"PEN\");\n              this.vmSetTransparentMode(stream, transparent);\n          }\n      }\n      pi() {\n          return Math.PI; // or less precise: 3.14159265\n      }\n      plot(x, y, gPen, gColMode) {\n          x = this.vmInRangeRound(x, -32768, 32767, \"PLOT\");\n          y = this.vmInRangeRound(y, -32768, 32767, \"PLOT\");\n          this.vmDrawMovePlot(\"PLOT\", gPen, gColMode);\n          this.canvas.plot(x, y);\n      }\n      plotr(x, y, gPen, gColMode) {\n          x = this.vmInRangeRound(x, -32768, 32767, \"PLOTR\") + this.canvas.getXpos();\n          y = this.vmInRangeRound(y, -32768, 32767, \"PLOTR\") + this.canvas.getYpos();\n          this.vmDrawMovePlot(\"PLOTR\", gPen, gColMode);\n          this.canvas.plot(x, y);\n      }\n      // put directly in memory without memory papping\n      vmSetMem(addr, byte) {\n          this.mem[addr] = byte;\n      }\n      poke(addr, byte) {\n          addr = this.vmRound2Complement(addr, \"POKE address\");\n          byte = this.vmInRangeRound(byte, 0, 255, \"POKE byte\");\n          // check two higher bits of 16 bit address to get 16K page\n          const page = addr >> 14; // eslint-disable-line no-bitwise\n          if (page === 1 && this.ramSelect) { // memory mapped RAM with page 1=0x4000..0x7fff?\n              addr = (this.ramSelect - 1) * 0x4000 + 0x10000 + addr;\n          }\n          else if (page === this.screenPage) { // screen memory page?\n              this.canvas.setByte(addr, byte); // write byte also to screen memory\n          }\n          else if (addr > this.minCharHimem && addr <= this.maxCharHimem) { // character map; TODO: can also be in memory mapped area\n              this.vmSetCharDataByte(addr, byte);\n          }\n          this.mem[addr] = byte;\n      }\n      pos(stream) {\n          stream = this.vmInRangeRound(stream, 0, 9, \"POS\");\n          let pos;\n          if (stream < 8) {\n              pos = this.vmGetAllowedPosOrVpos(stream, false) + 1; // get allowed pos\n          }\n          else if (stream === 8) { // printer position (starting with 1)\n              pos = 1; // TODO\n          }\n          else { // stream 9: number of characters written since last CR (\\r), \\n in CpcEmu, starting with one)\n              const win = this.windowDataList[stream];\n              pos = win.pos + 1;\n          }\n          return pos;\n      }\n      vmGetAllowedPosOrVpos(stream, vpos) {\n          const win = this.windowDataList[stream], left = win.left, right = win.right, top = win.top, bottom = win.bottom;\n          let x = win.pos, y = win.vpos;\n          if (x > (right - left)) {\n              y += 1;\n              x = 0;\n          }\n          if (x < 0) {\n              y -= 1;\n              x = right - left;\n          }\n          if (!vpos) {\n              return x;\n          }\n          if (y < 0) {\n              y = 0;\n          }\n          if (y > (bottom - top)) {\n              y = bottom - top;\n          }\n          return y;\n      }\n      vmMoveCursor2AllowedPos(stream) {\n          const win = this.windowDataList[stream], left = win.left, right = win.right, top = win.top, bottom = win.bottom;\n          let x = win.pos, y = win.vpos;\n          if (x > (right - left)) {\n              y += 1;\n              x = 0;\n              this.vmPrint2OutBuffer(\"\\n\");\n          }\n          if (x < 0) {\n              y -= 1;\n              x = right - left;\n          }\n          if (y < 0) {\n              y = 0;\n              if (stream < 8) {\n                  this.canvas.windowScrollDown(left, right, top, bottom, win.paper);\n              }\n          }\n          if (y > (bottom - top)) {\n              y = bottom - top;\n              if (stream < 8) {\n                  this.canvas.windowScrollUp(left, right, top, bottom, win.paper);\n              }\n          }\n          win.pos = x;\n          win.vpos = y;\n      }\n      vmPrintChars(stream, str) {\n          const win = this.windowDataList[stream];\n          if (!win.textEnabled) {\n              if (Utils.debug > 0) {\n                  Utils.console.debug(\"vmPrintChars: text output disabled:\", str);\n              }\n              return;\n          }\n          // put cursor in next line if string does not fit in line any more\n          this.vmMoveCursor2AllowedPos(stream);\n          if (win.pos && (win.pos + str.length > (win.right + 1 - win.left))) {\n              win.pos = 0;\n              win.vpos += 1; // \"\\r\\n\", newline if string does not fit in line\n          }\n          for (let i = 0; i < str.length; i += 1) {\n              const char = CpcVm.vmGetCpcCharCode(str.charCodeAt(i));\n              this.vmMoveCursor2AllowedPos(stream);\n              this.canvas.printChar(char, win.pos + win.left, win.vpos + win.top, win.pen, win.paper, win.transparent);\n              win.pos += 1;\n          }\n      }\n      vmControlSymbol(para) {\n          const paraList = [];\n          for (let i = 0; i < para.length; i += 1) {\n              paraList.push(para.charCodeAt(i));\n          }\n          while (paraList.length < 9) { // fill up with 0 (1xchar, 8xchardata)\n              paraList.push(0);\n          }\n          const char = paraList[0];\n          if (char >= this.minCustomChar) {\n              this.symbol.apply(this, paraList);\n          }\n          else if (Utils.debug > 0) {\n              Utils.console.debug(\"vmControlSymbol: define SYMBOL ignored:\", char);\n          }\n      }\n      vmControlWindow(para, stream) {\n          const paraList = [];\n          // args in para: left, right, top, bottom (all -1 !)\n          for (let i = 0; i < para.length; i += 1) {\n              let value = para.charCodeAt(i) + 1; // control ranges start with 0!\n              value %= 256;\n              if (!value) {\n                  value = 1; // avoid error\n              }\n              paraList.push(value);\n          }\n          this.window(stream, paraList[0], paraList[1], paraList[2], paraList[3]);\n      }\n      vmHandleControlCode(code, para, stream) {\n          const win = this.windowDataList[stream], out = \"\"; // no controls for text window\n          switch (code) {\n              case 0x00: // NUL, ignore\n                  break;\n              case 0x01: // SOH 0-255\n                  this.vmPrintChars(stream, para);\n                  break;\n              case 0x02: // STX\n                  win.cursorEnabled = false; // cursor disable (user)\n                  break;\n              case 0x03: // ETX\n                  win.cursorEnabled = true; // cursor enable (user)\n                  break;\n              case 0x04: // EOT 0-3 (on CPC: 0-2, 3 is ignored; really mod 4)\n                  this.mode(para.charCodeAt(0) & 0x03); // eslint-disable-line no-bitwise\n                  break;\n              case 0x05: // ENQ\n                  this.vmPrintGraphChars(para);\n                  break;\n              case 0x06: // ACK\n                  win.cursorEnabled = true;\n                  win.textEnabled = true;\n                  break;\n              case 0x07: // BEL\n                  this.sound(135, 90, 20, 12, 0, 0, 0);\n                  break;\n              case 0x08: // BS\n                  this.vmMoveCursor2AllowedPos(stream);\n                  win.pos -= 1;\n                  break;\n              case 0x09: // TAB\n                  this.vmMoveCursor2AllowedPos(stream);\n                  win.pos += 1;\n                  break;\n              case 0x0a: // LF\n                  this.vmMoveCursor2AllowedPos(stream);\n                  win.vpos += 1;\n                  break;\n              case 0x0b: // VT\n                  this.vmMoveCursor2AllowedPos(stream);\n                  win.vpos -= 1;\n                  break;\n              case 0x0c: // FF\n                  this.cls(stream);\n                  break;\n              case 0x0d: // CR\n                  this.vmMoveCursor2AllowedPos(stream);\n                  win.pos = 0;\n                  break;\n              case 0x0e: // SO\n                  this.paper(stream, para.charCodeAt(0) & 0x0f); // eslint-disable-line no-bitwise\n                  break;\n              case 0x0f: // SI\n                  this.pen(stream, para.charCodeAt(0) & 0x0f); // eslint-disable-line no-bitwise\n                  break;\n              case 0x10: // DLE\n                  this.vmMoveCursor2AllowedPos(stream);\n                  this.canvas.fillTextBox(win.left + win.pos, win.top + win.vpos, 1, 1, win.paper); // clear character under cursor\n                  break;\n              case 0x11: // DC1\n                  this.vmMoveCursor2AllowedPos(stream);\n                  this.canvas.fillTextBox(win.left, win.top + win.vpos, win.pos + 1, 1, win.paper); // clear line up to cursor\n                  break;\n              case 0x12: // DC2\n                  this.vmMoveCursor2AllowedPos(stream);\n                  this.canvas.fillTextBox(win.left + win.pos, win.top + win.vpos, win.right - win.left + 1 - win.pos, 1, win.paper); // clear line from cursor\n                  break;\n              case 0x13: // DC3\n                  this.vmMoveCursor2AllowedPos(stream);\n                  this.canvas.fillTextBox(win.left, win.top, win.right - win.left + 1, win.top - win.vpos, win.paper); // clear window up to cursor line -1\n                  this.canvas.fillTextBox(win.left, win.top + win.vpos, win.pos + 1, 1, win.paper); // clear line up to cursor (DC1)\n                  break;\n              case 0x14: // DC4\n                  this.vmMoveCursor2AllowedPos(stream);\n                  this.canvas.fillTextBox(win.left + win.pos, win.top + win.vpos, win.right - win.left + 1 - win.pos, 1, win.paper); // clear line from cursor (DC2)\n                  this.canvas.fillTextBox(win.left, win.top + win.vpos + 1, win.right - win.left + 1, win.bottom - win.top - win.vpos, win.paper); // clear window from cursor line +1\n                  break;\n              case 0x15: // NAK\n                  win.cursorEnabled = false;\n                  win.textEnabled = false;\n                  break;\n              case 0x16: // SYN\n                  // parameter: only bit 0 relevant (ROM: &14E3)\n                  this.vmSetTransparentMode(stream, para.charCodeAt(0) & 0x01); // eslint-disable-line no-bitwise\n                  break;\n              case 0x17: // ETB\n                  this.canvas.setGColMode(para.charCodeAt(0) % 4);\n                  break;\n              case 0x18: // CAN\n                  this.vmTxtInverse(stream);\n                  break;\n              case 0x19: // EM\n                  this.vmControlSymbol(para);\n                  break;\n              case 0x1a: // SUB\n                  this.vmControlWindow(para, stream);\n                  break;\n              case 0x1b: // ESC, ignored\n                  break;\n              case 0x1c: // FS\n                  this.ink(para.charCodeAt(0) & 0x0f, para.charCodeAt(1) & 0x1f, para.charCodeAt(2) & 0x1f); // eslint-disable-line no-bitwise\n                  break;\n              case 0x1d: // GS\n                  this.border(para.charCodeAt(0) & 0x1f, para.charCodeAt(1) & 0x1f); // eslint-disable-line no-bitwise\n                  break;\n              case 0x1e: // RS\n                  win.pos = 0;\n                  win.vpos = 0;\n                  break;\n              case 0x1f: // US\n                  this.vmLocate(stream, CpcVm.vmGetCharCodeAt(para, 0), CpcVm.vmGetCharCodeAt(para, 1));\n                  break;\n              default:\n                  Utils.console.warn(\"vmHandleControlCode: Unknown control code:\", code);\n                  break;\n          }\n          return out;\n      }\n      vmPrintCharsOrControls(stream, str) {\n          let buf = \"\", out = \"\", i = 0;\n          while (i < str.length) {\n              const code = CpcVm.vmGetCharCodeAt(str, i);\n              i += 1;\n              if (code <= 0x1f) { // control code?\n                  if (out !== \"\") {\n                      this.vmPrintChars(stream, out); // print chars collected so far\n                      out = \"\";\n                  }\n                  const paraCount = CpcVm.controlCodeParameterCount[code];\n                  if (i + paraCount <= str.length) {\n                      out += this.vmHandleControlCode(code, str.substring(i, i + paraCount), stream);\n                      i += paraCount;\n                  }\n                  else {\n                      buf = str.substring(i - 1); // not enough parameters, put code in buffer and wait for more\n                      i = str.length;\n                  }\n              }\n              else {\n                  out += String.fromCharCode(code);\n              }\n          }\n          if (out !== \"\") {\n              this.vmPrintChars(stream, out); // print chars collected so far\n          }\n          return buf;\n      }\n      vmPrintGraphChars(str) {\n          for (let i = 0; i < str.length; i += 1) {\n              const char = CpcVm.vmGetCpcCharCode(str.charCodeAt(i));\n              this.canvas.printGChar(char);\n          }\n      }\n      print(stream, ...args) {\n          stream = this.vmInRangeRound(stream, 0, 9, \"PRINT\");\n          const win = this.windowDataList[stream];\n          if (stream < 8) {\n              if (!win.tag) {\n                  this.vmDrawUndrawCursor(stream); // undraw\n              }\n          }\n          else if (stream === 9) {\n              if (!this.outFile.open) {\n                  throw this.vmComposeError(Error(), 31, \"PRINT #\" + stream); // File not open\n              }\n              this.outFile.stream = stream;\n          }\n          let buf = this.printControlBuf;\n          for (let i = 0; i < args.length; i += 1) {\n              const arg = args[i];\n              let str;\n              if (typeof arg === \"object\") { // delayed call for spc(), tab(), commaTab() with side effect (position)\n                  const specialArgs = arg.args;\n                  switch (arg.type) {\n                      case \"commaTab\":\n                          str = this.commaTab(stream);\n                          break;\n                      case \"spc\":\n                          str = this.spc(stream, specialArgs[0]);\n                          break;\n                      case \"tab\":\n                          str = this.tab(stream, specialArgs[0]);\n                          break;\n                      default:\n                          throw this.vmComposeError(Error(), 5, \"PRINT \" + arg.type); // Improper argument\n                  }\n              }\n              else if (typeof arg === \"number\") {\n                  str = ((arg >= 0) ? \" \" : \"\") + Utils.toPrecision9(arg) + \" \";\n              }\n              else { // e.g. string\n                  str = String(arg);\n              }\n              if (stream < 8) {\n                  if (win.tag) {\n                      this.vmPrintGraphChars(str);\n                  }\n                  else {\n                      if (buf.length) {\n                          str = buf + str;\n                      }\n                      buf = this.vmPrintCharsOrControls(stream, str);\n                  }\n                  this.vmPrint2OutBuffer(str); // console\n              }\n              else if (stream === 8) { // printer?\n                  this.vmPrint2OutBuffer(str); // put also in console\n              }\n              else { // stream === 9\n                  const lastCrPos = buf.lastIndexOf(\"\\r\");\n                  if (lastCrPos >= 0) {\n                      win.pos = str.length - lastCrPos; // number of characters written since last CR (\\r)\n                  }\n                  else {\n                      win.pos += str.length;\n                  }\n                  if (str === \"\\r\\n\") {\n                      win.pos = 0;\n                  }\n                  if (win.pos >= win.right) {\n                      str = \"\\r\\n\" + str; // e.g. after tab(256)\n                      win.pos = 0;\n                  }\n                  buf += str;\n              }\n          }\n          if (stream < 8) {\n              if (!win.tag) {\n                  this.vmDrawUndrawCursor(stream); // draw cursor\n                  this.printControlBuf = buf; // maybe some parameters missing\n              }\n          }\n          else if (stream === 9) {\n              this.outFile.fileData.push(buf);\n          }\n      }\n      rad() {\n          this.degFlag = false;\n      }\n      // https://en.wikipedia.org/wiki/Jenkins_hash_function\n      static vmHashCode(s) {\n          let hash = 0;\n          /* eslint-disable no-bitwise */\n          for (let i = 0; i < s.length; i += 1) {\n              hash += s.charCodeAt(i);\n              hash += hash << 10;\n              hash ^= hash >> 6;\n          }\n          hash += hash << 3;\n          hash ^= hash >> 11;\n          hash += hash << 15;\n          /* eslint-enable no-bitwise */\n          return hash;\n      }\n      vmRandomizeCallback() {\n          const inputParas = this.vmGetStopObject().paras, input = inputParas.input, value = this.vmVal(input); // convert to number (also binary, hex)\n          let inputOk = true;\n          if (Utils.debug > 0) {\n              Utils.console.debug(\"vmRandomizeCallback:\", input);\n          }\n          if (isNaN(value)) {\n              inputOk = false;\n              inputParas.input = \"\";\n              this.print(inputParas.stream, inputParas.message);\n          }\n          else {\n              this.vmSetInputValues([value]);\n          }\n          return inputOk;\n      }\n      randomize(n) {\n          const rndInit = 0x89656c07, // an arbitrary 32 bit number <> 0 (this one is used by the CPC)\n          stream = 0;\n          if (n === undefined) { // no argument? input...\n              const msg = \"Random number seed ? \";\n              this.print(stream, msg);\n              const inputParas = {\n                  command: \"randomize\",\n                  stream: stream,\n                  message: msg,\n                  fnInputCallback: this.fnRandomizeCallbackHandler,\n                  input: \"\",\n                  line: this.line // to repeat in case of break\n              };\n              this.vmStop(\"waitInput\", 45, false, inputParas);\n          }\n          else { // n can also be floating point, so compute a hash value of n\n              this.vmAssertNumber(n, \"RANDOMIZE\");\n              n = CpcVm.vmHashCode(String(n));\n              if (n === 0) {\n                  n = rndInit;\n              }\n              if (Utils.debug > 1) {\n                  Utils.console.debug(\"randomize:\", n);\n              }\n              this.random.init(n);\n          }\n      }\n      read(varType) {\n          this.vmAssertString(varType, \"READ\");\n          const type = this.vmDetermineVarType(varType);\n          let item;\n          if (this.dataIndex < this.dataList.length) {\n              const dataItem = this.dataList[this.dataIndex];\n              this.dataIndex += 1;\n              if (dataItem === undefined) { // empty arg?\n                  item = type === \"$\" ? \"\" : 0; // set arg depending on expected type\n              }\n              else if (type !== \"$\") { // not string expected? => convert to number (also binary, hex)\n                  // Note : Using a number variable to read a string would cause a syntax error on a real CPC. We cannot detect it since we get always strings.\n                  item = this.val(String(dataItem));\n              }\n              else {\n                  item = dataItem;\n              }\n              item = this.vmAssign(varType, item); // maybe rounding for type I\n          }\n          else {\n              throw this.vmComposeError(Error(), 4, \"READ\"); // DATA exhausted\n          }\n          return item;\n      }\n      release(channelMask) {\n          channelMask = this.vmInRangeRound(channelMask, 0, 7, \"RELEASE\");\n          this.soundClass.release(channelMask);\n      }\n      // rem\n      remain(timerNumber) {\n          timerNumber = this.vmInRangeRound(timerNumber, 0, 3, \"REMAIN\");\n          const timerEntry = this.timerList[timerNumber];\n          let remain = 0;\n          if (timerEntry.active) {\n              remain = timerEntry.nextTimeMs - Date.now();\n              remain /= CpcVm.frameTimeMs;\n              timerEntry.active = false; // switch off timer\n          }\n          return remain;\n      }\n      renum(newLine = 10, oldLine = 1, step = 10, keep = 65535) {\n          newLine = this.vmInRangeRound(newLine, 1, 65535, \"RENUM\");\n          oldLine = this.vmInRangeRound(oldLine, 1, 65535, \"RENUM\");\n          step = this.vmInRangeRound(step, 1, 65535, \"RENUM\");\n          keep = this.vmInRangeRound(keep, 1, 65535, \"RENUM\");\n          const lineRenumParas = {\n              command: \"renum\",\n              stream: 0, // unused\n              line: this.line, // unused\n              newLine: newLine,\n              oldLine: oldLine,\n              step: step,\n              keep: keep // keep lines\n          };\n          this.vmStop(\"renumLines\", 85, false, lineRenumParas);\n      }\n      restore(line) {\n          line = line === undefined ? 0 : this.vmLineInRange(line, \"RESTORE\");\n          const dataLineIndex = this.dataLineIndex;\n          if (line in dataLineIndex) {\n              this.dataIndex = dataLineIndex[line];\n          }\n          else {\n              if (Utils.debug > 0) {\n                  Utils.console.debug(\"restore: search for dataLine >\", line);\n              }\n              for (const dataLine in dataLineIndex) { // linear search a data line > line\n                  if (dataLineIndex.hasOwnProperty(dataLine)) {\n                      if (Number(dataLine) >= line) {\n                          dataLineIndex[line] = dataLineIndex[dataLine]; // set data index also for line\n                          break;\n                      }\n                  }\n              }\n              if (line in dataLineIndex) { // now found a data line?\n                  this.dataIndex = dataLineIndex[line];\n              }\n              else {\n                  if (Utils.debug > 0) {\n                      Utils.console.debug(\"restore\", line + \": No DATA found starting at line\");\n                  }\n                  this.dataIndex = this.dataList.length;\n              }\n          }\n      }\n      resume(line) {\n          if (this.errorGotoLine) {\n              const label = line === undefined ? this.errorResumeLine : this.vmLineInRange(line, \"RESUME\");\n              this.vmGoto(label, \"resume\");\n              this.errorResumeLine = 0;\n          }\n          else {\n              throw this.vmComposeError(Error(), 20, String(line)); // Unexpected RESUME\n          }\n      }\n      resumeNext() {\n          if (!this.errorGotoLine || !this.errorResumeLine) {\n              throw this.vmComposeError(Error(), 20, \"RESUME NEXT\"); // Unexpected RESUME\n          }\n          const resumeLineIndex = this.labelList.indexOf(this.errorResumeLine);\n          if (resumeLineIndex < 0) {\n              Utils.console.error(\"resumeNext: line not found: \" + this.errorResumeLine);\n              this.errorResumeLine = 0;\n              return;\n          }\n          const line = this.labelList[resumeLineIndex + 1]; // get next line\n          this.vmGoto(line, \"resumeNext\");\n          this.errorResumeLine = 0;\n      }\n      \"return\"() {\n          const line = this.gosubStack.pop();\n          if (line === undefined) {\n              throw this.vmComposeError(Error(), 3, \"\"); // Unexpected Return [in <line>]\n          }\n          else {\n              this.vmGoto(line, \"return\");\n          }\n          if (line === this.breakResumeLine) { // end of break handler?\n              this.breakResumeLine = 0; // can start another one\n          }\n          this.vmCheckTimerHandlers(); // if we are at end of a BASIC timer handler, delete handler flag\n          if (this.vmCheckSqTimerHandlers()) { // same for sq timers, timer reloaded?\n              this.fnCheckSqTimer(); // next one early\n          }\n      }\n      right$(s, len) {\n          this.vmAssertString(s, \"RIGHT$\");\n          len = this.vmInRangeRound(len, 0, 255, \"RIGHT$\");\n          return s.substring(s.length - len);\n      }\n      rnd(n) {\n          if (n !== undefined) {\n              this.vmAssertNumber(n, \"RND\");\n          }\n          let x;\n          if (n === undefined || n > 0) {\n              x = this.random.random();\n              this.lastRnd = x;\n          }\n          else if (n < 0) {\n              x = this.lastRnd || this.random.random();\n          }\n          else { // n === 0\n              x = this.lastRnd || this.random.random();\n          }\n          return x;\n      }\n      round(n, decimals) {\n          this.vmAssertNumber(n, \"ROUND\");\n          decimals = this.vmInRangeRound(decimals || 0, -39, 39, \"ROUND\");\n          const maxDecimals = 20 - Math.floor(Math.log10(n)); // limit for JS\n          if (decimals >= 0 && decimals > maxDecimals) {\n              decimals = maxDecimals;\n          }\n          // To avoid rounding errors: https://www.jacklmoore.com/notes/rounding-in-javascript\n          // Use Math.abs(n) and Math.sign(n) To round negative numbers to larger negative numbers\n          return Math.sign(n) * Number(Math.round(Number(Math.abs(n) + \"e\" + decimals)) + \"e\" + ((decimals >= 0) ? \"-\" + decimals : \"+\" + -decimals));\n      }\n      vmRunCallback(input, meta) {\n          const inFile = this.inFile, putInMemory = input !== null && meta && (meta.typeString === \"B\" || inFile.start !== undefined);\n          // TODO: we could put it in memory as we do it for LOAD\n          if (input !== null) {\n              const lineParas = {\n                  command: \"run\",\n                  stream: 0, // unused\n                  first: inFile.line,\n                  last: 0, // unused\n                  line: this.line\n              };\n              this.vmStop(\"run\", 95, false, lineParas);\n          }\n          this.closein();\n          return putInMemory;\n      }\n      run(numOrString) {\n          const inFile = this.inFile;\n          if (typeof numOrString === \"string\") { // filename?\n              const name = this.vmAdaptFilename(numOrString, \"RUN\");\n              this.closein();\n              inFile.open = true;\n              inFile.command = \"run\";\n              inFile.name = name;\n              inFile.start = undefined;\n              inFile.fnFileCallback = this.fnRunHandler;\n              this.vmStop(\"fileLoad\", 90);\n          }\n          else { // line number or no argument = undefined\n              if (numOrString !== undefined) {\n                  this.vmLineInRange(numOrString, \"RUN\");\n              }\n              const lineParas = {\n                  command: \"run\",\n                  stream: 0, // unused\n                  first: numOrString || 0,\n                  last: 0, // unused\n                  line: this.line\n              };\n              this.vmStop(\"run\", 95, false, lineParas);\n          }\n      }\n      save(name, type, start, length, entry) {\n          const outFile = this.outFile;\n          name = this.vmAdaptFilename(name, \"SAVE\");\n          if (!type) {\n              type = \"T\"; // default is tokenized BASIC\n          }\n          else {\n              type = String(type).toUpperCase();\n          }\n          const fileData = outFile.fileData;\n          fileData.length = 0;\n          if (type === \"B\") { // binary\n              start = this.vmRound2Complement(start, \"SAVE\");\n              length = this.vmRound2Complement(length, \"SAVE\");\n              if (entry !== undefined) {\n                  entry = this.vmRound2Complement(entry, \"SAVE\");\n              }\n              for (let i = 0; i < length; i += 1) {\n                  const address = (start + i) & 0xffff; // eslint-disable-line no-bitwise\n                  fileData[i] = String.fromCharCode(this.peek(address));\n              }\n          }\n          else if ((type === \"A\" || type === \"T\" || type === \"P\") && start === undefined) {\n              // ASCII or tokenized BASIC or protected BASIC, and no load address specified\n              start = 368; // BASIC start\n              // need file data from controller (text box)\n          }\n          else {\n              throw this.vmComposeError(Error(), 2, \"SAVE \" + type); // Syntax Error\n          }\n          outFile.open = true;\n          outFile.command = \"save\";\n          outFile.name = name;\n          outFile.typeString = type;\n          outFile.start = start;\n          outFile.length = length || 0;\n          outFile.entry = entry || 0;\n          outFile.fnFileCallback = this.fnCloseoutHandler; // we use closeout handler to reset out file handling\n          this.vmStop(\"fileSave\", 90); // must stop directly after save\n      }\n      sgn(n) {\n          this.vmAssertNumber(n, \"SGN\");\n          return Math.sign(n);\n      }\n      sin(n) {\n          this.vmAssertNumber(n, \"SIN\");\n          return Math.sin((this.degFlag) ? Utils.toRadians(n) : n);\n      }\n      sound(state, period, duration, volume, volEnv, toneEnv, noise) {\n          state = this.vmInRangeRound(state, 1, 255, \"SOUND\");\n          period = this.vmInRangeRound(period, 0, 4095, \"SOUND ,\");\n          const soundData = {\n              state: state,\n              period: period,\n              duration: (duration !== undefined) ? this.vmInRangeRound(duration, -32768, 32767, \"SOUND ,,\") : 20,\n              volume: (volume !== undefined) ? this.vmInRangeRound(volume, 0, 15, \"SOUND ,,,\") : 12,\n              volEnv: (volEnv !== undefined) ? this.vmInRangeRound(volEnv, 0, 15, \"SOUND ,,,,\") : 0,\n              toneEnv: (toneEnv !== undefined) ? this.vmInRangeRound(toneEnv, 0, 15, \"SOUND ,,,,,\") : 0,\n              noise: (noise !== undefined) ? this.vmInRangeRound(noise, 0, 31, \"SOUND ,,,,,,\") : 0\n          };\n          if (this.soundClass.testCanQueue(state)) {\n              this.soundClass.sound(soundData);\n          }\n          else {\n              this.soundData.push(soundData);\n              this.vmStop(\"waitSound\", 43);\n              for (let i = 0; i < 3; i += 1) {\n                  if (state & (1 << i)) { // eslint-disable-line no-bitwise\n                      const sqTimer = this.sqTimer[i];\n                      sqTimer.active = false; // set onSq timer to inactive\n                  }\n              }\n          }\n      }\n      space$(n) {\n          n = this.vmInRangeRound(n, 0, 255, \"SPACE$\");\n          return \" \".repeat(n);\n      }\n      spc(stream, n) {\n          stream = this.vmInRangeRound(stream, 0, 9, \"SPC\");\n          n = this.vmInRangeRound(n, -32768, 32767, \"SPC\");\n          let str = \"\";\n          if (n >= 0) {\n              const win = this.windowDataList[stream], width = win.right - win.left + 1;\n              if (width) {\n                  n %= width;\n              }\n              str = \" \".repeat(n);\n          }\n          else if (!this.quiet) {\n              Utils.console.log(\"SPC: negative number ignored:\", n);\n          }\n          return str;\n      }\n      speedInk(time1, time2) {\n          time1 = this.vmInRangeRound(time1, 1, 255, \"SPEED INK\");\n          time2 = this.vmInRangeRound(time2, 1, 255, \"SPEED INK\");\n          this.canvas.setSpeedInk(time1, time2);\n      }\n      speedKey(delay, repeat) {\n          delay = this.vmInRangeRound(delay, 1, 255, \"SPEED KEY\");\n          repeat = this.vmInRangeRound(repeat, 1, 255, \"SPEED KEY\");\n          this.vmNotImplemented(\"SPEED KEY \" + delay + \" \" + repeat);\n      }\n      speedWrite(n) {\n          n = this.vmInRangeRound(n, 0, 1, \"SPEED WRITE\");\n          this.vmNotImplemented(\"SPEED WRITE \" + n);\n      }\n      sq(channel) {\n          channel = this.vmInRangeRound(channel, 1, 4, \"SQ\");\n          if (channel === 3) {\n              throw this.vmComposeError(Error(), 5, \"SQ \" + channel); // Improper argument\n          }\n          channel = CpcVm.fnChannel2ChannelIndex(channel);\n          const sq = this.soundClass.sq(channel), sqTimer = this.sqTimer[channel];\n          // no space in queue and handler active?\n          if (!(sq & 0x07) && sqTimer.active) { // eslint-disable-line no-bitwise\n              sqTimer.active = false; // set onSq timer to inactive\n          }\n          return sq;\n      }\n      sqr(n) {\n          this.vmAssertNumber(n, \"SQR\");\n          if (n < 0) {\n              throw this.vmComposeError(Error(), 5, \"SQR \" + n); // Improper argument\n          }\n          return Math.sqrt(n);\n      }\n      // step\n      stop(label) {\n          this.vmGoto(label, \"stop\");\n          this.vmStop(\"stop\", 60);\n      }\n      str$(n) {\n          this.vmAssertNumber(n, \"STR$\");\n          return ((n >= 0) ? \" \" : \"\") + String(n);\n      }\n      string$(len, chr) {\n          len = this.vmInRangeRound(len, 0, 255, \"STRING$\");\n          if (typeof chr === \"number\") {\n              chr = this.vmInRangeRound(chr, 0, 255, \"STRING$\");\n              chr = String.fromCharCode(chr); // chr$\n          }\n          else { // expect string\n              this.vmAssertString(chr, \"STRING$\");\n              chr = chr.charAt(0); // only one char\n          }\n          return chr.repeat(len);\n      }\n      // swap (window swap)\n      symbol(char, ...args) {\n          char = this.vmInRangeRound(char, this.minCustomChar, 255, \"SYMBOL\");\n          const charData = [];\n          for (let i = 0; i < args.length; i += 1) { // get available args\n              const bitMask = this.vmInRangeRound(args[i], 0, 255, \"SYMBOL\");\n              charData.push(bitMask);\n          }\n          // Note: If there are less than 8 rows, set missing rows to 0 (needed for read char)\n          while (charData.length < 8) { // fill up with 0 (1xchar, 8xchardata)\n              charData.push(0);\n          }\n          this.canvas.setCustomChar(char, charData);\n      }\n      symbolAfter(char) {\n          char = this.vmInRangeRound(char, 0, 256, \"SYMBOL AFTER\");\n          if (this.minCustomChar < 256) { // symbol after <256 set?\n              if (this.minCharHimem !== this.himemValue) { // himem changed?\n                  throw this.vmComposeError(Error(), 5, \"SYMBOL AFTER \" + char); // Improper argument\n              }\n          }\n          else {\n              this.maxCharHimem = this.himemValue; // no characters defined => use current himem\n          }\n          let minCharHimem = this.maxCharHimem - (256 - char) * 8;\n          if (minCharHimem < this.progEnd) {\n              throw this.vmComposeError(Error(), 7, \"SYMBOL AFTER \" + minCharHimem); // Memory full\n          }\n          this.himemValue = minCharHimem;\n          this.canvas.resetCustomChars();\n          if (char === 256) { // maybe move up again\n              minCharHimem = CpcVm.maxHimem;\n              this.maxCharHimem = minCharHimem;\n          }\n          // TODO: Copy char data to screen memory, if screen starts at 0x4000 and chardata is in that range (and ram 0 is selected)\n          this.minCustomChar = char;\n          this.minCharHimem = minCharHimem;\n      }\n      tab(stream, n) {\n          stream = this.vmInRangeRound(stream, 0, 9, \"TAB\");\n          n = this.vmInRangeRound(n, -32768, 32767, \"TAB\");\n          let str = \"\";\n          if (n > 0) {\n              n -= 1;\n              const win = this.windowDataList[stream], width = win.right - win.left + 1;\n              if (width) {\n                  n %= width;\n              }\n              let count = n - win.pos;\n              if (count < 0) { // does it fit until tab position?\n                  win.pos = win.right + 1;\n                  this.vmMoveCursor2AllowedPos(stream);\n                  count = n; // set tab in next line\n              }\n              str = \" \".repeat(count);\n          }\n          else if (!this.quiet) {\n              Utils.console.log(\"TAB: no tab for value\", n);\n          }\n          return str;\n      }\n      tag(stream) {\n          stream = this.vmInRangeRound(stream, 0, 7, \"TAG\");\n          const win = this.windowDataList[stream];\n          win.tag = true;\n      }\n      tagoff(stream) {\n          stream = this.vmInRangeRound(stream, 0, 7, \"TAGOFF\");\n          const win = this.windowDataList[stream];\n          win.tag = false;\n      }\n      tan(n) {\n          this.vmAssertNumber(n, \"TAN\");\n          return Math.tan((this.degFlag) ? Utils.toRadians(n) : n);\n      }\n      test(x, y) {\n          x = this.vmInRangeRound(x, -32768, 32767, \"TEST\");\n          y = this.vmInRangeRound(y, -32768, 32767, \"TEST\");\n          return this.canvas.test(x, y);\n      }\n      testr(x, y) {\n          x = this.vmInRangeRound(x, -32768, 32767, \"TESTR\") + this.canvas.getXpos();\n          y = this.vmInRangeRound(y, -32768, 32767, \"TESTR\") + this.canvas.getYpos();\n          return this.canvas.test(x, y);\n      }\n      time() {\n          return ((Date.now() - this.startTime) * 300 / 1000) | 0; // eslint-disable-line no-bitwise\n      }\n      troff() {\n          this.tronFlag1 = false;\n      }\n      tron() {\n          this.tronFlag1 = true;\n      }\n      unt(n) {\n          n = this.vmInRangeRound(n, -32768, 65535, \"UNT\");\n          if (n > 32767) { // two's complement\n              n -= 65536;\n          }\n          return n;\n      }\n      static fnUpperCase(match) {\n          return match.toUpperCase();\n      }\n      upper$(s) {\n          this.vmAssertString(s, \"UPPER$\");\n          return s.replace(/[a-z]/g, CpcVm.fnUpperCase); // replace only characters a-z\n      }\n      using(format, ...args) {\n          const reFormat = /(_|!|&|\\\\ *\\\\|(?:\\*\\*|\\$\\$|\\*\\*\\$)?\\+?(?:#|,)+\\.?#*(?:\\^\\^\\^\\^)?[+-]?)/g, formatList = [];\n          this.vmAssertString(format, \"USING\");\n          // We simulate format.split(reFormat) here since it does not work with IE8\n          let index = 0, match;\n          while ((match = reFormat.exec(format)) !== null) {\n              let nonFormChars = format.substring(index, match.index); // non-format characters at the beginning\n              if (match[0] === \"_\") { // underscore \"_\" is escape character\n                  nonFormChars += format.charAt(match.index + 1) || \"_\"; // add escaped character\n              }\n              if (formatList.length % 2) { // odd?\n                  formatList[formatList.length - 1] += nonFormChars;\n              }\n              else {\n                  formatList.push(nonFormChars);\n              }\n              if (match[0] === \"_\") { // underscore \"_\" is escape character\n                  reFormat.lastIndex += 1;\n                  index = reFormat.lastIndex;\n              }\n              else {\n                  formatList.push(match[0]);\n                  index = match.index + match[0].length;\n              }\n          }\n          if (index < format.length) { // non-format characters at the end\n              const nonFormCharsEnd = format.substring(index);\n              if (formatList.length % 2) { // odd?\n                  formatList[formatList.length - 1] += nonFormCharsEnd;\n              }\n              else {\n                  formatList.push(nonFormCharsEnd);\n              }\n          }\n          if (formatList.length < 2) {\n              if (!this.quiet) {\n                  Utils.console.warn(\"USING: empty or invalid format:\", format);\n              }\n              throw this.vmComposeError(Error(), 5, \"USING format \" + format); // Improper argument\n          }\n          let formatIndex = 0, s = \"\";\n          for (let i = 0; i < args.length; i += 1) { // start with 1\n              formatIndex %= formatList.length;\n              if (formatIndex === 0) {\n                  s += formatList[formatIndex]; // non-format characters at the beginning of the format string\n                  formatIndex += 1;\n              }\n              if (formatIndex < formatList.length) {\n                  const arg = args[i];\n                  s += this.vmUsingFormat(formatList[formatIndex], arg); // format characters\n                  formatIndex += 1;\n              }\n              if (formatIndex < formatList.length) {\n                  s += formatList[formatIndex]; // following non-format characters\n                  formatIndex += 1;\n              }\n          }\n          return s;\n      }\n      vmVal(s) {\n          let num = 0;\n          s = s.trim().toLowerCase();\n          if (s[0] === \"&\") {\n              if (s[1] === \"x\") { // binary &x\n                  num = parseInt(s.slice(2), 2);\n              }\n              else {\n                  if (s[1] === \"h\") { // hex &h\n                      num = parseInt(s.slice(2), 16);\n                  }\n                  else { // hex &\n                      num = parseInt(s.slice(1), 16);\n                  }\n                  if (num > 32767) { // two's complement\n                      num -= 65536;\n                  }\n              }\n              if (isNaN(num)) {\n                  throw this.vmComposeError(Error(), 13, \"VAL \" + s); // Type mismatch\n              }\n          }\n          else if (s !== \"\") { // not empty string?\n              num = parseFloat(s);\n              if (isNaN(num)) {\n                  if (s[0] === \"-\" || s[0] === \".\") { // this characters must follow a valid number\n                      throw this.vmComposeError(Error(), 13, \"VAL \" + s); // Type mismatch\n                  }\n              }\n          }\n          return num;\n      }\n      val(s) {\n          this.vmAssertString(s, \"VAL\");\n          s = s.replace(/ /g, \"\"); // remove spaces\n          let num = this.vmVal(s);\n          if (isNaN(num)) {\n              num = 0;\n          }\n          return num;\n      }\n      vpos(stream) {\n          stream = this.vmInRangeRound(stream, 0, 7, \"VPOS\");\n          return this.vmGetAllowedPosOrVpos(stream, true) + 1;\n      }\n      wait(port, mask, inv) {\n          port = this.vmRound2Complement(port, \"WAIT\");\n          mask = this.vmInRangeRound(mask, 0, 255, \"WAIT\");\n          if (inv !== undefined) {\n              /* inv = */ this.vmInRangeRound(inv, 0, 255, \"WAIT\");\n          }\n          if ((port & 0xff00) === 0xf500) { // eslint-disable-line no-bitwise\n              if (mask === 1) {\n                  this.frame();\n              }\n          }\n      }\n      // wend\n      // while\n      width(width) {\n          width = this.vmInRangeRound(width, 1, 255, \"WIDTH\");\n          const win = this.windowDataList[8];\n          win.right = win.left + width;\n      }\n      static forceInRange(num, min, max) {\n          if (num < min) {\n              num = min;\n          }\n          else if (num > max) {\n              num = max;\n          }\n          return num;\n      }\n      window(stream, left, right, top, bottom) {\n          stream = this.vmInRangeRound(stream, 0, 7, \"WINDOW\");\n          left = this.vmInRangeRound(left, 1, 255, \"WINDOW\");\n          right = this.vmInRangeRound(right, 1, 255, \"WINDOW\");\n          top = this.vmInRangeRound(top, 1, 255, \"WINDOW\");\n          bottom = this.vmInRangeRound(bottom, 1, 255, \"WINDOW\");\n          const win = this.windowDataList[stream], winData = CpcVm.winData[this.modeValue];\n          // make left and top the smaller; make sure the window fits on the screen\n          win.left = CpcVm.forceInRange(Math.min(left, right) - 1, winData.left, winData.right);\n          win.right = CpcVm.forceInRange(Math.max(left, right) - 1, winData.left, winData.right);\n          win.top = CpcVm.forceInRange(Math.min(top, bottom) - 1, winData.top, winData.bottom);\n          win.bottom = CpcVm.forceInRange(Math.max(top, bottom) - 1, winData.top, winData.bottom);\n          win.pos = 0;\n          win.vpos = 0;\n      }\n      windowSwap(stream1, stream2) {\n          stream1 = this.vmInRangeRound(stream1, 0, 7, \"WINDOW SWAP\");\n          stream2 = this.vmInRangeRound(stream2 || 0, 0, 7, \"WINDOW SWAP\");\n          const temp = this.windowDataList[stream1];\n          this.windowDataList[stream1] = this.windowDataList[stream2];\n          this.windowDataList[stream2] = temp;\n      }\n      write(stream, ...args) {\n          stream = this.vmInRangeRound(stream, 0, 9, \"WRITE\");\n          const writeArgs = [];\n          let str;\n          for (let i = 0; i < args.length; i += 1) {\n              const arg = args[i];\n              if (typeof arg === \"number\") {\n                  str = Utils.toPrecision9(arg);\n              }\n              else {\n                  str = '\"' + String(arg) + '\"';\n              }\n              writeArgs.push(str);\n          }\n          str = writeArgs.join(\",\");\n          if (stream < 8) {\n              const win = this.windowDataList[stream];\n              if (win.tag) {\n                  this.vmPrintGraphChars(str + \"\\r\\n\");\n              }\n              else {\n                  this.vmDrawUndrawCursor(stream); // undraw\n                  this.vmPrintCharsOrControls(stream, str);\n                  this.vmPrintCharsOrControls(stream, \"\\r\\n\");\n                  this.vmDrawUndrawCursor(stream); // draw\n              }\n              this.vmPrint2OutBuffer(str + \"\\n\"); // console\n          }\n          else if (stream === 8) { // printer?\n              this.vmPrint2OutBuffer(str + \"\\n\"); // console\n          }\n          else if (stream === 9) {\n              this.outFile.stream = stream;\n              if (!this.outFile.open) {\n                  throw this.vmComposeError(Error(), 31, \"WRITE #\" + stream); // File not open\n              }\n              this.outFile.fileData.push(str + \"\\r\\n\"); // real CPC use CRLF\n              // currently we print data also to console...\n          }\n      }\n      // xor\n      xpos() {\n          return this.canvas.getXpos();\n      }\n      ypos() {\n          return this.canvas.getYpos();\n      }\n      zone(n) {\n          this.zoneValue = this.vmInRangeRound(n, 1, 255, \"ZONE\");\n      }\n      // access some private stuff for testing\n      vmTestGetTimerList() {\n          return this.timerList;\n      }\n      vmTestGetWindowDataList() {\n          return this.windowDataList;\n      }\n      /* eslint-disable no-invalid-this */\n      vmInternal = {\n          getTimerList: this.vmTestGetTimerList,\n          getWindowDataList: this.vmTestGetWindowDataList,\n          commaTab: this.commaTab,\n          spc: this.spc,\n          tab: this.tab\n      };\n  }\n\n  // ===== dist/esm/Diff.js =====\n  // Diff.ts - Diff strings\n  // (c) Slava Kim\n  // https://github.com/Slava/diff.js\n  //\n\n  class Diff {\n      // Refer to http://www.xmailserver.org/diff2.pdf\n      static composeError(error, message, value, pos) {\n          return Utils.composeError(\"Diff\", error, message, value, pos, undefined, 0);\n      }\n      static inRange(x, l, r) {\n          return (l <= x && x <= r) || (r <= x && x <= l);\n      }\n      static fnEquals(a, b) {\n          return a === b;\n      }\n      // Accepts custom comparator\n      static customIndexOf(arr, item, start, fnEquals) {\n          for (let i2 = start; i2 < arr.length; i2 += 1) {\n              if (fnEquals(item, arr[i2])) {\n                  return i2;\n              }\n          }\n          return -1;\n      }\n      /* can we use it here? need to define aA, aB, lcsAtoms, findMidSnake():\n      private static lcs(startA: number, endA: number, startB: number, endB: number) {\n          const N = endA - startA + 1,\n              M = endB - startB + 1;\n\n          if (N > 0 && M > 0) {\n              const middleSnake = findMidSnake(startA, endA, startB, endB),\n                  // A[x;u] == B[y,v] and is part of LCS\n                  x = middleSnake[0][0],\n                  y = middleSnake[0][1],\n                  u = middleSnake[1][0],\n                  v = middleSnake[1][1],\n                  D = middleSnake[2];\n\n              if (D > 1) {\n                  Diff.lcs(startA, x - 1, startB, y - 1);\n                  if (x <= u) {\n                      [].push.apply(lcsAtoms, aA.slice(x, u + 1));\n                  }\n                  lcs(u + 1, endA, v + 1, endB);\n              } else if (M > N) {\n                  [].push.apply(lcsAtoms, aA.slice(startA, endA + 1));\n              } else {\n                  [].push.apply(lcsAtoms, aB.slice(startB, endB + 1));\n              }\n          }\n      }\n      */\n      // Longest Common Subsequence\n      // @param A - sequence of atoms - Array\n      // @param B - sequence of atoms - Array\n      // @param equals - optional comparator of atoms - returns true or false,\n      //                 if not specified, triple equals operator is used\n      // @returns Array - sequence of atoms, one of LCSs, edit script from A to B\n      static fnLCS(aA, aB, equals) {\n          // Helpers\n          const // Takes X-component as argument, diagonal as context, returns array-pair of form x, y\n          toPoint = function (x) {\n              return [\n                  x,\n                  x - this // eslint-disable-line no-invalid-this\n              ]; // XXX context is not the best way to pass diagonal\n          }, \n          // NOTE: all intervals from now on are both sides inclusive\n          // Get the points in Edit Graph, one of the LCS paths goes through.\n          // The points are located on the same diagonal and represent the middle\n          // snake ([D/2] out of D+1) in the optimal edit path in edit graph.\n          // @param startA, endA - substring of A we are working on\n          // @param startB, endB - substring of B we are working on\n          // @returns Array - [\n          //                   [x, y], - beginning of the middle snake\n          //                   [u, v], - end of the middle snake\n          //                    D,     - optimal edit distance\n          //                    LCS ]  - length of LCS\n          findMidSnake = function (startA, endA, startB, endB) {\n              const iN = endA - startA + 1, iM = endB - startB + 1, max = iN + iM, delta = iN - iM, hhalfMaxCeil = (max + 1) / 2 | 0, // eslint-disable-line no-bitwise\n              // Maps -Max .. 0 .. +Max, diagonal index to endpoints for furthest reaching D-path on current iteration.\n              oV = {}, \n              // Same but for reversed paths.\n              oU = {};\n              let overlap, iD;\n              // Special case for the base case, D = 0, k = 0, x = y = 0\n              oV[1] = 0;\n              // Special case for the base case reversed, D = 0, k = 0, x = N, y = M\n              oU[delta - 1] = iN;\n              // Iterate over each possible length of edit script\n              for (iD = 0; iD <= hhalfMaxCeil; iD += 1) {\n                  // Iterate over each diagonal\n                  for (let k = -iD; k <= iD && !overlap; k += 2) {\n                      let x;\n                      // Positions in sequences A and B of furthest going D-path on diagonal k.\n                      // Choose from each diagonal we extend\n                      if (k === -iD || (k !== iD && oV[k - 1] < oV[k + 1])) {\n                          // Extending path one point down, that's why x doesn't change, y\n                          // increases implicitly\n                          x = oV[k + 1];\n                      }\n                      else {\n                          // Extending path one point to the right, x increases\n                          x = oV[k - 1] + 1;\n                      }\n                      // We can calculate the y out of x and diagonal index.\n                      let y = x - k;\n                      if (isNaN(y) || x > iN || y > iM) {\n                          continue;\n                      }\n                      const xx = x;\n                      // Try to extend the D-path with diagonal paths. Possible only if atoms\n                      // A_x match B_y\n                      while (x < iN && y < iM // if there are atoms to compare\n                          && equals(aA[startA + x], aB[startB + y])) {\n                          x += 1;\n                          y += 1;\n                      }\n                      // We can safely update diagonal k, since on every iteration we consider\n                      // only even or only odd diagonals and the result of one depends only on\n                      // diagonals of different iteration.\n                      oV[k] = x;\n                      // Check feasibility, Delta is checked for being odd.\n                      if ((delta & 1) === 1 && Diff.inRange(k, delta - (iD - 1), delta + (iD - 1))) { // eslint-disable-line no-bitwise\n                          // Forward D-path can overlap with reversed D-1-path\n                          if (oV[k] >= oU[k]) {\n                              // Found an overlap, the middle snake, convert X-components to dots\n                              overlap = [\n                                  xx,\n                                  x\n                              ].map(toPoint, k); // XXX ES5\n                          }\n                      }\n                  }\n                  let SES;\n                  if (overlap) {\n                      SES = iD * 2 - 1;\n                  }\n                  // Iterate over each diagonal for reversed case\n                  for (let k = -iD; k <= iD && !overlap; k += 2) {\n                      // The real diagonal we are looking for is k + Delta\n                      const K = k + delta;\n                      let x;\n                      if (k === iD || (k !== -iD && oU[K - 1] < oU[K + 1])) {\n                          x = oU[K - 1];\n                      }\n                      else {\n                          x = oU[K + 1] - 1;\n                      }\n                      let y = x - K;\n                      if (isNaN(y) || x < 0 || y < 0) {\n                          continue;\n                      }\n                      const xx = x;\n                      while (x > 0 && y > 0 && equals(aA[startA + x - 1], aB[startB + y - 1])) {\n                          x -= 1;\n                          y -= 1;\n                      }\n                      oU[K] = x;\n                      if (delta % 2 === 0 && Diff.inRange(K, -iD, iD)) {\n                          if (oU[K] <= oV[K]) {\n                              overlap = [\n                                  x,\n                                  xx\n                              ].map(toPoint, K); // XXX ES5\n                          }\n                      }\n                  }\n                  if (overlap) {\n                      SES = SES || iD * 2;\n                      // Remember we had offset of each sequence?\n                      for (let i = 0; i < 2; i += 1) {\n                          for (let j = 0; j < 2; j += 1) {\n                              overlap[i][j] += [\n                                  startA,\n                                  startB\n                              ][j] - i;\n                          }\n                      }\n                      return overlap.concat([\n                          SES,\n                          (max - SES) / 2\n                      ]);\n                  }\n              }\n              throw Diff.composeError(Error(), \"Programming error in findMidSnake\", \"\", 0); // should not occur\n          }, lcsAtoms = [], lcs = function (startA, endA, startB, endB) {\n              const N = endA - startA + 1, M = endB - startB + 1;\n              if (N > 0 && M > 0) {\n                  const middleSnake = findMidSnake(startA, endA, startB, endB), \n                  // A[x;u] == B[y,v] and is part of LCS\n                  x = middleSnake[0][0], y = middleSnake[0][1], u = middleSnake[1][0], v = middleSnake[1][1], D = middleSnake[2];\n                  if (D > 1) {\n                      lcs(startA, x - 1, startB, y - 1);\n                      if (x <= u) {\n                          [].push.apply(lcsAtoms, aA.slice(x, u + 1));\n                      }\n                      lcs(u + 1, endA, v + 1, endB);\n                  }\n                  else if (M > N) {\n                      [].push.apply(lcsAtoms, aA.slice(startA, endA + 1));\n                  }\n                  else {\n                      [].push.apply(lcsAtoms, aB.slice(startB, endB + 1));\n                  }\n              }\n          };\n          lcs(0, aA.length - 1, 0, aB.length - 1);\n          return lcsAtoms;\n      }\n      // Diff sequence\n      // @param A - sequence of atoms - Array\n      // @param B - sequence of atoms - Array\n      // [@param equals - optional comparator of atoms - returns true or false,\n      //                 if not specified, triple equals operator is used]\n      // @returns Array - sequence of objects in a form of:\n      //   - operation: one of \"none\", \"add\", \"delete\"\n      //   - atom: the atom found in either A or B\n      // Applying operations from diff sequence you should be able to transform A to B\n      static diff(aA, aB) {\n          const diff = [], fnEquals = Diff.fnEquals;\n          let i = 0, j = 0, iN = aA.length, iM = aB.length, iK = 0;\n          while (i < iN && j < iM && fnEquals(aA[i], aB[j])) {\n              i += 1;\n              j += 1;\n          }\n          while (i < iN && j < iM && fnEquals(aA[iN - 1], aB[iM - 1])) {\n              iN -= 1;\n              iM -= 1;\n              iK += 1;\n          }\n          [].push.apply(diff, aA.slice(0, i).map(function (atom2) {\n              return {\n                  operation: \"none\",\n                  atom: atom2\n              };\n          }));\n          const lcs = Diff.fnLCS(aA.slice(i, iN), aB.slice(j, iM), fnEquals);\n          for (let k = 0; k < lcs.length; k += 1) {\n              const atom = lcs[k], ni = Diff.customIndexOf(aA, atom, i, fnEquals), nj = Diff.customIndexOf(aB, atom, j, fnEquals);\n              // XXX ES5 map\n              // Delete unmatched atoms from A\n              [].push.apply(diff, aA.slice(i, ni).map(function (atom2) {\n                  return {\n                      operation: \"delete\",\n                      atom: atom2\n                  };\n              }));\n              // Add unmatched atoms from B\n              [].push.apply(diff, aB.slice(j, nj).map(function (atom2) {\n                  return {\n                      operation: \"add\",\n                      atom: atom2\n                  };\n              }));\n              // Add the atom found in both sequences\n              diff.push({\n                  operation: \"none\",\n                  atom: atom\n              });\n              i = ni + 1;\n              j = nj + 1;\n          }\n          // Don't forget about the rest\n          [].push.apply(diff, aA.slice(i, iN).map(function (atom2) {\n              return {\n                  operation: \"delete\",\n                  atom: atom2\n              };\n          }));\n          [].push.apply(diff, aB.slice(j, iM).map(function (atom2) {\n              return {\n                  operation: \"add\",\n                  atom: atom2\n              };\n          }));\n          [].push.apply(diff, aA.slice(iN, iN + iK).map(function (atom2) {\n              return {\n                  operation: \"none\",\n                  atom: atom2\n              };\n          }));\n          return diff;\n      }\n      static testDiff(text1, text2) {\n          const textParts1 = text1.split(\"\\n\"), textParts2 = text2.split(\"\\n\");\n          let diff = Diff.diff(textParts1, textParts2).map(function (o) {\n              let result = \"\";\n              if (o.operation === \"add\") {\n                  result = \"+ \" + o.atom;\n              }\n              else if (o.operation === \"delete\") {\n                  result = \"- \" + o.atom;\n              } // else \"none\"\n              return result;\n          }).join(\"\\n\");\n          diff = diff.replace(/\\n\\n+/g, \"\\n\");\n          return diff;\n      }\n  }\n\n  // ===== dist/esm/DiskImage.js =====\n  // DiskImage.ts - DiskImage\n  // (c) Marco Vieth, 2020\n  // https://benchmarko.github.io/cpclocots/\n  // Extended DSK image definition\n  // https://www.cpcwiki.eu/index.php/Format:DSK_disk_image_file_format\n  // http://www.cpctech.org.uk/docs/extdsk.html\n\n  class DiskImage {\n      options;\n      diskInfo;\n      formatDescriptor;\n      constructor(options) {\n          this.diskInfo = DiskImage.getInitialDiskInfo();\n          this.options = {\n              data: \"\",\n              quiet: false\n          };\n          this.setOptions(options);\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          const currentData = this.options.data;\n          Object.assign(this.options, options);\n          if (this.options.data !== currentData) { // changed?\n              this.diskInfo.ident = \"\"; // invalidate diskinfo\n              this.diskInfo.trackInfo.ident = \"\"; // invalidate trackinfo\n          }\n      }\n      static twoHeads = \"2h\";\n      static formatDescriptors = {\n          data: {\n              tracks: 40, // number of tracks (1-85)\n              heads: 1, // number of heads/sides (1-2)\n              // head: 0, // head number?\n              bps: 2, // Bytes per Sector (1-5)\n              spt: 9, // Sectors per Track (1-18)\n              gap3: 0x4e, // gap between ID and data\n              fill: 0xe5, // filler byte\n              firstSector: 0xc1, // first sector number\n              bls: 1024, // BLS: data block allocaton size (1024, 2048, 4096, 8192, 16384)\n              // bsh: 3, // log2 BLS - 7\n              // blm: 7, // BLS / 128 - 1\n              al0: 0xc0, // bit significant representation of reserved directory blocks 0..7 (0x80=0, 0xc00=0 and 1,,...)\n              al1: 0x00, // bit significant representation of reserved directory blocks 8..15 (0x80=8,...)\n              off: 0 // number of reserved tracks (also the track where the directory starts)\n          },\n          data42t: {\n              parentRef: \"data\",\n              tracks: 42\n          },\n          // double sided data\n          data2h: {\n              parentRef: \"data\",\n              heads: 2\n          },\n          system: {\n              parentRef: \"data\",\n              firstSector: 0x41,\n              off: 2\n          },\n          // double sided system\n          system2h: {\n              parentRef: \"system\",\n              heads: 2\n          },\n          vortex: {\n              parentRef: \"data\",\n              tracks: 80,\n              heads: 2,\n              firstSector: 0x01\n          },\n          \"3dos\": {\n              parentRef: \"data\",\n              firstSector: 0x00\n          },\n          parados80: {\n              parentRef: \"data\",\n              tracks: 80,\n              firstSector: 0x91,\n              spt: 10,\n              bls: 2048\n          },\n          big780k: {\n              parentRef: \"data\",\n              al0: 0x80, // block 0 reserved\n              tracks: 80,\n              off: 1,\n              firstSector: 0x01\n          },\n          big780k2h: {\n              parentRef: \"big780k\",\n              heads: 2\n          }\n      };\n      static getInitialDiskInfo() {\n          const diskInfo = {\n              ident: \"\",\n              creator: \"\",\n              tracks: 0,\n              heads: 0,\n              trackSize: 0,\n              trackInfo: {\n                  ident: \"\",\n                  sectorInfoList: []\n              },\n              trackSizes: [],\n              trackInfoPosList: [],\n              extended: false\n          };\n          return diskInfo;\n      }\n      getFormatDescriptor() {\n          const formatDescriptor = this.formatDescriptor;\n          if (!formatDescriptor) {\n              throw this.composeError(Error(), \"getFormatDescriptor: formatDescriptor:\", String(formatDescriptor));\n          }\n          return formatDescriptor;\n      }\n      composeError(error, message, value, pos) {\n          const len = 0;\n          return Utils.composeError(\"DiskImage\", error, this.options.diskName + \": \" + message, value, pos || 0, len);\n      }\n      static diskInfoIdentMap = {\n          \"MV - CPC\": 1,\n          EXTENDED: 2\n      };\n      static testDiskIdent(ident) {\n          const diskType = DiskImage.diskInfoIdentMap[ident] || 0;\n          return diskType;\n      }\n      readUtf(pos, len) {\n          const out = this.options.data.substring(pos, pos + len);\n          if (out.length !== len) {\n              throw this.composeError(new Error(), \"End of File\", \"\", pos);\n          }\n          return out;\n      }\n      readUInt8(pos) {\n          const num = this.options.data.charCodeAt(pos);\n          if (isNaN(num)) {\n              throw this.composeError(new Error(), \"End of File\", String(num), pos);\n          }\n          return num;\n      }\n      readUInt16(pos) {\n          return this.readUInt8(pos) + this.readUInt8(pos + 1) * 256;\n      }\n      static uInt8ToString(value) {\n          return String.fromCharCode(value);\n      }\n      static uInt16ToString(value) {\n          return DiskImage.uInt8ToString(value & 0xff) + DiskImage.uInt8ToString((value >> 8) & 0xff); // eslint-disable-line no-bitwise\n      }\n      static uInt24ToString(value) {\n          return DiskImage.uInt16ToString(value & 0xffff) + DiskImage.uInt8ToString(value >> 16); // eslint-disable-line no-bitwise\n      }\n      static diskInfoSize = 0x100;\n      readDiskInfo(diskInfo, pos) {\n          const ident = this.readUtf(pos, 8), // check first 8 characters as characteristic\n          diskType = DiskImage.testDiskIdent(ident);\n          if (!diskType) {\n              throw this.composeError(Error(), \"Ident not found\", ident, pos);\n          }\n          diskInfo.extended = (diskType === 2);\n          diskInfo.ident = ident + this.readUtf(pos + 8, 34 - 8); // read remaining ident\n          if (diskInfo.ident.substring(34 - 11, 34 - 11 + 9) !== \"Disk-Info\") { // some tools use \"Disk-Info  \" instead of \"Disk-Info\\r\\n\", so compare without \"\\r\\n\"\n              // \"Disk-Info\" string is optional\n              if (!this.options.quiet) {\n                  Utils.console.warn(this.composeError({}, \"Disk ident not found\", diskInfo.ident.substring(34 - 11, 34 - 11 + 9), pos + 34 - 11).message);\n              }\n          }\n          diskInfo.creator = this.readUtf(pos + 34, 14);\n          diskInfo.tracks = this.readUInt8(pos + 48);\n          diskInfo.heads = this.readUInt8(pos + 49);\n          diskInfo.trackSize = this.readUInt16(pos + 50);\n          const trackSizes = [], trackInfoPosList = [], trackSizeCount = diskInfo.tracks * diskInfo.heads; // number of track sizes\n          let trackInfoPos = DiskImage.diskInfoSize;\n          pos += 52; // track sizes high bytes start at offset 52 (0x35)\n          for (let i = 0; i < trackSizeCount; i += 1) {\n              trackInfoPosList.push(trackInfoPos);\n              const trackSize = diskInfo.trackSize || (this.readUInt8(pos + i) * 256); // take common track size or read individual track size (extended)\n              trackSizes.push(trackSize);\n              trackInfoPos += trackSize;\n          }\n          diskInfo.trackSizes = trackSizes;\n          diskInfo.trackInfoPosList = trackInfoPosList;\n          diskInfo.trackInfo.ident = \"\"; // make sure it is invalid\n          if (Utils.debug > 1) {\n              Utils.console.debug(\"readDiskInfo: extended=\" + diskInfo.extended + \", tracks=\" + diskInfo.tracks + \", heads=\" + diskInfo.heads + \", trackSize=\" + diskInfo.trackSize);\n          }\n      }\n      static createDiskInfoAsString(diskInfo) {\n          // only standard format\n          const diskInfoString = diskInfo.ident // 34\n              + diskInfo.creator // 14\n              + DiskImage.uInt8ToString(diskInfo.tracks)\n              + DiskImage.uInt8ToString(diskInfo.heads)\n              + DiskImage.uInt16ToString(diskInfo.trackSize)\n              + DiskImage.uInt8ToString(0).repeat(204); // unused\n          return diskInfoString;\n      }\n      static trackInfoSize = 0x100;\n      readTrackInfo(trackInfo, pos) {\n          const trackInfoSize = DiskImage.trackInfoSize, sectorInfoList = trackInfo.sectorInfoList, trackDataPos = pos + trackInfoSize;\n          trackInfo.ident = this.readUtf(pos, 12);\n          if (trackInfo.ident.substring(0, 10) !== \"Track-Info\") { // some tools use \"Track-Info  \" instead of \"Track-Info\\r\\n\", so compare without \"\\r\\n\"\n              // \"Track-Info\" string is optional\n              if (!this.options.quiet) {\n                  Utils.console.warn(this.composeError({}, \"Track ident not found\", trackInfo.ident.substring(0, 10), pos).message);\n              }\n          }\n          // 4 unused bytes\n          trackInfo.track = this.readUInt8(pos + 16);\n          trackInfo.head = this.readUInt8(pos + 17);\n          trackInfo.dataRate = this.readUInt8(pos + 18);\n          trackInfo.recMode = this.readUInt8(pos + 19);\n          trackInfo.bps = this.readUInt8(pos + 20);\n          trackInfo.spt = this.readUInt8(pos + 21);\n          trackInfo.gap3 = this.readUInt8(pos + 22);\n          trackInfo.fill = this.readUInt8(pos + 23);\n          sectorInfoList.length = trackInfo.spt;\n          const sectorNum2Index = {};\n          trackInfo.sectorNum2Index = sectorNum2Index;\n          pos += 24; // start sector info\n          let sectorPos = trackDataPos;\n          for (let i = 0; i < trackInfo.spt; i += 1) {\n              const sectorInfo = sectorInfoList[i] || {}; // reuse SectorInfo object if possible\n              sectorInfoList[i] = sectorInfo;\n              sectorInfo.dataPos = sectorPos;\n              sectorInfo.track = this.readUInt8(pos);\n              sectorInfo.head = this.readUInt8(pos + 1);\n              sectorInfo.sector = this.readUInt8(pos + 2);\n              sectorInfo.bps = this.readUInt8(pos + 3);\n              sectorInfo.state1 = this.readUInt8(pos + 4);\n              sectorInfo.state2 = this.readUInt8(pos + 5);\n              const sectorSize = this.readUInt16(pos + 6) || (0x0080 << trackInfo.bps); // eslint-disable-line no-bitwise\n              sectorInfo.sectorSize = sectorSize;\n              sectorPos += sectorSize;\n              sectorNum2Index[sectorInfo.sector] = i;\n              pos += 8;\n          }\n      }\n      static createTrackInfoAsString(trackInfo) {\n          const sectorInfoList = trackInfo.sectorInfoList;\n          let trackInfoString = trackInfo.ident // 12\n              + DiskImage.uInt8ToString(0).repeat(4) // 4 unused\n              + DiskImage.uInt8ToString(trackInfo.track)\n              + DiskImage.uInt8ToString(trackInfo.head)\n              + DiskImage.uInt8ToString(trackInfo.dataRate)\n              + DiskImage.uInt8ToString(trackInfo.recMode)\n              + DiskImage.uInt8ToString(trackInfo.bps)\n              + DiskImage.uInt8ToString(trackInfo.spt)\n              + DiskImage.uInt8ToString(trackInfo.gap3)\n              + DiskImage.uInt8ToString(trackInfo.fill);\n          for (let i = 0; i < trackInfo.spt; i += 1) {\n              const sectorInfo = sectorInfoList[i], sectorinfoString = DiskImage.uInt8ToString(sectorInfo.track)\n                  + DiskImage.uInt8ToString(sectorInfo.head)\n                  + DiskImage.uInt8ToString(sectorInfo.sector)\n                  + DiskImage.uInt8ToString(sectorInfo.bps)\n                  + DiskImage.uInt8ToString(sectorInfo.state1)\n                  + DiskImage.uInt8ToString(sectorInfo.state2)\n                  + DiskImage.uInt16ToString(0); // We use 0 (sectorInfo.sectorSize only needed for extended format)\n              trackInfoString += sectorinfoString;\n          }\n          // fill up\n          trackInfoString += DiskImage.uInt8ToString(0).repeat(DiskImage.trackInfoSize - trackInfoString.length);\n          return trackInfoString;\n      }\n      seekTrack(diskInfo, track, head) {\n          if (!diskInfo.ident) {\n              this.readDiskInfo(diskInfo, 0);\n          }\n          const trackInfo = diskInfo.trackInfo;\n          if (trackInfo.ident && trackInfo.track === track && trackInfo.head === head) { // already positionend?\n              return;\n          }\n          const trackInfoPos = diskInfo.trackInfoPosList[track * diskInfo.heads + head];\n          if (trackInfoPos === undefined) {\n              throw this.composeError(new Error(), \"Track not found\", String(track));\n          }\n          this.readTrackInfo(trackInfo, trackInfoPos);\n      }\n      static sectorNum2Index(trackInfo, sector) {\n          const sectorIndex = trackInfo.sectorNum2Index[sector];\n          return sectorIndex;\n      }\n      static seekSector(sectorInfoList, sectorIndex) {\n          return sectorInfoList[sectorIndex];\n      }\n      readSector(trackInfo, sector) {\n          const sectorIndex = DiskImage.sectorNum2Index(trackInfo, sector);\n          if (sectorIndex === undefined) {\n              throw this.composeError(Error(), \"Track \" + trackInfo.track + \": Sector not found\", String(sector), 0);\n          }\n          const sectorInfo = DiskImage.seekSector(trackInfo.sectorInfoList, sectorIndex), out = this.readUtf(sectorInfo.dataPos, sectorInfo.sectorSize);\n          return out;\n      }\n      writeSector(trackInfo, sector, sectorData) {\n          const sectorIndex = DiskImage.sectorNum2Index(trackInfo, sector);\n          if (sectorIndex === undefined) {\n              throw this.composeError(Error(), \"Track \" + trackInfo.track + \": Sector not found\", String(sector), 0);\n          }\n          const sectorInfo = DiskImage.seekSector(trackInfo.sectorInfoList, sectorIndex), data = this.options.data;\n          if (sectorData.length !== sectorInfo.sectorSize) {\n              Utils.console.error(this.composeError({}, \"sectordata.length \" + sectorData.length + \" <> sectorSize \" + sectorInfo.sectorSize, String(0)));\n          }\n          this.options.data = data.substring(0, sectorInfo.dataPos) + sectorData + data.substring(sectorInfo.dataPos + sectorInfo.sectorSize);\n      }\n      // ...\n      composeFormatDescriptor(format) {\n          const derivedFormatDescriptor = DiskImage.formatDescriptors[format];\n          if (!derivedFormatDescriptor) {\n              throw this.composeError(Error(), \"Unknown format\", format);\n          }\n          let formatDescriptor;\n          if (derivedFormatDescriptor.parentRef) {\n              const parentFormatDescriptor = this.composeFormatDescriptor(derivedFormatDescriptor.parentRef); // recursive\n              formatDescriptor = Object.assign({}, parentFormatDescriptor, derivedFormatDescriptor);\n          }\n          else {\n              formatDescriptor = Object.assign({}, derivedFormatDescriptor); // get a copy\n          }\n          return formatDescriptor;\n      }\n      determineFormat(diskInfo) {\n          const trackInfo = diskInfo.trackInfo, track = 0, head = 0;\n          this.seekTrack(diskInfo, track, head);\n          let firstSector = 0xff;\n          for (let i = 0; i < trackInfo.spt; i += 1) {\n              const sector = trackInfo.sectorInfoList[i].sector;\n              if (sector < firstSector) {\n                  firstSector = sector;\n              }\n          }\n          let format = \"\";\n          if (firstSector === 0xc1) {\n              format = \"data\";\n          }\n          else if (firstSector === 0x41) {\n              format = \"system\";\n          }\n          else if ((firstSector === 0x91) && (diskInfo.tracks === 80)) { // parados80\n              format = \"parados80\";\n          }\n          else if ((firstSector === 0x01) && (diskInfo.tracks === 80)) { // big780k (usually diskInfo.heads: 2)\n              format = \"big780k\";\n          }\n          else {\n              throw this.composeError(Error(), \"Unknown format with sector\", String(firstSector));\n          }\n          if (diskInfo.heads > 1) { // maybe 2 heads\n              format += DiskImage.twoHeads; // e.g. \"data\": \"data2h\"\n          }\n          if (Utils.debug > 1) {\n              Utils.console.debug(\"determineFormat: format=\", format);\n          }\n          return format;\n      }\n      createImage(format) {\n          const formatDescriptor = this.composeFormatDescriptor(format), sectorInfoList = [], sectorSize = (0x80 << formatDescriptor.bps), // eslint-disable-line no-bitwise\n          sectorInfo = {\n              track: 0,\n              head: 0,\n              sector: 0,\n              bps: formatDescriptor.bps,\n              state1: 0,\n              state2: 0,\n              sectorSize: sectorSize,\n              dataPos: 0\n          }, trackInfo = {\n              ident: \"Track-Info\\r\\n\",\n              track: 0,\n              head: 0,\n              dataRate: 0,\n              recMode: 0,\n              bps: formatDescriptor.bps,\n              spt: formatDescriptor.spt,\n              gap3: formatDescriptor.gap3,\n              fill: formatDescriptor.fill,\n              sectorInfoList: sectorInfoList,\n              sectorNum2Index: {}\n          }, diskInfo = {\n              ident: \"MV - CPCEMU Disk-File\\r\\nDisk-Info\\r\\n\", // 34\n              creator: (this.options.creator || \"cpclocots\").padEnd(14, \" \"), // 14\n              tracks: formatDescriptor.tracks,\n              heads: formatDescriptor.heads,\n              trackSize: DiskImage.trackInfoSize + formatDescriptor.spt * sectorSize, // eslint-disable-line no-bitwise\n              trackInfo: trackInfo,\n              trackSizes: [], // only for extended DSK format\n              trackInfoPosList: [],\n              extended: false\n          }, emptySectorData = DiskImage.uInt8ToString(formatDescriptor.fill).repeat(sectorSize);\n          for (let i = 0; i < trackInfo.spt; i += 1) {\n              const sectorInfoClone = {\n                  ...sectorInfo\n              };\n              sectorInfoClone.sector = formatDescriptor.firstSector + i;\n              trackInfo.sectorNum2Index[sectorInfoClone.sector] = i;\n              sectorInfoList.push(sectorInfoClone);\n          }\n          let image = DiskImage.createDiskInfoAsString(diskInfo), trackInfoPos = DiskImage.diskInfoSize;\n          for (let track = 0; track < formatDescriptor.tracks; track += 1) {\n              for (let head = 0; head < formatDescriptor.heads; head += 1) {\n                  trackInfo.track = track;\n                  trackInfo.head = head;\n                  diskInfo.trackInfoPosList.push(trackInfoPos);\n                  for (let sector = 0; sector < trackInfo.spt; sector += 1) {\n                      const sectorInfo2 = sectorInfoList[sector];\n                      sectorInfo2.track = track;\n                      sectorInfo2.head = head;\n                      // in case we want to use the formatted image...\n                      sectorInfo2.dataPos = trackInfoPos + DiskImage.trackInfoSize + sector * sectorInfo2.sectorSize;\n                  }\n                  const trackAsString = DiskImage.createTrackInfoAsString(trackInfo);\n                  image += trackAsString;\n                  for (let sector = 0; sector < formatDescriptor.spt; sector += 1) {\n                      image += emptySectorData;\n                  }\n                  trackInfoPos += diskInfo.trackSize;\n              }\n          }\n          this.diskInfo = diskInfo;\n          this.formatDescriptor = formatDescriptor;\n          return image;\n      }\n      formatImage(format) {\n          const image = this.createImage(format);\n          this.options.data = image;\n          return image;\n      }\n      static fnRemoveHighBit7(str) {\n          let out = \"\";\n          for (let i = 0; i < str.length; i += 1) {\n              const char = str.charCodeAt(i);\n              out += String.fromCharCode(char & 0x7f); // eslint-disable-line no-bitwise\n          }\n          return out;\n      }\n      readDirectoryExtents(extents, pos, endPos) {\n          while (pos < endPos) {\n              const extent = {\n                  user: this.readUInt8(pos),\n                  name: this.readUtf(pos + 1, 8),\n                  ext: this.readUtf(pos + 9, 3), // extension with flags\n                  extent: this.readUInt8(pos + 12),\n                  lastRecBytes: this.readUInt8(pos + 13),\n                  extentHi: this.readUInt8(pos + 14), // used for what?\n                  records: this.readUInt8(pos + 15),\n                  blocks: []\n              };\n              pos += 16;\n              const blocks = extent.blocks;\n              for (let i = 0; i < 16; i += 1) {\n                  const block = this.readUInt8(pos + i);\n                  blocks.push(block);\n              }\n              pos += 16;\n              extents.push(extent);\n          }\n          return extents;\n      }\n      static createDirectoryExtentAsString(extent) {\n          let extentString = DiskImage.uInt8ToString(extent.user)\n              + extent.name\n              + extent.ext\n              + DiskImage.uInt8ToString(extent.extent)\n              + DiskImage.uInt8ToString(extent.lastRecBytes)\n              + DiskImage.uInt8ToString(extent.extentHi)\n              + DiskImage.uInt8ToString(extent.records), blockString = \"\";\n          for (let i = 0; i < extent.blocks.length; i += 1) {\n              blockString += DiskImage.uInt8ToString(extent.blocks[i]);\n          }\n          extentString += blockString;\n          return extentString;\n      }\n      static createSeveralDirectoryExtentsAsString(extents, first, last) {\n          let extentString = \"\";\n          for (let i = first; i < last; i += 1) {\n              extentString += DiskImage.createDirectoryExtentAsString(extents[i]);\n          }\n          return extentString;\n      }\n      static fnSortByExtentNumber(a, b) {\n          return a.extent - b.extent;\n      }\n      // do not know if we need to sort the extents per file, but...\n      static sortFileExtents(dir) {\n          for (const name in dir) {\n              if (dir.hasOwnProperty(name)) {\n                  const fileExtents = dir[name];\n                  fileExtents.sort(DiskImage.fnSortByExtentNumber);\n              }\n          }\n      }\n      static prepareDirectoryList(extents, fill, reFilePattern) {\n          const dir = {};\n          for (let i = 0; i < extents.length; i += 1) {\n              const extent = extents[i];\n              if (fill === null || extent.user !== fill) {\n                  const name = DiskImage.fnRemoveHighBit7(extent.name) + \".\" + DiskImage.fnRemoveHighBit7(extent.ext); // and extent.user?\n                  // (do not convert filename here (to display messages in filenames))\n                  if (!reFilePattern || reFilePattern.test(name)) {\n                      if (!(name in dir)) {\n                          dir[name] = [];\n                      }\n                      dir[name].push(extent);\n                  }\n              }\n          }\n          DiskImage.sortFileExtents(dir);\n          return dir;\n      }\n      static convertBlock2Sector(formatDescriptor, block) {\n          const spt = formatDescriptor.spt, blockSectors = formatDescriptor.bls / 512, // usually 2\n          logSec = block * blockSectors, // directory is in block 0-1\n          pos = {\n              track: Math.floor(logSec / spt) + formatDescriptor.off,\n              head: 0, // currently always 0\n              sector: (logSec % spt) + formatDescriptor.firstSector\n          };\n          return pos;\n      }\n      readAllDirectoryExtents(diskInfo, formatDescriptor, extents) {\n          const directorySectors = 4, // could be determined from al0,al1\n          off = formatDescriptor.off, firstSector = formatDescriptor.firstSector, trackInfo = diskInfo.trackInfo, sectorInfoList = trackInfo.sectorInfoList;\n          this.seekTrack(diskInfo, off, 0);\n          for (let i = 0; i < directorySectors; i += 1) {\n              const sectorIndex = DiskImage.sectorNum2Index(trackInfo, firstSector + i);\n              if (sectorIndex === undefined) {\n                  throw this.composeError(Error(), \"Cannot read directory at track \" + off + \" sector\", String(firstSector));\n              }\n              const sectorInfo = DiskImage.seekSector(sectorInfoList, sectorIndex);\n              this.readDirectoryExtents(extents, sectorInfo.dataPos, sectorInfo.dataPos + sectorInfo.sectorSize);\n          }\n          return extents;\n      }\n      writeAllDirectoryExtents(diskInfo, formatDescriptor, extents) {\n          const directoryBlocks = 2, // could be determined from al0,al1\n          extentsPerBlock = extents.length / directoryBlocks;\n          for (let i = 0; i < directoryBlocks; i += 1) {\n              const blockData = DiskImage.createSeveralDirectoryExtentsAsString(extents, i * extentsPerBlock, (i + 1) * extentsPerBlock);\n              this.writeBlock(diskInfo, formatDescriptor, i, blockData);\n          }\n      }\n      readDirectory() {\n          const diskInfo = this.diskInfo, format = this.determineFormat(diskInfo), formatDescriptor = this.composeFormatDescriptor(format), extents = [];\n          this.formatDescriptor = formatDescriptor;\n          this.readAllDirectoryExtents(diskInfo, formatDescriptor, extents);\n          return DiskImage.prepareDirectoryList(extents, this.formatDescriptor.fill);\n      }\n      static nextSector(formatDescriptor, pos) {\n          pos.sector += 1;\n          if (pos.sector >= formatDescriptor.firstSector + formatDescriptor.spt) {\n              pos.track += 1;\n              pos.sector = formatDescriptor.firstSector;\n          }\n      }\n      readBlock(diskInfo, formatDescriptor, block) {\n          const blockSectors = formatDescriptor.bls / 512, // usually 2\n          pos = DiskImage.convertBlock2Sector(formatDescriptor, block);\n          let out = \"\";\n          if (pos.track >= diskInfo.tracks) {\n              Utils.console.error(this.composeError({}, \"Block \" + block + \": Track out of range\", String(pos.track)));\n          }\n          if (pos.head >= diskInfo.heads) {\n              Utils.console.error(this.composeError({}, \"Block \" + block + \": Head out of range\", String(pos.track)));\n          }\n          for (let i = 0; i < blockSectors; i += 1) {\n              this.seekTrack(diskInfo, pos.track, pos.head);\n              out += this.readSector(diskInfo.trackInfo, pos.sector);\n              DiskImage.nextSector(formatDescriptor, pos);\n          }\n          return out;\n      }\n      writeBlock(diskInfo, formatDescriptor, block, blockData) {\n          const blockSectors = formatDescriptor.bls / 512, // usually 2\n          sectorSize = (0x80 << formatDescriptor.bps), // eslint-disable-line no-bitwise\n          pos = DiskImage.convertBlock2Sector(formatDescriptor, block);\n          if (pos.track >= diskInfo.tracks) {\n              Utils.console.error(this.composeError({}, \"Block \" + block + \": Track out of range\", String(pos.track)));\n          }\n          if (pos.head >= diskInfo.heads) {\n              Utils.console.error(this.composeError({}, \"Block \" + block + \": Head out of range\", String(pos.track)));\n          }\n          if (blockData.length !== (blockSectors * sectorSize)) {\n              Utils.console.error(this.composeError({}, \"blockData.length \" + blockData.length + \" <> blockSize \" + (blockSectors * sectorSize), String(0)));\n          }\n          for (let i = 0; i < blockSectors; i += 1) {\n              this.seekTrack(diskInfo, pos.track, pos.head);\n              const sectorData = blockData.substring(i * sectorSize, (i + 1) * sectorSize);\n              this.writeSector(diskInfo.trackInfo, pos.sector, sectorData);\n              DiskImage.nextSector(formatDescriptor, pos);\n          }\n      }\n      readExtents(diskInfo, formatDescriptor, fileExtents) {\n          const recPerBlock = formatDescriptor.bls / 128; // usually 8\n          let out = \"\";\n          for (let i = 0; i < fileExtents.length; i += 1) {\n              const extent = fileExtents[i], blocks = extent.blocks;\n              let records = extent.records;\n              if (extent.extent > 0) {\n                  if (recPerBlock > 8) { // fast hack for parados: adapt records\n                      records += extent.extent * 128;\n                  }\n              }\n              for (let blockIndex = 0; blockIndex < blocks.length; blockIndex += 1) {\n                  let block = this.readBlock(diskInfo, formatDescriptor, blocks[blockIndex]);\n                  if (records < recPerBlock) { // block with some remaining data\n                      block = block.substring(0, 0x80 * records);\n                  }\n                  out += block;\n                  records -= recPerBlock;\n                  if (records <= 0) {\n                      break;\n                  }\n              }\n          }\n          return out;\n      }\n      readFile(fileExtents) {\n          const diskInfo = this.diskInfo, formatDescriptor = this.getFormatDescriptor();\n          let out = this.readExtents(diskInfo, formatDescriptor, fileExtents);\n          const header = DiskImage.parseAmsdosHeader(out);\n          let realLen;\n          if (header) {\n              const amsdosHeaderLength = 0x80;\n              realLen = header.length + amsdosHeaderLength;\n          }\n          if (realLen === undefined) { // no real length: ASCII: find EOF (0x1a) in last record\n              const fileLen = out.length, lastRecPos = fileLen > 0x80 ? (fileLen - 0x80) : 0, index = out.indexOf(String.fromCharCode(0x1a), lastRecPos);\n              if (index >= 0) {\n                  realLen = index;\n                  if (Utils.debug > 0) {\n                      Utils.console.debug(\"readFile: ASCII file length \" + fileLen + \" truncated to \" + realLen);\n                  }\n              }\n          }\n          if (realLen !== undefined) { // now real length (from header or ASCII)?\n              out = out.substring(0, realLen);\n          }\n          return out;\n      }\n      static getFreeExtents(extents, fill) {\n          const freeExtents = [];\n          for (let i = 0; i < extents.length; i += 1) {\n              if (extents[i].user === fill) {\n                  freeExtents.push(i);\n              }\n          }\n          return freeExtents;\n      }\n      static getBlockMask(extents, fill, dsm, al0, al1) {\n          const blockMask = [];\n          for (let i = 0; i < dsm - 1; i += 1) {\n              blockMask[i] = false;\n          }\n          // mark reserved blocks\n          let mask = 0x80;\n          for (let i = 0; i < 8; i += 1) {\n              if (al0 & mask) { // eslint-disable-line no-bitwise\n                  blockMask[i] = true; // mark reserved block\n              }\n              mask >>= 1; // eslint-disable-line no-bitwise\n          }\n          mask = 0x80;\n          for (let i = 8; i < 16; i += 1) {\n              if (al1 & mask) { // eslint-disable-line no-bitwise\n                  blockMask[i] = true; // mark reserved block\n              }\n              mask >>= 1; // eslint-disable-line no-bitwise\n          }\n          for (let i = 0; i < extents.length; i += 1) {\n              const extent = extents[i], blockList = extent.blocks;\n              if (extent.user !== fill) {\n                  for (let blockindex = 0; blockindex < blockList.length; blockindex += 1) {\n                      const block = blockList[blockindex];\n                      if (block) {\n                          if (blockMask[block]) { // eslint-disable-line max-depth\n                              Utils.console.warn(\"getBlockMask: Block number already in use: \", block);\n                          }\n                          blockMask[block] = true;\n                      }\n                      else {\n                          break; // block=0 -> no more for this extent\n                      }\n                  }\n              }\n          }\n          return blockMask;\n      }\n      static getFreeBlocks(blockMask, dsm) {\n          const freeBlocks = [];\n          for (let i = 0; i < dsm; i += 1) {\n              if (!blockMask[i]) {\n                  freeBlocks.push(i);\n              }\n          }\n          return freeBlocks;\n      }\n      static getFilenameAndExtension(filename) {\n          let [name1, ext1] = filename.split(\".\"); // eslint-disable-line array-element-newline\n          name1 = name1.substring(0, 8).toUpperCase().padEnd(8, \" \");\n          ext1 = ext1.substring(0, 3).toUpperCase().padEnd(3, \" \");\n          return [name1, ext1]; // eslint-disable-line array-element-newline\n      }\n      writeFile(filename, data) {\n          const diskInfo = this.diskInfo, formatDescriptor = this.getFormatDescriptor(), extents = [];\n          this.readAllDirectoryExtents(diskInfo, formatDescriptor, extents);\n          const fill = formatDescriptor.fill, freeExtents = DiskImage.getFreeExtents(extents, formatDescriptor.fill), sectors = (formatDescriptor.tracks - formatDescriptor.off) * formatDescriptor.spt, ssize = 0x80 << formatDescriptor.bps, // eslint-disable-line no-bitwise\n          dsm = ((sectors * ssize) / formatDescriptor.bls) | 0, // eslint-disable-line no-bitwise\n          // DSM: total size of disc in blocks excluding any reserved tracks\n          al0 = formatDescriptor.al0, al1 = formatDescriptor.al1, blockMask = DiskImage.getBlockMask(extents, fill, dsm, al0, al1), freeBlocks = DiskImage.getFreeBlocks(blockMask, dsm);\n          if (Utils.debug > 0) {\n              Utils.console.debug(\"writeFile: freeExtents=\", freeExtents.length, \", freeBlocks=\", freeBlocks);\n          }\n          if (!freeBlocks.length) {\n              Utils.console.warn(\"writeFile: \" + filename + \": No space left!\");\n              return false;\n          }\n          if (!freeExtents.length) {\n              Utils.console.warn(\"writeFile: \" + filename + \": Directory full!\");\n              return false;\n          }\n          const [name1, ext1] = DiskImage.getFilenameAndExtension(filename), // eslint-disable-line array-element-newline\n          fileSize = data.length, bls = formatDescriptor.bls, requiredBlocks = ((fileSize + bls - 1) / bls) | 0; // eslint-disable-line no-bitwise\n          if (requiredBlocks > freeBlocks.length) {\n              const requiredKB = ((requiredBlocks * bls) / 1024) | 0, // eslint-disable-line no-bitwise\n              freeKB = ((freeBlocks.length * bls) / 1024) | 0; // eslint-disable-line no-bitwise\n              Utils.console.warn(\"writeFile: \" + filename + \": Not enough space left (\" + requiredKB + \"K > \" + freeKB + \"K). Ignoring.\");\n              return false;\n          }\n          const blocksPerExtent = 16, requiredExtents = ((requiredBlocks + blocksPerExtent - 1) / blocksPerExtent) | 0; // eslint-disable-line no-bitwise\n          if (requiredExtents > freeExtents.length) {\n              Utils.console.warn(\"writeFile: \" + filename + \": Directory full!\");\n              return false;\n          }\n          let size = fileSize, extent, extentCnt = 0, blockCnt = 0;\n          while (size > 0) {\n              if (!extent || (blockCnt >= 16)) {\n                  const records = ((size + 0x80 - 1) / 0x80) | 0; // eslint-disable-line no-bitwise\n                  extent = extents[freeExtents[extentCnt]];\n                  extent.user = 0;\n                  extent.name = name1;\n                  extent.ext = ext1;\n                  extent.extent = extentCnt;\n                  extent.lastRecBytes = 0; // ($size >= 0x80) ? 0 : $size;\n                  extent.extentHi = 0;\n                  extent.records = (records > 0x80) ? 0x80 : records;\n                  extent.blocks.length = 0;\n                  for (let i = 0; i < 16; i += 1) {\n                      extent.blocks[i] = 0;\n                  }\n                  extentCnt += 1;\n                  blockCnt = 0;\n              }\n              const thisSize = (size > bls) ? bls : size;\n              let dataChunk = data.substring(fileSize - size, fileSize - size + thisSize);\n              if (thisSize < bls) {\n                  dataChunk += DiskImage.uInt8ToString(0x1a); // add EOF (0x1a)\n                  const remain = bls - thisSize - 1;\n                  dataChunk += DiskImage.uInt8ToString(formatDescriptor.fill).repeat(remain); // fill up last block with fill byte\n              }\n              const block = freeBlocks[(extentCnt - 1) * 16 + blockCnt];\n              this.writeBlock(diskInfo, formatDescriptor, block, dataChunk);\n              extent.blocks[blockCnt] = block;\n              blockCnt += 1;\n              size -= thisSize;\n          }\n          this.writeAllDirectoryExtents(diskInfo, formatDescriptor, extents);\n          return true;\n      }\n      static isSectorEmpty(data, index, size, fill) {\n          const endIndex = (index + size) <= data.length ? index + size : data.length - index;\n          let isEmpty = true;\n          for (let i = index; i < endIndex; i += 1) {\n              if (data.charCodeAt(i) !== fill) {\n                  isEmpty = false;\n                  break;\n              }\n          }\n          return isEmpty;\n      }\n      stripEmptyTracks() {\n          const diskInfo = this.diskInfo, format = this.determineFormat(diskInfo), formatDescriptor = this.composeFormatDescriptor(format), tracks = diskInfo.tracks, firstDataTrack = formatDescriptor.off, head = 0;\n          let data = this.options.data;\n          this.formatDescriptor = formatDescriptor;\n          for (let track = firstDataTrack; track < tracks; track += 1) {\n              this.seekTrack(diskInfo, track, head);\n              const trackInfo = diskInfo.trackInfo, fill = diskInfo.trackInfo.fill, sectorInfoList = trackInfo.sectorInfoList;\n              let isEmpty = true;\n              for (let i = 0; i < trackInfo.spt; i += 1) {\n                  const sectorInfo = sectorInfoList[i];\n                  if (!DiskImage.isSectorEmpty(data, sectorInfo.dataPos, sectorInfo.sectorSize, fill)) {\n                      isEmpty = false;\n                      break;\n                  }\n              }\n              if (isEmpty) {\n                  diskInfo.tracks = track; // set new number of tracks\n                  const trackDataPos = sectorInfoList[0].dataPos;\n                  data = DiskImage.createDiskInfoAsString(diskInfo) + data.substring(DiskImage.diskInfoSize, trackDataPos - DiskImage.trackInfoSize); // set new track count and remove empty track and rest\n                  this.options.data = data;\n                  break;\n              }\n          }\n          return data;\n      }\n      // ...\n      // see AMSDOS ROM, &D252\n      /* eslint-disable array-element-newline */\n      static protectTable = [\n          [0xe2, 0x9d, 0xdb, 0x1a, 0x42, 0x29, 0x39, 0xc6, 0xb3, 0xc6, 0x90, 0x45, 0x8a], // 13 bytes\n          [0x49, 0xb1, 0x36, 0xf0, 0x2e, 0x1e, 0x06, 0x2a, 0x28, 0x19, 0xea] // 11 bytes\n      ];\n      /* eslint-enable array-element-newline */\n      static unOrProtectData(data) {\n          const table1 = DiskImage.protectTable[0], table2 = DiskImage.protectTable[1];\n          let out = \"\";\n          for (let i = 0; i < data.length; i += 1) {\n              let byte = data.charCodeAt(i);\n              byte ^= table1[(i & 0x7f) % table1.length] ^ table2[(i & 0x7f) % table2.length]; // eslint-disable-line no-bitwise\n              out += String.fromCharCode(byte);\n          }\n          return out;\n      }\n      // ...\n      static computeChecksum(data) {\n          let sum = 0;\n          for (let i = 0; i < data.length; i += 1) {\n              sum += data.charCodeAt(i);\n          }\n          return sum;\n      }\n      static hasAmsdosHeader(data) {\n          let hasHeader = false;\n          if (data.length >= 0x80) {\n              const computed = DiskImage.computeChecksum(data.substring(0, 66)), sum = data.charCodeAt(67) + data.charCodeAt(68) * 256;\n              hasHeader = computed === sum;\n          }\n          return hasHeader;\n      }\n      static parseAmsdosHeader(data) {\n          const typeMap = {\n              0: \"T\", // tokenized BASIC (T=not official)\n              1: \"P\", // protected BASIC (also tokenized)\n              2: \"B\", // Binary\n              8: \"G\", // GENA3 Assember (G=not official)\n              0x16: \"A\" // ASCII\n          };\n          let header;\n          // http://www.benchmarko.de/cpcemu/cpcdoc/chapter/cpcdoc7_e.html#I_AMSDOS_HD\n          // http://www.cpcwiki.eu/index.php/AMSDOS_Header\n          // https://www.cpcwiki.eu/imgs/b/bc/S968se09.pdf (Firmware Guide Section 9)\n          if (DiskImage.hasAmsdosHeader(data)) {\n              header = {\n                  user: data.charCodeAt(0),\n                  name: data.substring(1, 1 + 8),\n                  ext: data.substring(9, 9 + 3),\n                  typeNumber: data.charCodeAt(18),\n                  start: data.charCodeAt(21) + data.charCodeAt(22) * 256,\n                  pseudoLen: data.charCodeAt(24) + data.charCodeAt(25) * 256,\n                  entry: data.charCodeAt(26) + data.charCodeAt(27) * 256,\n                  length: data.charCodeAt(64) + data.charCodeAt(65) * 256 + data.charCodeAt(66) * 65536,\n                  typeString: \"\"\n              };\n              header.typeString = typeMap[header.typeNumber] || typeMap[16]; // default: ASCII\n          }\n          return header;\n      }\n      static combineAmsdosHeader(header) {\n          const typeMap = {\n              T: 0, // tokenized BASIC (T=not official)\n              P: 1, // protected BASIC\n              B: 2, // Binary\n              G: 8, // GENA3 Assember (G=not official)\n              A: 0x16 // ASCII\n          };\n          let type = header.typeNumber;\n          if (header.typeString) { // overwrite type form type\n              type = typeMap[header.typeString];\n              if (type === undefined) {\n                  type = typeMap.A;\n              }\n          }\n          let length = header.pseudoLen || header.length; // logical length;\n          if (length > 0xffff) { // 16 bit\n              length = 0xffff;\n          }\n          const data1 = DiskImage.uInt8ToString(header.user || 0)\n              + (header.name || \"\").padEnd(8, \" \")\n              + (header.ext || \"\").padEnd(3, \" \")\n              + DiskImage.uInt16ToString(0)\n              + DiskImage.uInt16ToString(0)\n              + DiskImage.uInt8ToString(0) // block number (unused)\n              + DiskImage.uInt8ToString(0) // last block (unused)\n              + DiskImage.uInt8ToString(type)\n              + DiskImage.uInt16ToString(0) // data location (unused)\n              + DiskImage.uInt16ToString(header.start || 0)\n              + DiskImage.uInt8ToString(0x00) // first block (unused; always 0x00 or 0xff?)\n              + DiskImage.uInt16ToString(length) // logical length\n              + DiskImage.uInt16ToString(header.entry || 0)\n              + \"\\x00\".repeat(36)\n              + DiskImage.uInt24ToString(header.length), checksum = DiskImage.computeChecksum(data1), data = data1\n              + DiskImage.uInt16ToString(checksum)\n              + \"\\x00\".repeat(59);\n          return data;\n      }\n      static createAmsdosHeader(parameter) {\n          const header = {\n              user: 0,\n              name: \"\",\n              ext: \"\",\n              typeNumber: 0,\n              start: 0,\n              pseudoLen: 0,\n              entry: 0,\n              length: 0,\n              typeString: \"\",\n              ...parameter\n          };\n          return header;\n      }\n  }\n\n  // ===== dist/esm/Snapshot.js =====\n  // Snapshot.ts - Snapshot\n  // (c) Marco Vieth, 2023\n  // https://benchmarko.github.io/cpclocots/\n  // Snapshot definition\n  // https://www.cpcwiki.eu/index.php/Format:SNA_snapshot_file_format\n  // https://cpctech.cpcwiki.de/docs/snapshot.html\n\n  class Snapshot {\n      options;\n      pos = 0;\n      constructor(options) {\n          this.options = {\n              quiet: false\n          };\n          this.setOptions(options);\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      composeError(error, message, value, pos) {\n          const len = 0;\n          return Utils.composeError(\"DiskImage\", error, this.options.name + \": \" + message, value, pos || 0, len);\n      }\n      static testSnapIdent(ident) {\n          return ident === \"MV - SNA\";\n      }\n      readUInt8() {\n          const num = this.options.data.charCodeAt(this.pos);\n          if (isNaN(num)) {\n              throw this.composeError(new Error(), \"End of File\", String(num), this.pos);\n          }\n          this.pos += 1;\n          return num;\n      }\n      readUInt16() {\n          return this.readUInt8() + this.readUInt8() * 256;\n      }\n      readUInt8Array(len) {\n          const arr = [];\n          for (let i = 0; i < len; i += 1) {\n              arr.push(this.readUInt8());\n          }\n          return arr;\n      }\n      readUtf(len) {\n          const out = this.options.data.substring(this.pos, this.pos + len);\n          if (out.length !== len) {\n              throw this.composeError(new Error(), \"End of File\", \"\", this.pos);\n          }\n          this.pos += len;\n          return out;\n      }\n      getSnapshotInfo() {\n          this.pos = 0;\n          const info = {\n              ident: this.readUtf(8),\n              unused1: this.readUtf(8),\n              version: this.readUInt8(),\n              z80: {\n                  AF: this.readUInt16(),\n                  BC: this.readUInt16(),\n                  DE: this.readUInt16(),\n                  HL: this.readUInt16(),\n                  IR: this.readUInt16(),\n                  IFF: this.readUInt16(),\n                  IX: this.readUInt16(),\n                  IY: this.readUInt16(),\n                  SP: this.readUInt16(),\n                  PC: this.readUInt16(),\n                  M: this.readUInt8(),\n                  AF2: this.readUInt16(),\n                  BC2: this.readUInt16(),\n                  DE2: this.readUInt16(),\n                  HL2: this.readUInt16()\n              },\n              ga: {\n                  inknum: this.readUInt8(),\n                  inkval: this.readUInt8Array(17),\n                  multi: this.readUInt8()\n              },\n              ramconf: this.readUInt8(),\n              crtc: {\n                  index: this.readUInt8(),\n                  reg: this.readUInt8Array(18)\n              },\n              romnum: this.readUInt8(),\n              ppi: {\n                  portA: this.readUInt8(),\n                  portB: this.readUInt8(),\n                  portC: this.readUInt8(),\n                  portCtl: this.readUInt8()\n              },\n              psg: {\n                  index: this.readUInt8(),\n                  reg: this.readUInt8Array(16)\n              },\n              memsize: this.readUInt8()\n          };\n          return info;\n      }\n      getMemory() {\n          return this.options.data.substring(0x100); // memory dump without snapshot header\n      }\n  }\n\n  // ===== dist/esm/ZipFile.js =====\n  // ZipFile.ts - ZIP file handling\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n  // Idea based on: https://github.com/frash23/jzsip/blob/master/jzsip.js\n  // (and Cpcemu: zip.cpp)\n  // https://en.wikipedia.org/wiki/Zip_(file_format)\n\n  class ZipFile {\n      options;\n      data;\n      entryTable = {};\n      constructor(options) {\n          this.options = {};\n          this.setOptions(options, true);\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options, force) {\n          const currentData = this.options.data;\n          Object.assign(this.options, options);\n          if (force || (this.options.data !== currentData)) {\n              this.data = this.options.data;\n              this.entryTable = this.readZipDirectory();\n          }\n      }\n      getZipDirectory() {\n          return this.entryTable;\n      }\n      composeError(error, message, value, pos) {\n          message = this.options.zipName + \": \" + message; // put zipname in message\n          return Utils.composeError(\"ZipFile\", error, message, value, pos);\n      }\n      subArr(begin, length) {\n          const data = this.data, end = begin + length;\n          return data.slice ? data.slice(begin, end) : data.subarray(begin, end); // array.slice on Uint8Array not for IE11\n      }\n      readUTF(offset, len) {\n          const callSize = 25000; // use call window to avoid \"maximum call stack error\" for e.g. size 336461\n          let out = \"\";\n          while (len) {\n              const chunkLen = Math.min(len, callSize), nums = this.subArr(offset, chunkLen);\n              out += String.fromCharCode.apply(null, nums); // on Chrome this is faster than single character processing\n              offset += chunkLen;\n              len -= chunkLen;\n          }\n          return out;\n      }\n      readUInt(i) {\n          const data = this.data;\n          return (data[i + 3] << 24) | (data[i + 2] << 16) | (data[i + 1] << 8) | data[i]; // eslint-disable-line no-bitwise\n      }\n      readUShort(i) {\n          const data = this.data;\n          return ((data[i + 1]) << 8) | data[i]; // eslint-disable-line no-bitwise\n      }\n      readEocd(eocdPos) {\n          const eocd = {\n              signature: this.readUInt(eocdPos),\n              entries: this.readUShort(eocdPos + 10), // total number of central directory records\n              cdfhOffset: this.readUInt(eocdPos + 16), // offset of start of central directory, relative to start of archive\n              cdSize: this.readUInt(eocdPos + 20) // size of central directory (just for information)\n          };\n          return eocd;\n      }\n      readCdfh(pos) {\n          const cdfh = {\n              signature: this.readUInt(pos),\n              version: this.readUShort(pos + 6), // version needed to extract (minimum)\n              flag: this.readUShort(pos + 8), // General purpose bit flag\n              compressionMethod: this.readUShort(pos + 10), // compression method\n              modificationTime: this.readUShort(pos + 12), // File last modification time (DOS time)\n              crc: this.readUInt(pos + 16), // CRC-32 of uncompressed data\n              compressedSize: this.readUInt(pos + 20), // compressed size\n              size: this.readUInt(pos + 24), // Uncompressed size\n              fileNameLength: this.readUShort(pos + 28), // file name length\n              extraFieldLength: this.readUShort(pos + 30), // extra field length\n              fileCommentLength: this.readUShort(pos + 32), // file comment length\n              localOffset: this.readUInt(pos + 42), // relative offset of local file header\n              // set later...\n              name: \"\",\n              isDirectory: false,\n              extra: [],\n              comment: \"\",\n              timestamp: 0,\n              dataStart: 0\n          };\n          return cdfh;\n      }\n      readZipDirectory() {\n          const eocdLen = 22, // End of central directory (EOCD)\n          maxEocdCommentLen = 0xffff, eocdSignature = 0x06054B50, // EOCD signature: \"PK\\x05\\x06\"\n          cdfhSignature = 0x02014B50, // Central directory file header signature: PK\\x01\\x02\"\n          cdfhLen = 46, // Central directory file header length\n          lfhSignature = 0x04034b50, // Local file header signature\n          lfhLen = 30, // Local file header length\n          data = this.data, entryTable = {};\n          // find End of central directory (EOCD) record\n          let i = data.length - eocdLen + 1, // +1 because of loop\n          eocd;\n          const n = Math.max(0, i - maxEocdCommentLen);\n          while (i >= n) {\n              i -= 1;\n              if (this.readUInt(i) === eocdSignature) {\n                  eocd = this.readEocd(i);\n                  if (this.readUInt(eocd.cdfhOffset) === cdfhSignature) {\n                      break; // looks good, so we assume that we have found the EOCD\n                  }\n              }\n          }\n          if (!eocd) {\n              throw this.composeError(Error(), \"Zip: File ended abruptly: EOCD not found\", \"\", (i >= 0) ? i : 0);\n          }\n          const entries = eocd.entries;\n          let offset = eocd.cdfhOffset;\n          for (i = 0; i < entries; i += 1) {\n              const cdfh = this.readCdfh(offset);\n              if (cdfh.signature !== cdfhSignature) {\n                  throw this.composeError(Error(), \"Zip: Bad CDFH signature\", \"\", offset);\n              }\n              if (!cdfh.fileNameLength) {\n                  throw this.composeError(Error(), \"Zip Entry name missing\", \"\", offset);\n              }\n              offset += cdfhLen;\n              cdfh.name = this.readUTF(offset, cdfh.fileNameLength);\n              offset += cdfh.fileNameLength;\n              cdfh.isDirectory = cdfh.name.charAt(cdfh.name.length - 1) === \"/\";\n              cdfh.extra = this.subArr(offset, cdfh.extraFieldLength);\n              offset += cdfh.extraFieldLength;\n              cdfh.comment = this.readUTF(offset, cdfh.fileCommentLength);\n              offset += cdfh.fileCommentLength;\n              if ((cdfh.flag & 1) === 1) { // eslint-disable-line no-bitwise\n                  throw this.composeError(Error(), \"Zip encrypted entries not supported\", \"\", i);\n              }\n              const dostime = cdfh.modificationTime;\n              // year, month, day, hour, minute, second\n              cdfh.timestamp = new Date(((dostime >> 25) & 0x7F) + 1980, ((dostime >> 21) & 0x0F) - 1, (dostime >> 16) & 0x1F, (dostime >> 11) & 0x1F, (dostime >> 5) & 0x3F, (dostime & 0x1F) << 1).getTime(); // eslint-disable-line no-bitwise\n              // local file header... much more info\n              if (this.readUInt(cdfh.localOffset) !== lfhSignature) {\n                  Utils.console.error(\"Zip: readZipDirectory: LFH signature not found at offset\", cdfh.localOffset);\n              }\n              const lfhExtrafieldLength = this.readUShort(cdfh.localOffset + 28); // extra field length\n              cdfh.dataStart = cdfh.localOffset + lfhLen + cdfh.name.length + lfhExtrafieldLength;\n              entryTable[cdfh.name] = cdfh;\n          }\n          return entryTable;\n      }\n      static fnInflateConstruct(codes, lens2, n) {\n          let i;\n          for (i = 0; i <= 0xF; i += 1) {\n              codes.count[i] = 0;\n          }\n          for (i = 0; i < n; i += 1) {\n              codes.count[lens2[i]] += 1;\n          }\n          if (codes.count[0] === n) {\n              return 0;\n          }\n          let left = 1;\n          for (i = 1; i <= 0xF; i += 1) {\n              if ((left = (left << 1) - codes.count[i]) < 0) { // eslint-disable-line no-bitwise\n                  return left;\n              }\n          }\n          const offs = [\n              undefined,\n              0\n          ];\n          for (i = 1; i < 0xF; i += 1) {\n              offs[i + 1] = offs[i] + codes.count[i];\n          }\n          for (i = 0; i < n; i += 1) {\n              if (lens2[i] !== 0) {\n                  codes.symbol[offs[lens2[i]]] = i; // TTT\n                  offs[lens2[i]] += 1; // TTT\n              }\n          }\n          return left;\n      }\n      static fnConstructFixedHuffman(lens, lenCode, distCode) {\n          let symbol;\n          for (symbol = 0; symbol < 0x90; symbol += 1) {\n              lens[symbol] = 8;\n          }\n          for (; symbol < 0x100; symbol += 1) {\n              lens[symbol] = 9;\n          }\n          for (; symbol < 0x118; symbol += 1) {\n              lens[symbol] = 7;\n          }\n          for (; symbol < 0x120; symbol += 1) {\n              lens[symbol] = 8;\n          }\n          ZipFile.fnInflateConstruct(lenCode, lens, 0x120);\n          for (symbol = 0; symbol < 0x1E; symbol += 1) {\n              lens[symbol] = 5;\n          }\n          ZipFile.fnInflateConstruct(distCode, lens, 0x1E);\n      }\n      inflate(offset, compressedSize, finalSize) {\n          /* eslint-disable array-element-newline */\n          const startLens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], lExt = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], dists = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], dExt = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], dynamicTableOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], \n          /* eslint-enable array-element-newline */\n          that = this, // eslint-disable-line @typescript-eslint/no-this-alias\n          data = this.data, bufEnd = offset + compressedSize, outBuf = new Uint8Array(finalSize);\n          let inCnt = offset, // read position\n          outCnt = 0, // bytes written to outbuf\n          bitCnt = 0, // helper to keep track of where we are in #bits\n          bitBuf = 0, distCode, lenCode, lens;\n          const fnBits = function (need) {\n              let out = bitBuf;\n              while (bitCnt < need) {\n                  if (inCnt === bufEnd) {\n                      throw that.composeError(Error(), \"Zip: inflate: Data overflow\", that.options.zipName, -1);\n                  }\n                  out |= data[inCnt] << bitCnt; // eslint-disable-line no-bitwise\n                  inCnt += 1;\n                  bitCnt += 8;\n              }\n              bitBuf = out >> need; // eslint-disable-line no-bitwise\n              bitCnt -= need;\n              return out & ((1 << need) - 1); // eslint-disable-line no-bitwise\n          }, fnDecode = function (codes) {\n              let code = 0, first = 0, i = 0;\n              for (let j = 1; j <= 0xF; j += 1) {\n                  code |= fnBits(1); // eslint-disable-line no-bitwise\n                  const count = codes.count[j];\n                  if (code < first + count) {\n                      return codes.symbol[i + (code - first)];\n                  }\n                  i += count;\n                  first += count;\n                  first <<= 1; // eslint-disable-line no-bitwise\n                  code <<= 1; // eslint-disable-line no-bitwise\n              }\n              return null;\n          }, fnInflateStored = function () {\n              bitBuf = 0;\n              bitCnt = 0;\n              if (inCnt + 4 > bufEnd) {\n                  throw that.composeError(Error(), \"Zip: inflate: Data overflow\", \"\", inCnt);\n              }\n              let len = that.readUShort(inCnt);\n              inCnt += 2;\n              if (data[inCnt] !== (~len & 0xFF) || data[inCnt + 1] !== ((~len >> 8) & 0xFF)) { // eslint-disable-line no-bitwise\n                  throw that.composeError(Error(), \"Zip: inflate: Bad length\", \"\", inCnt);\n              }\n              inCnt += 2;\n              if (inCnt + len > bufEnd) {\n                  throw that.composeError(Error(), \"Zip: inflate: Data overflow\", \"\", inCnt);\n              }\n              // Compatibility: Instead of: outbuf.push.apply(outbuf, outbuf.slice(incnt, incnt + len)); outcnt += len; incnt += len;\n              while (len) {\n                  outBuf[outCnt] = data[inCnt];\n                  outCnt += 1;\n                  inCnt += 1;\n                  len -= 1;\n              }\n          }, fnConstructDynamicHuffman = function () {\n              const nLen = fnBits(5) + 257, nDist = fnBits(5) + 1, nCode = fnBits(4) + 4;\n              if (nLen > 0x11E || nDist > 0x1E) {\n                  throw that.composeError(Error(), \"Zip: inflate: length/distance code overflow\", \"\", 0);\n              }\n              let i;\n              for (i = 0; i < nCode; i += 1) {\n                  lens[dynamicTableOrder[i]] = fnBits(3);\n              }\n              for (; i < 19; i += 1) {\n                  lens[dynamicTableOrder[i]] = 0;\n              }\n              if (ZipFile.fnInflateConstruct(lenCode, lens, 19) !== 0) {\n                  throw that.composeError(Error(), \"Zip: inflate: length codes incomplete\", \"\", 0);\n              }\n              for (i = 0; i < nLen + nDist;) {\n                  let symbol = fnDecode(lenCode); // TTT\n                  /* eslint-disable max-depth */\n                  if (symbol < 16) {\n                      lens[i] = symbol;\n                      i += 1;\n                  }\n                  else {\n                      let len = 0;\n                      if (symbol === 16) {\n                          if (i === 0) {\n                              throw that.composeError(Error(), \"Zip: inflate: repeat lengths with no first length\", \"\", 0);\n                          }\n                          len = lens[i - 1];\n                          symbol = 3 + fnBits(2);\n                      }\n                      else if (symbol === 17) {\n                          symbol = 3 + fnBits(3);\n                      }\n                      else {\n                          symbol = 11 + fnBits(7);\n                      }\n                      if (i + symbol > nLen + nDist) {\n                          throw that.composeError(Error(), \"Zip: inflate: more lengths than specified\", \"\", 0);\n                      }\n                      while (symbol) {\n                          lens[i] = len;\n                          symbol -= 1;\n                          i += 1;\n                      }\n                  }\n                  /* eslint-enable max-depth */\n              }\n              const err1 = ZipFile.fnInflateConstruct(lenCode, lens, nLen), err2 = ZipFile.fnInflateConstruct(distCode, lens.slice(nLen), nDist);\n              if ((err1 < 0 || (err1 > 0 && nLen - lenCode.count[0] !== 1))\n                  || (err2 < 0 || (err2 > 0 && nDist - distCode.count[0] !== 1))) {\n                  throw that.composeError(Error(), \"Zip: inflate: bad literal or length codes\", \"\", 0);\n              }\n          }, fnInflateHuffmann = function () {\n              let symbol;\n              do { // decode deflated data\n                  symbol = fnDecode(lenCode); // TTT\n                  if (symbol < 256) {\n                      outBuf[outCnt] = symbol;\n                      outCnt += 1;\n                  }\n                  if (symbol > 256) {\n                      symbol -= 257;\n                      if (symbol > 28) {\n                          throw that.composeError(Error(), \"Zip: inflate: Invalid length/distance\", \"\", 0);\n                      }\n                      let len = startLens[symbol] + fnBits(lExt[symbol]);\n                      symbol = fnDecode(distCode); // TTT\n                      const dist = dists[symbol] + fnBits(dExt[symbol]);\n                      if (dist > outCnt) {\n                          throw that.composeError(Error(), \"Zip: inflate: distance out of range\", \"\", 0);\n                      }\n                      // instead of outbuf.slice, we use...\n                      while (len) {\n                          outBuf[outCnt] = outBuf[outCnt - dist];\n                          len -= 1;\n                          outCnt += 1;\n                      }\n                  }\n              } while (symbol !== 256);\n          };\n          let last;\n          do { // The actual inflation\n              last = fnBits(1);\n              const type = fnBits(2);\n              switch (type) {\n                  case 0: // STORED\n                      fnInflateStored();\n                      break;\n                  case 1:\n                  case 2: // fixed (=1) or dynamic (=2) huffman\n                      lenCode = {\n                          count: [],\n                          symbol: []\n                      };\n                      distCode = {\n                          count: [],\n                          symbol: []\n                      };\n                      lens = [];\n                      if (type === 1) { // construct fixed huffman tables\n                          ZipFile.fnConstructFixedHuffman(lens, lenCode, distCode);\n                      }\n                      else { // construct dynamic huffman tables\n                          fnConstructDynamicHuffman();\n                      }\n                      fnInflateHuffmann();\n                      break;\n                  default:\n                      throw this.composeError(Error(), \"Zip: inflate: unsupported compression type\" + type, \"\", 0);\n              }\n          } while (!last);\n          return outBuf;\n      }\n      readData(name) {\n          const cdfh = this.entryTable[name];\n          if (!cdfh) {\n              throw this.composeError(Error(), \"Zip: readData: file does not exist:\" + name, \"\", 0);\n          }\n          let dataUTF8 = \"\";\n          if (cdfh.compressionMethod === 0) { // stored\n              dataUTF8 = this.readUTF(cdfh.dataStart, cdfh.size);\n          }\n          else if (cdfh.compressionMethod === 8) { // deflated\n              const fileData = this.inflate(cdfh.dataStart, cdfh.compressedSize, cdfh.size), savedData = this.data;\n              this.data = fileData; // we need to switch this.data\n              dataUTF8 = this.readUTF(0, fileData.length);\n              this.data = savedData; // restore\n          }\n          else {\n              throw this.composeError(Error(), \"Zip: readData: compression method not supported:\" + cdfh.compressionMethod, \"\", 0);\n          }\n          if (dataUTF8.length !== cdfh.size) { // assert\n              Utils.console.error(\"Zip: readData: different length 2!\");\n          }\n          return dataUTF8;\n      }\n  }\n\n  // ===== dist/esm/FileHandler.js =====\n  // FileHandler.ts - FileHandler\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n\n\n\n  class FileHandler {\n      options;\n      static metaIdent = \"CpcLoco\";\n      processFileImports = true;\n      diskImage;\n      constructor(options) {\n          this.options = {};\n          this.setOptions(options);\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      getDiskImage() {\n          if (!this.diskImage) {\n              this.diskImage = new DiskImage({\n                  data: \"\" // will be set later\n              });\n          }\n          return this.diskImage;\n      }\n      static fnLocalStorageName(name, defaultExtension) {\n          // modify name so we do not clash with localstorage methods/properites\n          if (name.indexOf(\".\") < 0) { // no dot inside name?\n              name += \".\" + (defaultExtension || \"\"); // append dot or default extension\n          }\n          return name;\n      }\n      static getMetaIdent() {\n          return FileHandler.metaIdent;\n      }\n      static joinMeta(meta) {\n          return [\n              FileHandler.metaIdent,\n              meta.typeString,\n              meta.start,\n              meta.length,\n              meta.entry,\n              meta.encoding\n          ].join(\";\");\n      }\n      static reRegExpIsText = new RegExp(/^\\d+ |^[\\t\\r\\n\\x1a\\x20-\\x7e]*$/); // eslint-disable-line no-control-regex\n      // starting with (line) number, or 7 bit ASCII characters without control codes except \\x1a=EOF\n      processDskFile(data, name, imported) {\n          try {\n              const dsk = this.getDiskImage();\n              dsk.setOptions({\n                  data: data,\n                  diskName: name\n              });\n              const dir = dsk.readDirectory(), diskFiles = Object.keys(dir);\n              for (let i = 0; i < diskFiles.length; i += 1) {\n                  const fileName = diskFiles[i];\n                  try { // eslint-disable-line max-depth\n                      data = dsk.readFile(dir[fileName]);\n                      this.fnLoad2(data, fileName, \"\", imported); // recursive\n                  }\n                  catch (e) {\n                      Utils.console.error(e);\n                      if (e instanceof Error) { // eslint-disable-line max-depth\n                          this.options.outputError(e, true);\n                      }\n                  }\n              }\n          }\n          catch (e) {\n              Utils.console.error(e);\n              if (e instanceof Error) {\n                  this.options.outputError(e, true);\n              }\n          }\n      }\n      processZipFile(uint8Array, name, imported) {\n          let zip;\n          try {\n              zip = new ZipFile({\n                  data: uint8Array, // rather data\n                  zipName: name\n              });\n          }\n          catch (e) {\n              Utils.console.error(e);\n              if (e instanceof Error) {\n                  this.options.outputError(e, true);\n              }\n          }\n          if (zip) {\n              const zipDirectory = zip.getZipDirectory(), entries = Object.keys(zipDirectory);\n              for (let i = 0; i < entries.length; i += 1) {\n                  const name2 = entries[i];\n                  if (name2.startsWith(\"__MACOSX/\")) { // MacOS X creates some extra folder in ZIP files\n                      Utils.console.log(\"processZipFile: Ignoring file:\", name2);\n                  }\n                  else {\n                      let data2;\n                      try {\n                          data2 = zip.readData(name2);\n                      }\n                      catch (e) {\n                          Utils.console.error(e);\n                          if (e instanceof Error) { // eslint-disable-line max-depth\n                              this.options.outputError(e, true);\n                          }\n                      }\n                      if (data2) {\n                          this.fnLoad2(data2, name2, \"\", imported); // type not known but without meta\n                      }\n                  }\n              }\n          }\n      }\n      fnLoad2(data, name, type, imported) {\n          let header;\n          if (type === \"\" && !(data instanceof Uint8Array)) { // detetermine type\n              header = DiskImage.parseAmsdosHeader(data);\n              if (header) {\n                  type = \"H\"; // with header\n                  data = data.substring(0x80); // remove header\n              }\n              else if (FileHandler.reRegExpIsText.test(data)) {\n                  type = \"A\";\n              }\n              else if (Snapshot.testSnapIdent(data.substring(0, 8))) { // snapshot file?\n                  type = \"S\";\n              }\n              else if (DiskImage.testDiskIdent(data.substring(0, 8))) { // disk image file?\n                  type = \"X\";\n              }\n          }\n          switch (type) {\n              case \"A\": // \"text/plain\"\n              case \"B\": // binary?\n                  header = DiskImage.createAmsdosHeader({\n                      typeString: type,\n                      length: data.length\n                  });\n                  break;\n              case \"H\": // with header?\n                  break;\n              case \"S\": // sna file?\n                  header = DiskImage.createAmsdosHeader({\n                      typeString: type,\n                      length: data.length\n                  }); // currently we store it\n                  break;\n              case \"X\": // dsk file?\n                  if (this.processFileImports) {\n                      this.processDskFile(data, name, imported); // we know data is string\n                  }\n                  else {\n                      header = DiskImage.createAmsdosHeader({\n                          typeString: type,\n                          length: data.length\n                      });\n                  }\n                  break;\n              case \"Z\": // zip file?\n                  if (this.processFileImports) {\n                      this.processZipFile(data instanceof Uint8Array ? data : Utils.string2Uint8Array(data), name, imported);\n                  }\n                  else {\n                      header = DiskImage.createAmsdosHeader({\n                          typeString: type,\n                          length: data.length\n                      });\n                  }\n                  break;\n              default:\n                  Utils.console.warn(\"fnLoad2: \" + name + \": Unknown file type: \" + type + \", assuming B\");\n                  header = DiskImage.createAmsdosHeader({\n                      typeString: \"B\",\n                      length: data.length\n                  });\n                  break;\n          }\n          if (header) { // do we have a header? (means we should store it as a file in storage...)\n              const storageName = FileHandler.fnLocalStorageName(this.options.adaptFilename(name, \"FILE\")), meta = FileHandler.joinMeta(header), dataAsString = data instanceof Uint8Array ? Utils.uint8Array2string(data) : data;\n              try {\n                  Utils.localStorage.setItem(storageName, meta + \",\" + dataAsString);\n                  this.options.updateStorageDatabase(\"set\", storageName);\n                  Utils.console.log(\"fnOnLoad: file: \" + storageName + \" meta: \" + meta + \" imported\");\n                  imported.push(name);\n              }\n              catch (e) { // maybe quota exceeded\n                  Utils.console.error(e);\n                  if (e instanceof Error) {\n                      if (e.name === \"QuotaExceededError\") {\n                          e.shortMessage = storageName + \": Quota exceeded\";\n                      }\n                      this.options.outputError(e, true);\n                  }\n              }\n          }\n      }\n  }\n\n  // ===== dist/esm/FileSelect.js =====\n  // FileSelect.ts - FileSelect\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n\n  class FileSelect {\n      options;\n      fnOnErrorHandler;\n      fnOnLoadHandler;\n      fnOnFileSelectHandler;\n      files;\n      fileIndex = 0;\n      imported = []; // imported file names\n      file; // current file\n      constructor(options) {\n          this.fnOnLoadHandler = this.fnOnLoad.bind(this);\n          this.fnOnErrorHandler = this.fnOnError.bind(this);\n          this.fnOnFileSelectHandler = this.fnOnFileSelect.bind(this);\n          this.options = {};\n          this.setOptions(options);\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      fnReadNextFile(reader) {\n          if (this.files && this.fileIndex < this.files.length) {\n              const file = this.files[this.fileIndex];\n              this.fileIndex += 1;\n              const lastModified = file.lastModified, lastModifiedDate = lastModified ? new Date(lastModified) : file.lastModifiedDate, // lastModifiedDate deprecated, but for old IE\n              text = file.name + \" \" + (file.type || \"n/a\") + \" \" + file.size + \" \" + (lastModifiedDate ? lastModifiedDate.toLocaleDateString() : \"n/a\");\n              Utils.console.log(text);\n              if (file.type === \"text/plain\") {\n                  reader.readAsText(file);\n              }\n              else if (file.type === \"application/x-zip-compressed\" || file.type === \"application/zip\") { // on Mac OS it is \"application/zip\"\n                  reader.readAsArrayBuffer(file);\n              }\n              else {\n                  reader.readAsDataURL(file);\n              }\n              this.file = file;\n          }\n          else {\n              this.options.fnEndOfImport(this.imported);\n          }\n      }\n      fnOnLoad(event) {\n          if (!this.file) {\n              Utils.console.error(\"fnOnLoad: Programming error: No file\");\n              return;\n          }\n          const file = this.file, name = file.name, reader = event.target;\n          let data = (reader && reader.result) || null, type = file.type;\n          if ((type === \"application/x-zip-compressed\" || type === \"application/zip\") && data instanceof ArrayBuffer) { // on Mac OS it is \"application/zip\"\n              type = \"Z\";\n              this.options.fnLoad2(new Uint8Array(data), name, type, this.imported);\n          }\n          else if (typeof data === \"string\") {\n              if (type === \"text/plain\") { // \"text/plain\"\n                  type = \"A\";\n              }\n              else if (data.indexOf(\"data:\") === 0) {\n                  // check for meta info in data: data:application/octet-stream;base64, or: data:text/javascript;base64,\n                  const index = data.indexOf(\",\");\n                  if (index >= 0) {\n                      const info1 = data.substring(0, index);\n                      // remove meta prefix\n                      data = data.substring(index + 1);\n                      if (info1.indexOf(\"base64\") >= 0) {\n                          data = Utils.atob(data); // decode base64\n                      }\n                      if (info1.indexOf(\"text/\") >= 0) {\n                          type = \"A\";\n                      }\n                  }\n              }\n              this.options.fnLoad2(data, name, type, this.imported);\n          }\n          else {\n              Utils.console.warn(\"Error loading file\", name, \"with type\", type, \" unexpected data:\", data);\n          }\n          if (reader) {\n              this.fnReadNextFile(reader);\n          }\n      }\n      fnOnError(event) {\n          const reader = event.target, filename = (this.file && this.file.name) || \"unknown\";\n          let msg = \"fnOnError: \" + filename;\n          if (reader && reader.error) {\n              msg += \": \" + String(reader.error);\n          }\n          Utils.console.error(msg);\n          if (reader) {\n              this.fnReadNextFile(reader);\n          }\n      }\n      // https://stackoverflow.com/questions/10261989/html5-javascript-drag-and-drop-file-from-external-window-windows-explorer\n      // https://www.w3.org/TR/file-upload/#dfn-filereader\n      fnOnFileSelect(event) {\n          event.stopPropagation();\n          event.preventDefault();\n          const dataTransfer = event.dataTransfer, files = dataTransfer ? dataTransfer.files : View.getEventTarget(event).files; // dataTransfer for drag&drop, target.files for file input\n          if (!files || !files.length) {\n              Utils.console.error(\"fnHandleFileSelect: No files!\");\n              return;\n          }\n          this.files = files;\n          this.fileIndex = 0;\n          this.imported.length = 0;\n          if (window.FileReader) {\n              const reader = new window.FileReader();\n              reader.onerror = this.fnOnErrorHandler;\n              reader.onload = this.fnOnLoadHandler;\n              this.fnReadNextFile(reader);\n          }\n          else {\n              Utils.console.warn(\"fnHandleFileSelect: FileReader API not supported.\");\n          }\n      }\n      //TODO: can we use View.attachEventHandler() somehow?\n      addFileSelectHandler(element, type) {\n          element.addEventListener(type, this.fnOnFileSelectHandler, false);\n      }\n  }\n\n  // ===== dist/esm/InputStack.js =====\n  // InputStack.ts - InputStack...\n  // see: https://github.com/jzaefferer/undo\n  //\n  class InputStack {\n      input = [];\n      stackPosition = -1;\n      reset() {\n          this.input.length = 0;\n          this.stackPosition = -1;\n      }\n      getInput() {\n          return this.input[this.stackPosition];\n      }\n      clearRedo() {\n          this.input = this.input.slice(0, this.stackPosition + 1);\n      }\n      save(input) {\n          this.clearRedo();\n          this.input.push(input);\n          this.stackPosition += 1;\n      }\n      canUndoKeepOne() {\n          return this.stackPosition > 0;\n      }\n      undo() {\n          this.stackPosition -= 1;\n          return this.getInput();\n      }\n      canRedo() {\n          return this.stackPosition < this.input.length - 1;\n      }\n      redo() {\n          this.stackPosition += 1;\n          return this.getInput();\n      }\n  }\n\n  // ===== dist/esm/Keyboard.js =====\n  // Keyboard.ts - Keyboard handling\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n  class Keyboard {\n      fnKeydownOrKeyupHandler;\n      options;\n      keyBuffer = []; // buffered pressed keys\n      expansionTokens = []; // strings for expansion tokens 0..31 (in reality: 128..159)\n      cpcKeyExpansions; // cpc keys to expansion tokens for normal, shift, ctrl; also repeat\n      active = false; // flag if keyboard is active/focused, set from outside\n      key2CpcKey;\n      codeStringsRemoved = false;\n      pressedKeys = {}; // currently pressed browser keys\n      simulatedNumLock; // simulated num lock for Mac OS\n      constructor(options) {\n          this.fnKeydownOrKeyupHandler = this.onKeydownOrKeyup.bind(this);\n          this.options = {};\n          this.setOptions(options);\n          this.key2CpcKey = Keyboard.key2CpcKey;\n          this.cpcKeyExpansions = {\n              normal: {},\n              shift: {},\n              ctrl: {},\n              repeat: {}\n          }; // cpc keys to expansion tokens for normal, shift, ctrl; also repeat\n          const view = this.options.view;\n          view.addEventListenerById(\"keydown\", this.fnKeydownOrKeyupHandler, \"cpcArea\" /* ViewID.cpcArea */);\n          view.addEventListenerById(\"keyup\", this.fnKeydownOrKeyupHandler, \"cpcArea\" /* ViewID.cpcArea */);\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      // use this:\n      static key2CpcKey = {\n          \"38ArrowUp\": 0,\n          \"39ArrowRight\": 1,\n          \"40ArrowDown\": 2,\n          \"105Numpad9\": 3,\n          \"120F9\": 3,\n          \"102Numpad6\": 4,\n          \"117F6\": 4,\n          \"99Numpad3\": 5,\n          \"114F3\": 5,\n          \"13NumpadEnter\": 6,\n          \"110NumpadDecimal\": 7,\n          \"37ArrowLeft\": 8,\n          \"18AltLeft\": 9,\n          \"103Numpad7\": 10,\n          \"118F7\": 10,\n          \"104Numpad8\": 11,\n          \"119F8\": 11,\n          \"101Numpad5\": 12,\n          \"116F5\": 12,\n          \"97Numpad1\": 13,\n          \"112F1\": 13,\n          \"98Numpad2\": 14,\n          \"113F2\": 14,\n          \"96Numpad0\": 15,\n          \"121F10\": 15,\n          \"46Delete\": 16,\n          \"187BracketRight\": 17,\n          \"171BracketRight\": 17,\n          \"221BracketRight\": 17,\n          \"13Enter\": 18,\n          \"191Backslash\": 19,\n          \"163Backslash\": 19,\n          \"220Backslash\": 19,\n          \"100Numpad4\": 20,\n          \"115F4\": 20,\n          \"16ShiftLeft\": 21,\n          \"16ShiftRight\": 21,\n          \"220Backquote\": 22,\n          \"160Backquote\": 22,\n          \"192Backquote\": 22,\n          \"17ControlLeft\": 23,\n          \"17ControlRight\": 23,\n          \"221Equal\": 24,\n          \"192Equal\": 24,\n          \"187Equal\": 24,\n          \"219Minus\": 25,\n          \"63Minus\": 25,\n          \"189Minus\": 25,\n          \"186BracketLeft\": 26,\n          \"59BracketLeft\": 26,\n          \"219BracketLeft\": 26,\n          \"80KeyP\": 27,\n          \"222Quote\": 28,\n          \"192Quote\": 28,\n          \"192Semicolon\": 29,\n          \"186Semicolon\": 29,\n          \"189Slash\": 30,\n          \"173Slash\": 30,\n          \"191Slash\": 30,\n          \"190Period\": 31,\n          \"48Digit0\": 32,\n          \"57Digit9\": 33,\n          \"79KeyO\": 34,\n          \"73KeyI\": 35,\n          \"76KeyL\": 36,\n          \"75KeyK\": 37,\n          \"77KeyM\": 38,\n          \"188Comma\": 39,\n          \"56Digit8\": 40,\n          \"55Digit7\": 41,\n          \"85KeyU\": 42,\n          \"90KeyY\": 43,\n          \"89KeyY\": 43,\n          \"72KeyH\": 44,\n          \"74KeyJ\": 45,\n          \"78KeyN\": 46,\n          \"32Space\": 47,\n          \"54Digit6\": 48,\n          \"53Digit5\": 49,\n          \"82KeyR\": 50,\n          \"84KeyT\": 51,\n          \"71KeyG\": 52,\n          \"70KeyF\": 53,\n          \"66KeyB\": 54,\n          \"86KeyV\": 55,\n          \"52Digit4\": 56,\n          \"51Digit3\": 57,\n          \"69KeyE\": 58,\n          \"87KeyW\": 59,\n          \"83KeyS\": 60,\n          \"68KeyD\": 61,\n          \"67KeyC\": 62,\n          \"88KeyX\": 63,\n          \"49Digit1\": 64,\n          \"50Digit2\": 65,\n          \"27Escape\": 66,\n          \"81KeyQ\": 67,\n          \"9Tab\": 68,\n          \"65KeyA\": 69,\n          \"20CapsLock\": 70,\n          \"89KeyZ\": 71,\n          \"90KeyZ\": 71,\n          \"38Numpad8\": 72,\n          \"40Numpad2\": 73,\n          \"37Numpad4\": 74,\n          \"39Numpad6\": 75,\n          \"12Numpad5\": 76,\n          \"45Numpad0\": 76,\n          \"46NumpadDecimal\": 77,\n          \"8Backspace\": 79,\n          \"36Numpad7\": 80,\n          \"33Numpad9\": 81,\n          \"35Numpad1\": 82,\n          \"34Numpad3\": 83,\n          \"226IntlBackslash\": 85,\n          \"60IntlBackslash\": 85,\n          \"220IntlBackslash\": 85,\n          \"111NumpadDivide\": 86,\n          \"106NumpadMultiply\": 87,\n          \"109NumpadSubtract\": 88,\n          \"107NumpadAdd\": 89\n      };\n      static specialKeys = {\n          Alt: String.fromCharCode(224), // Copy\n          ArrowUp: String.fromCharCode(240),\n          ArrowDown: String.fromCharCode(241),\n          ArrowLeft: String.fromCharCode(242),\n          ArrowRight: String.fromCharCode(243),\n          ArrowUpShift: String.fromCharCode(244),\n          ArrowDownShift: String.fromCharCode(245),\n          ArrowLeftShift: String.fromCharCode(246),\n          ArrowRightShift: String.fromCharCode(247),\n          ArrowUpCtrl: String.fromCharCode(248),\n          ArrowDownCtrl: String.fromCharCode(249),\n          ArrowLeftCtrl: String.fromCharCode(250),\n          ArrowRightCtrl: String.fromCharCode(251),\n          Backspace: String.fromCharCode(127),\n          Delete: String.fromCharCode(16),\n          Enter: \"\\r\",\n          JoyUp: String.fromCharCode(11),\n          JoyDown: String.fromCharCode(10),\n          JoyLeft: String.fromCharCode(8),\n          JoyRight: String.fromCharCode(9),\n          Clear: \"X\", // joy fire 2\n          Spacebar: \" \", // for IE\n          Tab: String.fromCharCode(9),\n          : \";\",\n          : \"+\",\n          : \":\",\n          : \"*\",\n          : \"@\",\n          : \"|\",\n          : \"-\",\n          DeadBackquote: \"^\",\n          \"\": \"\",\n          DeadEqual: String.fromCharCode(161), // tick\n          \"\": String.fromCharCode(161), // IE: tick\n          DeadEqualShift: \"`\" // backtick\n      };\n      /* eslint-disable array-element-newline */\n      static joyKeyCodes = [\n          [72, 73, 74, 75, 76, 77],\n          [48, 49, 50, 51, 52, 53]\n      ];\n      /* eslint-enable array-element-newline */\n      reset() {\n          this.options.fnOnKeyDown = undefined;\n          this.clearInput();\n          this.pressedKeys = {}; // currently pressed browser keys\n          this.resetExpansionTokens();\n          this.resetCpcKeysExpansions();\n      }\n      clearInput() {\n          this.keyBuffer.length = 0;\n      }\n      resetExpansionTokens() {\n          const expansionTokens = this.expansionTokens;\n          for (let i = 0; i <= 9; i += 1) {\n              expansionTokens[i] = String(i);\n          }\n          expansionTokens[10] = \".\";\n          expansionTokens[11] = \"\\r\";\n          expansionTokens[12] = 'RUN\"\\r';\n          for (let i = 13; i <= 31; i += 1) {\n              expansionTokens[i] = \"0\";\n          }\n      }\n      resetCpcKeysExpansions() {\n          const cpcKeyExpansions = this.cpcKeyExpansions;\n          cpcKeyExpansions.normal = {\n              15: 0 + 128, // F0\n              13: 1 + 128, // F1\n              14: 2 + 128, // F2\n              5: 3 + 128, // F3\n              20: 4 + 128, // F4\n              12: 5 + 128, // F5\n              4: 6 + 128, // F6\n              10: 7 + 128, // F7\n              11: 8 + 128, // F8\n              3: 9 + 128, // F9\n              7: 10 + 128, // F.\n              6: 11 + 128 // Enter\n          };\n          cpcKeyExpansions.shift = {};\n          cpcKeyExpansions.ctrl = {\n              6: 12 + 128 // ctrl+Enter\n          };\n          cpcKeyExpansions.repeat = {};\n      }\n      setActive(active) {\n          this.active = active;\n      }\n      removeCodeStringsFromKeymap() {\n          const key2CpcKey = this.key2CpcKey, newMap = {};\n          if (Utils.debug > 1) {\n              Utils.console.log(\"removeCodeStringsFromKeymap: Unfortunately not all keys can be used.\");\n          }\n          for (const key in key2CpcKey) {\n              if (key2CpcKey.hasOwnProperty(key)) {\n                  const keyCode = parseInt(key, 10); // get just the number\n                  newMap[keyCode] = key2CpcKey[key];\n              }\n          }\n          this.key2CpcKey = newMap;\n      }\n      fnPressCpcKey(event, cpcKeyCode, pressedKey, key) {\n          const shiftKey = event.shiftKey, ctrlKey = event.ctrlKey, pressedKeys = this.pressedKeys, cpcKeyExpansions = this.cpcKeyExpansions, specialKeys = Keyboard.specialKeys, cpcKey = String(cpcKeyCode);\n          let cpcKeyEntry = pressedKeys[cpcKey];\n          if (!cpcKeyEntry) {\n              pressedKeys[cpcKey] = {\n                  keys: {},\n                  shift: false,\n                  ctrl: false\n              };\n              cpcKeyEntry = pressedKeys[cpcKey];\n          }\n          const keyAlreadyPressed = cpcKeyEntry.keys[pressedKey];\n          cpcKeyEntry.keys[pressedKey] = true;\n          cpcKeyEntry.shift = shiftKey;\n          cpcKeyEntry.ctrl = ctrlKey;\n          if (Utils.debug > 1) {\n              Utils.console.log(\"fnPressCpcKey: pressedKey=\" + pressedKey + \", key=\" + key + \", affected cpc key=\" + cpcKey);\n          }\n          const repeat = cpcKeyExpansions.repeat;\n          if (keyAlreadyPressed && ((cpcKey in repeat) && !repeat[cpcKey])) {\n              key = \"\"; // repeat off => ignore key\n          }\n          else {\n              let expansions;\n              if (ctrlKey) {\n                  expansions = cpcKeyExpansions.ctrl;\n              }\n              else if (shiftKey) {\n                  expansions = cpcKeyExpansions.shift;\n              }\n              else {\n                  expansions = cpcKeyExpansions.normal;\n              }\n              if (cpcKey in expansions) {\n                  const expKey = expansions[cpcKey];\n                  if (expKey >= 128 && expKey <= 159) {\n                      key = this.expansionTokens[expKey - 128];\n                      for (let i = 0; i < key.length; i += 1) {\n                          this.putKeyInBuffer(key.charAt(i));\n                      }\n                  }\n                  else { // ascii code\n                      key = String.fromCharCode(expKey);\n                      this.putKeyInBuffer(key.charAt(0));\n                  }\n                  key = \"\"; // already done, ignore key form keyboard\n              }\n          }\n          const shiftCtrlKey = key + (shiftKey ? \"Shift\" : \"\") + (ctrlKey ? \"Ctrl\" : \"\");\n          if (shiftCtrlKey in specialKeys) {\n              key = specialKeys[shiftCtrlKey];\n          }\n          else if (key in specialKeys) {\n              key = specialKeys[key];\n          }\n          else if (ctrlKey) {\n              if (key >= \"a\" && key <= \"z\") { // map keys with ctrl to control codes (problem: some control codes are browser functions, e.g. w: close window)\n                  key = String.fromCharCode(key.charCodeAt(0) - 96); // ctrl+a => \\x01\n              }\n          }\n          if (key.length === 1) { // put normal keys in buffer, ignore special keys with more than 1 character\n              this.putKeyInBuffer(key);\n          }\n          if (cpcKeyCode === 66 && this.options.fnOnEscapeHandler) { // or: key === \"Escape\" or \"Esc\" (on IE)\n              this.options.fnOnEscapeHandler(key, pressedKey);\n          }\n          if (this.options.fnOnKeyDown) { // special handler?\n              this.options.fnOnKeyDown();\n          }\n      }\n      fnReleaseCpcKey(event, cpcKeyCode, pressedKey, key) {\n          const shiftKey = event.shiftKey, ctrlKey = event.ctrlKey, pressedKeys = this.pressedKeys, cpcKey = pressedKeys[cpcKeyCode];\n          if (Utils.debug > 1) {\n              Utils.console.log(\"fnReleaseCpcKey: pressedKey=\" + pressedKey + \", key=\" + key + \", affected cpc key=\" + cpcKeyCode + \", keys:\", (cpcKey ? cpcKey.keys : \"undef.\"));\n          }\n          if (!cpcKey) {\n              Utils.console.warn(\"fnReleaseCpcKey: cpcKey was not pressed:\", cpcKeyCode);\n          }\n          else {\n              delete cpcKey.keys[pressedKey];\n              if (!Object.keys(cpcKey.keys).length) {\n                  delete pressedKeys[cpcKeyCode];\n              }\n              else {\n                  cpcKey.shift = shiftKey;\n                  cpcKey.ctrl = ctrlKey;\n              }\n          }\n      }\n      static keyIdentifier2Char(event) {\n          // SliTaz web browser has not key but keyIdentifier\n          const identifier = event.keyIdentifier, // eslint-disable-line @typescript-eslint/no-explicit-any\n          shiftKey = event.shiftKey;\n          let char = \"\";\n          if ((/^U\\+/i).test(identifier || \"\")) { // unicode string?\n              char = String.fromCharCode(parseInt(identifier.substr(2), 16));\n              if (char === \"\\0\") { // ignore\n                  char = \"\";\n              }\n              char = shiftKey ? char.toUpperCase() : char.toLowerCase(); // do we get keys in unicode always in uppercase?\n          }\n          else {\n              char = identifier; // take it, could be \"Enter\"\n          }\n          return char;\n      }\n      static numPadOffKeyMap = {\n          \"96Numpad0\": \"45Numpad0\",\n          \"97Numpad1\": \"35Numpad1\",\n          \"98Numpad2\": \"40Numpad2\",\n          \"99Numpad3\": \"34Numpad3\",\n          \"100Numpad4\": \"37Numpad4\",\n          \"101Numpad5\": \"12Numpad5\",\n          \"102Numpad6\": \"39Numpad6\",\n          \"103Numpad7\": \"36Numpad7\",\n          \"104Numpad8\": \"38Numpad8\",\n          \"105Numpad9\": \"33Numpad9\",\n          \"110NumpadDecimal\": \"46NumpadDecimal\"\n      };\n      fnKeyboardKeydown(event) {\n          const keyCode = event.which || event.keyCode;\n          let pressedKey = String(keyCode) + (event.code ? event.code : \"\"), // event.code available for e.g. Chrome, Firefox\n          key = event.key || Keyboard.keyIdentifier2Char(event) || \"\"; // SliTaz web browser has not key but keyIdentifier\n          if (!event.code && !this.codeStringsRemoved) { // event.code not available on e.g. IE, Edge\n              this.removeCodeStringsFromKeymap(); // remove code information from the mapping. Not all keys can be detected any more\n              this.codeStringsRemoved = true;\n          }\n          if (Utils.debug > 1) {\n              Utils.console.log(\"fnKeyboardKeydown: keyCode=\" + keyCode + \" pressedKey=\" + pressedKey + \" key='\" + key + \"' \" + key.charCodeAt(0) + \" loc=\" + event.location + \" \", event);\n          }\n          if (pressedKey in this.key2CpcKey) {\n              const numTabOffKey = this.simulatedNumLock === false ? Keyboard.numPadOffKeyMap[pressedKey] : undefined;\n              if (numTabOffKey) {\n                  pressedKey = numTabOffKey;\n              }\n              let cpcKey = this.key2CpcKey[pressedKey];\n              if (cpcKey === 85) { // map virtual cpc key 85 to 22 (english keyboard)\n                  cpcKey = 22;\n              }\n              // map numpad cursor to joystick\n              if (cpcKey === 72) {\n                  key = \"JoyUp\";\n              }\n              else if (cpcKey === 73) {\n                  key = \"JoyDown\";\n              }\n              else if (cpcKey === 74) {\n                  key = \"JoyLeft\";\n              }\n              else if (cpcKey === 75) {\n                  key = \"JoyRight\";\n              }\n              else if (key === \"Dead\") { // Chrome, FF\n                  key += event.code + (event.shiftKey ? \"Shift\" : \"\"); // special handling => \"DeadBackquote\" or \"DeadEqual\"; and \"Shift\"\n              }\n              else if (key === \"Unidentified\") { // IE, Edge\n                  if (keyCode === 220) {\n                      key = event.shiftKey ? \"\" : \"DeadBackquote\";\n                  }\n                  else if (keyCode === 221) {\n                      key = \"DeadEqual\" + (event.shiftKey ? \"Shift\" : \"\");\n                  }\n                  else if (keyCode === 226) { // \"|\"\n                      key = \"|\";\n                  }\n              }\n              else if (key.length === 2) {\n                  if (key.charAt(0) === \"^\" || key.charAt(0) === \"\" || key.charAt(0) === \"`\") { // IE, Edge? prefix key\n                      key = key.substring(1); // remove prefix\n                  }\n              }\n              this.fnPressCpcKey(event, cpcKey, pressedKey, key);\n          }\n          else if (key.length === 1) { // put normal keys in buffer, ignore special keys with more than 1 character\n              this.putKeyInBuffer(key);\n              Utils.console.log(\"fnKeyboardKeydown: Partly unhandled key\", pressedKey + \":\", key);\n          }\n          else if (pressedKey === \"12NumLock\") { // key = \"Clear\"; MacOS\n              this.simulatedNumLock = this.simulatedNumLock !== undefined ? !this.simulatedNumLock : false;\n              if (Utils.debug > 1) {\n                  Utils.console.log(\"fnKeyboardKeydown: simulatedNumLock=\" + this.simulatedNumLock);\n              }\n          }\n          else {\n              Utils.console.log(\"fnKeyboardKeydown: Unhandled key\", pressedKey + \":\", key);\n          }\n      }\n      fnKeyboardKeyup(event) {\n          const keyCode = event.which || event.keyCode, key = event.key || Keyboard.keyIdentifier2Char(event) || \"\"; // SliTaz web browser has not key but keyIdentifier\n          let pressedKey = String(keyCode) + (event.code ? event.code : \"\"); // event.code available for e.g. Chrome, Firefox\n          if (Utils.debug > 1) {\n              Utils.console.log(\"fnKeyboardKeyup: keyCode=\" + keyCode + \" pressedKey=\" + pressedKey + \" key='\" + key + \"' \" + key.charCodeAt(0) + \" loc=\" + event.location + \" \", event);\n          }\n          if (pressedKey in this.key2CpcKey) {\n              const numTabOffKey = this.simulatedNumLock === false ? Keyboard.numPadOffKeyMap[pressedKey] : undefined;\n              if (numTabOffKey) {\n                  pressedKey = numTabOffKey;\n              }\n              let cpcKey = this.key2CpcKey[pressedKey];\n              if (cpcKey === 85) { // map virtual cpc key 85 to 22 (english keyboard)\n                  cpcKey = 22;\n              }\n              this.fnReleaseCpcKey(event, cpcKey, pressedKey, key);\n          }\n          else if (pressedKey === \"12NumLock\") { // key = \"Clear\"; MacOS\n              if (Utils.debug > 1) {\n                  Utils.console.log(\"fnKeyboardKeyup: simulatedNumLock=\" + this.simulatedNumLock);\n              }\n          }\n          else {\n              Utils.console.log(\"fnKeyboardKeyup: Unhandled key\", pressedKey + \":\", key);\n          }\n      }\n      getKeyFromBuffer() {\n          const keyBuffer = this.keyBuffer, key = keyBuffer.length ? keyBuffer.shift() : \"\";\n          return key;\n      }\n      putKeyInBuffer(key, triggerOnKeyDown) {\n          this.keyBuffer.push(key);\n          if (triggerOnKeyDown) {\n              const keyDownHandler = this.options.fnOnKeyDown;\n              if (keyDownHandler) {\n                  keyDownHandler();\n              }\n          }\n      }\n      putKeysInBuffer(input) {\n          for (let i = 0; i < input.length; i += 1) {\n              const key = input.charAt(i);\n              this.keyBuffer.push(key);\n          }\n      }\n      getKeyState(cpcKeyCode) {\n          const pressedKeys = this.pressedKeys;\n          let state = -1;\n          if (cpcKeyCode in pressedKeys) {\n              const cpcKeyEntry = pressedKeys[cpcKeyCode];\n              state = 0 + (cpcKeyEntry.shift ? 32 : 0) + (cpcKeyEntry.ctrl ? 128 : 0);\n          }\n          return state;\n      }\n      getJoyState(joy) {\n          const joyKeyList = Keyboard.joyKeyCodes[joy];\n          let value = 0;\n          /* eslint-disable no-bitwise */\n          for (let i = 0; i < joyKeyList.length; i += 1) {\n              if (this.getKeyState(joyKeyList[i]) !== -1) {\n                  value |= (1 << i);\n              }\n          }\n          // check additional special codes for joy 0 (not available on CPC)\n          if (joy === 0) {\n              if (this.getKeyState(80) !== -1) { // up left\n                  value |= 1 + 4;\n              }\n              if (this.getKeyState(81) !== -1) { // up right\n                  value |= 1 + 8;\n              }\n              if (this.getKeyState(82) !== -1) { // down left\n                  value |= 2 + 4;\n              }\n              if (this.getKeyState(83) !== -1) { // down right\n                  value |= 2 + 8;\n              }\n          }\n          /* eslint-enable no-bitwise */\n          return value;\n      }\n      setExpansionToken(token, string) {\n          this.expansionTokens[token] = string;\n      }\n      setCpcKeyExpansion(options) {\n          const cpcKeyExpansions = this.cpcKeyExpansions, cpcKey = options.cpcKey;\n          cpcKeyExpansions.repeat[cpcKey] = options.repeat;\n          if (options.normal !== undefined) {\n              cpcKeyExpansions.normal[cpcKey] = options.normal;\n          }\n          if (options.shift !== undefined) {\n              cpcKeyExpansions.shift[cpcKey] = options.shift;\n          }\n          if (options.ctrl !== undefined) {\n              cpcKeyExpansions.ctrl[cpcKey] = options.ctrl;\n          }\n      }\n      onKeydownOrKeyup(event) {\n          if (this.active) {\n              if (event.type === \"keydown\") {\n                  this.fnKeyboardKeydown(event);\n              }\n              else if (event.type === \"keyup\") {\n                  this.fnKeyboardKeyup(event);\n              }\n              else {\n                  Utils.console.error(\"onKeydownOrKeyup: Unknown type:\", event.type);\n              }\n              event.preventDefault();\n              return false;\n          }\n          return undefined;\n      }\n  }\n\n  // ===== dist/esm/NoCanvas.js =====\n  // NoCanvas.ts - No Canvas\n  // (c) Marco Vieth, 2023\n  // https://benchmarko.github.io/cpclocots/\n  //\n  class NoCanvas {\n      options;\n      constructor(options) {\n          this.options = {};\n          this.setOptions(options);\n          this.reset();\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      reset() {\n      }\n      resetCustomChars() {\n      }\n      setScreenOffset(_offset) {\n      }\n      updateColorsAndCanvasImmediately(_inkList) {\n      }\n      updateSpeedInk() {\n      }\n      setCustomChar(_char, _charData) {\n      }\n      getCharData(_char) {\n          return [];\n      }\n      setDefaultInks() {\n      }\n      onCanvasClick(_event) {\n      }\n      getXpos() {\n          return 0;\n      }\n      getYpos() {\n          return 0;\n      }\n      getByte(_addr) {\n          return 0;\n      }\n      setByte(_addr, _byte) {\n      }\n      draw(_x, _y) {\n      }\n      move(_x, _y) {\n      }\n      plot(_x, _y) {\n      }\n      test(_x, _y) {\n          return 0;\n      }\n      setInk(_pen, _ink1, _ink2) {\n          return false;\n      }\n      setBorder(_ink1, _ink2) {\n      }\n      setGPen(_gPen) {\n      }\n      setGPaper(_gPaper) {\n      }\n      setGTransparentMode(_transparent) {\n      }\n      printGChar(_char) {\n      }\n      drawCursor(_x, _y, _pen, _paper) {\n      }\n      fill(_fillPen) {\n      }\n      setOrigin(_xOrig, _yOrig) {\n      }\n      getXOrigin() {\n          return 0;\n      }\n      getYOrigin() {\n          return 0;\n      }\n      setGWindow(_xLeft, _xRight, _yTop, _yBottom) {\n      }\n      setGColMode(_gColMode) {\n      }\n      clearGraphicsWindow() {\n      }\n      setSpeedInk(_time1, _time2) {\n      }\n      setMask(_mask) {\n      }\n      setMaskFirst(_maskFirst) {\n      }\n      getMode() {\n          return 0;\n      }\n      changeMode(_mode) {\n      }\n      takeScreenShot() {\n          return \"\";\n      }\n      startUpdateCanvas() {\n      }\n      stopUpdateCanvas() {\n      }\n      onWindowClick(_event) {\n      }\n      fillTextBox(_left, _top, _width, _height, _paper) {\n      }\n      printChar(_char, _x, _y, _pen, _paper, _transparent) {\n      }\n      readChar(_x, _y, _pen, _paper) {\n          return 0;\n      }\n      clearTextWindow(_left, _right, _top, _bottom, _paper) {\n      }\n      setMode(_mode) {\n      }\n      clearFullWindow() {\n      }\n      windowScrollUp(_left, _right, _top, _bottom, _paper) {\n      }\n      windowScrollDown(_left, _right, _top, _bottom, _paper) {\n      }\n  }\n\n  // ===== dist/esm/TextCanvas.js =====\n  // TextCanvas.ts - Text \"Canvas\"\n  // (c) Marco Vieth, 2022\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n  class TextCanvas {\n      options;\n      fnUpdateCanvasHandler;\n      fnUpdateCanvas2Handler;\n      fps = 15; // FPS for canvas update\n      isRunning = false;\n      animationTimeoutId;\n      animationFrame;\n      cpcAreaBox;\n      textText;\n      borderWidth = 1;\n      cols;\n      rows;\n      needUpdate = false;\n      textBuffer = []; // textbuffer characters at row,column\n      hasFocus = false; // canvas has focus\n      customCharset = {};\n      constructor(options) {\n          this.options = {};\n          this.setOptions(options);\n          this.textText = View.getElementByIdAs(this.options.canvasID);\n          this.cpcAreaBox = View.getElementById1(\"cpcArea\" /* ViewID.cpcArea */);\n          this.fnUpdateCanvasHandler = this.updateCanvas.bind(this);\n          this.fnUpdateCanvas2Handler = this.updateCanvas2.bind(this);\n          this.cols = parseFloat(this.textText.getAttribute(\"cols\") || \"0\");\n          this.rows = parseFloat(this.textText.getAttribute(\"rows\") || \"0\");\n          this.animationTimeoutId = undefined;\n          this.animationFrame = undefined;\n          this.reset();\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      // CPC Unicode map for text mode (https://www.unicode.org/L2/L2019/19025-terminals-prop.pdf AMSCPC.TXT) incomplete; wider chars replaced by \".\"\n      // tooWide = [132,134,135,136,137,139,141,142,224,225,226,227,245];\n      // For equal height we set line-height: 15px;\n      static cpc2Unicode = \"................................ !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]\\u2195_`abcdefghijklmnopqrstuvwxyz{|}~\\u2591\\u00A0\\u2598\\u259D\\u2580.\\u258C....\\u2590.\\u2584..\\u2588\\u00B7\\u2575\\u2576\\u2514\\u2577\\u2502\\u250C\\u251C\\u2574\\u2518\\u2500\\u2534\\u2510\\u2524\\u252C\\u253C^\\u00B4\\u00A8\\u00A3\\u00A9\\u00B6\\u00A7\\u2018\\u00BC\\u00BD\\u00BE\\u00B1\\u00F7\\u00AC\\u00BF\\u00A1\\u03B1\\u03B2\\u03B3\\u03B4\\u03B5\\u03B8\\u03BB\\u03BC\\u03C0\\u03C3\\u03C6\\u03C8\\u03C7\\u03C9\\u03A3\\u03A9\\u1FBA0\\u1FBA1\\u1FBA3\\u1FBA2\\u1FBA7\\u1FBA5\\u1FBA6\\u1FBA4\\u1FBA8\\u1FBA9\\u1FBAE\\u2573\\u2571\\u2572\\u1FB95\\u2592\\u23BA\\u23B9\\u23BD\\u23B8....\\u1FB8E\\u1FB8D\\u1FB8F\\u1FB8C\\u1FB9C\\u1FB9D\\u1FB9E\\u1FB9F\\u263A.\\u2663\\u2666\\u2665\\u2660\\u25CB\\u25CF\\u25A1\\u25A0\\u2642\\u2640\";\n      // same as in CpcVm\n      static winData = [\n          {\n              left: 0,\n              right: 19,\n              top: 0,\n              bottom: 24\n          },\n          {\n              left: 0,\n              right: 39,\n              top: 0,\n              bottom: 24\n          },\n          {\n              left: 0,\n              right: 79,\n              top: 0,\n              bottom: 24\n          },\n          {\n              left: 0, // mode 3 not available on CPC\n              right: 79,\n              top: 0,\n              bottom: 49\n          }\n      ];\n      reset() {\n          this.resetTextBuffer();\n          this.setNeedUpdate();\n      }\n      resetCustomChars() {\n      }\n      setScreenOffset(_offset) {\n      }\n      updateColorsAndCanvasImmediately(_inkList) {\n      }\n      updateSpeedInk() {\n      }\n      setCustomChar(char, charData) {\n          this.customCharset[char] = charData;\n      }\n      getCharData(char) {\n          return this.customCharset[char] || this.options.charset[char];\n      }\n      setDefaultInks() {\n      }\n      getXpos() {\n          return 0;\n      }\n      getYpos() {\n          return 0;\n      }\n      getByte(_addr) {\n          return 0;\n      }\n      setByte(_addr, _byte) {\n      }\n      draw(_x, _y) {\n      }\n      move(_x, _y) {\n      }\n      plot(_x, _y) {\n      }\n      test(_x, _y) {\n          return 0;\n      }\n      setInk(_pen, _ink1, _ink2) {\n          return false;\n      }\n      setBorder(_ink1, _ink2) {\n      }\n      setGPen(_gPen) {\n      }\n      setGPaper(_gPaper) {\n      }\n      setGTransparentMode(_transparent) {\n      }\n      printGChar(_char) {\n      }\n      drawCursor(_x, _y, _pen, _paper) {\n      }\n      fill(_fillPen) {\n      }\n      setOrigin(_xOrig, _yOrig) {\n      }\n      getXOrigin() {\n          return 0;\n      }\n      getYOrigin() {\n          return 0;\n      }\n      setGWindow(_xLeft, _xRight, _yTop, _yBottom) {\n      }\n      setGColMode(_gColMode) {\n      }\n      clearGraphicsWindow() {\n      }\n      setSpeedInk(_time1, _time2) {\n      }\n      setMask(_mask) {\n      }\n      setMaskFirst(_maskFirst) {\n      }\n      getMode() {\n          return 0;\n      }\n      changeMode(_mode) {\n      }\n      takeScreenShot() {\n          return \"\";\n      }\n      resetTextBuffer() {\n          this.textBuffer.length = 0;\n      }\n      setNeedUpdate() {\n          this.needUpdate = true;\n      }\n      updateCanvas2() {\n          if (!this.isRunning) {\n              return; // ignore remaining timeouts, if stopped\n          }\n          this.animationFrame = requestAnimationFrame(this.fnUpdateCanvasHandler);\n          if (this.textText.offsetParent) { // text area visible?\n              if (this.needUpdate) {\n                  this.needUpdate = false;\n                  this.updateTextWindow();\n              }\n          }\n      }\n      updateCanvas() {\n          this.animationTimeoutId = window.setTimeout(this.fnUpdateCanvas2Handler, 1000 / this.fps); // ts (node)\n      }\n      startUpdateCanvas() {\n          if (!this.isRunning && this.textText.offsetParent !== null) { // animation off and canvas visible in DOM? (with noteJS it is currently undefined)\n              this.isRunning = true;\n              this.updateCanvas();\n          }\n      }\n      stopUpdateCanvas() {\n          if (this.isRunning) {\n              this.isRunning = false;\n              if (this.animationFrame) {\n                  cancelAnimationFrame(this.animationFrame);\n                  this.animationFrame = undefined;\n              }\n              clearTimeout(this.animationTimeoutId);\n              this.animationTimeoutId = undefined;\n          }\n      }\n      updateTextWindow() {\n          const textBuffer = this.textBuffer, cpc2Unicode = TextCanvas.cpc2Unicode;\n          let out = \"\";\n          for (let y = 0; y < textBuffer.length; y += 1) {\n              const textBufferRow = textBuffer[y];\n              if (textBufferRow) {\n                  for (let x = 0; x < textBufferRow.length; x += 1) {\n                      out += cpc2Unicode[textBufferRow[x] || 32];\n                  }\n              }\n              out += \"\\n\";\n          }\n          this.textText.value = out;\n      }\n      setFocusOnCanvas() {\n          this.cpcAreaBox.style.background = \"#463c3c\";\n          if (this.textText) {\n              this.textText.focus();\n          }\n          this.hasFocus = true;\n      }\n      getMousePos(event, canvasWidth, canvasHeight) {\n          const rect = this.textText.getBoundingClientRect(), pos = {\n              x: (event.clientX - this.borderWidth - rect.left) / (rect.right - rect.left - this.borderWidth * 2) * canvasWidth,\n              y: (event.clientY - this.borderWidth - rect.top) / (rect.bottom - rect.top - this.borderWidth * 2) * canvasHeight\n          };\n          return pos;\n      }\n      canvasClickAction(event) {\n          const canvasWidth = 640, canvasHeight = 400, pos = this.getMousePos(event, canvasWidth, canvasHeight), \n          /* eslint-disable no-bitwise */\n          x = pos.x | 0, // force integer\n          y = pos.y | 0;\n          /* eslint-enable no-bitwise */\n          if (this.options.onCanvasClick) {\n              const charWidth = canvasWidth / this.cols, charHeight = canvasHeight / this.rows, \n              /* eslint-disable no-bitwise */\n              xTxt = (x / charWidth) | 0, yTxt = (y / charHeight) | 0;\n              /* eslint-enable no-bitwise */\n              this.options.onCanvasClick(event, x, y, xTxt, yTxt);\n          }\n      }\n      onCanvasClick(event) {\n          if (!this.hasFocus) {\n              this.setFocusOnCanvas();\n          }\n          else {\n              this.canvasClickAction(event);\n          }\n          event.stopPropagation();\n      }\n      onWindowClick(_event) {\n          if (this.hasFocus) {\n              this.hasFocus = false;\n              this.cpcAreaBox.style.background = \"\";\n          }\n      }\n      fillTextBox(left, top, width, height, _paper) {\n          this.clearTextBufferBox(left, top, width, height);\n      }\n      clearTextBufferBox(left, top, width, height) {\n          const textBuffer = this.textBuffer;\n          for (let y = top; y < top + height; y += 1) {\n              const textBufferRow = textBuffer[y];\n              if (textBufferRow) {\n                  for (let x = left; x < left + width; x += 1) {\n                      delete textBufferRow[x];\n                  }\n              }\n          }\n          this.setNeedUpdate();\n      }\n      copyTextBufferBoxUp(left, top, width, height, left2, top2) {\n          const textBuffer = this.textBuffer;\n          for (let y = 0; y < height; y += 1) {\n              const sourceRow = textBuffer[top + y];\n              let destinationRow = textBuffer[top2 + y];\n              if (sourceRow) {\n                  // could be optimized, if complete rows\n                  if (!destinationRow) {\n                      destinationRow = [];\n                      textBuffer[top2 + y] = destinationRow;\n                  }\n                  for (let x = 0; x < width; x += 1) {\n                      destinationRow[left2 + x] = sourceRow[left + x];\n                  }\n              }\n              else if (destinationRow) {\n                  delete textBuffer[top2 + y]; // no sourceRow => clear destinationRow\n              }\n          }\n          this.setNeedUpdate();\n      }\n      copyTextBufferBoxDown(left, top, width, height, left2, top2) {\n          const textBuffer = this.textBuffer;\n          for (let y = height - 1; y >= 0; y -= 1) {\n              const sourceRow = textBuffer[top + y];\n              let destinationRow = textBuffer[top2 + y];\n              if (sourceRow) {\n                  if (!destinationRow) {\n                      destinationRow = [];\n                      textBuffer[top2 + y] = destinationRow;\n                  }\n                  for (let x = 0; x < width; x += 1) {\n                      destinationRow[left2 + x] = sourceRow[left + x];\n                  }\n              }\n              else if (destinationRow) {\n                  delete textBuffer[top2 + y]; // no sourceRow => clear destinationRow\n              }\n          }\n          this.setNeedUpdate();\n      }\n      putCharInTextBuffer(char, x, y) {\n          const textBuffer = this.textBuffer;\n          if (!textBuffer[y]) {\n              textBuffer[y] = [];\n          }\n          this.textBuffer[y][x] = char;\n          this.setNeedUpdate();\n      }\n      getCharFromTextBuffer(x, y) {\n          const textBuffer = this.textBuffer;\n          let char;\n          if (textBuffer[y]) {\n              char = this.textBuffer[y][x]; // can be undefined, if not set\n          }\n          return char;\n      }\n      printChar(char, x, y, _pen, _paper, _transparent) {\n          this.putCharInTextBuffer(char, x, y);\n      }\n      readChar(x, y, _pen, _paper) {\n          let char = this.getCharFromTextBuffer(x, y);\n          if (char === undefined) {\n              char = -1; // not detected\n          }\n          return char;\n      }\n      clearTextWindow(left, right, top, bottom, _paper) {\n          const width = right + 1 - left, height = bottom + 1 - top;\n          this.fillTextBox(left, top, width, height);\n      }\n      setMode(mode) {\n          const winData = TextCanvas.winData[mode], cols = winData.right + 1, rows = winData.bottom + 1;\n          if (this.cols !== cols) {\n              this.cols = cols;\n              this.textText.setAttribute(\"cols\", String(cols));\n          }\n          if (this.rows !== rows) {\n              this.rows = rows;\n              this.textText.setAttribute(\"rows\", String(rows));\n          }\n      }\n      clearFullWindow() {\n          this.resetTextBuffer();\n          this.setNeedUpdate();\n      }\n      windowScrollUp(left, right, top, bottom, _paper) {\n          const width = right + 1 - left, height = bottom + 1 - top;\n          if (height > 1) { // scroll part\n              // adapt also text buffer\n              this.copyTextBufferBoxUp(left, top + 1, width, height - 1, left, top);\n          }\n          this.fillTextBox(left, bottom, width, 1);\n      }\n      windowScrollDown(left, right, top, bottom, _paper) {\n          const width = right + 1 - left, height = bottom + 1 - top;\n          if (height > 1) { // scroll part\n              // adapt also text buffer\n              this.copyTextBufferBoxDown(left, top, width, height - 1, left, top + 1);\n          }\n          this.fillTextBox(left, top, width, 1);\n      }\n  }\n\n  // ===== dist/esm/VirtualKeyboard.js =====\n  // VirtualKeyboard.ts - VirtualKeyboard\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n\n  class VirtualKeyboard {\n      fnVirtualKeyboardKeydownHandler;\n      fnVirtualKeyboardKeyupOrKeyoutHandler;\n      fnKeydownOrKeyupHandler;\n      options;\n      eventNames;\n      shiftLock = false;\n      numLock = false;\n      constructor(options) {\n          this.fnVirtualKeyboardKeydownHandler = this.onVirtualKeyboardKeydown.bind(this);\n          this.fnVirtualKeyboardKeyupOrKeyoutHandler = this.onVirtualKeyboardKeyupOrKeyout.bind(this);\n          this.fnKeydownOrKeyupHandler = this.onKeydownOrKeyup.bind(this); // for real Enter and Space\n          this.options = {};\n          this.setOptions(options);\n          const view = this.options.view;\n          this.eventNames = this.options.view.fnAttachPointerEvents(\"kbdAreaInner\" /* ViewID.kbdAreaInner */, this.fnVirtualKeyboardKeydownHandler, undefined, this.fnVirtualKeyboardKeyupOrKeyoutHandler);\n          view.addEventListenerById(\"keydown\", this.fnKeydownOrKeyupHandler, \"kbdAreaInner\" /* ViewID.kbdAreaInner */);\n          view.addEventListenerById(\"keyup\", this.fnKeydownOrKeyupHandler, \"kbdAreaInner\" /* ViewID.kbdAreaInner */);\n          this.virtualKeyboardCreate();\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      static cpcKey2Key = [\n          {\n              keys: \"38ArrowUp\", // 0: cursor up\n              key: \"ArrowUp\",\n              text: \"\\u2191\",\n              title: \"Cursor up\"\n          },\n          {\n              keys: \"39ArrowRight\", // 1: cursor right\n              key: \"ArrowRight\",\n              text: \"\\u2192\",\n              title: \"Cursor right\",\n              style: 1\n          },\n          {\n              keys: \"40ArrowDown\", // 2: cursor down\n              key: \"ArrowDown\",\n              text: \"\\u2193\",\n              title: \"Cursor down\"\n          },\n          {\n              keys: \"105Numpad9,120F9\", // 3: numpad f9\n              key: \"9\",\n              text: \"f9\",\n              style: 1,\n              numLockCpcKey: 81 // joy 0 up+right\n          },\n          {\n              keys: \"102Numpad6,117F6\", // 4: numpad f6\n              key: \"6\",\n              text: \"f6\",\n              style: 1,\n              numLockCpcKey: 75 // joy 0 right\n          },\n          {\n              keys: \"99Numpad3,114F3\", // 5: numpad f3\n              key: \"3\",\n              text: \"f3\",\n              style: 1,\n              numLockCpcKey: 83 // joy 0 down+right\n          },\n          {\n              keys: \"13NumpadEnter\", // 6: numpad enter\n              key: \"Enter\",\n              style: 4\n          },\n          {\n              keys: \"110NumpadDecimal\", // 7: numpad .\n              key: \".\",\n              numLockCpcKey: 77 // joy 0 fire 1\n          },\n          {\n              keys: \"37ArrowLeft\", // 8: cursor left\n              key: \"ArrowLeft\",\n              text: \"\\u2190\",\n              title: \"Cursor left\",\n              style: 1\n          },\n          {\n              keys: \"18AltLeft\", // 9: copy\n              key: \"Alt\",\n              text: \"Copy\",\n              style: 2\n          },\n          {\n              keys: \"103Numpad7,118F7\", // 10: numpad f7\n              key: \"7\",\n              text: \"f7\",\n              style: 1,\n              numLockCpcKey: 80 // joy 0 up+left\n          },\n          {\n              keys: \"104Numpad8,119F8\", // 11: numpad f8\n              key: \"8\",\n              text: \"f8\",\n              style: 1,\n              numLockCpcKey: 72 // joy 0 up\n          },\n          {\n              keys: \"101Numpad5,116F5\", // 12: numpad f5\n              key: \"5\",\n              text: \"f5\",\n              style: 1,\n              numLockCpcKey: 76 // joy 0 fire 2\n          },\n          {\n              keys: \"97Numpad1,112F1\", // 13: numpad f1\n              key: \"1\",\n              text: \"f1\",\n              style: 1,\n              numLockCpcKey: 82 // joy 0 down+left\n          },\n          {\n              keys: \"98Numpad2,113F2\", // 14: numpad f2\n              key: \"2\",\n              text: \"f2\",\n              style: 1,\n              numLockCpcKey: 73 // joy 0 down\n          },\n          {\n              keys: \"96Numpad0,121F10\", // 15: numpad f0\n              key: \"0\",\n              text: \"f0\",\n              style: 1\n              // numLockCpcKey: 90 // Num lock\n          },\n          {\n              keys: \"46Delete\", // 16: clr\n              key: \"Delete\",\n              text: \"Clr\",\n              title: \"Clear\",\n              style: 1\n          },\n          {\n              keys: \"187BracketRight,171BracketRight,221BracketRight\", // 17: [ { (Chrome: 187; FF: 171); EN: 221BracketRight\n              key: \"[\",\n              keyShift: \"{\"\n          },\n          {\n              keys: \"13Enter\", // 18: return\n              key: \"Enter\",\n              text: \"Ret\",\n              title: \"Return\",\n              style: 2\n          },\n          {\n              keys: \"191Backslash,163Backslash,220Backslash\", // 19: ] } => # ' (Chrome: 191; FF: 163); EN: 220Backslash\n              key: \"]\",\n              keyShift: \"}\"\n          },\n          {\n              keys: \"100Numpad4,115F4\", // 20: numpad f4\n              key: \"4\",\n              text: \"f4\",\n              style: 1,\n              numLockCpcKey: 74 // joy 0 left\n          },\n          {\n              keys: \"16ShiftLeft,16ShiftRight\", // 21: shift left, shift right (2 keys!)\n              key: \"Shift\",\n              style: 4\n          },\n          {\n              keys: \"220Backquote,160Backquote,192Backquote\", // 22: \\ ` (different location, key!; Chrome: 220; FF: 160); EN: 192Backquote, 226IntlBackslash?\n              key: \"\\\\\",\n              keyShift: \"`\"\n          },\n          {\n              keys: \"17ControlLeft,17ControlRight\", // 23: Note: alt-gr also triggers ctrl-left and alt-gr!\n              key: \"Control\",\n              text: \"Ctrl\",\n              title: \"Control\",\n              style: 4\n          },\n          {\n              keys: \"221Equal,192Equal,187Equal\", // 24: ^  (pound: \\u00A3) (Chrome: 221; FF: 192); EN: 187Equal\n              key: \"^\",\n              keyShift: \"\"\n          },\n          {\n              keys: \"219Minus,63Minus,189Minus\", // 25: - = (Chrome: 219; FF: 63); EN: 189Minus\n              key: \"-\",\n              keyShift: \"=\"\n          },\n          {\n              keys: \"186BracketLeft,59BracketLeft,219BracketLeft\", // 26: @ | (Chrome: 168; FF: 59); EN: 219BracketLeft\n              key: \"@\",\n              keyShift: \"|\",\n              style: 1\n          },\n          {\n              keys: \"80KeyP\", // 27: P\n              key: \"p\",\n              keyShift: \"P\"\n          },\n          {\n              keys: \"222Quote,192Quote\", // 28: ; + (same on Chrome, FF); Android Bluetooth EN: 192Quote\n              key: \";\",\n              keyShift: \"+\"\n          },\n          {\n              keys: \"192Semicolon,186Semicolon\", // 29: : * (same on Chrome, FF); EN: 186Semicolon\n              key: \":\",\n              keyShift: \"*\"\n          },\n          {\n              keys: \"189Slash,173Slash,191Slash\", // 30: / ? (Chrome: 189; FF: 173); EN: 191Slash\n              key: \"/\",\n              keyShift: \"?\"\n          },\n          {\n              keys: \"190Period\", // 31: . <\n              key: \".\",\n              keyShift: \"<\"\n          },\n          {\n              keys: \"48Digit0\", // 32: 0 _\n              key: \"0\",\n              keyShift: \"_\"\n          },\n          {\n              keys: \"57Digit9\", // 33: 9 )\n              key: \"9\",\n              keyShift: \")\"\n          },\n          {\n              keys: \"79KeyO\", // 34:\n              key: \"o\",\n              keyShift: \"O\"\n          },\n          {\n              keys: \"73KeyI\", // 35:\n              key: \"i\",\n              keyShift: \"I\"\n          },\n          {\n              keys: \"76KeyL\", // 36:\n              key: \"l\",\n              keyShift: \"L\"\n          },\n          {\n              keys: \"75KeyK\", // 37:\n              key: \"k\",\n              keyShift: \"K\"\n          },\n          {\n              keys: \"77KeyM\", // 38:\n              key: \"m\",\n              keyShift: \"M\"\n          },\n          {\n              keys: \"188Comma\", // 39: , >\n              key: \",\",\n              keyShift: \">\"\n          },\n          {\n              keys: \"56Digit8\", // 40: 8 (\n              key: \"8\",\n              keyShift: \"(\"\n          },\n          {\n              keys: \"55Digit7\", // 41: 7 '\n              key: \"7\",\n              keyShift: \"'\"\n          },\n          {\n              keys: \"85KeyU\", // 42:\n              key: \"u\",\n              keyShift: \"U\"\n          },\n          {\n              keys: \"90KeyY,89KeyY\", // 43:\n              key: \"y\",\n              keyShift: \"Y\"\n          },\n          {\n              keys: \"72KeyH\", // 44:\n              key: \"h\",\n              keyShift: \"H\"\n          },\n          {\n              keys: \"74KeyJ\", // 45:\n              key: \"j\",\n              keyShift: \"J\"\n          },\n          {\n              keys: \"78KeyN\", // 46:\n              key: \"n\",\n              keyShift: \"N\"\n          },\n          {\n              keys: \"32Space\", // 47: space\n              key: \" \",\n              text: \"Space\",\n              style: 5\n          },\n          {\n              keys: \"54Digit6\", // 48: 6 &\n              key: \"6\",\n              keyShift: \"(\"\n          },\n          {\n              keys: \"53Digit5\", // 49: 5 %\n              key: \"5\",\n              keyShift: \"%\"\n          },\n          {\n              keys: \"82KeyR\", // 50:\n              key: \"r\",\n              keyShift: \"R\"\n          },\n          {\n              keys: \"84KeyT\", // 51:\n              key: \"t\",\n              keyShift: \"T\"\n          },\n          {\n              keys: \"71KeyG\", // 52:\n              key: \"g\",\n              keyShift: \"G\"\n          },\n          {\n              keys: \"70KeyF\", // 53:\n              key: \"f\",\n              keyShift: \"F\"\n          },\n          {\n              keys: \"66KeyB\", // 54:\n              key: \"b\",\n              keyShift: \"B\"\n          },\n          {\n              keys: \"86KeyV\", // 55:\n              key: \"v\",\n              keyShift: \"V\"\n          },\n          {\n              keys: \"52Digit4\", // 56: 4 $\n              key: \"4\",\n              keyShift: \"$\"\n          },\n          {\n              keys: \"51Digit3\", // 57: 3 #\n              key: \"3\",\n              keyShift: \"#\"\n          },\n          {\n              keys: \"69KeyE\", // 58:\n              key: \"e\",\n              keyShift: \"E\"\n          },\n          {\n              keys: \"87KeyW\", // 59:\n              key: \"w\",\n              keyShift: \"W\"\n          },\n          {\n              keys: \"83KeyS\", // 60:\n              key: \"s\",\n              keyShift: \"S\"\n          },\n          {\n              keys: \"68KeyD\", // 61:\n              key: \"d\",\n              keyShift: \"D\"\n          },\n          {\n              keys: \"67KeyC\", // 62:\n              key: \"c\",\n              keyShift: \"C\"\n          },\n          {\n              keys: \"88KeyX\", // 63:\n              key: \"x\",\n              keyShift: \"X\"\n          },\n          {\n              keys: \"49Digit1\", // 64: 1 !\n              key: \"1\",\n              keyShift: \"!\"\n          },\n          {\n              keys: \"50Digit2\", // 65: 2 \"\n              key: \"2\",\n              keyShift: \"\\\"\"\n          },\n          {\n              keys: \"27Escape\", // 66: esc\n              key: \"Escape\",\n              text: \"Esc\",\n              title: \"Escape\",\n              style: 1\n          },\n          {\n              keys: \"81KeyQ\", // 67:\n              key: \"q\",\n              keyShift: \"Q\"\n          },\n          {\n              keys: \"9Tab\", // 68:\n              key: \"Tab\",\n              style: 2\n          },\n          {\n              keys: \"65KeyA\", // 69:\n              key: \"a\",\n              keyShift: \"A\"\n          },\n          {\n              keys: \"20CapsLock\", // 70: caps lock\n              key: \"CapsLock\",\n              text: \"Caps\",\n              title: \"Caps Lock\",\n              style: 3\n          },\n          {\n              keys: \"89KeyZ,90KeyZ\", // 71: DE,EN\n              key: \"z\",\n              keyShift: \"Z\"\n          },\n          {\n              keys: \"38Numpad8\", // 72: joy 0 up (arrow up)\n              key: \"JoyUp\",\n              text: \"\\u21D1\",\n              title: \"Joy up\"\n          },\n          {\n              keys: \"40Numpad2\", // 73: joy 0 down\n              key: \"JoyDown\",\n              text: \"\\u21D3\",\n              title: \"Joy down\"\n          },\n          {\n              keys: \"37Numpad4\", // 74: joy 0 left\n              key: \"JoyLeft\",\n              text: \"\\u21D0\",\n              title: \"Joy left\"\n          },\n          {\n              keys: \"39Numpad6\", // 75: joy 0 right\n              key: \"JoyRight\",\n              text: \"\\u21D2\",\n              title: \"Joy right\"\n          },\n          {\n              keys: \"12Numpad5,45Numpad0\", // 76: joy 0 fire 2 (clear,...)\n              key: \"X\",\n              text: \"\\u29BF\",\n              title: \"Joy fire\"\n          },\n          {\n              keys: \"46NumpadDecimal\", // 77: joy 0 fire 1\n              key: \"Z\",\n              text: \"\\u25E6\",\n              title: \"Joy fire 1\"\n          },\n          {\n              keys: \"\", // 78: \"\"? not null? (joy 0 fire 3?)\n              key: \"\"\n          },\n          {\n              keys: \"8Backspace\", // 79: del\n              key: \"Backspace\", // 79: del\n              text: \"Del\",\n              title: \"Delete\",\n              style: 1\n          },\n          // starting with 80, not on CPC\n          // not on CPC:\n          {\n              keys: \"36Numpad7\", // 80: joy 0 up+left\n              key: \"\",\n              text: \"\\u21D6\",\n              title: \"Joy up+left\"\n          },\n          {\n              keys: \"33Numpad9\", // 81: joy 0 up+right\n              key: \"\",\n              text: \"\\u21D7\",\n              title: \"Joy up+right\"\n          },\n          {\n              keys: \"35Numpad1\", // 82: joy 0 down+left\n              key: \"\",\n              text: \"\\u21D9\",\n              title: \"Joy down+leftt\"\n          },\n          {\n              keys: \"34Numpad3\", // 83: joy 0 down+right\n              key: \"\",\n              text: \"\\u21D8\",\n              title: \"Joy down+right\"\n          },\n          {\n              keys: \"\", // 84: (not null?)\n              key: \"\"\n          },\n          {\n              keys: \"226IntlBackslash,60IntlBackslash,220IntlBackslash\", // 85: < > | // key not on CPC! (Chrome: 226, FF: 60);  Android Bluetooth EN: 220IntlBackslash\n              key: \"\"\n          },\n          {\n              keys: \"111NumpadDivide\", // 86:\n              key: \"\"\n          },\n          {\n              keys: \"106NumpadMultiply\", // 87:\n              key: \"\"\n          },\n          {\n              keys: \"109NumpadSubtract\", // 88:\n              key: \"\"\n          },\n          {\n              keys: \"107NumpadAdd\", // 89:\n              key: \"\"\n          },\n          {\n              keys: \"\",\n              key: \"\", // 90: special num lock key to switch between joystick and numpad\n              text: \"Num\",\n              title: \"Num / Joy\",\n              style: 1\n          }\n          // only on PC:\n          // \"226IntlBackslash\", \"122F11\", \"123F12\", \"44PrintScreen\", \"145ScrollLock\", \"19Pause\", \"45Insert\", \"36Home\", \"33PageUp\", \"35End\", \"34PageDown\", \"111NumpadDivide\", \"106NumpadMultiply\", \"109NumpadSubtract\", \"107NumpadAdd\"\n      ];\n      /* eslint-disable array-element-newline */\n      static virtualKeyboardAlpha = [\n          [66, 64, 65, 57, 56, 49, 48, 41, 40, 33, 32, 25, 24, 16, 79],\n          [68, 67, 59, 58, 50, 51, 43, 42, 35, 34, 27, 26, 17, 18],\n          [70, 69, 60, 61, 53, 52, 44, 45, 37, 36, 29, 28, 19, 90], // 90=virtual numpad button\n          [\n              21, 71, 63, 62, 55, 54, 46, 38, 39, 31, 30, 22,\n              {\n                  key: 21, // right shift has same code and style\n                  style: 2\n              }\n          ],\n          [23, 9, 47, 6]\n      ];\n      static virtualKeyboardNum = [\n          [10, 11, 3],\n          [20, 12, 4],\n          [13, 14, 5],\n          [15, 0, 7],\n          [8, 2, 1]\n      ];\n      /* eslint-enable array-element-newline */\n      reset() {\n          this.virtualKeyboardAdaptKeys(false, false);\n      }\n      mapNumLockCpcKey(cpcKey) {\n          const key = VirtualKeyboard.cpcKey2Key[cpcKey];\n          if (key.numLockCpcKey) {\n              cpcKey = key.numLockCpcKey;\n          }\n          return cpcKey;\n      }\n      fnVirtualGetAscii(cpcKey, shiftKey, numLock) {\n          const keyEntry = VirtualKeyboard.cpcKey2Key[cpcKey];\n          let key, text, title;\n          if (numLock && keyEntry.keyNumLock) {\n              key = keyEntry.keyNumLock;\n              text = keyEntry.textNumLock || key;\n              title = keyEntry.titleNumLock || text;\n          }\n          else if (shiftKey && keyEntry.keyShift) {\n              key = keyEntry.keyShift;\n              text = keyEntry.textShift || key;\n              title = keyEntry.titleShift || text;\n          }\n          else {\n              key = keyEntry.key;\n              text = keyEntry.text || key;\n              title = keyEntry.title || text;\n          }\n          return {\n              key: key,\n              text: text,\n              title: title\n          };\n      }\n      createButtonRow(id, options) {\n          const place = View.getElementById1(id);\n          if (place.insertAdjacentElement) {\n              const buttonList = document.createElement(\"div\");\n              buttonList.className = \"displayFlex\";\n              for (let i = 0; i < options.length; i += 1) {\n                  const item = options[i], button = document.createElement(\"button\");\n                  button.innerText = item.text;\n                  button.setAttribute(\"title\", item.title);\n                  button.className = item.className;\n                  button.setAttribute(\"data-key\", String(item.key));\n                  buttonList.insertAdjacentElement(\"beforeend\", button);\n              }\n              place.insertAdjacentElement(\"beforeend\", buttonList);\n          }\n          else { // Polyfill for old browsers\n              let html = \"<div class=displayFlex>\\n\";\n              for (let i = 0; i < options.length; i += 1) {\n                  const item = options[i];\n                  html += '<button title=\"' + item.title + '\" class=\"' + item.className + '\" data-key=\"' + item.key + '\">' + item.text + \"</button>\\n\";\n              }\n              html += \"</div>\";\n              place.innerHTML += html;\n          }\n          return this;\n      }\n      virtualKeyboardCreatePart(id, virtualKeyboard) {\n          const keyArea = View.getElementById1(id), shiftLock = this.shiftLock, numLock = this.numLock, cpcKey2Key = VirtualKeyboard.cpcKey2Key, buttons = keyArea.getElementsByTagName(\"button\");\n          if (!buttons.length) { // not yet created?\n              for (let row = 0; row < virtualKeyboard.length; row += 1) {\n                  const rowList = virtualKeyboard[row], optionsList = [];\n                  for (let col = 0; col < rowList.length; col += 1) {\n                      let cpcKeyEntry;\n                      if (typeof rowList[col] === \"number\") {\n                          cpcKeyEntry = {\n                              key: rowList[col]\n                          };\n                      }\n                      else { // object\n                          cpcKeyEntry = rowList[col];\n                      }\n                      const cpcKey = numLock ? this.mapNumLockCpcKey(cpcKeyEntry.key) : cpcKeyEntry.key, keyEntry = cpcKey2Key[cpcKeyEntry.key], ascii = this.fnVirtualGetAscii(cpcKey, shiftLock, numLock), className = \"kbdButton\" + (cpcKeyEntry.style || keyEntry.style || \"\") + ((col === rowList.length - 1) ? \" kbdNoRightMargin\" : \"\"), options = {\n                          key: cpcKey,\n                          text: ascii.text,\n                          title: ascii.title,\n                          className: className\n                      };\n                      optionsList.push(options);\n                  }\n                  this.createButtonRow(id, optionsList);\n              }\n          }\n      }\n      virtualKeyboardCreate() {\n          this.virtualKeyboardCreatePart(\"kbdAlpha\" /* ViewID.kbdAlpha */, VirtualKeyboard.virtualKeyboardAlpha);\n          this.virtualKeyboardCreatePart(\"kbdNum\" /* ViewID.kbdNum */, VirtualKeyboard.virtualKeyboardNum);\n      }\n      virtualKeyboardAdaptKeys(shiftLock, numLock) {\n          const keyArea = View.getElementById1(\"kbdAreaInner\" /* ViewID.kbdAreaInner */), buttons = keyArea.getElementsByTagName(\"button\"); // or: keyArea.childNodes and filter\n          for (let i = 0; i < buttons.length; i += 1) {\n              const button = buttons[i];\n              let cpcKey = Number(button.getAttribute(\"data-key\"));\n              if (numLock) {\n                  cpcKey = this.mapNumLockCpcKey(cpcKey);\n              }\n              const ascii = this.fnVirtualGetAscii(cpcKey, shiftLock, numLock);\n              if (ascii.key !== button.innerText) {\n                  button.innerText = ascii.text;\n                  button.title = ascii.title;\n              }\n          }\n      }\n      fnVirtualGetPressedKey(cpcKey) {\n          const key = VirtualKeyboard.cpcKey2Key[cpcKey];\n          let pressedKey = \"\";\n          if (key) {\n              pressedKey = key.keys;\n              if (pressedKey.indexOf(\",\") >= 0) { // maybe more\n                  pressedKey = pressedKey.substring(0, pressedKey.indexOf(\",\")); // take the first\n              }\n          }\n          return pressedKey;\n      }\n      onVirtualKeyboardKeydown(event) {\n          const node = View.getEventTarget(event), cpcKey = node.getAttribute(\"data-key\");\n          if (Utils.debug > 1) {\n              Utils.console.debug(\"onVirtualKeyboardKeydown: event\", String(event), \"type:\", event.type, \"title:\", node.title, \"cpcKey:\", cpcKey);\n          }\n          if (cpcKey !== null) {\n              let cpcKeyCode = Number(cpcKey);\n              if (this.numLock) {\n                  cpcKeyCode = this.mapNumLockCpcKey(cpcKeyCode);\n              }\n              const pressedKey = this.fnVirtualGetPressedKey(cpcKeyCode), ascii = this.fnVirtualGetAscii(cpcKeyCode, this.shiftLock || event.shiftKey, this.numLock);\n              this.options.fnPressCpcKey(event, cpcKeyCode, pressedKey, ascii.key);\n          }\n          // A pointerdown event can also ended by pointerout when leaving the area\n          if (this.eventNames.out) {\n              this.options.view.addEventListener(this.eventNames.out, this.fnVirtualKeyboardKeyupOrKeyoutHandler, node);\n          }\n          event.preventDefault();\n          return false;\n      }\n      fnVirtualKeyboardKeyupOrKeyout(event) {\n          const node = View.getEventTarget(event), cpcKey = node.getAttribute(\"data-key\");\n          if (cpcKey !== null) {\n              let cpcKeyCode = Number(cpcKey);\n              if (this.numLock) {\n                  cpcKeyCode = this.mapNumLockCpcKey(cpcKeyCode);\n              }\n              const pressedKey = this.fnVirtualGetPressedKey(cpcKeyCode), ascii = this.fnVirtualGetAscii(cpcKeyCode, this.shiftLock || event.shiftKey, this.numLock);\n              this.options.fnReleaseCpcKey(event, cpcKeyCode, pressedKey, ascii.key);\n              if (cpcKeyCode === 70) { // Caps Lock?\n                  this.shiftLock = !this.shiftLock;\n                  this.virtualKeyboardAdaptKeys(this.shiftLock, this.numLock);\n              }\n              else if (cpcKeyCode === 90) { // Num lock\n                  this.numLock = !this.numLock;\n                  this.virtualKeyboardAdaptKeys(this.shiftLock, this.numLock);\n              }\n          }\n      }\n      onVirtualKeyboardKeyupOrKeyout(event) {\n          const node = View.getEventTarget(event);\n          if (Utils.debug > 1) {\n              Utils.console.debug(\"onVirtualKeyboardKeyupOrKeyout: event\", String(event), \"type:\", event.type, \"title:\", node.title, \"cpcKey:\", node.getAttribute(\"data-key\"));\n          }\n          this.fnVirtualKeyboardKeyupOrKeyout(event);\n          if (this.eventNames.out) {\n              this.options.view.removeEventListener(this.eventNames.out, this.fnVirtualKeyboardKeyupOrKeyoutHandler, node); // do not need out event any more for this key\n          }\n          event.preventDefault();\n          return false;\n      }\n      static keyIdentifier2Char(event) {\n          // SliTaz web browser has not key but keyIdentifier\n          const identifier = event.keyIdentifier, // eslint-disable-line @typescript-eslint/no-explicit-any\n          shiftKey = event.shiftKey;\n          let char = \"\";\n          if ((/^U\\+/i).test(identifier || \"\")) { // unicode string?\n              char = String.fromCharCode(parseInt(identifier.substr(2), 16));\n              if (char === \"\\0\") { // ignore\n                  char = \"\";\n              }\n              char = shiftKey ? char.toUpperCase() : char.toLowerCase(); // do we get keys in unicode always in uppercase?\n          }\n          else {\n              char = identifier; // take it, could be \"Enter\"\n          }\n          return char;\n      }\n      onKeydownOrKeyup(event) {\n          const key = event.key || VirtualKeyboard.keyIdentifier2Char(event) || \"\", // SliTaz web browser has not key but keyIdentifier (also in Keyboard)\n          activeElement = window.document.activeElement;\n          if (key === \"Enter\" || key === \" \") { // enter or space\n              const simPointerEvent = {\n                  type: event.type,\n                  target: activeElement, // active selected element\n                  preventDefault: function () {\n                      // empty\n                  }\n              };\n              if (event.type === \"keydown\") {\n                  this.onVirtualKeyboardKeydown(simPointerEvent);\n              }\n              else if (event.type === \"keyup\") {\n                  this.onVirtualKeyboardKeyupOrKeyout(simPointerEvent);\n              }\n              else {\n                  Utils.console.error(\"onKeydownOrKeyup: Unknown type:\", event.type);\n              }\n              event.preventDefault();\n              return false;\n          }\n          return undefined;\n      }\n  }\n\n  // ===== dist/esm/Sound.js =====\n  // Sound.ts - Sound output via WebAudio\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n  class Sound {\n      options;\n      isSoundOn = false;\n      isActivatedByUserFlag = false;\n      contextNotAvailable = false;\n      contextStartTime = 0;\n      context;\n      mergerNode;\n      gainNodes = [];\n      oscillators = []; // 3 oscillators left, middle, right\n      queues = []; // node queues and info for the three channels\n      fScheduleAheadTime = 0.1; // 100 ms\n      volEnv = [];\n      toneEnv = [];\n      debugLogList;\n      constructor(options) {\n          this.options = {};\n          this.setOptions(options);\n          for (let i = 0; i < 3; i += 1) {\n              this.queues[i] = {\n                  soundData: [],\n                  fNextNoteTime: 0,\n                  onHold: false,\n                  rendevousMask: 0\n              };\n          }\n          if (Utils.debug > 1) {\n              this.debugLogList = []; // access: CpcLoco.controller.sound.debugLog\n          }\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      reset() {\n          const oscillators = this.oscillators, volEnvData = {\n              steps: 1,\n              diff: 0,\n              time: 200\n          };\n          this.resetQueue();\n          for (let i = 0; i < 3; i += 1) {\n              if (oscillators[i]) {\n                  this.stopOscillator(i);\n              }\n          }\n          this.volEnv.length = 0;\n          this.setVolEnv(0, [volEnvData]); // set default ENV (should not be changed)\n          this.toneEnv.length = 0;\n          if (this.debugLogList) {\n              this.debugLogList.length = 0;\n          }\n      }\n      stopOscillator(n) {\n          const oscillators = this.oscillators, oscillatorNode = oscillators[n];\n          if (oscillatorNode) {\n              oscillatorNode.frequency.value = 0;\n              oscillatorNode.stop();\n              oscillatorNode.disconnect();\n              oscillators[n] = undefined;\n          }\n      }\n      debugLog(msg) {\n          if (this.debugLogList) {\n              this.debugLogList.push([\n                  this.context ? this.context.currentTime : 0,\n                  msg\n              ]);\n          }\n      }\n      resetQueue() {\n          const queues = this.queues;\n          for (let i = 0; i < queues.length; i += 1) {\n              const queue = queues[i];\n              queue.soundData.length = 0;\n              queue.fNextNoteTime = 0;\n              queue.onHold = false;\n              queue.rendevousMask = 0;\n          }\n      }\n      createSoundContext() {\n          const channelMap2Cpc = [\n              0,\n              2,\n              1\n          ];\n          let context;\n          try {\n              context = new this.options.AudioContextConstructor(); // may produce exception if not available\n              const mergerNode = context.createChannelMerger(6); // create mergerNode with 6 inputs; we are using the first 3 for left, right, center\n              this.mergerNode = mergerNode; // set as side effect\n              for (let i = 0; i < 3; i += 1) {\n                  const gainNode = context.createGain();\n                  gainNode.connect(mergerNode, 0, channelMap2Cpc[i]); // connect output #0 of gainNode i to input #j of the mergerNode\n                  this.gainNodes[i] = gainNode;\n              }\n          }\n          catch (e) {\n              Utils.console.warn(\"createSoundContext:\", e);\n              this.contextNotAvailable = true;\n          }\n          const oldContextStartTime = this.contextStartTime;\n          this.contextStartTime = Date.now() / 1000;\n          if (oldContextStartTime && context) { // was there a start time set before?\n              const correctionTime = context.currentTime + (this.contextStartTime - oldContextStartTime), queues = this.queues;\n              for (let i = 0; i < 3; i += 1) {\n                  if (queues[i].soundData.length) {\n                      queues[i].fNextNoteTime -= correctionTime;\n                  }\n              }\n          }\n          return context;\n      }\n      playNoise(oscillator, fTime, fDuration, noise) {\n          const context = this.context, bufferSize = context.sampleRate * fDuration, // set the time of the note\n          buffer = context.createBuffer(1, bufferSize, context.sampleRate), // create an empty buffer\n          data = buffer.getChannelData(0), // get data\n          noiseNode = context.createBufferSource(); // create a buffer source for noise data\n          // fill the buffer with noise\n          for (let i = 0; i < bufferSize; i += 1) {\n              data[i] = Math.random() * 2 - 1; // -1..1\n          }\n          noiseNode.buffer = buffer;\n          if (noise > 1) {\n              const bandHz = 20000 / noise, bandpass = context.createBiquadFilter();\n              bandpass.type = \"bandpass\";\n              bandpass.frequency.value = bandHz;\n              // bandpass.Q.value = q; // ?\n              noiseNode.connect(bandpass).connect(this.gainNodes[oscillator]);\n          }\n          else {\n              noiseNode.connect(this.gainNodes[oscillator]);\n          }\n          noiseNode.start(fTime);\n          noiseNode.stop(fTime + fDuration);\n      }\n      simulateApplyVolEnv(volData, duration, volEnvRepeat) {\n          let time = 0;\n          for (let loop = 0; loop < volEnvRepeat; loop += 1) {\n              for (let part = 0; part < volData.length; part += 1) {\n                  const group = volData[part];\n                  if (group.steps !== undefined) {\n                      const group1 = group, volTime = group1.time;\n                      let volSteps = group1.steps;\n                      if (!volSteps) { // steps=0\n                          volSteps = 1;\n                      }\n                      for (let i = 0; i < volSteps; i += 1) {\n                          time += volTime;\n                          if (duration && time >= duration) { // eslint-disable-line max-depth\n                              loop = volEnvRepeat; // stop early if longer than specified duration\n                              part = volData.length;\n                              break;\n                          }\n                      }\n                  }\n                  else { // register\n                      const group2 = group, register = group2.register, period = group2.period, volTime = period;\n                      if (register === 0) {\n                          time += volTime;\n                      }\n                      else {\n                          // TODO: other registers\n                      }\n                  }\n              }\n          }\n          if (duration === 0) {\n              duration = time;\n          }\n          return duration;\n      }\n      applyVolEnv(volData, gain, fTime, volume, duration, volEnvRepeat) {\n          const maxVolume = 15, i100ms2sec = 100; // time duration unit: 1/100 sec=10 ms, convert to sec\n          let time = 0;\n          for (let loop = 0; loop < volEnvRepeat; loop += 1) {\n              for (let part = 0; part < volData.length; part += 1) {\n                  const group = volData[part];\n                  if (group.steps !== undefined) {\n                      const group1 = group, volDiff = group1.diff, volTime = group1.time;\n                      let volSteps = group1.steps;\n                      if (!volSteps) { // steps=0\n                          volSteps = 1;\n                          volume = 0; // we will set volDiff as absolute volume\n                      }\n                      for (let i = 0; i < volSteps; i += 1) {\n                          volume = (volume + volDiff) % (maxVolume + 1);\n                          const fVolume = volume / maxVolume;\n                          gain.setValueAtTime(fVolume * fVolume, fTime + time / i100ms2sec);\n                          time += volTime;\n                          if (duration && time >= duration) { // eslint-disable-line max-depth\n                              loop = volEnvRepeat; // stop early if longer than specified duration\n                              part = volData.length;\n                              break;\n                          }\n                      }\n                  }\n                  else { // register\n                      const group2 = group, register = group2.register, period = group2.period, volTime = period;\n                      if (register === 0) {\n                          volume = 15;\n                          let fVolume = volume / maxVolume;\n                          gain.setValueAtTime(fVolume * fVolume, fTime + time / i100ms2sec);\n                          time += volTime;\n                          fVolume = 0;\n                          gain.linearRampToValueAtTime(fVolume, fTime + time / i100ms2sec); // or: exponentialRampToValueAtTime?\n                      }\n                      else {\n                          // TODO: other registers\n                      }\n                  }\n              }\n          }\n          if (duration === 0) {\n              duration = time;\n          }\n          return duration;\n      }\n      applyToneEnv(toneData, frequency, fTime, period, duration) {\n          const i100ms2sec = 100, // time duration unit: 1/100 sec=10 ms, convert to sec\n          repeat = toneData[0], toneEnvRepeat = repeat ? 5 : 1; // we use at most 5\n          let time = 0;\n          for (let loop = 0; loop < toneEnvRepeat; loop += 1) {\n              for (let part = 0; part < toneData.length; part += 1) {\n                  const group = toneData[part];\n                  if (group.steps !== undefined) {\n                      const group1 = group, toneSteps = group1.steps || 1, // steps 0 => 1\n                      toneDiff = group1.diff, toneTime = group1.time;\n                      for (let i = 0; i < toneSteps; i += 1) {\n                          const fFrequency = (period >= 3) ? 62500 / period : 0;\n                          frequency.setValueAtTime(fFrequency, fTime + time / i100ms2sec);\n                          period += toneDiff;\n                          time += toneTime;\n                          if (duration && time >= duration) { // eslint-disable-line max-depth\n                              loop = toneEnvRepeat; // stop early if longer than specified duration\n                              part = toneData.length;\n                              break;\n                          }\n                      }\n                  }\n                  else { // absolute period\n                      const group2 = group, toneTime = group2.time;\n                      period = group2.period;\n                      const fFrequency = (period >= 3) ? 62500 / period : 0;\n                      frequency.setValueAtTime(fFrequency, fTime + time / i100ms2sec);\n                      // TODO\n                      time += toneTime;\n                      // frequency.linearRampToValueAtTime(fXXX, fTime + time / i100ms2sec); // or: exponentialRampToValueAtTime?\n                  }\n              }\n          }\n      }\n      // simulate schedule note when sound is off\n      simulateScheduleNote(soundData) {\n          let duration = soundData.duration, volEnv = soundData.volEnv, volEnvRepeat = 1;\n          if (duration < 0) { // <0: repeat volume envelope?\n              volEnvRepeat = Math.min(5, -duration); // we limit repeat to 5 times sice we precompute duration\n              duration = 0;\n          }\n          if (volEnv || !duration) { // some volume envelope or duration 0?\n              if (!this.volEnv[volEnv]) {\n                  volEnv = 0; // envelope not defined => use default envelope 0\n              }\n              duration = this.simulateApplyVolEnv(this.volEnv[volEnv], duration, volEnvRepeat);\n          }\n          const i100ms2sec = 100, // time duration unit: 1/100 sec=10 ms, convert to sec\n          fDuration = duration / i100ms2sec;\n          return fDuration;\n      }\n      scheduleNote(oscillator, fTime, soundData) {\n          if (Utils.debug > 1) {\n              this.debugLog(\"scheduleNote: \" + oscillator + \" \" + fTime);\n          }\n          if (!this.isSoundOn) {\n              return this.simulateScheduleNote(soundData);\n          }\n          const context = this.context, oscillatorNode = context.createOscillator();\n          oscillatorNode.type = \"square\";\n          oscillatorNode.frequency.value = (soundData.period >= 3) ? 62500 / soundData.period : 0;\n          oscillatorNode.connect(this.gainNodes[oscillator]);\n          if (fTime < context.currentTime) {\n              if (Utils.debug) {\n                  Utils.console.debug(\"Test: sound: scheduleNote:\", fTime, \"<\", context.currentTime);\n              }\n          }\n          const volume = soundData.volume, gain = this.gainNodes[oscillator].gain, maxVolume = 15, fVolume = volume / maxVolume;\n          gain.setValueAtTime(fVolume * fVolume, fTime); // start volume\n          let duration = soundData.duration, volEnv = soundData.volEnv, volEnvRepeat = 1;\n          if (duration < 0) { // <0: repeat volume envelope?\n              volEnvRepeat = Math.min(5, -duration); // we limit repeat to 5 times sice we precompute duration\n              duration = 0;\n          }\n          if (volEnv || !duration) { // some volume envelope or duration 0?\n              if (!this.volEnv[volEnv]) {\n                  volEnv = 0; // envelope not defined => use default envelope 0\n              }\n              duration = this.applyVolEnv(this.volEnv[volEnv], gain, fTime, volume, duration, volEnvRepeat);\n          }\n          const toneEnv = soundData.toneEnv;\n          if (toneEnv && this.toneEnv[toneEnv]) { // some tone envelope?\n              this.applyToneEnv(this.toneEnv[toneEnv], oscillatorNode.frequency, fTime, soundData.period, duration);\n          }\n          const i100ms2sec = 100, // time duration unit: 1/100 sec=10 ms, convert to sec\n          fDuration = duration / i100ms2sec;\n          oscillatorNode.start(fTime);\n          oscillatorNode.stop(fTime + fDuration);\n          this.oscillators[oscillator] = oscillatorNode;\n          if (soundData.noise) {\n              this.playNoise(oscillator, fTime, fDuration, soundData.noise);\n          }\n          return fDuration;\n      }\n      testCanQueue(state) {\n          let canQueue = true;\n          if (this.isSoundOn && !this.isActivatedByUserFlag) { // sound on but not yet activated? -> say cannot queue\n              canQueue = false;\n              /* eslint-disable no-bitwise */\n          }\n          else if (!(state & 0x80)) { // 0x80: flush\n              const queues = this.queues;\n              if ((state & 0x01 && queues[0].soundData.length >= 4)\n                  || (state & 0x02 && queues[1].soundData.length >= 4)\n                  || (state & 0x04 && queues[2].soundData.length >= 4)) {\n                  canQueue = false;\n              }\n          }\n          /* eslint-enable no-bitwise */\n          return canQueue;\n      }\n      sound(soundData) {\n          const queues = this.queues, state = soundData.state;\n          for (let i = 0; i < 3; i += 1) {\n              if ((state >> i) & 0x01) { // eslint-disable-line no-bitwise\n                  const queue = queues[i];\n                  if (state & 0x80) { // eslint-disable-line no-bitwise\n                      queue.soundData.length = 0; // flush queue\n                      queue.fNextNoteTime = 0;\n                      this.stopOscillator(i);\n                  }\n                  queue.soundData.push(soundData); // just a reference\n                  if (Utils.debug > 1) {\n                      this.debugLog(\"sound: \" + i + \" \" + state + \":\" + queue.soundData.length);\n                  }\n                  this.updateQueueStatus(i, queue);\n              }\n          }\n          this.scheduler(); // schedule early to allow SQ busy check immediately (can channels go out of sync by this?)\n      }\n      setVolEnv(volEnv, volEnvData) {\n          this.volEnv[volEnv] = volEnvData;\n      }\n      setToneEnv(toneEnv, toneEnvData) {\n          this.toneEnv[toneEnv] = toneEnvData;\n      }\n      updateQueueStatus(i, queue) {\n          const soundData = queue.soundData;\n          if (soundData.length) {\n              /* eslint-disable no-bitwise */\n              queue.onHold = Boolean(soundData[0].state & 0x40); // check if next note on hold\n              queue.rendevousMask = (soundData[0].state & 0x07); // get channel bits\n              queue.rendevousMask &= ~(1 << i); // mask out our channel\n              queue.rendevousMask |= (soundData[0].state >> 3) & 0x07; // and combine rendevous\n              /* eslint-enable no-bitwise */\n          }\n          else {\n              queue.onHold = false;\n              queue.rendevousMask = 0;\n          }\n      }\n      // idea from: https://www.html5rocks.com/en/tutorials/audio/scheduling/\n      scheduler() {\n          if (!this.isActivatedByUserFlag) {\n              return;\n          }\n          const context = this.context, fCurrentTime = context ? context.currentTime : Date.now() / 1000 - this.contextStartTime, // use Date.now() when sound is off\n          queues = this.queues;\n          let canPlayMask = 0;\n          for (let i = 0; i < 3; i += 1) {\n              const queue = queues[i];\n              while (queue.soundData.length && !queue.onHold && queue.fNextNoteTime < fCurrentTime + this.fScheduleAheadTime) { // something to schedule and not on hold and time reached\n                  if (!queue.rendevousMask) { // no rendevous needed, schedule now\n                      if (queue.fNextNoteTime < fCurrentTime) {\n                          queue.fNextNoteTime = fCurrentTime;\n                      }\n                      const soundData = queue.soundData.shift();\n                      queue.fNextNoteTime += this.scheduleNote(i, queue.fNextNoteTime, soundData);\n                      this.updateQueueStatus(i, queue); // check if next note on hold\n                  }\n                  else { // need rendevous\n                      canPlayMask |= (1 << i); // eslint-disable-line no-bitwise\n                      break;\n                  }\n              }\n          }\n          if (!canPlayMask) { // no channel can play\n              return;\n          }\n          for (let i = 0; i < 3; i += 1) {\n              const queue = queues[i];\n              // we can play, if in rendevous\n              if ((canPlayMask >> i) & 0x01 && ((queue.rendevousMask & canPlayMask) === queue.rendevousMask)) { // eslint-disable-line no-bitwise\n                  if (queue.fNextNoteTime < fCurrentTime) {\n                      queue.fNextNoteTime = fCurrentTime;\n                  }\n                  const soundData = queue.soundData.shift();\n                  queue.fNextNoteTime += this.scheduleNote(i, queue.fNextNoteTime, soundData);\n                  this.updateQueueStatus(i, queue); // check if next note on hold\n              }\n          }\n      }\n      release(releaseMask) {\n          const queues = this.queues;\n          if (!queues.length) {\n              return;\n          }\n          if (Utils.debug > 1) {\n              this.debugLog(\"release: \" + releaseMask);\n          }\n          for (let i = 0; i < 3; i += 1) {\n              const queue = queues[i], soundData = queue.soundData;\n              if (((releaseMask >> i) & 0x01) && soundData.length && queue.onHold) { // eslint-disable-line no-bitwise\n                  queue.onHold = false; // release\n              }\n          }\n          this.scheduler(); // extra schedule now so that following sound instructions are not releases early\n      }\n      sq(n) {\n          const queues = this.queues, queue = queues[n], soundData = queue.soundData, context = this.context;\n          let sq = 4 - soundData.length;\n          if (sq < 0) {\n              sq = 0;\n          }\n          /* eslint-disable no-bitwise */\n          sq |= (queue.rendevousMask << 3);\n          if (this.oscillators[n] && queues[n].fNextNoteTime > context.currentTime) { // note still playing?\n              sq |= 0x80; // eslint-disable-line no-bitwise\n          }\n          else if (soundData.length && (soundData[0].state & 0x40)) {\n              sq |= 0x40;\n          }\n          /* eslint-enable no-bitwise */\n          return sq;\n      }\n      setActivatedByUser() {\n          this.isActivatedByUserFlag = true;\n          if (!this.contextStartTime) { // not yet started?\n              this.contextStartTime = Date.now() / 1000; // set it\n          }\n      }\n      isActivatedByUser() {\n          return this.isActivatedByUserFlag;\n      }\n      soundOn() {\n          if (!this.isSoundOn) {\n              if (!this.context && !this.contextNotAvailable) { // try to create context\n                  this.context = this.createSoundContext(); // still undefined in case of exception\n              }\n              if (this.context) { // maybe not available\n                  this.mergerNode.connect(this.context.destination);\n              }\n              this.isSoundOn = true;\n              if (Utils.debug) {\n                  Utils.console.debug(\"soundOn: Sound switched on\");\n              }\n          }\n          return Boolean(this.context); // true if sound is available\n      }\n      soundOff() {\n          if (this.isSoundOn) {\n              if (this.context) {\n                  this.mergerNode.disconnect(this.context.destination);\n              }\n              this.isSoundOn = false;\n              if (Utils.debug) {\n                  Utils.console.debug(\"soundOff: Sound switched off\");\n              }\n          }\n      }\n  }\n\n  // ===== dist/esm/Variables.js =====\n  // Variables.ts - Variables\n  // (c) Marco Vieth, 2020\n  // https://benchmarko.github.io/cpclocots/\n\n  class ArrayProxy {\n      constructor(len) {\n          return new Proxy(new Array(len), this);\n      }\n      // eslint-disable-next-line class-methods-use-this\n      get(target, prop) {\n          if (typeof prop === \"string\" && !isNaN(Number(prop))) {\n              const numProp = Number(prop);\n              if (numProp < 0 || numProp >= target.length) {\n                  throw Utils.composeVmError(\"Variables\", Error(), 9, prop); // Subscript out of range\n              }\n          }\n          return target[prop];\n      }\n      // eslint-disable-next-line class-methods-use-this\n      set(target, prop, value) {\n          if (!isNaN(Number(prop))) {\n              const numProp = Number(prop);\n              if (numProp < 0 || numProp >= target.length) {\n                  throw Utils.composeVmError(\"Variables\", Error(), 9, prop); // Subscript out of range\n              }\n          }\n          target[prop] = value;\n          return true;\n      }\n  }\n  class Variables {\n      options;\n      variables;\n      varTypes; // default variable types for variables starting with letters a-z\n      constructor(options) {\n          this.options = {\n              arrayBounds: false\n          };\n          this.setOptions(options);\n          this.variables = {};\n          this.varTypes = {}; // default variable types for variables starting with letters a-z\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n      }\n      removeAllVariables() {\n          const variables = this.variables;\n          for (const name in variables) { // eslint-disable-line guard-for-in\n              delete variables[name];\n          }\n      }\n      getAllVariables() {\n          return this.variables;\n      }\n      getAllVarTypes() {\n          return this.varTypes;\n      }\n      createNDimArray(dims, initVal) {\n          const that = this, fnCreateRec = function (index) {\n              const len = dims[index], arr = that.options.arrayBounds ? new ArrayProxy(len) : new Array(len);\n              index += 1;\n              if (index < dims.length) { // more dimensions?\n                  for (let i = 0; i < len; i += 1) {\n                      arr[i] = fnCreateRec(index); // recursive call\n                  }\n              }\n              else { // one dimension\n                  for (let i = 0; i < len; i += 1) {\n                      arr[i] = initVal;\n                  }\n              }\n              return arr;\n          }, ret = fnCreateRec(0);\n          return ret;\n      }\n      // determine static varType (first letter + optional fixed vartype) from a variable name\n      // format: (v.|v[\"])(_)<sname>(A*)(I|R|$)([...]([...])) with optional parts in ()\n      determineStaticVarType(name) {\n          if (name.indexOf(\"v.\") === 0) { // preceding variable object?\n              name = name.substring(2); // remove preceding \"v.\"\n          }\n          if (name.indexOf('v[\"') === 0) { // preceding variable object?\n              name = name.substring(3); // remove preceding 'v[\"'\n          }\n          let nameType = name.charAt(0); // take first character to determine variable type later\n          if (nameType === \"_\") { // ignore underscore (do not clash with keywords)\n              nameType = name.charAt(1);\n          }\n          const bracketPos = name.indexOf(\"[\"), typePos = bracketPos >= 0 ? bracketPos - 1 : name.length - 1, typeChar = name.charAt(typePos); // check character before array bracket\n          if (typeChar === \"I\" || typeChar === \"R\" || typeChar === \"$\") { // explicit type specified?\n              nameType += typeChar;\n          }\n          return nameType;\n      }\n      getVarDefault(varName, dimensions) {\n          let isString = varName.includes(\"$\");\n          if (!isString) { // check dynamic varType...\n              let first = varName.charAt(0);\n              if (first === \"_\") { // ignore underscore (do not clash with keywords)\n                  first = first.charAt(1);\n              }\n              isString = (this.getVarType(first) === \"$\");\n          }\n          let value = isString ? \"\" : 0, arrayIndices = varName.split(\"A\").length - 1;\n          if (arrayIndices) {\n              if (!dimensions) {\n                  dimensions = [];\n                  if (arrayIndices > 3) { // on CPC up to 3 dimensions 0..10 without dim\n                      arrayIndices = 3;\n                  }\n                  for (let i = 0; i < arrayIndices; i += 1) {\n                      dimensions.push(11);\n                  }\n              }\n              const valueArray = this.createNDimArray(dimensions, value);\n              value = valueArray;\n          }\n          return value;\n      }\n      initVariable(name) {\n          this.variables[name] = this.getVarDefault(name);\n      }\n      dimVariable(name, dimensions) {\n          this.variables[name] = this.getVarDefault(name, dimensions);\n      }\n      getAllVariableNames() {\n          return Object.keys(this.variables);\n      }\n      getVariableIndex(name) {\n          const varNames = this.getAllVariableNames(), pos = varNames.indexOf(name);\n          return pos;\n      }\n      initAllVariables() {\n          const variables = this.getAllVariableNames();\n          for (let i = 0; i < variables.length; i += 1) {\n              this.initVariable(variables[i]);\n          }\n      }\n      getVariable(name) {\n          return this.variables[name];\n      }\n      setVariable(name, value) {\n          this.variables[name] = value;\n      }\n      getVariableByIndex(index) {\n          const variables = this.getAllVariableNames(), name = variables[index];\n          return this.variables[name];\n      }\n      variableExist(name) {\n          return name in this.variables;\n      }\n      getVarType(varChar) {\n          return this.varTypes[varChar];\n      }\n      setVarType(varChar, type) {\n          this.varTypes[varChar] = type;\n      }\n  }\n\n  // ===== dist/esm/DragElement.js =====\n  // DragElement.ts - DragElement\n  // (c) Marco Vieth, 2023\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n\n  class DragElement {\n      fnDragStartHandler;\n      fnDragMoveHandler;\n      fnDragEndHandler;\n      options;\n      containerId = \"window\" /* ViewID.window */;\n      initialX = 0;\n      initialY = 0;\n      currentX = 0;\n      currentY = 0;\n      dragInfo;\n      dragItem;\n      constructor(options) {\n          this.fnDragStartHandler = this.dragStart.bind(this);\n          this.fnDragMoveHandler = this.dragMove.bind(this);\n          this.fnDragEndHandler = this.dragEnd.bind(this);\n          this.options = {};\n          this.setOptions(options);\n      }\n      getOptions() {\n          return this.options;\n      }\n      setOptions(options) {\n          Object.assign(this.options, options);\n          const entries = this.options.entries;\n          for (const key in entries) {\n              if (entries.hasOwnProperty(key)) {\n                  const item = entries[key];\n                  if (item.enabled) {\n                      this.options.view.fnAttachPointerEvents(item.itemId, this.fnDragStartHandler);\n                  }\n                  else {\n                      this.options.view.fnDetachPointerEvents(item.itemId, this.fnDragStartHandler);\n                  }\n              }\n          }\n      }\n      dragStart(event) {\n          const node = View.getEventTarget(event), entries = this.options.entries;\n          let entry = entries[node.id];\n          if (!entry) {\n              const parentElement = node.parentElement;\n              if (parentElement && entries[parentElement.id]) {\n                  entry = entries[parentElement.id];\n                  this.dragItem = parentElement;\n              }\n              else {\n                  return;\n              }\n          }\n          else {\n              this.dragItem = node;\n          }\n          this.dragInfo = entry;\n          const dragInfo = this.dragInfo, clientObject = (event.type === \"touchstart\") ? event.touches[0] : event; // special handling for TouchEvent (otherwise MouseEvent or similar PointerEvent)\n          this.initialX = clientObject.clientX - dragInfo.xOffset;\n          this.initialY = clientObject.clientY - dragInfo.yOffset;\n          this.options.view.fnAttachPointerEvents(this.containerId, undefined, this.fnDragMoveHandler, this.fnDragEndHandler);\n          if (Utils.debug > 0) {\n              Utils.console.debug(\"dragStart: \" + dragInfo.itemId + \": x=\" + this.initialX + \", y=\" + this.initialY);\n          }\n      }\n      static setDragTranslate(xPos, yPos, el) {\n          el.style.transform = \"translate3d(\" + xPos + \"px, \" + yPos + \"px, 0)\";\n      }\n      dragMove(event) {\n          const dragInfo = this.dragInfo;\n          if (dragInfo) {\n              event.preventDefault();\n              const clientObject = (event.type === \"touchstart\") ? event.touches[0] : event;\n              this.currentX = clientObject.clientX - this.initialX;\n              this.currentY = clientObject.clientY - this.initialY;\n              dragInfo.xOffset = this.currentX;\n              dragInfo.yOffset = this.currentY;\n              DragElement.setDragTranslate(this.currentX, this.currentY, this.dragItem);\n          }\n      }\n      dragEnd(_event) {\n          const dragInfo = this.dragInfo;\n          if (dragInfo) {\n              this.options.view.fnDetachPointerEvents(this.containerId, undefined, this.fnDragMoveHandler, this.fnDragEndHandler);\n              if (Utils.debug > 0) {\n                  Utils.console.debug(\"dragEnd: \" + dragInfo.itemId + \": x=\" + this.currentX + \", y=\" + this.currentY);\n              }\n          }\n      }\n  }\n\n  // ===== dist/esm/RsxAmsdos.js =====\n  // RsxAmsdos.ts - RSX Amsdos Commands\n  // (c) Marco Vieth, 2023\n  // https://benchmarko.github.io/cpclocots/\n  //\n  class RsxAmsdos {\n      static fnGetParameterAsString(vm, stringOrAddress) {\n          let string = \"\"; // for undefined\n          if (typeof stringOrAddress === \"number\") { // assuming addressOf\n              string = String(vm.vmGetVariableByIndex(stringOrAddress) || \"\");\n          }\n          else if (typeof stringOrAddress === \"string\") {\n              string = stringOrAddress;\n          }\n          return string;\n      }\n      static dir(fileMask) {\n          const stream = 0;\n          let fileMaskString = RsxAmsdos.fnGetParameterAsString(this, fileMask);\n          if (fileMaskString) {\n              fileMaskString = this.vmAdaptFilename(fileMaskString, \"|DIR\");\n          }\n          const fileParas = {\n              stream: stream,\n              command: \"|dir\",\n              fileMask: fileMaskString,\n              line: this.line\n          };\n          this.vmStop(\"fileDir\", 45, false, fileParas);\n      }\n      static era(fileMask) {\n          const stream = 0;\n          let fileMaskString = RsxAmsdos.fnGetParameterAsString(this, fileMask);\n          fileMaskString = this.vmAdaptFilename(fileMaskString, \"|ERA\");\n          const fileParas = {\n              stream: stream,\n              command: \"|era\",\n              fileMask: fileMaskString,\n              line: this.line\n          };\n          this.vmStop(\"fileEra\", 45, false, fileParas);\n      }\n      static ren(newName, oldName) {\n          const stream = 0;\n          let newName2 = RsxAmsdos.fnGetParameterAsString(this, newName), oldName2 = RsxAmsdos.fnGetParameterAsString(this, oldName);\n          newName2 = this.vmAdaptFilename(newName2, \"|REN\");\n          oldName2 = this.vmAdaptFilename(oldName2, \"|REN\");\n          const fileParas = {\n              stream: stream,\n              command: \"|ren\",\n              fileMask: \"\", // unused\n              newName: newName2,\n              oldName: oldName2,\n              line: this.line\n          };\n          this.vmStop(\"fileRen\", 45, false, fileParas);\n      }\n      static rsxCommands = {\n          a: function () {\n              this.vmNotImplemented(\"|A\");\n          },\n          b: function () {\n              this.vmNotImplemented(\"|B\");\n          },\n          cpm: function () {\n              this.vmNotImplemented(\"|CPM\");\n          },\n          dir: RsxAmsdos.dir,\n          disc: function () {\n              this.vmNotImplemented(\"|DISC\");\n          },\n          \"disc.in\": function () {\n              this.vmNotImplemented(\"|DISC.IN\");\n          },\n          \"disc.out\": function () {\n              this.vmNotImplemented(\"|DISC.OUT\");\n          },\n          drive: function () {\n              this.vmNotImplemented(\"|DRIVE\");\n          },\n          era: RsxAmsdos.era,\n          ren: RsxAmsdos.ren,\n          tape: function () {\n              this.vmNotImplemented(\"|TAPE\");\n          },\n          \"tape.in\": function () {\n              this.vmNotImplemented(\"|TAPE.IN\");\n          },\n          \"tape.out\": function () {\n              this.vmNotImplemented(\"|TAPE.OUT\");\n          },\n          user: function () {\n              this.vmNotImplemented(\"|USER\");\n          }\n      };\n      getRsxCommands() {\n          return RsxAmsdos.rsxCommands;\n      }\n  }\n\n  // ===== dist/esm/RsxCpcLoco.js =====\n  // RsxCpcLoco.ts - RSX CpcLoco\n  // (c) Marco Vieth, 2023\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n  class RsxCpcLoco {\n      static rsxCommands = {\n          basic() {\n              Utils.console.log(\"basic: |BASIC\");\n              this.vmStop(\"reset\", 90);\n          },\n          mode: function (mode) {\n              mode = this.vmInRangeRound(Number(mode), 0, 3, \"|MODE\");\n              this.vmChangeMode(mode);\n          },\n          renum: function (...args) {\n              this.renum.apply(this, args);\n          }\n      };\n      getRsxCommands() {\n          return RsxCpcLoco.rsxCommands;\n      }\n  }\n\n  // ===== dist/esm/Controller.js =====\n  // Controller.ts - Controller\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  import { Z80Disass } from \"./Z80Disass\"; // test\n  class Controller {\n      fnRunLoopHandler;\n      fnWaitKeyHandler;\n      fnWaitInputHandler;\n      fnOnEscapeHandler;\n      fnDirectInputHandler;\n      fnPutKeyInBufferHandler;\n      fnOnDragoverHandler;\n      fnOnUserActionHandler;\n      fnWaitForContinueHandler;\n      fnEditLineCallbackHandler;\n      fnScript = undefined; // eslint-disable-line @typescript-eslint/ban-types\n      timeoutHandlerActive = false;\n      nextLoopTimeOut = 0; // next timeout for the main loop\n      initialLoopTimeout = 0;\n      inputSet = false;\n      variables;\n      basicFormatter; // for renum\n      basicTokenizer; // to decode tokenized BASIC\n      codeGeneratorToken; // to encode tokenized BASIC\n      codeGeneratorBasic; // for pretty print\n      model;\n      view;\n      commonEventHandler;\n      basicLexer;\n      basicParser;\n      codeGeneratorJs;\n      canvases = {};\n      canvas;\n      inputStack = new InputStack();\n      keyboard;\n      virtualKeyboard;\n      dragElement;\n      sound = new Sound({\n          AudioContextConstructor: window.AudioContext\n      });\n      vm;\n      noStop;\n      savedStop; // backup of stop object\n      fileHandler;\n      fileSelect;\n      hasStorageDatabase;\n      z80Disass;\n      constructor(model, view) {\n          this.fnRunLoopHandler = this.fnRunLoop.bind(this);\n          this.fnWaitKeyHandler = this.fnWaitKey.bind(this);\n          this.fnWaitInputHandler = this.fnWaitInput.bind(this);\n          this.fnOnEscapeHandler = this.fnOnEscape.bind(this);\n          this.fnDirectInputHandler = this.fnDirectInput.bind(this);\n          this.fnPutKeyInBufferHandler = this.fnPutKeysInBuffer.bind(this);\n          this.fnOnDragoverHandler = Controller.fnOnDragover;\n          this.fnOnUserActionHandler = this.onUserAction.bind(this);\n          this.fnWaitForContinueHandler = this.fnWaitForContinue.bind(this);\n          this.fnEditLineCallbackHandler = this.fnEditLineCallback.bind(this);\n          this.model = model;\n          this.view = view;\n          this.commonEventHandler = new CommonEventHandler({\n              model: model,\n              view: view,\n              controller: this\n          });\n          this.view.addEventListener(\"click\", this.commonEventHandler);\n          this.view.addEventListener(\"change\", this.commonEventHandler);\n          this.commonEventHandler.initToggles();\n          this.canvas = this.setCanvasType(model.getProperty(\"canvasType\" /* ModelPropID.canvasType */));\n          this.variables = new Variables({\n              arrayBounds: model.getProperty(\"arrayBounds\" /* ModelPropID.arrayBounds */)\n          });\n          this.fnSpeed();\n          this.commonEventHandler.onKbdLayoutSelectChange(this.commonEventHandler.getEventDefById(\"change\", \"kbdLayoutSelect\" /* ViewID.kbdLayoutSelect */));\n          this.keyboard = new Keyboard({\n              view: this.view,\n              fnOnEscapeHandler: this.fnOnEscapeHandler\n          });\n          if (this.model.getProperty(\"showKbd\" /* ModelPropID.showKbd */)) { // maybe we need to draw virtual keyboard\n              this.getVirtualKeyboard();\n          }\n          this.commonEventHandler.fnSetUserAction(this.fnOnUserActionHandler); // check first user action, also if sound is not yet on\n          this.vm = new CpcVm({\n              canvas: this.canvas,\n              keyboard: this.keyboard,\n              sound: this.sound,\n              variables: this.variables,\n              onClickKey: this.fnPutKeyInBufferHandler\n          });\n          this.vm.vmReset();\n          this.vm.vmRegisterRsx(new RsxAmsdos(), true);\n          this.vm.vmRegisterRsx(new RsxCpcLoco(), true);\n          this.noStop = Object.assign({}, this.vm.vmGetStopObject());\n          this.savedStop = {\n              reason: \"\",\n              priority: 0,\n              paras: {\n                  command: \"\",\n                  stream: 0,\n                  line: 0,\n                  first: 0, // unused\n                  last: 0 // unused\n              }\n          }; // backup of stop object\n          this.setStopObject(this.noStop);\n          this.basicParser = new BasicParser({\n              basicVersion: this.model.getProperty(\"basicVersion\" /* ModelPropID.basicVersion */)\n          });\n          this.basicLexer = new BasicLexer({\n              keywords: this.basicParser.getKeywords()\n          });\n          this.codeGeneratorJs = new CodeGeneratorJs({\n              lexer: this.basicLexer,\n              parser: this.basicParser,\n              trace: model.getProperty(\"trace\" /* ModelPropID.trace */),\n              implicitLines: model.getProperty(\"implicitLines\" /* ModelPropID.implicitLines */),\n              integerOverflow: model.getProperty(\"integerOverflow\" /* ModelPropID.integerOverflow */)\n          });\n          if (model.getProperty(\"sound\" /* ModelPropID.sound */)) { // activate sound needs user action\n              this.setSoundActive(); // activate in waiting state\n          }\n          this.initDropZone();\n          const example = model.getProperty(\"example\" /* ModelPropID.example */);\n          view.setSelectValue(\"exampleSelect\" /* ViewID.exampleSelect */, example);\n          this.hasStorageDatabase = this.initDatabases();\n          if (model.getProperty(\"showCpc\" /* ModelPropID.showCpc */)) {\n              this.canvas.startUpdateCanvas();\n          }\n          if (model.getProperty(\"dragElements\" /* ModelPropID.dragElements */)) {\n              this.fnDragElementsActive(true);\n          }\n      }\n      static codeGenJsBasicParserOptions = {\n          keepBrackets: false,\n          keepColons: false,\n          keepDataComma: false,\n          keepTokens: false\n      };\n      static codeGenTokenBasicParserOptions = {\n          keepTokens: true,\n          keepBrackets: true,\n          keepColons: true,\n          keepDataComma: true\n      };\n      static formatterBasicParserOptions = {\n          keepBrackets: false,\n          keepColons: false,\n          keepDataComma: false,\n          keepTokens: false\n      };\n      static getUniqueDbKey(name, databases) {\n          let key = name, index = 2;\n          while (databases[key]) {\n              key = name + index;\n              index += 1;\n          }\n          return key;\n      }\n      initDatabases() {\n          const model = this.model, databases = {}, databaseDirs = model.getProperty(\"databaseDirs\" /* ModelPropID.databaseDirs */).split(\",\");\n          let hasStorageDatabase = false;\n          for (let i = 0; i < databaseDirs.length; i += 1) {\n              const databaseDir = databaseDirs[i], parts1 = databaseDir.split(\"=\"), databaseSrc = parts1[0], assignedName = parts1.length > 1 ? parts1[1] : \"\", parts2 = databaseSrc.split(\"/\"), name = assignedName || parts2[parts2.length - 1], key = Controller.getUniqueDbKey(name, databases);\n              databases[key] = {\n                  text: key,\n                  title: databaseSrc,\n                  src: databaseSrc\n              };\n              if (databaseDir === \"storage\") {\n                  hasStorageDatabase = true;\n              }\n          }\n          this.model.addDatabases(databases);\n          this.setDatabaseSelectOptions();\n          return hasStorageDatabase;\n      }\n      onUserAction( /* event, id */) {\n          this.commonEventHandler.fnSetUserAction(undefined); // deactivate user action\n          this.sound.setActivatedByUser();\n          this.setSoundActive();\n      }\n      // Also called from index file 0index.js\n      addIndex(_dir, input) {\n          for (const value in input) {\n              if (input.hasOwnProperty(value)) {\n                  const item = input[value];\n                  for (let i = 0; i < item.length; i += 1) {\n                      //item[i].dir = dir; // TTT to check\n                      this.model.setExample(item[i]);\n                  }\n              }\n          }\n      }\n      // Also called from example files xxxxx.js\n      addItem(key, input) {\n          if (!key) { // maybe \"\"\n              key = (document.currentScript && document.currentScript.getAttribute(\"data-key\")) || this.model.getProperty(\"example\" /* ModelPropID.example */);\n              // on IE we can just get the current example\n          }\n          input = input.replace(/^\\n/, \"\").replace(/\\n$/, \"\"); // remove preceding and trailing newlines\n          // beware of data files ending with newlines! (do not use trimEnd)\n          const implicitLines = this.model.getProperty(\"implicitLines\" /* ModelPropID.implicitLines */), linesOnLoad = this.model.getProperty(\"linesOnLoad\" /* ModelPropID.linesOnLoad */);\n          if (input.startsWith(\"REM \") && !implicitLines && linesOnLoad) {\n              input = Controller.addLineNumbers(input);\n          }\n          const example = this.model.getExample(key);\n          example.key = key; // maybe changed\n          example.script = input;\n          example.loaded = true;\n          Utils.console.log(\"addItem:\", key);\n          return key;\n      }\n      addRsx(key, RsxConstructor) {\n          if (!key) { // maybe \"\"\n              key = (document.currentScript && document.currentScript.getAttribute(\"data-key\")) || this.model.getProperty(\"example\" /* ModelPropID.example */);\n              // on IE we can just get the current example\n          }\n          const example = this.model.getExample(key);\n          example.key = key; // maybe changed\n          example.rsx = new RsxConstructor();\n          example.loaded = true;\n          Utils.console.log(\"addItem:\", key);\n          return key;\n      }\n      setDatabaseSelectOptions() {\n          const items = [], databases = this.model.getAllDatabases(), database = this.model.getProperty(\"database\" /* ModelPropID.database */);\n          for (const value in databases) {\n              if (databases.hasOwnProperty(value)) {\n                  const db = databases[value], item = {\n                      value: value,\n                      text: db.text,\n                      title: db.title,\n                      selected: value === database\n                  };\n                  items.push(item);\n              }\n          }\n          this.view.setSelectOptions(\"databaseSelect\" /* ViewID.databaseSelect */, items);\n      }\n      static getPathFromExample(example) {\n          const index = example.lastIndexOf(\"/\");\n          let path = \"\";\n          if (index >= 0) {\n              path = example.substring(0, index);\n          }\n          return path;\n      }\n      static getNameFromExample(example) {\n          const index = example.lastIndexOf(\"/\");\n          let name = example;\n          if (index >= 0) {\n              name = example.substring(index + 1);\n          }\n          return name;\n      }\n      setDirectorySelectOptions() {\n          const items = [], allExamples = this.model.getAllExamples(), examplePath = Controller.getPathFromExample(this.model.getProperty(\"example\" /* ModelPropID.example */)), directorySeen = {};\n          for (const key in allExamples) {\n              if (allExamples.hasOwnProperty(key)) {\n                  const exampleEntry = allExamples[key], value = Controller.getPathFromExample(exampleEntry.key);\n                  if (!directorySeen[value]) {\n                      const item = {\n                          value: value,\n                          text: value,\n                          title: value,\n                          selected: value === examplePath\n                      };\n                      items.push(item);\n                      directorySeen[value] = true;\n                  }\n              }\n          }\n          this.view.setSelectOptions(\"directorySelect\" /* ViewID.directorySelect */, items);\n      }\n      setExampleSelectOptions() {\n          const maxTitleLength = 160, maxTextLength = 60, // (32 visible?)\n          items = [], exampleName = Controller.getNameFromExample(this.model.getProperty(\"example\" /* ModelPropID.example */)), allExamples = this.model.getAllExamples(), directoryName = this.view.getSelectValue(\"directorySelect\" /* ViewID.directorySelect */), selectDataFiles = this.model.getProperty(\"selectDataFiles\" /* ModelPropID.selectDataFiles */);\n          let exampleSelected = false;\n          for (const key in allExamples) {\n              if (allExamples.hasOwnProperty(key) && (Controller.getPathFromExample(key) === directoryName)) {\n                  const exampleEntry = allExamples[key], exampleName2 = Controller.getNameFromExample(exampleEntry.key);\n                  if (selectDataFiles || (exampleEntry.meta !== \"D\")) { // skip data files\n                      const title = (exampleName2 + \": \" + exampleEntry.title).substring(0, maxTitleLength), item = {\n                          value: exampleName2,\n                          title: title,\n                          text: title.substring(0, maxTextLength),\n                          selected: exampleName2 === exampleName\n                      };\n                      if (item.selected) {\n                          exampleSelected = true;\n                      }\n                      items.push(item);\n                  }\n              }\n          }\n          if (!exampleSelected && items.length) {\n              items[0].selected = true; // if example is not found, select first element\n          }\n          this.view.setSelectOptions(\"exampleSelect\" /* ViewID.exampleSelect */, items);\n      }\n      setGalleryAreaInputs() {\n          const database = this.model.getDatabase(), directory = this.view.getSelectValue(\"directorySelect\" /* ViewID.directorySelect */), options = this.view.getSelectOptions(\"exampleSelect\" /* ViewID.exampleSelect */), inputs = [];\n          for (let i = 0; i < options.length; i += 1) {\n              const item = options[i], input = {\n                  value: item.value,\n                  title: item.title,\n                  checked: item.selected,\n                  imgUrl: database.src + \"/\" + directory + \"/img/\" + item.value + \".png\"\n              };\n              inputs.push(input);\n          }\n          this.view.setAreaInputList(\"galleryAreaItems\" /* ViewID.galleryAreaItems */, inputs);\n      }\n      static fnSortByStringProperties(a, b) {\n          const x = a.value, y = b.value;\n          if (x < y) {\n              return -1;\n          }\n          else if (x > y) {\n              return 1;\n          }\n          return 0;\n      }\n      setVarSelectOptions(select, variables) {\n          const maxVarLength = 35, varNames = variables.getAllVariableNames(), items = [];\n          for (let i = 0; i < varNames.length; i += 1) {\n              const key = varNames[i], value = variables.getVariable(key), title = key + \"=\" + value;\n              let strippedTitle = title.substring(0, maxVarLength); // limit length\n              if (title !== strippedTitle) {\n                  strippedTitle += \" ...\";\n              }\n              const item = {\n                  value: key,\n                  text: strippedTitle,\n                  title: strippedTitle,\n                  selected: false\n              };\n              items.push(item);\n          }\n          items.sort(Controller.fnSortByStringProperties);\n          this.view.setSelectOptions(select, items);\n      }\n      static exportEditorText = \"<editor>\";\n      setExportSelectOptions(select) {\n          const dirList = Controller.fnGetStorageDirectoryEntries(), items = [], editorText = Controller.exportEditorText;\n          dirList.sort(); // we sort keys without editorText\n          dirList.unshift(editorText);\n          for (let i = 0; i < dirList.length; i += 1) {\n              const key = dirList[i], title = key, item = {\n                  value: key,\n                  text: title,\n                  title: title,\n                  selected: title === editorText\n              };\n              items.push(item);\n          }\n          // sort already done\n          this.view.setSelectOptions(select, items);\n      }\n      updateStorageDatabase(action, key) {\n          if (!this.hasStorageDatabase) {\n              return;\n          }\n          const database = this.model.getProperty(\"database\" /* ModelPropID.database */), storage = Utils.localStorage;\n          let selectedExample = \"\", exampleChanged = false;\n          if (database !== \"storage\") {\n              this.model.setProperty(\"database\" /* ModelPropID.database */, \"storage\"); // switch to storage database\n          }\n          else {\n              selectedExample = this.view.getSelectValue(\"exampleSelect\" /* ViewID.exampleSelect */);\n          }\n          let dir;\n          if (!key) { // no key => get all\n              dir = Controller.fnGetStorageDirectoryEntries();\n              dir.sort();\n          }\n          else {\n              dir = [key];\n          }\n          for (let i = 0; i < dir.length; i += 1) {\n              key = dir[i];\n              if (action === \"remove\") {\n                  this.model.removeExample(key);\n              }\n              else if (action === \"set\") {\n                  let example = this.model.getExample(key);\n                  if (selectedExample === \"\" || (selectedExample === key)) {\n                      exampleChanged = true;\n                  }\n                  if (!example) {\n                      const dataString = storage.getItem(key) || \"\", data = Controller.splitMeta(dataString);\n                      example = {\n                          key: key,\n                          title: \"\", // or set key?\n                          meta: data.meta.typeString // currently we take only the type\n                      };\n                      this.model.setExample(example);\n                  }\n              }\n              else {\n                  Utils.console.error(\"updateStorageDatabase: unknown action\", action);\n              }\n          }\n          if (database === \"storage\") {\n              this.setDirectorySelectOptions();\n              if (exampleChanged) {\n                  this.onDirectorySelectChange();\n              }\n              else {\n                  this.setExampleSelectOptions();\n              }\n          }\n          else {\n              this.model.setProperty(\"database\" /* ModelPropID.database */, database); // restore database\n          }\n      }\n      removeKeyBoardHandler() {\n          this.keyboard.setOptions({\n              fnOnKeyDown: undefined\n          });\n      }\n      setInputText(input, keepStack) {\n          this.view.setAreaValue(\"inputText\" /* ViewID.inputText */, input);\n          if (!keepStack) {\n              this.fnInitUndoRedoButtons();\n          }\n          else {\n              this.fnUpdateUndoRedoButtons();\n          }\n      }\n      invalidateScript() {\n          this.fnScript = undefined;\n      }\n      fnWaitForContinue() {\n          const stream = 0, key = this.keyboard.getKeyFromBuffer();\n          if (key !== \"\") {\n              this.vm.cursor(stream, 0);\n              this.removeKeyBoardHandler();\n              this.startContinue();\n          }\n      }\n      fnOnEscape() {\n          const stop = this.vm.vmGetStopObject(), stream = 0;\n          if (this.vm.vmOnBreakContSet()) {\n              // ignore break\n          }\n          else if (stop.reason === \"direct\" || this.vm.vmOnBreakHandlerActive()) {\n              stop.paras.input = \"\";\n              const msg = \"*Break*\\r\\n\";\n              this.vm.print(stream, msg);\n          }\n          else if (stop.reason !== \"escape\") { // first escape?\n              this.vm.cursor(stream, 1);\n              this.keyboard.clearInput();\n              this.keyboard.setOptions({\n                  fnOnKeyDown: this.fnWaitForContinueHandler\n              });\n              this.setStopObject(stop);\n              this.vm.vmStop(\"escape\", 85, false, {\n                  command: \"escape\",\n                  stream: stream,\n                  first: 0, // unused\n                  last: 0, // unused\n                  line: this.vm.line\n              });\n          }\n          else { // second escape\n              this.removeKeyBoardHandler();\n              this.vm.cursor(stream, 0);\n              const savedStop = this.getStopObject();\n              if (savedStop.reason === \"waitInput\") { // sepcial handling: set line to repeat input\n                  this.vm.vmGoto(savedStop.paras.line);\n              }\n              if (!this.vm.vmEscape()) {\n                  this.vm.vmStop(\"\", 0, true); // continue program, in break handler?\n                  this.setStopObject(this.noStop);\n              }\n              else {\n                  this.vm.vmStop(\"stop\", 0, true); // stop\n                  const msg = \"Break in \" + this.vm.line + \"\\r\\n\";\n                  this.vm.print(stream, msg);\n              }\n          }\n          this.startMainLoop();\n      }\n      fnWaitSound() {\n          const stop = this.vm.vmGetStopObject();\n          this.vm.vmLoopCondition(); // update nextFrameTime, timers, inks; schedule sound: free queue\n          if (this.sound.isActivatedByUser()) { // only if activated\n              const soundDataList = this.vm.vmGetSoundData();\n              while (soundDataList.length && this.sound.testCanQueue(soundDataList[0].state)) {\n                  const soundData = soundDataList.shift();\n                  this.sound.sound(soundData);\n              }\n              if (!soundDataList.length) {\n                  if (stop.reason === \"waitSound\") { // only for this reason\n                      this.vm.vmStop(\"\", 0, true); // no more wait\n                  }\n              }\n          }\n          this.nextLoopTimeOut = this.vm.vmGetTimeUntilFrame(); // wait until next frame\n      }\n      fnWaitKey() {\n          const key = this.keyboard.getKeyFromBuffer();\n          if (key !== \"\") { // do we have a key from the buffer already?\n              Utils.console.log(\"Wait for key:\", key);\n              this.vm.vmStop(\"\", 0, true);\n              this.removeKeyBoardHandler();\n          }\n          else {\n              this.fnWaitSound(); // sound and blinking events\n              // wait until keypress handler (for call &bb18)\n              this.keyboard.setOptions({\n                  fnOnKeyDown: this.fnWaitKeyHandler\n              });\n          }\n          return key;\n      }\n      fnWaitInput() {\n          const stop = this.vm.vmGetStopObject(), inputParas = stop.paras, stream = inputParas.stream;\n          let input = inputParas.input, key;\n          if (input === undefined || stream === undefined) {\n              this.outputError(this.vm.vmComposeError(Error(), 32, \"Programming Error: fnWaitInput\"), true);\n              return;\n          }\n          do {\n              key = this.keyboard.getKeyFromBuffer(); // (inkey$ could insert frame if checked too often)\n              // chr13 shows as empty string!\n              switch (key) {\n                  case \"\": // no key?\n                      break;\n                  case \"\\r\": // cr (\\x0d)\n                      break;\n                  case \"\\x10\": // DLE (clear character under cursor)\n                      key = \"\\x07\"; // currently ignore (BEL)\n                      break;\n                  case \"\\x7f\": // del\n                      if (input.length) {\n                          input = input.slice(0, -1);\n                          key = \"\\x08\\x10\"; // use BS and DLE\n                      }\n                      else {\n                          key = \"\\x07\"; // ignore BS, use BEL\n                      }\n                      break;\n                  case \"\\xe0\": // copy\n                      key = this.vm.copychr$(stream);\n                      if (key.length) {\n                          input += key;\n                          key = \"\\x09\"; // TAB\n                      }\n                      else {\n                          key = \"\\x07\"; // ignore (BEL)\n                      }\n                      break;\n                  case \"\\xf0\": // cursor up\n                      if (!input.length) {\n                          key = \"\\x0b\"; // VT\n                      }\n                      else {\n                          key = \"\\x07\"; // ignore (BEL)\n                      }\n                      break;\n                  case \"\\xf1\": // cursor down\n                      if (!input.length) {\n                          key = \"\\x0a\"; // LF\n                      }\n                      else {\n                          key = \"\\x07\"; // ignore (BEL)\n                      }\n                      break;\n                  case \"\\xf2\": // cursor left\n                      if (!input.length) {\n                          key = \"\\x08\"; // BS\n                      }\n                      else {\n                          key = \"\\x07\"; // ignore (BEL) TODO\n                      }\n                      break;\n                  case \"\\xf3\": // cursor right\n                      if (!input.length) {\n                          key = \"\\x09\"; // TAB\n                      }\n                      else {\n                          key = \"\\x07\"; // ignore (BEL) TODO\n                      }\n                      break;\n                  case \"\\xf4\": // shift+cursor up\n                      key = \"\"; // currently ignore\n                      break;\n                  case \"\\xf5\": // shift+cursor down\n                      key = \"\"; // currently ignore\n                      break;\n                  case \"\\xf6\": // shift+cursor left\n                      key = \"\"; // currently ignore\n                      break;\n                  case \"\\xf7\": // shift+cursor right\n                      key = \"\"; // currently ignore\n                      break;\n                  case \"\\xf8\": // ctrl+cursor up\n                      key = \"\"; // currently ignore\n                      break;\n                  case \"\\xf9\": // ctrl+cursor down\n                      key = \"\"; // currently ignore\n                      break;\n                  case \"\\xfa\": // ctrl+cursor left\n                      key = \"\"; // currently ignore\n                      break;\n                  case \"\\xfb\": // ctrl+cursor right\n                      key = \"\"; // currently ignore\n                      break;\n                  default:\n                      input += key;\n                      if (key < \"\\x20\") { // control code\n                          key = \"\\x01\" + key; // print control code (do not execute)\n                      }\n                      break;\n              }\n              if (key && key !== \"\\r\") {\n                  this.vm.print(stream, key);\n              }\n          } while (key !== \"\" && key !== \"\\r\"); // get all keys until CR or no more key\n          inputParas.input = input;\n          let inputOk = false;\n          if (key === \"\\r\") {\n              Utils.console.log(\"fnWaitInput:\", input, \"reason\", stop.reason);\n              if (!inputParas.noCRLF) {\n                  this.vm.print(stream, \"\\r\\n\");\n              }\n              if (inputParas.fnInputCallback) {\n                  inputOk = inputParas.fnInputCallback();\n              }\n              else {\n                  inputOk = true;\n              }\n              if (inputOk) {\n                  this.removeKeyBoardHandler();\n                  if (stop.reason === \"waitInput\") { // only for this reason\n                      this.vm.vmStop(\"\", 0, true); // no more wait\n                  }\n                  else {\n                      this.startContinue();\n                  }\n              }\n          }\n          if (!inputOk) {\n              if (stop.reason === \"waitInput\") { // only for this reason\n                  this.fnWaitSound(); // sound and blinking events\n              }\n              // make sure the handler is set\n              this.keyboard.setOptions({\n                  fnOnKeyDown: this.fnWaitInputHandler\n              });\n          }\n      }\n      static parseLineNumber(line) {\n          return parseInt(line, 10); // we do not check for linenumber in range 0...65535\n      }\n      static addLineNumbers(input) {\n          const lineParts = input.split(\"\\n\");\n          let lastLine = 0;\n          for (let i = 0; i < lineParts.length; i += 1) {\n              let lineNum = parseInt(lineParts[i], 10);\n              if (isNaN(lineNum)) {\n                  lineNum = lastLine + 1;\n                  lineParts[i] = String(lastLine + 1) + \" \" + lineParts[i];\n              }\n              lastLine = lineNum;\n          }\n          return lineParts.join(\"\\n\");\n      }\n      splitLines(input) {\n          if (this.model.getProperty(\"implicitLines\" /* ModelPropID.implicitLines */)) {\n              input = Controller.addLineNumbers(input);\n          }\n          // get numbers starting at the beginning of a line (allows some simple multi line strings)\n          const lineParts = input.split(/^(\\s*\\d+)/m), lines = [];\n          if (lineParts[0] === \"\") {\n              lineParts.shift(); // remove first empty item\n          }\n          if (lineParts.length % 2 !== 0) {\n              Utils.console.warn(\"splitLines: No line numbers?\");\n              const error = this.vm.vmComposeError(Error(), 21, \"split\"); // \"Direct command found\"\n              this.outputError(error, true);\n              return lines;\n          }\n          for (let i = 0; i < lineParts.length; i += 2) {\n              const number = lineParts[i];\n              let content = lineParts[i + 1];\n              if (content.endsWith(\"\\n\")) {\n                  content = content.substring(0, content.length - 1);\n              }\n              lines.push(number + content);\n          }\n          return lines;\n      }\n      // merge two scripts with sorted line numbers, lines from script2 overwrite lines from script1\n      mergeScripts(script1, script2) {\n          const lines1 = this.splitLines(Utils.stringTrimEnd(script1)), lines2 = this.splitLines(Utils.stringTrimEnd(script2));\n          let result = [], lineNumber1, lineNumber2;\n          while (lines1.length && lines2.length) {\n              lineNumber1 = lineNumber1 || Controller.parseLineNumber(lines1[0]);\n              lineNumber2 = lineNumber2 || Controller.parseLineNumber(lines2[0]);\n              if (lineNumber1 < lineNumber2) { // use line from script1\n                  result.push(lines1.shift());\n                  lineNumber1 = 0;\n              }\n              else { // use line from script2\n                  const line2 = lines2.shift();\n                  if (String(lineNumber2) !== line2) { // line not empty?\n                      result.push(line2);\n                  }\n                  if (lineNumber1 === lineNumber2) { // same line number in script1 and script2\n                      lines1.shift(); // ignore line from script1 (overwrite it)\n                      lineNumber1 = 0;\n                  }\n                  lineNumber2 = 0;\n              }\n          }\n          result = result.concat(lines1, lines2); // put in remaining lines from one source\n          if (result.length >= 2) {\n              if (result[result.length - 2] === \"\" && result[result.length - 1] === \"\") {\n                  result.pop(); // remove additional newline\n              }\n          }\n          return result.join(\"\\n\");\n      }\n      // get line range from a script with sorted line numbers\n      fnGetLinesInRange(script, firstLine, lastLine) {\n          const lines = script ? this.splitLines(script) : [];\n          while (lines.length && Controller.parseLineNumber(lines[0]) < firstLine) {\n              lines.shift();\n          }\n          if (lines.length && lines[lines.length - 1] === \"\") { // trailing empty line?\n              lines.pop(); // remove\n          }\n          while (lines.length && Controller.parseLineNumber(lines[lines.length - 1]) > lastLine) {\n              lines.pop();\n          }\n          return lines;\n      }\n      static fnPrepareMaskRegExp(mask) {\n          mask = mask.replace(/([.+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n          mask = mask.replace(/\\?/g, \".\");\n          mask = mask.replace(/\\*/g, \".*\");\n          return new RegExp(\"^\" + mask + \"$\");\n      }\n      fnGetExampleDirectoryEntries(mask) {\n          const dir = [], allExamples = this.model.getAllExamples();\n          let regExp;\n          if (mask) {\n              regExp = Controller.fnPrepareMaskRegExp(mask);\n          }\n          for (const key in allExamples) {\n              if (allExamples.hasOwnProperty(key)) {\n                  const example = allExamples[key], key2 = example.key, matchKey2 = key2 + ((key2.indexOf(\".\") < 0) ? \".\" : \"\");\n                  if (!regExp || regExp.test(matchKey2)) {\n                      dir.push(key2);\n                  }\n              }\n          }\n          return dir;\n      }\n      static fnGetStorageDirectoryEntries(mask) {\n          const storage = Utils.localStorage, metaIdent = FileHandler.getMetaIdent(), dir = [];\n          let regExp;\n          if (mask) {\n              regExp = Controller.fnPrepareMaskRegExp(mask);\n          }\n          for (let i = 0; i < storage.length; i += 1) {\n              const key = storage.key(i);\n              if (key !== null && storage[key].startsWith(metaIdent)) { // take only CpcLoco files\n                  const keywithOutNl = key.replace(/[\\n\\r]/g, \"\"); // support also strange names; (newer browsers support also \"s\" regex modifier)\n                  if (!regExp || regExp.test(keywithOutNl)) {\n                      dir.push(key);\n                  }\n              }\n          }\n          return dir;\n      }\n      fnPrintDirectoryEntries(stream, dir, sort) {\n          // first, format names\n          for (let i = 0; i < dir.length; i += 1) {\n              const parts = dir[i].split(\".\");\n              dir[i] = parts[0].padEnd(8, \" \") + \".\" + (parts.length >= 2 ? parts[1] : \"\").padEnd(3, \" \");\n          }\n          if (sort) {\n              dir.sort();\n          }\n          this.vm.print(stream, \"\\r\\nDrive A: user  0\\r\\n\\r\\n\");\n          for (let i = 0; i < dir.length; i += 1) {\n              const key = dir[i] + \"  \";\n              this.vm.print(stream, key);\n          }\n          this.vm.print(stream, \"\\r\\n\\r\\n999K free\\r\\n\\r\\n\");\n      }\n      fnFileCat(paras) {\n          const stream = paras.stream, dirList = Controller.fnGetStorageDirectoryEntries();\n          this.fnPrintDirectoryEntries(stream, dirList, true);\n          // currently only from localstorage\n          this.vm.vmStop(\"\", 0, true);\n      }\n      fnFileDir(paras) {\n          const stream = paras.stream, example = this.model.getProperty(\"example\" /* ModelPropID.example */), lastSlash = example.lastIndexOf(\"/\");\n          let fileMask = paras.fileMask ? Controller.fnLocalStorageName(paras.fileMask) : \"\";\n          const dirList = Controller.fnGetStorageDirectoryEntries(fileMask);\n          let path = \"\";\n          if (lastSlash >= 0) {\n              path = example.substring(0, lastSlash) + \"/\";\n              fileMask = path + (fileMask ? fileMask : \"*.*\"); // only in same directory\n          }\n          const fileExists = {};\n          for (let i = 0; i < dirList.length; i += 1) {\n              fileExists[dirList[i]] = true;\n          }\n          const dirListEx = this.fnGetExampleDirectoryEntries(fileMask); // also from examples\n          for (let i = 0; i < dirListEx.length; i += 1) {\n              const file = dirListEx[i].substring(path.length); // remove preceding path including \"/\"\n              if (!fileExists[file]) { // ignore duplicates\n                  fileExists[file] = true;\n                  dirList.push(file);\n              }\n          }\n          this.fnPrintDirectoryEntries(stream, dirList, false);\n          this.vm.vmStop(\"\", 0, true);\n      }\n      fnFileEra(paras) {\n          const stream = paras.stream, storage = Utils.localStorage, fileMask = Controller.fnLocalStorageName(paras.fileMask || \"\"), dir = Controller.fnGetStorageDirectoryEntries(fileMask);\n          if (!dir.length) {\n              this.vm.print(stream, fileMask + \" not found\\r\\n\");\n          }\n          for (let i = 0; i < dir.length; i += 1) {\n              const name = dir[i];\n              if (storage.getItem(name) !== null) {\n                  storage.removeItem(name);\n                  this.updateStorageDatabase(\"remove\", name);\n                  if (Utils.debug > 0) {\n                      Utils.console.debug(\"fnEraseFile: name=\" + name + \": removed from localStorage\");\n                  }\n              }\n              else {\n                  this.vm.print(stream, name + \" not found\\r\\n\");\n                  Utils.console.warn(\"fnEraseFile: file not found in localStorage:\", name);\n              }\n          }\n          this.vm.vmStop(\"\", 0, true);\n      }\n      fnFileRen(paras) {\n          const stream = paras.stream, storage = Utils.localStorage, newName = Controller.fnLocalStorageName(paras.newName), oldName = Controller.fnLocalStorageName(paras.oldName), item = storage.getItem(oldName);\n          if (item !== null) {\n              if (!storage.getItem(newName)) {\n                  storage.setItem(newName, item);\n                  this.updateStorageDatabase(\"set\", newName);\n                  storage.removeItem(oldName);\n                  this.updateStorageDatabase(\"remove\", oldName);\n              }\n              else {\n                  this.vm.print(stream, oldName + \" already exists\\r\\n\");\n              }\n          }\n          else {\n              this.vm.print(stream, oldName + \" not found\\r\\n\");\n          }\n          this.vm.vmStop(\"\", 0, true);\n      }\n      // Hisoft Devpac GENA3 Z80 Assember (http://www.cpcwiki.eu/index.php/Hisoft_Devpac)\n      static asmGena3Convert(data) {\n          const fnUInt16 = function (pos2) {\n              return data.charCodeAt(pos2) + data.charCodeAt(pos2 + 1) * 256;\n          }, length = data.length;\n          let pos = 0, out = \"\";\n          pos += 4; // what is the meaning of these bytes?\n          while (pos < length) {\n              const lineNum = fnUInt16(pos);\n              pos += 2;\n              let index1 = data.indexOf(\"\\r\", pos); // EOL marker 0x0d\n              if (index1 < 0) {\n                  index1 = length;\n              }\n              let index2 = data.indexOf(\"\\x1c\", pos); // EOL marker 0x1c\n              if (index2 < 0) {\n                  index2 = length;\n              }\n              index1 = Math.min(index1, index2);\n              out += lineNum + \" \" + data.substring(pos, index1) + \"\\n\";\n              pos = index1 + 1;\n          }\n          return out;\n      }\n      getBasicFormatter() {\n          if (!this.basicFormatter) {\n              this.basicFormatter = new BasicFormatter({\n                  lexer: this.basicLexer,\n                  parser: this.basicParser\n              });\n          }\n          return this.basicFormatter;\n      }\n      getBasicTokenizer() {\n          if (!this.basicTokenizer) {\n              this.basicTokenizer = new BasicTokenizer();\n          }\n          return this.basicTokenizer;\n      }\n      getCodeGeneratorBasic() {\n          if (!this.codeGeneratorBasic) {\n              this.codeGeneratorBasic = new CodeGeneratorBasic({\n                  lexer: this.basicLexer,\n                  parser: this.basicParser,\n                  lowercaseVars: this.model.getProperty(\"prettyLowercaseVars\" /* ModelPropID.prettyLowercaseVars */)\n              });\n          }\n          return this.codeGeneratorBasic;\n      }\n      getCodeGeneratorToken() {\n          if (!this.codeGeneratorToken) {\n              this.codeGeneratorToken = new CodeGeneratorToken({\n                  lexer: this.basicLexer,\n                  parser: this.basicParser,\n                  implicitLines: this.model.getProperty(\"implicitLines\" /* ModelPropID.implicitLines */)\n              });\n          }\n          return this.codeGeneratorToken;\n      }\n      decodeTokenizedBasic(input) {\n          const basicTokenizer = this.getBasicTokenizer();\n          return basicTokenizer.decode(input);\n      }\n      encodeTokenizedBasic(input, name = \"test\") {\n          const codeGeneratorToken = this.getCodeGeneratorToken();\n          this.basicLexer.setOptions({\n              keepWhiteSpace: true\n          });\n          this.basicParser.setOptions(Controller.codeGenTokenBasicParserOptions);\n          const output = codeGeneratorToken.generate(input);\n          if (output.error) {\n              this.outputError(output.error);\n          }\n          else if (Utils.debug > 1) {\n              const outputText = output.text, hex = outputText.split(\"\").map(function (s) { return s.charCodeAt(0).toString(16).toUpperCase().padStart(2, \"0\"); }).join(\",\"), decoded = this.decodeTokenizedBasic(outputText), diff = Diff.testDiff(input.toUpperCase(), decoded.toUpperCase()); // for testing\n              Utils.console.debug(\"TokenizerInput (\" + name + \") [len=\" + input.length + \"]:\\n\" + input);\n              Utils.console.debug(\"TokenizerOutputHex (\" + name + \") [len=\" + outputText.length + \"]:\\n\" + hex);\n              Utils.console.debug(\"TokenizerOutputDecoded (\" + name + \") [len=\" + decoded.length + \"]:\\n\" + decoded);\n              Utils.console.debug(\"TokenizerDiff (\" + name + \") [len=\" + diff.length + \"]:\\n\" + diff);\n          }\n          return output.text;\n      }\n      prettyPrintBasic(input, keepWhiteSpace, keepBrackets, keepColons) {\n          const codeGeneratorBasic = this.getCodeGeneratorBasic(), keepDataComma = true;\n          this.basicLexer.setOptions({\n              keepWhiteSpace: keepWhiteSpace\n          });\n          this.basicParser.setOptions({\n              keepTokens: true,\n              keepBrackets: keepBrackets,\n              keepColons: keepColons,\n              keepDataComma: keepDataComma\n          });\n          const output = codeGeneratorBasic.generate(input);\n          if (output.error) {\n              this.outputError(output.error);\n          }\n          return output.text;\n      }\n      // gate array ink to basic ink\n      static gaInk2Ink = [\n          13,\n          27,\n          19,\n          25,\n          1,\n          7,\n          10,\n          16,\n          28,\n          29,\n          24,\n          26,\n          6,\n          8,\n          15,\n          17,\n          30,\n          31,\n          18,\n          20,\n          0,\n          2,\n          9,\n          11,\n          4,\n          22,\n          21,\n          23,\n          3,\n          5,\n          12,\n          14\n      ];\n      applyGaInks(inkval) {\n          for (let i = 0; i < inkval.length - 1; i += 1) {\n              this.vm.ink(i, Controller.gaInk2Ink[inkval[i]]);\n          }\n          this.vm.border(Controller.gaInk2Ink[inkval[inkval.length - 1]]);\n      }\n      applyCrtcRegs(reg) {\n          for (let i = 0; i < reg.length; i += 1) {\n              this.vm.vmSetCrtcData(i, reg[i]);\n          }\n      }\n      applySnapshot(input) {\n          const snapshot = new Snapshot({\n              name: \"\",\n              data: input\n          }), info = snapshot.getSnapshotInfo(), mode = info.ga.multi & 0x03, // eslint-disable-line no-bitwise\n          mem = snapshot.getMemory();\n          this.vm.vmChangeMode(mode);\n          this.applyGaInks(info.ga.inkval);\n          this.vm.vmSetRamSelect(info.ramconf);\n          this.applyCrtcRegs(info.crtc.reg);\n          return mem;\n      }\n      loadFileContinue(input) {\n          const inFile = this.vm.vmGetInFileObject();\n          let data;\n          if (input !== null && input !== undefined) {\n              data = Controller.splitMeta(input);\n              input = data.data; // maybe changed\n              if (data.meta.encoding === \"base64\") {\n                  input = Utils.atob(input); // decode base64\n              }\n              const type = data.meta.typeString;\n              if (type === \"T\") { // tokenized basic?\n                  input = this.decodeTokenizedBasic(input);\n              }\n              else if (type === \"P\") { // BASIC?\n                  input = DiskImage.unOrProtectData(input);\n                  input = this.decodeTokenizedBasic(input);\n              }\n              else if (type === \"B\") { // binary?\n              }\n              else if (type === \"A\") { // ASCII?\n                  // remove EOF character(s) (0x1a) from the end of file\n                  input = input.replace(/\\x1a+$/, \"\"); // eslint-disable-line no-control-regex\n              }\n              else if (type === \"G\") { // Hisoft Devpac GENA3 Z80 Assember\n                  input = Controller.asmGena3Convert(input);\n              }\n              else if (type === \"S\") { // Snapshot\n                  input = this.applySnapshot(input);\n              }\n              else if (type === \"X\") { // (Extended) Disk image file\n                  const fileHandler = this.getFileHandler(), imported = [];\n                  fileHandler.fnLoad2(input, inFile.name, type, imported); // no meta in data\n                  input = \"1 ' \" + imported.join(\", \"); // imported files\n              }\n              else if (type === \"Z\") { // ZIP file\n                  const fileHandler = this.getFileHandler(), imported = [];\n                  fileHandler.fnLoad2(input, inFile.name, type, imported);\n                  input = \"1 ' \" + imported.join(\", \"); // imported files\n              }\n          }\n          const command = inFile.command, // create copy of data\n          inFileLine = inFile.line || 0;\n          let putInMemory = false, startLine = 0;\n          if (inFile.fnFileCallback) {\n              try {\n                  // the callback could close inFile, so do not use it any more\n                  putInMemory = inFile.fnFileCallback(input, data && data.meta);\n              }\n              catch (e) {\n                  Utils.console.warn(e);\n              }\n          }\n          if (input === undefined) {\n              Utils.console.error(\"loadFileContinue: File \" + inFile.name + \": input undefined!\");\n              this.vm.vmStop(\"stop\", 60, true);\n              this.startMainLoop();\n              return;\n          }\n          if (input === null) {\n              this.startMainLoop();\n              return;\n          }\n          if (data && data.meta.typeString === \"S\" && putInMemory) { // fast hack\n              input = this.decodeTokenizedBasic(input.substring(0x170));\n              putInMemory = false; // put input in text box\n          }\n          switch (command) {\n              case \"openin\":\n                  break;\n              case \"chainMerge\":\n                  input = this.mergeScripts(this.view.getAreaValue(\"inputText\" /* ViewID.inputText */), input);\n                  this.setInputText(input);\n                  this.view.setAreaValue(\"resultText\" /* ViewID.resultText */, \"\");\n                  startLine = inFileLine;\n                  this.invalidateScript();\n                  this.fnParseChain();\n                  break;\n              case \"load\":\n                  if (!putInMemory) {\n                      this.setInputText(input);\n                      this.view.setAreaValue(\"resultText\" /* ViewID.resultText */, \"\");\n                      this.invalidateScript();\n                      this.vm.vmStop(\"end\", 90);\n                  }\n                  break;\n              case \"merge\":\n                  input = this.mergeScripts(this.view.getAreaValue(\"inputText\" /* ViewID.inputText */), input);\n                  this.setInputText(input);\n                  this.view.setAreaValue(\"resultText\" /* ViewID.resultText */, \"\");\n                  this.invalidateScript();\n                  this.fnRemoveAllVariables();\n                  this.vm.vmStop(\"end\", 90);\n                  break;\n              case \"chain\": // TODO: if we have a line number, make sure it is not optimized away when compiling\n                  this.setInputText(input);\n                  this.view.setAreaValue(\"resultText\" /* ViewID.resultText */, \"\");\n                  startLine = inFileLine;\n                  this.invalidateScript();\n                  this.fnParseChain();\n                  break;\n              case \"run\":\n                  if (!putInMemory) {\n                      this.setInputText(input);\n                      this.view.setAreaValue(\"resultText\" /* ViewID.resultText */, \"\");\n                      startLine = inFileLine;\n                      if (!data || data.meta.typeString !== \"S\") { // keep memory, config for snapshots\n                          this.fnReset();\n                      }\n                      this.fnParseRun();\n                  }\n                  else {\n                      this.fnReset();\n                      this.vm.clear(); // do we need this?\n                  }\n                  break;\n              default:\n                  Utils.console.error(\"loadExample: Unknown command:\", command);\n                  break;\n          }\n          this.vm.vmSetStartLine(startLine);\n          this.startMainLoop();\n      }\n      createFnExampleLoaded(example, url, inFile) {\n          return (_sFullUrl, key, suppressLog) => {\n              if (key !== example) {\n                  Utils.console.warn(\"fnExampleLoaded: Unexpected\", key, \"<>\", example);\n              }\n              const exampleEntry = this.model.getExample(example);\n              if (!suppressLog) {\n                  Utils.console.log(\"Example\", url, (exampleEntry.meta ? exampleEntry.meta + \" \" : \"\") + \"loaded\");\n              }\n              this.model.setProperty(\"example\" /* ModelPropID.example */, inFile.memorizedExample);\n              this.vm.vmStop(\"\", 0, true);\n              if (exampleEntry.rsx) {\n                  this.vm.vmRegisterRsx(exampleEntry.rsx, false);\n              }\n              const input = exampleEntry.script;\n              this.loadFileContinue(input);\n          };\n      }\n      createFnExampleError(example, url, inFile) {\n          return () => {\n              Utils.console.log(\"Example\", url, \"error\");\n              this.model.setProperty(\"example\" /* ModelPropID.example */, inFile.memorizedExample);\n              this.vm.vmStop(\"\", 0, true);\n              const error = this.vm.vmComposeError(Error(), 32, example + \" not found\"); // TODO: set also derr=146 (xx not found)\n              // error or onError set\n              if (error.hidden) {\n                  this.vm.vmStop(\"\", 0, true); // clear onError\n              }\n              this.outputError(error, true);\n              this.loadFileContinue(null);\n          };\n      }\n      loadExample() {\n          const inFile = this.vm.vmGetInFileObject(), key = this.model.getProperty(\"example\" /* ModelPropID.example */);\n          let name = inFile.name;\n          if (name.charAt(0) === \"/\") { // absolute path?\n              name = name.substring(1); // remove \"/\"\n              inFile.memorizedExample = name; // change!\n          }\n          else {\n              inFile.memorizedExample = key;\n              const lastSlash = key.lastIndexOf(\"/\");\n              if (lastSlash >= 0) {\n                  const path = key.substring(0, lastSlash); // take path from selected example\n                  name = path + \"/\" + name;\n                  name = name.replace(/\\w+\\/\\.\\.\\//, \"\"); // simplify 2 dots (go back) in path: \"dir/..\"\" => \"\"\n              }\n          }\n          const example = name;\n          if (Utils.debug > 0) {\n              Utils.console.debug(\"loadExample: name=\" + name + \" (current=\" + key + \")\");\n          }\n          const exampleEntry = this.model.getExample(example); // already loaded\n          let url;\n          if (exampleEntry && exampleEntry.loaded) {\n              this.model.setProperty(\"example\" /* ModelPropID.example */, example);\n              url = example;\n              const fnExampleLoaded = this.createFnExampleLoaded(example, url, inFile);\n              fnExampleLoaded(\"\", example, true);\n          }\n          else if (example && exampleEntry) { // need to load\n              this.model.setProperty(\"example\" /* ModelPropID.example */, example);\n              const databaseDir = this.model.getDatabase().src;\n              url = databaseDir + \"/\" + example + \".js\";\n              Utils.loadScript(url, this.createFnExampleLoaded(example, url, inFile), this.createFnExampleError(example, url, inFile), example);\n          }\n          else { // keep original example in this error case\n              url = example;\n              if (example !== \"\") { // only if not empty\n                  Utils.console.warn(\"loadExample: Unknown file:\", example);\n                  const fnExampleError = this.createFnExampleError(example, url, inFile);\n                  fnExampleError();\n              }\n              else {\n                  this.model.setProperty(\"example\" /* ModelPropID.example */, example);\n                  this.vm.vmStop(\"\", 0, true);\n                  this.loadFileContinue(\"\"); // empty input?\n              }\n          }\n      }\n      static fnLocalStorageName(name, defaultExtension) {\n          // modify name so we do not clash with localstorage methods/properites\n          if (name.indexOf(\".\") < 0) { // no dot inside name?\n              name += \".\" + (defaultExtension || \"\"); // append dot or default extension\n          }\n          return name;\n      }\n      static defaultExtensions = [\n          \"\",\n          \"bas\",\n          \"bin\"\n      ];\n      static tryLoadingFromLocalStorage(name) {\n          const storage = Utils.localStorage;\n          let input = null;\n          if (name.indexOf(\".\") >= 0) { // extension specified?\n              input = storage.getItem(name);\n          }\n          else {\n              for (let i = 0; i < Controller.defaultExtensions.length; i += 1) {\n                  const storageName = Controller.fnLocalStorageName(name, Controller.defaultExtensions[i]);\n                  input = storage.getItem(storageName);\n                  if (input !== null) {\n                      break; // found\n                  }\n              }\n          }\n          return input; // null=not found\n      }\n      fnFileLoad() {\n          const inFile = this.vm.vmGetInFileObject();\n          if (inFile.open) {\n              if (inFile.command === \"chainMerge\" && inFile.first && inFile.last) { // special handling to delete line numbers first\n                  this.fnDeleteLines({\n                      first: inFile.first,\n                      last: inFile.last,\n                      command: \"CHAIN MERGE\",\n                      stream: 0, // unused\n                      line: this.vm.line\n                  });\n                  this.vm.vmStop(\"fileLoad\", 90); // restore\n              }\n              const name = inFile.name;\n              if (Utils.debug > 1) {\n                  Utils.console.debug(\"fnFileLoad:\", inFile.command, name, \"details:\", inFile);\n              }\n              const input = Controller.tryLoadingFromLocalStorage(name);\n              if (input !== null) {\n                  if (Utils.debug > 0) {\n                      Utils.console.debug(\"fnFileLoad:\", inFile.command, name, \"from localStorage\");\n                  }\n                  this.vm.vmStop(\"\", 0, true);\n                  this.loadFileContinue(input);\n              }\n              else { // load from example\n                  this.loadExample( /* name */);\n              }\n          }\n          else {\n              Utils.console.error(\"fnFileLoad:\", inFile.name, \"File not open!\"); // hopefully isName is defined\n          }\n          this.nextLoopTimeOut = this.vm.vmGetTimeUntilFrame(); // wait until next frame\n      }\n      static splitMeta(input) {\n          let fileMeta;\n          if (input.indexOf(FileHandler.getMetaIdent()) === 0) { // starts with metaIdent?\n              const index = input.indexOf(\",\"); // metadata separator\n              if (index >= 0) {\n                  const metaString = input.substring(0, index);\n                  input = input.substring(index + 1);\n                  const meta = metaString.split(\";\");\n                  fileMeta = {\n                      typeString: meta[1],\n                      start: Number(meta[2]),\n                      length: Number(meta[3]),\n                      entry: Number(meta[4]),\n                      encoding: meta[5]\n                  };\n              }\n          }\n          if (!fileMeta) {\n              fileMeta = {\n                  typeString: \"\"\n              };\n          }\n          const metaAndData = {\n              meta: fileMeta,\n              data: input\n          };\n          return metaAndData;\n      }\n      fnFileSave() {\n          const outFile = this.vm.vmGetOutFileObject(), storage = Utils.localStorage;\n          let defaultExtension = \"\";\n          if (outFile.open) {\n              const type = outFile.typeString, name = outFile.name;\n              if (type === \"P\" || type === \"T\") {\n                  defaultExtension = \"bas\";\n              }\n              else if (type === \"B\") {\n                  defaultExtension = \"bin\";\n              }\n              const storageName = Controller.fnLocalStorageName(name, defaultExtension);\n              let fileData;\n              if (outFile.fileData.length || (type === \"B\") || (outFile.command === \"openout\")) { // type A(for openout) or B\n                  fileData = outFile.fileData.join(\"\");\n                  if (!outFile.length) { // not yet set, e.g. for ASCII? (or can we set it always?)\n                      outFile.length = fileData.length; // set length\n                  }\n              }\n              else { // no file data (assuming type A, P or T) => get text\n                  fileData = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */);\n                  if (type === \"T\" || type === \"P\") {\n                      fileData = this.encodeTokenizedBasic(fileData, storageName);\n                      if (fileData === \"\") {\n                          outFile.typeString = \"A\"; // override type\n                      }\n                      else if (type === \"P\") {\n                          fileData = DiskImage.unOrProtectData(fileData);\n                      }\n                  }\n                  outFile.length = fileData.length; // set length\n              }\n              if (Utils.debug > 0) {\n                  Utils.console.debug(\"fnFileSave: name=\" + name + \": put into localStorage\");\n              }\n              const meta = FileHandler.joinMeta(outFile);\n              storage.setItem(storageName, meta + \",\" + fileData);\n              this.updateStorageDatabase(\"set\", storageName);\n              if (outFile.fnFileCallback) {\n                  try {\n                      outFile.fnFileCallback(fileData); // close file\n                  }\n                  catch (e) {\n                      Utils.console.warn(e);\n                  }\n              }\n              this.vm.vmResetOutFileHandling(); // make sure it is closed\n          }\n          else {\n              Utils.console.error(\"fnFileSave: file not open!\");\n          }\n          this.vm.vmStop(\"\", 0, true); // continue\n      }\n      fnDeleteLines(paras) {\n          const inputText = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */), lines = this.fnGetLinesInRange(inputText, paras.first || 0, paras.last || 65535);\n          let error;\n          if (lines.length) {\n              for (let i = 0; i < lines.length; i += 1) {\n                  const line = Controller.parseLineNumber(lines[i]);\n                  if (isNaN(line)) {\n                      error = this.vm.vmComposeError(Error(), 21, paras.command); // \"Direct command found\"\n                      this.outputError(error, true);\n                      break;\n                  }\n                  lines[i] = String(line); // keep just the line numbers\n              }\n              if (!error) {\n                  let input = lines.join(\"\\n\");\n                  input = this.mergeScripts(inputText, input); // delete input lines\n                  this.setInputText(input);\n              }\n          }\n          this.vm.vmGoto(0); // reset current line\n          this.vm.vmStop(\"end\", 0, true);\n      }\n      fnNew() {\n          const input = \"\";\n          this.setInputText(input);\n          this.fnRemoveAllVariables();\n          this.vm.vmGoto(0); // reset current line\n          this.vm.vmStop(\"end\", 0, true);\n          this.invalidateScript();\n      }\n      fnList(paras) {\n          const input = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */), stream = paras.stream, lines = this.fnGetLinesInRange(input, paras.first || 0, paras.last || 65535), regExp = new RegExp(/([\\x00-\\x1f])/g); // eslint-disable-line no-control-regex\n          for (let i = 0; i < lines.length; i += 1) {\n              let line = lines[i];\n              if (stream !== 9) {\n                  line = line.replace(regExp, \"\\x01$1\"); // escape control characters to print them directly\n              }\n              this.vm.print(stream, line, \"\\r\\n\");\n          }\n          this.vm.vmGoto(0); // reset current line\n          this.vm.vmStop(\"end\", 0, true);\n      }\n      fnReset() {\n          const vm = this.vm;\n          this.fnRemoveAllVariables();\n          vm.vmReset();\n          if (this.virtualKeyboard) {\n              this.virtualKeyboard.reset();\n          }\n          vm.vmStop(\"end\", 0, true); // set \"end\" with priority 0, so that \"compile only\" still works\n          this.view.setAreaValue(\"outputText\" /* ViewID.outputText */, \"\");\n          this.invalidateScript();\n      }\n      outputError(error, noSelection) {\n          const stream = 0;\n          let shortError;\n          if (Utils.isCustomError(error)) {\n              shortError = error.shortMessage || error.message;\n              if (!noSelection) {\n                  const startPos = error.pos || 0, len = error.len || ((error.value !== undefined) ? String(error.value).length : 0), endPos = startPos + len;\n                  this.view.setAreaSelection(\"inputText\" /* ViewID.inputText */, error.pos, endPos);\n              }\n          }\n          else {\n              shortError = error.message;\n          }\n          const escapedShortError = shortError.replace(/([\\x00-\\x1f])/g, \"\\x01$1\"); // eslint-disable-line no-control-regex\n          this.vm.print(stream, escapedShortError + \"\\r\\n\");\n          return shortError;\n      }\n      fnRenumLines(paras) {\n          const vm = this.vm, input = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */), basicFormatter = this.getBasicFormatter();\n          this.basicLexer.setOptions({\n              keepWhiteSpace: false\n          });\n          this.basicParser.setOptions(Controller.formatterBasicParserOptions);\n          const output = basicFormatter.renumber(input, paras.newLine || 10, paras.oldLine || 1, paras.step || 10, paras.keep || 65535);\n          if (output.error) {\n              Utils.console.warn(output.error);\n              this.outputError(output.error);\n          }\n          else {\n              this.fnPutChangedInputOnStack();\n              this.setInputText(output.text, true);\n              this.fnPutChangedInputOnStack();\n          }\n          this.vm.vmGoto(0); // reset current line\n          vm.vmStop(\"end\", 0, true);\n      }\n      fnEditLineCallback() {\n          const inputParas = this.vm.vmGetStopObject().paras, inputText = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */);\n          let input = inputParas.input;\n          input = this.mergeScripts(inputText, input);\n          this.setInputText(input);\n          this.vm.vmSetStartLine(0);\n          this.vm.vmGoto(0); // to be sure\n          this.view.setDisabled(\"continueButton\" /* ViewID.continueButton */, true);\n          this.vm.cursor(inputParas.stream, 0);\n          this.vm.vmStop(\"end\", 90);\n          return true;\n      }\n      fnEditLine(paras) {\n          const input = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */), stream = paras.stream, lineNumber = paras.first || 0, lines = this.fnGetLinesInRange(input, lineNumber, lineNumber);\n          if (lines.length) {\n              const lineString = lines[0];\n              this.vm.print(stream, lineString);\n              this.vm.cursor(stream, 1);\n              const inputParas = {\n                  command: paras.command,\n                  line: paras.line,\n                  stream: stream,\n                  message: \"\",\n                  fnInputCallback: this.fnEditLineCallbackHandler,\n                  input: lineString\n              };\n              this.vm.vmStop(\"waitInput\", 45, true, inputParas);\n              this.fnWaitInput();\n          }\n          else {\n              const error = this.vm.vmComposeError(Error(), 8, String(lineNumber)); // \"Line does not exist\"\n              this.outputError(error);\n              this.vm.vmStop(\"stop\", 60, true);\n          }\n      }\n      fnParseBench(input, bench) {\n          let output;\n          for (let i = 0; i < bench; i += 1) {\n              let time = Date.now();\n              output = this.codeGeneratorJs.generate(input, this.variables);\n              time = Date.now() - time;\n              Utils.console.debug(\"bench size\", input.length, \"labels\", this.codeGeneratorJs.debugGetLabelsCount(), \"loop\", i, \":\", time, \"ms\");\n              if (output.error) {\n                  break;\n              }\n          }\n          return output;\n      }\n      fnParse() {\n          const input = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */), bench = this.model.getProperty(\"bench\" /* ModelPropID.bench */);\n          // keep variables; this.variables.removeAllVariables();\n          let output;\n          this.basicLexer.setOptions({\n              keepWhiteSpace: false\n          });\n          this.basicParser.setOptions(Controller.codeGenJsBasicParserOptions);\n          if (!bench) {\n              output = this.codeGeneratorJs.generate(input, this.variables);\n          }\n          else {\n              output = this.fnParseBench(input, bench);\n          }\n          let outputString;\n          if (output.error) {\n              outputString = this.outputError(output.error);\n          }\n          else {\n              outputString = output.text;\n              this.vm.vmSetSourceMap(this.codeGeneratorJs.getSourceMap());\n              // optional: tokenize to put tokens into memory...\n              const tokens = this.encodeTokenizedBasic(input);\n              if (Utils.debug) {\n                  Utils.console.debug(\"parse: input length:\", input.length, \", tokenized length:\", tokens.length);\n              }\n              this.vm.vmPutProgramInMem(tokens);\n          }\n          if (outputString && outputString.length > 0) {\n              outputString += \"\\n\";\n          }\n          this.view.setAreaValue(\"outputText\" /* ViewID.outputText */, outputString);\n          this.invalidateScript();\n          this.setVarSelectOptions(\"varSelect\" /* ViewID.varSelect */, this.variables);\n          this.commonEventHandler.onVarSelectChange();\n          return output;\n      }\n      fnPretty() {\n          const input = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */), keepWhiteSpace = this.view.getInputChecked(\"prettySpaceInput\" /* ViewID.prettySpaceInput */), keepBrackets = this.view.getInputChecked(\"prettyBracketsInput\" /* ViewID.prettyBracketsInput */), keepColons = this.view.getInputChecked(\"prettyColonsInput\" /* ViewID.prettyColonsInput */), output = this.prettyPrintBasic(input, keepWhiteSpace, keepBrackets, keepColons);\n          if (output) {\n              this.fnPutChangedInputOnStack();\n              this.setInputText(output, true);\n              this.fnPutChangedInputOnStack();\n              // for testing:\n              const diff = Diff.testDiff(input.toUpperCase(), output.toUpperCase());\n              this.view.setAreaValue(\"outputText\" /* ViewID.outputText */, diff);\n          }\n      }\n      fnAddLines() {\n          const input = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */), output = Controller.addLineNumbers(input);\n          if (output) {\n              this.fnPutChangedInputOnStack();\n              this.setInputText(output, true);\n              this.fnPutChangedInputOnStack();\n          }\n      }\n      fnRemoveLines() {\n          const basicFormatter = this.getBasicFormatter();\n          this.basicLexer.setOptions({\n              keepWhiteSpace: false\n          });\n          this.basicParser.setOptions(Controller.formatterBasicParserOptions);\n          const input = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */), output = basicFormatter.removeUnusedLines(input);\n          if (output.error) {\n              this.outputError(output.error);\n          }\n          else {\n              this.fnPutChangedInputOnStack();\n              this.setInputText(output.text, true);\n              this.fnPutChangedInputOnStack();\n          }\n      }\n      fnGetFilename(input) {\n          let name = \"file\";\n          const reRemMatcher = /^\\d* ?(?:REM|rem) ([\\w.]+)+/, matches = input.match(reRemMatcher);\n          if (matches !== null) {\n              name = matches[1];\n          }\n          else {\n              const example = this.model.getProperty(\"example\" /* ModelPropID.example */);\n              if (example !== \"\") {\n                  if (example.indexOf(\"/\") >= 0) {\n                      name = example.substring(example.lastIndexOf(\"/\") + 1);\n                  }\n              }\n          }\n          if (name.indexOf(\".\") < 0) {\n              name += \".bas\";\n          }\n          return name;\n      }\n      // eslint-disable-next-line complexity\n      fnDownload() {\n          const options = this.view.getSelectOptions(\"exportFileSelect\" /* ViewID.exportFileSelect */), exportTokenized = this.view.getInputChecked(\"exportTokenizedInput\" /* ViewID.exportTokenizedInput */), exportDSK = this.view.getInputChecked(\"exportDSKInput\" /* ViewID.exportDSKInput */), format = this.view.getSelectValue(\"exportDSKFormatSelect\" /* ViewID.exportDSKFormatSelect */), stripEmpty = this.view.getInputChecked(\"exportDSKStripEmptyInput\" /* ViewID.exportDSKStripEmptyInput */), exportBase64 = this.view.getInputChecked(\"exportBase64Input\" /* ViewID.exportBase64Input */), editorText = Controller.exportEditorText, meta = {\n              typeString: \"A\", // ASCII\n              start: 0x170,\n              length: 0,\n              entry: 0\n          };\n          let diskImage, name = \"\", data = \"\";\n          const fnExportBase64 = function () {\n              meta.encoding = \"base64\";\n              const metaString = FileHandler.joinMeta(meta);\n              data = metaString + \",\" + Utils.btoa(data);\n              name += \".b64.txt\";\n          };\n          if (exportDSK) {\n              diskImage = this.getFileHandler().getDiskImage();\n              diskImage.setOptions({\n                  diskName: \"test\",\n                  data: diskImage.formatImage(format) // data or system\n              });\n          }\n          for (let i = 0; i < options.length; i += 1) {\n              const item = options[i];\n              if (item.selected) {\n                  if (item.value === editorText) {\n                      data = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */);\n                      name = this.fnGetFilename(data);\n                      const eolStr = data.indexOf(\"\\r\\n\") > 0 ? \"\\r\\n\" : \"\\n\"; // heuristic: if CRLF found, use it as split\n                      if (eolStr === \"\\n\") {\n                          data = data.replace(/\\n/g, \"\\r\\n\"); // replace LF by CRLF (not really needed if tokenized is used)\n                      }\n                      meta.typeString = \"A\"; // ASCII\n                      meta.start = 0x170;\n                      meta.length = data.length;\n                      meta.entry = 0;\n                  }\n                  else {\n                      name = item.value;\n                      data = Controller.tryLoadingFromLocalStorage(name) || \"\";\n                      const metaAndData = Controller.splitMeta(data);\n                      Object.assign(meta, metaAndData.meta); // copy meta info\n                      data = metaAndData.data;\n                  }\n                  if (exportTokenized && meta.typeString === \"A\") { // do we need to tokenize it?\n                      const tokens = this.encodeTokenizedBasic(data);\n                      if (!tokens) { // not successful?\n                          return;\n                      }\n                      data = tokens;\n                      meta.typeString = \"T\";\n                      meta.start = 0x170;\n                      meta.length = data.length;\n                      meta.entry = 0;\n                  }\n                  if (meta.typeString !== \"A\" && meta.typeString !== \"X\" && meta.typeString !== \"Z\") {\n                      const [name1, ext1] = DiskImage.getFilenameAndExtension(name), // eslint-disable-line array-element-newline\n                      header = DiskImage.createAmsdosHeader({\n                          name: name1,\n                          ext: ext1,\n                          typeString: meta.typeString,\n                          start: meta.start,\n                          length: meta.length,\n                          entry: meta.entry\n                      }), headerString = DiskImage.combineAmsdosHeader(header);\n                      data = headerString + data;\n                  }\n                  if (diskImage) {\n                      diskImage.writeFile(name, data);\n                      const diskOptions = diskImage.getOptions();\n                      data = diskOptions.data; // we need the modified disk image with the file(s) inside\n                      name = name.substring(0, name.indexOf(\".\") + 1) + \"dsk\";\n                      meta.length = data.length;\n                      meta.typeString = \"X\"; // (extended) disk image\n                  }\n                  else {\n                      if (exportBase64) {\n                          fnExportBase64();\n                      }\n                      if (data) {\n                          this.view.fnDownloadBlob(data, name);\n                      }\n                  }\n              }\n          }\n          if (diskImage) {\n              if (stripEmpty) {\n                  data = diskImage.stripEmptyTracks();\n              }\n              if (exportBase64) {\n                  fnExportBase64();\n              }\n              if (data) {\n                  this.view.fnDownloadBlob(data, name);\n              }\n          }\n      }\n      selectJsError(script, e) {\n          const lineNumber = e.lineNumber, // only on FireFox\n          columnNumber = e.columnNumber;\n          if (lineNumber || columnNumber) { // only available on Firefox\n              const errLine = lineNumber - 3; // for some reason line 0 is 3\n              let pos = 0, line = 0;\n              while (pos < script.length && line < errLine) {\n                  pos = script.indexOf(\"\\n\", pos) + 1;\n                  line += 1;\n              }\n              pos += columnNumber;\n              Utils.console.warn(\"Info: JS Error occurred at line\", lineNumber, \"column\", columnNumber, \"pos\", pos);\n              this.view.setAreaSelection(\"outputText\" /* ViewID.outputText */, pos, pos + 1);\n          }\n      }\n      fnChain(paras) {\n          const script = this.view.getAreaValue(\"outputText\" /* ViewID.outputText */), vm = this.vm;\n          let line = paras && paras.first || 0;\n          line = line || 0;\n          if (line === 0) {\n              vm.vmResetData(); // start from the beginning => also reset data! (or put it in line 0 in the script)\n          }\n          if (this.vm.vmGetOutFileObject().open) {\n              this.fnFileSave();\n          }\n          if (!this.fnScript) {\n              try {\n                  this.fnScript = new Function(\"o\", script); // eslint-disable-line no-new-func\n              }\n              catch (e) {\n                  Utils.console.error(e);\n                  if (e instanceof Error) {\n                      this.selectJsError(script, e);\n                      e.shortMessage = \"JS \" + String(e);\n                      this.outputError(e, true);\n                  }\n                  this.fnScript = undefined;\n              }\n          }\n          vm.vmReset4Run();\n          if (this.fnScript) {\n              vm.vmStop(\"\", 0, true);\n              vm.vmGoto(0); // to load DATA lines\n              this.vm.vmSetStartLine(line); // clear resets also startline\n              this.view.setDisabled(\"runButton\" /* ViewID.runButton */, true);\n              this.view.setDisabled(\"stopButton\" /* ViewID.stopButton */, false);\n              this.view.setDisabled(\"continueButton\" /* ViewID.continueButton */, true);\n          }\n          if (!this.inputSet) {\n              this.inputSet = true;\n              const input = this.model.getProperty(\"input\" /* ModelPropID.input */);\n              if (input !== \"\") {\n                  this.view.setAreaValue(\"inp2Text\" /* ViewID.inp2Text */, input);\n                  const that = this, timeout = 1;\n                  setTimeout(function () {\n                      that.startEnter();\n                      that.view.setAreaValue(\"inp2Text\" /* ViewID.inp2Text */, \"\"); // delete input\n                  }, timeout);\n              }\n          }\n          if (Utils.debug > 1) {\n              Utils.console.debug(\"End of fnRun\");\n          }\n      }\n      fnRun(paras) {\n          this.vm.clear(); // init variables\n          this.fnChain(paras);\n      }\n      fnParseRun() {\n          this.fnRemoveAllVariables();\n          const output = this.fnParse();\n          if (!output.error) {\n              this.fnRun();\n          }\n      }\n      fnParseChain() {\n          const output = this.fnParse();\n          if (!output.error) {\n              this.fnChain();\n          }\n      }\n      fnRunPart1(fnScript) {\n          try {\n              fnScript(this.vm);\n          }\n          catch (e) {\n              if (e instanceof Error) {\n                  if (e.name === \"CpcVm\" || e.name === \"Variables\") {\n                      let customError = e;\n                      if (customError.errCode !== undefined) {\n                          customError = this.vm.vmComposeError(customError, customError.errCode, customError.value);\n                      }\n                      if (!customError.hidden) {\n                          Utils.console.warn(customError);\n                          this.outputError(customError, !customError.pos);\n                      }\n                      else {\n                          Utils.console.log(customError.message);\n                      }\n                  }\n                  else {\n                      Utils.console.error(e);\n                      this.selectJsError(this.view.getAreaValue(\"outputText\" /* ViewID.outputText */), e);\n                      this.vm.vmComposeError(e, 2, \"JS \" + String(e)); // generate Syntax Error, set also err and erl and set stop\n                      this.outputError(e, true);\n                  }\n              }\n              else {\n                  Utils.console.error(e);\n              }\n          }\n      }\n      fnDirectInput() {\n          const inputParas = this.vm.vmGetStopObject().paras, stream = inputParas.stream;\n          let input = inputParas.input;\n          input = input.trim();\n          inputParas.input = \"\";\n          if (input !== \"\") { // direct input\n              this.vm.cursor(stream, 0);\n              const inputText = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */);\n              if (!isNaN(Controller.parseLineNumber(input))) { // start with number?\n                  if (Utils.debug > 0) {\n                      Utils.console.debug(\"fnDirectInput: insert line=\" + input);\n                  }\n                  input = this.mergeScripts(inputText, input);\n                  this.setInputText(input, true);\n                  this.vm.vmSetStartLine(0);\n                  this.vm.vmGoto(0); // to be sure\n                  this.view.setDisabled(\"continueButton\" /* ViewID.continueButton */, true);\n                  this.vm.cursor(stream, 1);\n                  this.updateResultText();\n                  return false; // continue direct input\n              }\n              Utils.console.log(\"fnDirectInput: execute:\", input);\n              const codeGeneratorJs = this.codeGeneratorJs;\n              let output, outputString;\n              if (inputText && (!isNaN(Controller.parseLineNumber(inputText)) || this.model.getProperty(\"implicitLines\" /* ModelPropID.implicitLines */))) { // do we have a program starting with a line number?\n                  const separator = inputText.endsWith(\"\\n\") ? \"\" : \"\\n\";\n                  this.basicParser.setOptions(Controller.codeGenJsBasicParserOptions);\n                  output = codeGeneratorJs.generate(inputText + separator + input, this.variables, true); // compile both; allow direct command\n                  if (output.error) {\n                      const error = output.error;\n                      if (error.pos < inputText.length + 1) { // error not in direct?\n                          error.message = \"[prg] \" + error.message;\n                          output = undefined;\n                      }\n                  }\n              }\n              if (!output) {\n                  this.basicParser.setOptions(Controller.codeGenJsBasicParserOptions);\n                  output = codeGeneratorJs.generate(input, this.variables, true); // compile direct input only\n              }\n              if (output.error) {\n                  outputString = this.outputError(output.error, true);\n              }\n              else {\n                  outputString = output.text;\n              }\n              if (outputString && outputString.length > 0) {\n                  outputString += \"\\n\";\n              }\n              this.view.setAreaValue(\"outputText\" /* ViewID.outputText */, outputString);\n              if (!output.error) {\n                  this.vm.vmSetStartLine(this.vm.line); // fast hack\n                  this.vm.vmGoto(\"direct\");\n                  try {\n                      const fnScript = new Function(\"o\", outputString); // eslint-disable-line no-new-func\n                      this.fnScript = fnScript;\n                      this.vm.vmSetSourceMap(codeGeneratorJs.getSourceMap());\n                  }\n                  catch (e) {\n                      Utils.console.error(e);\n                      if (e instanceof Error) {\n                          this.outputError(e, true);\n                      }\n                  }\n              }\n              if (!output.error) {\n                  this.updateResultText();\n                  return true;\n              }\n              const msg = inputParas.message;\n              this.vm.print(stream, msg);\n              this.vm.cursor(stream, 1);\n          }\n          this.updateResultText();\n          return false;\n      }\n      startWithDirectInput() {\n          const vm = this.vm, stream = 0, msg = \"Ready\\r\\n\";\n          this.vm.tagoff(stream);\n          this.vm.vmResetControlBuffer();\n          if (this.vm.pos(stream) > 1) {\n              this.vm.print(stream, \"\\r\\n\");\n          }\n          this.vm.print(stream, msg);\n          this.vm.cursor(stream, 1, 1);\n          vm.vmStop(\"direct\", 0, true, {\n              command: \"direct\",\n              stream: stream,\n              message: msg,\n              // noCRLF: true,\n              fnInputCallback: this.fnDirectInputHandler,\n              input: \"\",\n              line: this.vm.line\n          });\n          this.fnWaitInput();\n      }\n      updateResultText() {\n          this.view.setAreaValue(\"resultText\" /* ViewID.resultText */, this.vm.vmGetOutBuffer());\n          this.view.setAreaScrollTop(\"resultText\" /* ViewID.resultText */); // scroll to bottom\n      }\n      exitLoop() {\n          const stop = this.vm.vmGetStopObject(), reason = stop.reason;\n          this.updateResultText();\n          this.view.setDisabled(\"runButton\" /* ViewID.runButton */, reason === \"reset\");\n          this.view.setDisabled(\"stopButton\" /* ViewID.stopButton */, reason !== \"fileLoad\" && reason !== \"fileSave\");\n          this.view.setDisabled(\"continueButton\" /* ViewID.continueButton */, reason === \"end\" || reason === \"fileLoad\" || reason === \"fileSave\" || reason === \"parse\" || reason === \"renumLines\" || reason === \"reset\");\n          this.setVarSelectOptions(\"varSelect\" /* ViewID.varSelect */, this.variables);\n          this.commonEventHandler.onVarSelectChange();\n          if (reason === \"stop\" || reason === \"end\" || reason === \"error\" || reason === \"parse\" || reason === \"parseRun\") {\n              this.startWithDirectInput();\n          }\n      }\n      fnWaitFrame() {\n          this.vm.vmStop(\"\", 0, true);\n          this.nextLoopTimeOut = this.vm.vmGetTimeUntilFrame(); // wait until next frame\n      }\n      fnOnError() {\n          this.vm.vmStop(\"\", 0, true); // continue\n      }\n      static fnDummy() {\n          // empty\n      }\n      fnTimer() {\n          this.vm.vmStop(\"\", 0, true); // continue\n      }\n      fnRunLoop() {\n          const stop = this.vm.vmGetStopObject();\n          this.nextLoopTimeOut = this.initialLoopTimeout;\n          if (!stop.reason && this.fnScript) {\n              this.fnRunPart1(this.fnScript); // could change reason\n          }\n          if (stop.reason in this.handlers) {\n              this.handlers[stop.reason].call(this, stop.paras);\n          }\n          else {\n              Utils.console.warn(\"runLoop: Unknown run mode:\", stop.reason);\n              this.vm.vmStop(\"error\", 50);\n          }\n          if (stop.reason && stop.reason !== \"waitSound\" && stop.reason !== \"waitKey\" && stop.reason !== \"waitInput\") {\n              this.timeoutHandlerActive = false; // not running any more\n              this.exitLoop();\n          }\n          else {\n              setTimeout(this.fnRunLoopHandler, this.nextLoopTimeOut);\n          }\n      }\n      startMainLoop() {\n          if (!this.timeoutHandlerActive) {\n              this.timeoutHandlerActive = true;\n              setTimeout(this.fnRunLoopHandler, 0);\n          }\n      }\n      setStopObject(stop) {\n          Object.assign(this.savedStop, stop);\n      }\n      getStopObject() {\n          return this.savedStop;\n      }\n      startParse() {\n          this.removeKeyBoardHandler();\n          this.vm.vmStop(\"parse\", 95);\n          this.startMainLoop();\n      }\n      startRenum() {\n          const stream = 0;\n          this.vm.vmStop(\"renumLines\", 85, false, {\n              command: \"renum\",\n              stream: 0, // unused\n              newLine: Number(this.view.getInputValue(\"renumNewInput\" /* ViewID.renumNewInput */)), // 10\n              oldLine: Number(this.view.getInputValue(\"renumStartInput\" /* ViewID.renumStartInput */)), // 1\n              step: Number(this.view.getInputValue(\"renumStepInput\" /* ViewID.renumStepInput */)), // 10\n              keep: Number(this.view.getInputValue(\"renumKeepInput\" /* ViewID.renumKeepInput */)), // 65535, keep lines\n              line: this.vm.line\n          });\n          if (this.vm.pos(stream) > 1) {\n              this.vm.print(stream, \"\\r\\n\");\n          }\n          this.vm.print(stream, \"renum\\r\\n\");\n          this.startMainLoop();\n      }\n      startRun() {\n          this.setStopObject(this.noStop);\n          this.removeKeyBoardHandler();\n          this.vm.vmStop(\"run\", 95);\n          this.startMainLoop();\n      }\n      startParseRun() {\n          this.setStopObject(this.noStop);\n          this.removeKeyBoardHandler();\n          this.vm.vmStop(\"parseRun\", 95);\n          this.startMainLoop();\n      }\n      startBreak() {\n          const vm = this.vm, stop = vm.vmGetStopObject();\n          this.setStopObject(stop);\n          this.removeKeyBoardHandler();\n          this.vm.vmStop(\"break\", 80);\n          this.startMainLoop();\n      }\n      startContinue() {\n          const vm = this.vm, stop = vm.vmGetStopObject(), savedStop = this.getStopObject();\n          this.view.setDisabled(\"runButton\" /* ViewID.runButton */, true);\n          this.view.setDisabled(\"stopButton\" /* ViewID.stopButton */, false);\n          this.view.setDisabled(\"continueButton\" /* ViewID.continueButton */, true);\n          if (stop.reason === \"break\" || stop.reason === \"escape\" || stop.reason === \"stop\" || stop.reason === \"direct\") {\n              if (savedStop.paras && !savedStop.paras.fnInputCallback) { // no keyboard callback? make sure no handler is set (especially for direct->continue)\n                  this.removeKeyBoardHandler();\n              }\n              if (stop.reason === \"direct\" || stop.reason === \"escape\") {\n                  this.vm.cursor(stop.paras.stream, 0); // switch it off (for continue button)\n              }\n              Object.assign(stop, savedStop); // fast hack\n              this.setStopObject(this.noStop);\n          }\n          this.startMainLoop();\n      }\n      startReset() {\n          this.setStopObject(this.noStop);\n          this.removeKeyBoardHandler();\n          this.vm.vmStop(\"reset\", 99);\n          this.startMainLoop();\n      }\n      startScreenshot() {\n          return this.canvas.takeScreenShot();\n      }\n      fnPutKeysInBuffer(keys) {\n          for (let i = 0; i < keys.length; i += 1) {\n              this.keyboard.putKeyInBuffer(keys.charAt(i));\n          }\n          const options = this.keyboard.getOptions(), keyDownHandler = options.fnOnKeyDown;\n          if (keyDownHandler) {\n              keyDownHandler();\n          }\n      }\n      startEnter() {\n          let input = this.view.getAreaValue(\"inp2Text\" /* ViewID.inp2Text */);\n          input = input.replace(/\\n/g, \"\\r\"); // LF => CR\n          this.fnPutKeysInBuffer(input);\n      }\n      static generateFunction(par, functionString) {\n          if (functionString.startsWith(\"function anonymous(\")) { // already a modified function (inside an anonymous function)?\n              const firstIndex = functionString.indexOf(\"{\"), lastIndex = functionString.lastIndexOf(\"}\");\n              if (firstIndex >= 0 && lastIndex >= 0) {\n                  functionString = functionString.substring(firstIndex + 1, lastIndex - 1); // remove anonymous function\n              }\n              functionString = functionString.trim();\n          }\n          else {\n              functionString = \"var o=CpcLoco.controller.vm, v=o.vmGetAllVariables(); v.\" + par + \" = \" + functionString;\n          }\n          const match = (/function \\(([^)]*)/).exec(functionString), args = match ? match[1].split(\",\") : [], fnFunction = new Function(args[0], args[1], args[2], args[3], args[4], functionString); // eslint-disable-line no-new-func\n          // we support at most 5 arguments\n          return fnFunction;\n      }\n      changeVariable() {\n          const par = this.view.getSelectValue(\"varSelect\" /* ViewID.varSelect */), valueString = this.view.getSelectValue(\"varText\" /* ViewID.varText */), variables = this.variables;\n          let value = variables.getVariable(par);\n          if (typeof value === \"function\") {\n              value = Controller.generateFunction(par, valueString);\n              variables.setVariable(par, value);\n          }\n          else {\n              const varType = this.variables.determineStaticVarType(par), type = this.vm.vmDetermineVarType(varType); // do we know dynamic type?\n              if (type !== \"$\") { // not string? => convert to number\n                  value = parseFloat(valueString);\n              }\n              else {\n                  value = valueString;\n              }\n              try {\n                  const value2 = this.vm.vmAssign(varType, value);\n                  variables.setVariable(par, value2);\n                  Utils.console.log(\"Variable\", par, \"changed:\", variables.getVariable(par), \"=>\", value);\n              }\n              catch (e) {\n                  Utils.console.warn(e);\n              }\n          }\n          this.setVarSelectOptions(\"varSelect\" /* ViewID.varSelect */, variables);\n          this.commonEventHandler.onVarSelectChange(); // title change?\n      }\n      setBasicVersion(basicVersion) {\n          this.basicParser.setOptions({\n              basicVersion: basicVersion\n          });\n          this.basicLexer.setOptions({\n              keywords: this.basicParser.getKeywords()\n          });\n          this.invalidateScript();\n      }\n      setPalette(palette) {\n          const validPalette = palette === \"green\" || palette === \"grey\" ? palette : \"color\";\n          this.canvas.setOptions({\n              palette: validPalette\n          });\n      }\n      setCanvasType(canvasType) {\n          let canvas = this.canvas;\n          if (canvas) {\n              canvas.stopUpdateCanvas(); // stop updates on current canvas\n              const canvasID = canvas.getOptions().canvasID;\n              this.view.setHidden(canvasID, true);\n          }\n          else if (canvasType !== \"graphics\") {\n              // initially graphics canvas is not hidden, but we must hide it, if other canvas should be shown\n              this.view.setHidden(\"cpcCanvas\" /* ViewID.cpcCanvas */, true);\n          }\n          const palette = this.model.getProperty(\"palette\" /* ModelPropID.palette */);\n          if (this.canvases[canvasType]) {\n              canvas = this.canvases[canvasType];\n              this.canvas = canvas;\n              this.setPalette(palette);\n          }\n          else {\n              const validPalette = palette === \"green\" || palette === \"grey\" ? palette : \"color\";\n              if (canvasType === \"text\") {\n                  canvas = new TextCanvas({\n                      canvasID: \"textText\" /* ViewID.textText */,\n                      charset: cpcCharset,\n                      palette: validPalette\n                  });\n              }\n              else if (canvasType === \"none\") {\n                  canvas = new NoCanvas({\n                      canvasID: \"noCanvas\" /* ViewID.noCanvas */,\n                      charset: cpcCharset,\n                      palette: validPalette\n                  });\n              }\n              else { // \"graphics\"\n                  const isAreaHidden = this.view.getHidden(\"cpcArea\" /* ViewID.cpcArea */);\n                  // make sure canvas area is not hidden when creating canvas object (allows to get width, height)\n                  if (isAreaHidden) {\n                      this.commonEventHandler.toggleAreaHiddenById(\"change\", \"showCpcInput\" /* ViewID.showCpcInput */); // show: ViewID.cpcArea\n                  }\n                  this.view.setHidden(\"cpcCanvas\" /* ViewID.cpcCanvas */, false);\n                  canvas = new Canvas({\n                      canvasID: \"cpcCanvas\" /* ViewID.cpcCanvas */,\n                      charset: cpcCharset,\n                      palette: validPalette\n                  });\n                  if (isAreaHidden) {\n                      this.commonEventHandler.toggleAreaHiddenById(\"change\", \"showCpcInput\" /* ViewID.showCpcInput */); // hide again: ViewID.cpcArea\n                  }\n              }\n              this.canvases[canvasType] = canvas;\n              this.canvas = canvas;\n          }\n          if (this.vm) {\n              this.vm.setCanvas(canvas);\n          }\n          const canvasId = canvas.getOptions().canvasID;\n          this.view.setHidden(canvasId, false);\n          if (this.model.getProperty(\"showCpc\" /* ModelPropID.showCpc */)) {\n              this.canvas.startUpdateCanvas();\n          }\n          return canvas;\n      }\n      setSoundActive() {\n          const sound = this.sound, active = this.model.getProperty(\"sound\" /* ModelPropID.sound */);\n          if (active) {\n              sound.soundOn();\n          }\n          else {\n              sound.soundOff();\n              const stop = this.vm && this.vm.vmGetStopObject();\n              if (stop && stop.reason === \"waitSound\") {\n                  this.vm.vmStop(\"\", 0, true); // do not wait\n              }\n          }\n      }\n      getZ80Disass() {\n          if (!this.z80Disass) {\n              const dataArr = this.vm.vmGetMem(), data = dataArr; // fast hack: we take number array as Uint8Array\n              this.z80Disass = new Z80Disass({\n                  data: data,\n                  addr: 0\n              });\n          }\n          return this.z80Disass;\n      }\n      setDisassAddr(addr, endAddr) {\n          const z80Disass = this.getZ80Disass();\n          if (endAddr === undefined) {\n              endAddr = addr + 0x100;\n          }\n          z80Disass.setOptions({\n              addr: addr\n          });\n          const opts = z80Disass.getOptions(), lines = [];\n          while (addr < endAddr) { // currently not limited to < 0x10000\n              lines.push(z80Disass.disassLine());\n              if (opts.addr > addr) {\n                  addr = opts.addr;\n              }\n              else {\n                  Utils.console.error(\"setDisassAddr: Not increasing:\", addr, opts.addr);\n                  break;\n              }\n          }\n          const out = lines.join(\"\\n\") + \"\\n\";\n          this.view.setAreaValue(\"disassText\" /* ViewID.disassText */, out);\n      }\n      fnEndOfImport(imported) {\n          const stream = 0, vm = this.vm;\n          for (let i = 0; i < imported.length; i += 1) {\n              vm.print(stream, imported[i], \" \");\n          }\n          vm.print(stream, \"\\r\\n\", imported.length + \" file\" + (imported.length !== 1 ? \"s\" : \"\") + \" imported.\\r\\n\");\n          this.updateResultText();\n      }\n      static fnOnDragover(evt) {\n          evt.stopPropagation();\n          evt.preventDefault();\n          if (evt.dataTransfer !== null) {\n              evt.dataTransfer.dropEffect = \"copy\"; // explicitly show this is a copy\n          }\n      }\n      adaptFilename(name, err) {\n          return this.vm.vmAdaptFilename(name, err);\n      }\n      getFileHandler() {\n          if (!this.fileHandler) {\n              this.fileHandler = new FileHandler({\n                  adaptFilename: this.adaptFilename.bind(this),\n                  updateStorageDatabase: this.updateStorageDatabase.bind(this),\n                  outputError: this.outputError.bind(this),\n                  processFileImports: this.model.getProperty(\"processFileImports\" /* ModelPropID.processFileImports */)\n              });\n          }\n          return this.fileHandler;\n      }\n      getFileSelect(fileHandler) {\n          if (!this.fileSelect) {\n              this.fileSelect = new FileSelect({\n                  fnEndOfImport: this.fnEndOfImport.bind(this),\n                  fnLoad2: fileHandler.fnLoad2.bind(fileHandler)\n              });\n          }\n          return this.fileSelect;\n      }\n      initDropZone() {\n          const fileHandler = this.getFileHandler(), fileSelect = this.getFileSelect(fileHandler), dropZone = View.getElementById1(\"dropZone\" /* ViewID.dropZone */);\n          dropZone.addEventListener(\"dragover\", this.fnOnDragoverHandler, false);\n          fileSelect.addFileSelectHandler(dropZone, \"drop\");\n          const canvasID = this.canvas.getOptions().canvasID, canvasElement = View.getElementById1(canvasID);\n          canvasElement.addEventListener(\"dragover\", this.fnOnDragoverHandler, false);\n          fileSelect.addFileSelectHandler(canvasElement, \"drop\");\n          const fileInput = View.getElementById1(\"fileInput\" /* ViewID.fileInput */);\n          fileSelect.addFileSelectHandler(fileInput, \"change\");\n      }\n      fnUpdateUndoRedoButtons() {\n          this.view.setDisabled(\"undoButton\" /* ViewID.undoButton */, !this.inputStack.canUndoKeepOne());\n          this.view.setDisabled(\"undoButton2\" /* ViewID.undoButton2 */, !this.inputStack.canUndoKeepOne());\n          this.view.setDisabled(\"redoButton\" /* ViewID.redoButton */, !this.inputStack.canRedo());\n          this.view.setDisabled(\"redoButton2\" /* ViewID.redoButton2 */, !this.inputStack.canRedo());\n      }\n      fnInitUndoRedoButtons() {\n          this.inputStack.reset();\n          this.fnUpdateUndoRedoButtons();\n      }\n      fnPutChangedInputOnStack() {\n          const input = this.view.getAreaValue(\"inputText\" /* ViewID.inputText */), stackInput = this.inputStack.getInput();\n          if (stackInput !== input) {\n              this.inputStack.save(input);\n              this.fnUpdateUndoRedoButtons();\n          }\n      }\n      startUpdateCanvas() {\n          this.canvas.startUpdateCanvas();\n      }\n      stopUpdateCanvas() {\n          this.canvas.stopUpdateCanvas();\n      }\n      getDragElement() {\n          if (!this.dragElement) {\n              this.dragElement = new DragElement({\n                  view: this.view,\n                  entries: {}\n              });\n          }\n          return this.dragElement;\n      }\n      getVirtualKeyboard() {\n          if (!this.virtualKeyboard) {\n              this.virtualKeyboard = new VirtualKeyboard({\n                  view: this.view,\n                  fnPressCpcKey: this.keyboard.fnPressCpcKey.bind(this.keyboard),\n                  fnReleaseCpcKey: this.keyboard.fnReleaseCpcKey.bind(this.keyboard)\n              });\n          }\n          return this.virtualKeyboard;\n      }\n      dragElementsData = {\n          entries: {\n              consoleLogArea: {\n                  itemId: \"consoleLogArea\" /* ViewID.consoleLogArea */,\n                  xOffset: 0,\n                  yOffset: 0,\n                  enabled: false\n              },\n              cpcArea: {\n                  itemId: \"cpcArea\" /* ViewID.cpcArea */,\n                  xOffset: 0,\n                  yOffset: 0,\n                  enabled: false\n              },\n              disassArea: {\n                  itemId: \"disassArea\" /* ViewID.disassArea */,\n                  xOffset: 0,\n                  yOffset: 0,\n                  enabled: false\n              },\n              inp2Area: {\n                  itemId: \"inp2Area\" /* ViewID.inp2Area */,\n                  xOffset: 0,\n                  yOffset: 0,\n                  enabled: false\n              },\n              inputArea: {\n                  itemId: \"inputArea\" /* ViewID.inputArea */,\n                  xOffset: 0,\n                  yOffset: 0,\n                  enabled: false\n              },\n              kbdArea: {\n                  itemId: \"kbdArea\" /* ViewID.kbdArea */,\n                  xOffset: 0,\n                  yOffset: 0,\n                  enabled: false\n              },\n              mainArea: {\n                  itemId: \"mainArea\" /* ViewID.mainArea */,\n                  xOffset: 0,\n                  yOffset: 0,\n                  enabled: false\n              },\n              outputArea: {\n                  itemId: \"outputArea\" /* ViewID.outputArea */,\n                  xOffset: 0,\n                  yOffset: 0,\n                  enabled: false\n              },\n              resultArea: {\n                  itemId: \"resultArea\" /* ViewID.resultArea */,\n                  xOffset: 0,\n                  yOffset: 0,\n                  enabled: false\n              },\n              variableArea: {\n                  itemId: \"variableArea\" /* ViewID.variableArea */,\n                  xOffset: 0,\n                  yOffset: 0,\n                  enabled: false\n              }\n          }\n      };\n      fnDragElementsActive(enabled) {\n          const dragElement = this.getDragElement(), dragElementsData = this.dragElementsData;\n          for (const entry in dragElementsData.entries) {\n              if (dragElementsData.entries.hasOwnProperty(entry)) {\n                  dragElementsData.entries[entry].enabled = enabled;\n              }\n          }\n          dragElement.setOptions(this.dragElementsData);\n      }\n      getVariable(par) {\n          return this.variables.getVariable(par);\n      }\n      undoStackElement() {\n          return this.inputStack.undo();\n      }\n      redoStackElement() {\n          return this.inputStack.redo();\n      }\n      createFnDatabaseLoaded(url) {\n          return (_sFullUrl, key) => {\n              const selectedName = this.model.getProperty(\"database\" /* ModelPropID.database */);\n              if (selectedName === key) {\n                  this.model.getDatabase().loaded = true;\n              }\n              else { // should not occur\n                  Utils.console.warn(\"databaseLoaded: name changed: \" + key + \" => \" + selectedName);\n                  this.model.setProperty(\"database\" /* ModelPropID.database */, key);\n                  const database = this.model.getDatabase();\n                  if (database) {\n                      database.loaded = true;\n                  }\n                  this.model.setProperty(\"database\" /* ModelPropID.database */, selectedName);\n              }\n              Utils.console.log(\"fnDatabaseLoaded: database loaded: \" + key + \": \" + url);\n              this.setDirectorySelectOptions();\n              this.onDirectorySelectChange();\n          };\n      }\n      createFnDatabaseError(url) {\n          return (_sFullUrl, key) => {\n              Utils.console.error(\"fnDatabaseError: database error: \" + key + \": \" + url);\n              this.setDirectorySelectOptions();\n              this.onDirectorySelectChange();\n              this.setInputText(\"\");\n              this.view.setAreaValue(\"resultText\" /* ViewID.resultText */, \"Cannot load database: \" + key);\n          };\n      }\n      onDatabaseSelectChange() {\n          const databaseName = this.view.getSelectValue(\"databaseSelect\" /* ViewID.databaseSelect */);\n          this.model.setProperty(\"database\" /* ModelPropID.database */, databaseName);\n          this.view.setSelectTitleFromSelectedOption(\"databaseSelect\" /* ViewID.databaseSelect */);\n          const database = this.model.getDatabase();\n          if (!database) {\n              Utils.console.error(\"onDatabaseSelectChange: database not available:\", databaseName);\n              return;\n          }\n          if (database.text === \"storage\") { // special handling: browser localStorage\n              this.updateStorageDatabase(\"set\", \"\"); // set all\n              database.loaded = true;\n          }\n          if (database.loaded) {\n              this.setDirectorySelectOptions();\n              this.onDirectorySelectChange();\n          }\n          else {\n              this.setInputText(\"#loading database \" + databaseName + \"...\");\n              const exampleIndex = this.model.getProperty(\"exampleIndex\" /* ModelPropID.exampleIndex */), url = database.src + \"/\" + exampleIndex;\n              Utils.loadScript(url, this.createFnDatabaseLoaded(url), this.createFnDatabaseError(url), databaseName);\n          }\n      }\n      onDirectorySelectChange() {\n          this.setExampleSelectOptions();\n          this.onExampleSelectChange();\n      }\n      onExampleSelectChange() {\n          const vm = this.vm, inFile = vm.vmGetInFileObject(), dataBaseName = this.model.getProperty(\"database\" /* ModelPropID.database */), directoryName = this.view.getSelectValue(\"directorySelect\" /* ViewID.directorySelect */);\n          vm.closein();\n          this.commonEventHandler.setPopoversHiddenExcept(); // hide all popovers, especially the gallery\n          inFile.open = true;\n          let exampleName = this.view.getSelectValue(\"exampleSelect\" /* ViewID.exampleSelect */);\n          if (directoryName) {\n              exampleName = directoryName + \"/\" + exampleName;\n          }\n          const exampleEntry = this.model.getExample(exampleName);\n          let autorun = this.model.getProperty(\"autorun\" /* ModelPropID.autorun */);\n          if (exampleEntry && exampleEntry.meta) { // TTT TODO: this is just a workaround, meta is in input now; should change command after loading!\n              const type = exampleEntry.meta.charAt(0);\n              if (type === \"B\" || type === \"D\" || type === \"G\") { // binary, data only, Gena Assembler?\n                  autorun = false;\n              }\n          }\n          inFile.command = autorun ? \"run\" : \"load\";\n          if (dataBaseName !== \"storage\") {\n              exampleName = \"/\" + exampleName; // load absolute\n          }\n          else {\n              this.model.setProperty(\"example\" /* ModelPropID.example */, exampleName);\n          }\n          inFile.name = exampleName;\n          inFile.start = undefined;\n          inFile.fnFileCallback = vm.vmGetLoadHandler();\n          vm.vmStop(\"fileLoad\", 90);\n          this.startMainLoop();\n      }\n      // currently not used. Can be called manually: CpcLoco.controller.exportAsBase64(file);\n      exportAsBase64(storageName) {\n          const storage = Utils.localStorage;\n          let data = storage.getItem(storageName), out = \"\";\n          if (data !== null) {\n              const index = data.indexOf(\",\"); // metadata separator\n              if (index >= 0) {\n                  const meta = data.substring(0, index);\n                  data = data.substring(index + 1);\n                  data = Utils.btoa(data);\n                  out = meta + \";base64,\" + data;\n              }\n              else { // hmm, no meta info\n                  data = Utils.btoa(data);\n                  out = \"base64,\" + data;\n              }\n          }\n          Utils.console.log(out);\n          return out;\n      }\n      onCpcCanvasClick(event) {\n          this.commonEventHandler.setPopoversHiddenExcept(); // hide all popovers\n          this.canvas.onCanvasClick(event);\n          this.keyboard.setActive(true);\n      }\n      onWindowClick(event) {\n          this.canvas.onWindowClick(event);\n          this.keyboard.setActive(false);\n      }\n      fnArrayBounds() {\n          const arrayBounds = this.model.getProperty(\"arrayBounds\" /* ModelPropID.arrayBounds */);\n          this.variables.setOptions({\n              arrayBounds: arrayBounds\n          });\n          this.vm.vmGoto(0); // reset current line\n          this.vm.vmStop(\"end\", 0, true);\n          this.fnRemoveAllVariables();\n      }\n      fnImplicitLines() {\n          const implicitLines = this.model.getProperty(\"implicitLines\" /* ModelPropID.implicitLines */);\n          this.codeGeneratorJs.setOptions({\n              implicitLines: implicitLines\n          });\n          if (this.codeGeneratorToken) {\n              this.codeGeneratorToken.setOptions({\n                  implicitLines: implicitLines\n              });\n          }\n      }\n      fnRemoveAllVariables() {\n          if (Object.keys(this.variables.getAllVariables()).length) {\n              this.variables.removeAllVariables();\n              this.setVarSelectOptions(\"varSelect\" /* ViewID.varSelect */, this.variables);\n          }\n      }\n      fnPrettyLowercaseVars() {\n          const prettyLowercaseVars = this.model.getProperty(\"prettyLowercaseVars\" /* ModelPropID.prettyLowercaseVars */);\n          this.getCodeGeneratorBasic().setOptions({\n              lowercaseVars: prettyLowercaseVars\n          });\n      }\n      fnIntegerOverflow() {\n          const integerOverflow = this.model.getProperty(\"integerOverflow\" /* ModelPropID.integerOverflow */);\n          this.codeGeneratorJs.setOptions({\n              integerOverflow: integerOverflow\n          });\n      }\n      fnTrace() {\n          const trace = this.model.getProperty(\"trace\" /* ModelPropID.trace */);\n          this.codeGeneratorJs.setOptions({\n              trace: trace\n          });\n      }\n      fnSpeed() {\n          const speed = this.model.getProperty(\"speed\" /* ModelPropID.speed */);\n          this.initialLoopTimeout = 1000 - speed * 10;\n      }\n      /* eslint-disable no-invalid-this */\n      handlers = {\n          timer: this.fnTimer,\n          waitKey: this.fnWaitKey,\n          waitFrame: this.fnWaitFrame,\n          waitSound: this.fnWaitSound,\n          waitInput: this.fnWaitInput,\n          fileCat: this.fnFileCat,\n          fileDir: this.fnFileDir,\n          fileEra: this.fnFileEra,\n          fileRen: this.fnFileRen,\n          error: Controller.fnDummy,\n          onError: this.fnOnError,\n          stop: Controller.fnDummy,\n          \"break\": Controller.fnDummy,\n          escape: Controller.fnDummy,\n          renumLines: this.fnRenumLines,\n          deleteLines: this.fnDeleteLines,\n          end: Controller.fnDummy,\n          editLine: this.fnEditLine,\n          list: this.fnList,\n          fileLoad: this.fnFileLoad,\n          fileSave: this.fnFileSave,\n          \"new\": this.fnNew,\n          run: this.fnRun,\n          parse: this.fnParse,\n          parseRun: this.fnParseRun,\n          reset: this.fnReset\n      };\n  }\n\n  // ===== dist/esm/cpcconfig.js =====\n  /* cpcconfig.ts - configuration file for cpclocots */\n  const cpcconfig = {\n      databaseDirs: \"./examples,https://benchmarko.github.io/CpcLocoApps/apps,https://benchmarko.github.io/LocoBasic/examples=locobasic,https://benchmarko.github.io/CpcLocoApps/rosetta,storage\",\n      //databaseDirs: \"./examples,../../CpcLocoApps/apps,../../LocoBasic/dist/examples=locobasic,../../CpcLocoApps/rosetta,storage\", // local test\n      // just an example, not the full list of moved examples...\n      redirectExamples: {\n          \"examples/art\": {\n              database: \"apps\",\n              example: \"demo/art\"\n          },\n          \"examples/blkedit\": {\n              database: \"apps\",\n              example: \"apps/blkedit\"\n          }\n      }\n  };\n\n  // ===== dist/esm/Model.js =====\n  // Model.ts - Model (MVC)\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n\n  class Model {\n      config;\n      initialConfig;\n      databases;\n      examples;\n      constructor(config) {\n          this.config = config || {}; // store only a reference\n          this.initialConfig = Object.assign({}, this.config); // save initial config\n          this.databases = {};\n          this.examples = {}; // loaded examples per database\n      }\n      getProperty(property) {\n          return this.config[property];\n      }\n      setProperty(property, value) {\n          this.config[property] = value;\n      }\n      getAllProperties() {\n          return this.config;\n      }\n      getAllInitialProperties() {\n          return this.initialConfig;\n      }\n      getChangedProperties() {\n          const current = this.config, initial = this.initialConfig, changed = {};\n          for (const name in current) {\n              if (current.hasOwnProperty(name)) {\n                  if (current[name] !== initial[name]) {\n                      changed[name] = current[name];\n                  }\n              }\n          }\n          return changed;\n      }\n      addDatabases(db) {\n          for (const par in db) {\n              if (db.hasOwnProperty(par)) {\n                  const entry = db[par];\n                  this.databases[par] = entry;\n                  this.examples[par] = {};\n              }\n          }\n      }\n      getAllDatabases() {\n          return this.databases;\n      }\n      getDatabase() {\n          const database = this.getProperty(\"database\" /* ModelPropID.database */);\n          return this.databases[database];\n      }\n      getAllExamples() {\n          const database = this.getProperty(\"database\" /* ModelPropID.database */);\n          return this.examples[database];\n      }\n      getExample(key) {\n          const database = this.getProperty(\"database\" /* ModelPropID.database */);\n          return this.examples[database][key];\n      }\n      setExample(example) {\n          const database = this.getProperty(\"database\" /* ModelPropID.database */), key = example.key;\n          if (!this.examples[database][key]) {\n              if (Utils.debug > 1) {\n                  Utils.console.debug(\"setExample: creating new example:\", key);\n              }\n          }\n          this.examples[database][key] = example;\n      }\n      removeExample(key) {\n          const database = this.getProperty(\"database\" /* ModelPropID.database */);\n          if (!this.examples[database][key]) {\n              Utils.console.warn(\"removeExample: example does not exist: \" + key);\n          }\n          delete this.examples[database][key];\n      }\n  }\n\n  // ===== dist/esm/NodeAdapt.js =====\n  // NodeAdapt.ts - Adaptations for nodeJS\n  //\n\n  class NodeAdapt {\n      static doAdapt() {\n          let https, // nodeJs\n          fs, module, audioContext;\n          const domElements = {}, myCreateElement = function (id) {\n              domElements[id] = {\n                  className: \"\",\n                  style: {\n                      borderwidth: \"\",\n                      borderStyle: \"\"\n                  },\n                  addEventListener: () => {\n                      // nothing\n                  },\n                  options: [],\n                  getAttribute: () => {\n                      // nothing\n                  },\n                  setAttribute: () => {\n                      // nothing\n                  }\n              };\n              // old syntax for getter with \"get length() { ... }\"\n              Object.defineProperty(domElements[id], \"length\", {\n                  get() {\n                      return domElements[id].options.length;\n                  },\n                  set(len) {\n                      domElements[id].options.length = len;\n                  },\n                  enumerable: true,\n                  configurable: true\n              });\n              return domElements[id];\n          };\n          function fnEval(code) {\n              return eval(code); // eslint-disable-line no-eval\n          }\n          if (!audioContext) {\n              // fnEval('audioContext = require(\"web-audio-api\").AudioContext;'); // has no createChannelMerger()\n              if (!audioContext) {\n                  audioContext = () => {\n                      throw new Error(\"AudioContext not supported\");\n                  };\n              }\n          }\n          Object.assign(window, {\n              console: console,\n              document: {\n                  addEventListener: () => {\n                      // nothing\n                  },\n                  getElementById: (id) => domElements[id] || myCreateElement(id),\n                  createElement: (type) => {\n                      if (type === \"option\") {\n                          return {};\n                      }\n                      Utils.console.error(\"createElement: unknown type\", type);\n                      return {};\n                  }\n              },\n              AudioContext: audioContext\n          });\n          // eslint-disable-next-line no-eval\n          const nodeExports = eval(\"exports\"), view = nodeExports.View, setSelectOptionsOrig = view.prototype.setSelectOptions;\n          // fast hacks...\n          view.prototype.setSelectOptions = (id, options) => {\n              const element = domElements[id] || myCreateElement(id);\n              if (!element.options.add) {\n                  element.add = (option) => {\n                      // eslint-disable-next-line no-invalid-this\n                      element.options.push(option);\n                      if (element.options.length === 1 || option.selected) {\n                          element.value = element.options[element.options.length - 1].value;\n                      }\n                  };\n              }\n              return setSelectOptionsOrig(id, options);\n          };\n          const setAreaValueOrig = view.prototype.setAreaValue;\n          view.prototype.setAreaValue = (id, value) => {\n              if (id === \"resultText\" /* ViewID.resultText */) {\n                  if (value) {\n                      Utils.console.log(value);\n                  }\n              }\n              return setAreaValueOrig(id, value);\n          };\n          // https://nodejs.dev/learn/accept-input-from-the-command-line-in-nodejs\n          // readline?\n          const controller = nodeExports.Controller;\n          controller.prototype.startWithDirectInput = function () {\n              this.stopUpdateCanvas();\n              Utils.console.log(\"We are ready.\");\n          };\n          function isUrl(s) {\n              return s.startsWith(\"http\"); // http or https\n          }\n          function nodeReadUrl(url, fnDataLoaded) {\n              if (!https) {\n                  fnEval('https = require(\"https\");'); // to trick TypeScript\n              }\n              https.get(url, (resp) => {\n                  let data = \"\";\n                  // A chunk of data has been received.\n                  resp.on(\"data\", (chunk) => {\n                      data += chunk;\n                  });\n                  // The whole response has been received. Print out the result.\n                  resp.on(\"end\", () => {\n                      fnDataLoaded(undefined, data);\n                  });\n              }).on(\"error\", (err) => {\n                  Utils.console.log(\"Error: \" + err.message);\n                  fnDataLoaded(err);\n              });\n          }\n          let modulePath;\n          function nodeReadFile(name, fnDataLoaded) {\n              if (!fs) {\n                  fnEval('fs = require(\"fs\");'); // to trick TypeScript\n              }\n              if (!module) {\n                  fnEval('module = require(\"module\");'); // to trick TypeScript\n                  modulePath = module.path || \"\";\n                  if (!modulePath) {\n                      Utils.console.warn(\"nodeReadFile: Cannot determine module path\");\n                  }\n              }\n              const name2 = modulePath ? modulePath + \"/\" + name : name;\n              fs.readFile(name2, \"utf8\", fnDataLoaded);\n          }\n          const utils = nodeExports.Utils;\n          utils.loadScript = (fileOrUrl, fnSuccess, _fnError, key) => {\n              const fnLoaded = (error, data) => {\n                  if (error) {\n                      Utils.console.error(\"file error: \", error);\n                  }\n                  if (data) {\n                      fnEval(data); // load js (for nodeJs)\n                  }\n                  fnSuccess(fileOrUrl, key);\n              };\n              if (isUrl(fileOrUrl)) {\n                  nodeReadUrl(fileOrUrl, fnLoaded);\n              }\n              else {\n                  nodeReadFile(fileOrUrl, fnLoaded);\n              }\n          };\n      }\n  }\n  // end\n\n  // ===== dist/esm/index.js =====\n  // CpcLoco.ts - CpcLoco for the Browser\n  // (c) Marco Vieth, 2019\n  // https://benchmarko.github.io/cpclocots/\n  //\n\n\n\n\n\n\n  class CpcLoco {\n      static config = {\n          arrayBounds: false,\n          autorun: true,\n          basicVersion: \"1.1\", // \"1.1\" or \"1.0\"\n          bench: 0, // debug: number of parse bench loops\n          canvasType: \"graphics\", // \"graphics\", \"text\", \"none\"\n          databaseDirs: \"examples\", // example base directories (comma separated)\n          database: \"examples\", // examples, apps, saved\n          debug: 0,\n          example: \"CpcLoco\",\n          exampleIndex: \"0index.js\", // example index for every databaseDir\n          implicitLines: false, // allow implicit line numbers\n          input: \"\", // keyboard input when starting the app\n          integerOverflow: false, // check for integer overflow\n          kbdLayout: \"alphanum\", // alphanum, alpha, num\n          linesOnLoad: true, // add missing line numbers on load\n          dragElements: false,\n          palette: \"color\", // \"color\", \"green\", \"grey\"\n          prettyBrackets: true, // pretty print: brackets\n          prettyColons: true, // pretty print: colons\n          prettyLowercaseVars: false, // pretty print: lowercase variables\n          prettySpace: false, // pretty print: spaces\n          processFileImports: true, // open ZIP, DSK files on import\n          selectDataFiles: false, // select data files in example selection\n          showConsoleLog: false,\n          showCpc: true,\n          showDisass: false,\n          showExport: false,\n          showGallery: false,\n          showInput: true,\n          showInp2: false,\n          showKbd: false,\n          showKbdSettings: false,\n          showMore: false,\n          showOutput: false,\n          showPretty: false,\n          showRenum: false,\n          showResult: false,\n          showSettings: false,\n          showVariable: false,\n          showView: false,\n          sound: true,\n          speed: 100,\n          trace: false // trace code\n      };\n      static model;\n      static view;\n      static controller;\n      static fnHereDoc(fn) {\n          return String(fn).\n              replace(/^[^/]+\\/\\*\\S*/, \"\").\n              replace(/\\*\\/[^/]+$/, \"\");\n      }\n      static addIndex(dir, input) {\n          if (typeof input === \"function\") {\n              input = {\n                  [dir]: JSON.parse(this.fnHereDoc(input).trim())\n              };\n          }\n          return CpcLoco.controller.addIndex(dir, input);\n      }\n      static addItem(key, input) {\n          const inputString = (typeof input !== \"string\") ? this.fnHereDoc(input) : input;\n          return CpcLoco.controller.addItem(key, inputString);\n      }\n      static addRsx(key, RsxConstructor) {\n          return CpcLoco.controller.addRsx(key, RsxConstructor);\n      }\n      // can be used for nodeJS\n      static fnParseArgs(args, config) {\n          for (let i = 0; i < args.length; i += 1) {\n              const nameValue = args[i], nameValueList = Utils.split2(nameValue, \"=\"), name = nameValueList[0];\n              if (config.hasOwnProperty(name)) {\n                  let value = nameValueList[1]; // string|number|boolean\n                  if (value !== undefined && config.hasOwnProperty(name)) {\n                      switch (typeof config[name]) {\n                          case \"string\":\n                              break;\n                          case \"boolean\":\n                              value = (value === \"true\");\n                              break;\n                          case \"number\":\n                              value = Number(value);\n                              break;\n                          case \"object\":\n                              break;\n                          default:\n                              break;\n                      }\n                  }\n                  config[name] = value;\n              }\n          }\n          return config;\n      }\n      static fnDecodeUri(s) {\n          const rPlus = /\\+/g; // Regex for replacing addition symbol with a space\n          let decoded = \"\";\n          try {\n              decoded = decodeURIComponent(s.replace(rPlus, \" \"));\n          }\n          catch (err) {\n              err.message += \": \" + s;\n              Utils.console.error(err);\n          }\n          return decoded;\n      }\n      // https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript\n      static fnParseUri(urlQuery, config) {\n          const rSearch = /([^&=]+)=?([^&]*)/g, args = [];\n          let match;\n          while ((match = rSearch.exec(urlQuery)) !== null) {\n              const name = CpcLoco.fnDecodeUri(match[1]), value = CpcLoco.fnDecodeUri(match[2]);\n              if (value !== null && config.hasOwnProperty(name)) {\n                  args.push(name + \"=\" + value);\n              }\n          }\n          CpcLoco.fnParseArgs(args, config);\n      }\n      static fnMapObjectProperties(arg) {\n          if (typeof arg === \"object\") {\n              const res = [];\n              for (const key in arg) { // eslint-disable-line guard-for-in\n                  // if (arg.hasOwnProperty(key)) {\n                  const value = arg[key];\n                  if (typeof value !== \"object\" && typeof value !== \"function\") {\n                      res.push(key + \": \" + value);\n                  }\n              }\n              arg = String(arg) + \"{\" + res.join(\", \") + \"}\";\n          }\n          return arg;\n      }\n      static createDebugUtilsConsole(CpcLocoLog) {\n          const currentConsole = Utils.console;\n          return {\n              consoleLog: {\n                  value: CpcLocoLog || \"\" // already something collected?\n              },\n              console: currentConsole,\n              rawLog: function (fnMethod, level, args) {\n                  if (level) {\n                      args.unshift(level);\n                  }\n                  if (fnMethod) {\n                      if (fnMethod.apply) {\n                          fnMethod.apply(console, args);\n                      }\n                  }\n                  if (this.consoleLog) {\n                      this.consoleLog.value += args.map(CpcLoco.fnMapObjectProperties).join(\" \") + ((level !== null) ? \"\\n\" : \"\");\n                  }\n              },\n              log: function () {\n                  this.rawLog(this.console && this.console.log, \"\", Array.prototype.slice.call(arguments));\n              },\n              debug: function () {\n                  this.rawLog(this.console && this.console.debug, \"DEBUG:\", Array.prototype.slice.call(arguments));\n              },\n              info: function () {\n                  this.rawLog(this.console && this.console.info, \"INFO:\", Array.prototype.slice.call(arguments));\n              },\n              warn: function () {\n                  this.rawLog(this.console && this.console.warn, \"WARN:\", Array.prototype.slice.call(arguments));\n              },\n              error: function () {\n                  this.rawLog(this.console && this.console.error, \"ERROR:\", Array.prototype.slice.call(arguments));\n              },\n              changeLog: function (log) {\n                  const oldLog = this.consoleLog;\n                  this.consoleLog = log;\n                  if (oldLog && oldLog.value && log) { // some log entires collected?\n                      log.value += oldLog.value; // take collected log entries\n                  }\n              }\n          };\n      }\n      static fnRedirectExamples(redirectExamples) {\n          const name = this.model.getProperty(\"database\" /* ModelPropID.database */) + \"/\" + this.model.getProperty(\"example\" /* ModelPropID.example */);\n          if (redirectExamples[name]) {\n              this.model.setProperty(\"database\" /* ModelPropID.database */, redirectExamples[name].database);\n              this.model.setProperty(\"example\" /* ModelPropID.example */, redirectExamples[name].example);\n          }\n      }\n      static fnDoStart() {\n          const startConfig = CpcLoco.config, winCpcConfig = window.cpcConfig || {};\n          Object.assign(startConfig, cpcconfig, winCpcConfig);\n          const redirectExamples = startConfig.redirectExamples;\n          delete startConfig.redirectExamples;\n          CpcLoco.model = new Model(startConfig);\n          // eslint-disable-next-line no-new-func\n          const myGlobalThis = (typeof globalThis !== \"undefined\") ? globalThis : Function(\"return this\")(); // for old IE\n          if (!myGlobalThis.process) { // browser\n              CpcLoco.fnParseUri(window.location.search.substring(1), startConfig);\n          }\n          else { // nodeJs\n              CpcLoco.fnParseArgs(myGlobalThis.process.argv.slice(2), startConfig);\n          }\n          CpcLoco.view = new View();\n          const debug = Number(CpcLoco.model.getProperty(\"debug\" /* ModelPropID.debug */));\n          Utils.debug = debug;\n          let UtilsConsole = Utils.console, CpcLocoLog = \"\";\n          if (UtilsConsole.CpcLocoLog) {\n              CpcLocoLog = UtilsConsole.CpcLocoLog;\n              UtilsConsole.CpcLocoLog = undefined; // do not log any more to dummy console\n          }\n          if (Utils.debug > 0 && CpcLoco.model.getProperty(\"showConsoleLog\" /* ModelPropID.showConsoleLog */)) { // console log window?\n              UtilsConsole = CpcLoco.createDebugUtilsConsole(CpcLocoLog);\n              Utils.console = UtilsConsole;\n              Utils.console.log(\"CpcLoco log started at\", Utils.dateFormat(new Date()));\n              UtilsConsole.changeLog(View.getElementById1(\"consoleLogText\" /* ViewID.consoleLogText */));\n          }\n          if (redirectExamples) {\n              this.fnRedirectExamples(redirectExamples);\n          }\n          CpcLoco.controller = new Controller(CpcLoco.model, CpcLoco.view);\n          CpcLoco.controller.onDatabaseSelectChange(); // trigger loading example\n      }\n      static fnOnLoad() {\n          Utils.console.log(\"CpcLoco started at\", Utils.dateFormat(new Date()));\n          CpcLoco.fnDoStart();\n      }\n  }\n  window.CpcLoco = CpcLoco;\n  window.onload = () => {\n      CpcLoco.fnOnLoad();\n  };\n  const MyPolyfills = (typeof window !== \"undefined\" && window.Polyfills) ? window.Polyfills : globalThis.Polyfills;\n  if (MyPolyfills && MyPolyfills.isNodeAvailable) {\n      NodeAdapt.doAdapt();\n      CpcLoco.fnOnLoad();\n      Utils.console.debug(\"End of main.\");\n  }\n\n\n  const api = {\n    \"CpcLoco\": CpcLoco\n  };\n  global.Cpclocots = api;\n    if (typeof globalThis !== 'undefined') {\n      globalThis.Cpclocots = api;\n    }\n    if (global.window) {\n      global.window.Cpclocots = api;\n    }\n    if (typeof window !== 'undefined') {\n      window.Cpclocots = api;\n    }\n})(typeof window !== 'undefined' ? window : (typeof globalThis !== 'undefined' ? globalThis : this));\n"],"names":[],"mappings":"AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"}